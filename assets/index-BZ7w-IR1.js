var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __pow = Math.pow;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var require_index_001 = __commonJS({
  "assets/index-BZ7w-IR1.js"(exports) {
    function _mergeNamespaces(n2, m2) {
      for (var i = 0; i < m2.length; i++) {
        const e = m2[i];
        if (typeof e !== "string" && !Array.isArray(e)) {
          for (const k2 in e) {
            if (k2 !== "default" && !(k2 in n2)) {
              const d = Object.getOwnPropertyDescriptor(e, k2);
              if (d) {
                Object.defineProperty(n2, k2, d.get ? d : {
                  enumerable: true,
                  get: () => e[k2]
                });
              }
            }
          }
        }
      }
      return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
    }
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node of mutation.addedNodes) {
            if (node.tagName === "LINK" && node.rel === "modulepreload")
              processPreload(node);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link) {
        const fetchOpts = {};
        if (link.integrity) fetchOpts.integrity = link.integrity;
        if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
        if (link.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
        else fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link) {
        if (link.ep)
          return;
        link.ep = true;
        const fetchOpts = getFetchOpts(link);
        fetch(link.href, fetchOpts);
      }
    })();
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x2) {
      return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
    }
    var jsxRuntime = { exports: {} };
    var reactJsxRuntime_production_min = {};
    var react = { exports: {} };
    var react_production_min = {};
    /**
     * @license React
     * react.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var l$1 = Symbol.for("react.element"), n$1 = Symbol.for("react.portal"), p$2 = Symbol.for("react.fragment"), q$1 = Symbol.for("react.strict_mode"), r$1 = Symbol.for("react.profiler"), t = Symbol.for("react.provider"), u = Symbol.for("react.context"), v$1 = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x$1 = Symbol.for("react.memo"), y$1 = Symbol.for("react.lazy"), z$1 = Symbol.iterator;
    function A$1(a2) {
      if (null === a2 || "object" !== typeof a2) return null;
      a2 = z$1 && a2[z$1] || a2["@@iterator"];
      return "function" === typeof a2 ? a2 : null;
    }
    var B$1 = { isMounted: function() {
      return false;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } }, C$1 = Object.assign, D$1 = {};
    function E$1(a2, b, e) {
      this.props = a2;
      this.context = b;
      this.refs = D$1;
      this.updater = e || B$1;
    }
    E$1.prototype.isReactComponent = {};
    E$1.prototype.setState = function(a2, b) {
      if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, a2, b, "setState");
    };
    E$1.prototype.forceUpdate = function(a2) {
      this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
    };
    function F() {
    }
    F.prototype = E$1.prototype;
    function G$1(a2, b, e) {
      this.props = a2;
      this.context = b;
      this.refs = D$1;
      this.updater = e || B$1;
    }
    var H$1 = G$1.prototype = new F();
    H$1.constructor = G$1;
    C$1(H$1, E$1.prototype);
    H$1.isPureReactComponent = true;
    var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$3 = { key: true, ref: true, __self: true, __source: true };
    function M$1(a2, b, e) {
      var d, c2 = {}, k2 = null, h = null;
      if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k2 = "" + b.key), b) J.call(b, d) && !L$3.hasOwnProperty(d) && (c2[d] = b[d]);
      var g = arguments.length - 2;
      if (1 === g) c2.children = e;
      else if (1 < g) {
        for (var f2 = Array(g), m2 = 0; m2 < g; m2++) f2[m2] = arguments[m2 + 2];
        c2.children = f2;
      }
      if (a2 && a2.defaultProps) for (d in g = a2.defaultProps, g) void 0 === c2[d] && (c2[d] = g[d]);
      return { $$typeof: l$1, type: a2, key: k2, ref: h, props: c2, _owner: K$1.current };
    }
    function N$1(a2, b) {
      return { $$typeof: l$1, type: a2.type, key: b, ref: a2.ref, props: a2.props, _owner: a2._owner };
    }
    function O$2(a2) {
      return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$1;
    }
    function escape(a2) {
      var b = { "=": "=0", ":": "=2" };
      return "$" + a2.replace(/[=:]/g, function(a3) {
        return b[a3];
      });
    }
    var P$2 = /\/+/g;
    function Q$1(a2, b) {
      return "object" === typeof a2 && null !== a2 && null != a2.key ? escape("" + a2.key) : b.toString(36);
    }
    function R$1(a2, b, e, d, c2) {
      var k2 = typeof a2;
      if ("undefined" === k2 || "boolean" === k2) a2 = null;
      var h = false;
      if (null === a2) h = true;
      else switch (k2) {
        case "string":
        case "number":
          h = true;
          break;
        case "object":
          switch (a2.$$typeof) {
            case l$1:
            case n$1:
              h = true;
          }
      }
      if (h) return h = a2, c2 = c2(h), a2 = "" === d ? "." + Q$1(h, 0) : d, I$1(c2) ? (e = "", null != a2 && (e = a2.replace(P$2, "$&/") + "/"), R$1(c2, b, e, "", function(a3) {
        return a3;
      })) : null != c2 && (O$2(c2) && (c2 = N$1(c2, e + (!c2.key || h && h.key === c2.key ? "" : ("" + c2.key).replace(P$2, "$&/") + "/") + a2)), b.push(c2)), 1;
      h = 0;
      d = "" === d ? "." : d + ":";
      if (I$1(a2)) for (var g = 0; g < a2.length; g++) {
        k2 = a2[g];
        var f2 = d + Q$1(k2, g);
        h += R$1(k2, b, e, f2, c2);
      }
      else if (f2 = A$1(a2), "function" === typeof f2) for (a2 = f2.call(a2), g = 0; !(k2 = a2.next()).done; ) k2 = k2.value, f2 = d + Q$1(k2, g++), h += R$1(k2, b, e, f2, c2);
      else if ("object" === k2) throw b = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
      return h;
    }
    function S$1(a2, b, e) {
      if (null == a2) return a2;
      var d = [], c2 = 0;
      R$1(a2, d, "", "", function(a3) {
        return b.call(e, a3, c2++);
      });
      return d;
    }
    function T$1(a2) {
      if (-1 === a2._status) {
        var b = a2._result;
        b = b();
        b.then(function(b2) {
          if (0 === a2._status || -1 === a2._status) a2._status = 1, a2._result = b2;
        }, function(b2) {
          if (0 === a2._status || -1 === a2._status) a2._status = 2, a2._result = b2;
        });
        -1 === a2._status && (a2._status = 0, a2._result = b);
      }
      if (1 === a2._status) return a2._result.default;
      throw a2._result;
    }
    var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
    function X$2() {
      throw Error("act(...) is not supported in production builds of React.");
    }
    react_production_min.Children = { map: S$1, forEach: function(a2, b, e) {
      S$1(a2, function() {
        b.apply(this, arguments);
      }, e);
    }, count: function(a2) {
      var b = 0;
      S$1(a2, function() {
        b++;
      });
      return b;
    }, toArray: function(a2) {
      return S$1(a2, function(a3) {
        return a3;
      }) || [];
    }, only: function(a2) {
      if (!O$2(a2)) throw Error("React.Children.only expected to receive a single React element child.");
      return a2;
    } };
    react_production_min.Component = E$1;
    react_production_min.Fragment = p$2;
    react_production_min.Profiler = r$1;
    react_production_min.PureComponent = G$1;
    react_production_min.StrictMode = q$1;
    react_production_min.Suspense = w;
    react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
    react_production_min.act = X$2;
    react_production_min.cloneElement = function(a2, b, e) {
      if (null === a2 || void 0 === a2) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
      var d = C$1({}, a2.props), c2 = a2.key, k2 = a2.ref, h = a2._owner;
      if (null != b) {
        void 0 !== b.ref && (k2 = b.ref, h = K$1.current);
        void 0 !== b.key && (c2 = "" + b.key);
        if (a2.type && a2.type.defaultProps) var g = a2.type.defaultProps;
        for (f2 in b) J.call(b, f2) && !L$3.hasOwnProperty(f2) && (d[f2] = void 0 === b[f2] && void 0 !== g ? g[f2] : b[f2]);
      }
      var f2 = arguments.length - 2;
      if (1 === f2) d.children = e;
      else if (1 < f2) {
        g = Array(f2);
        for (var m2 = 0; m2 < f2; m2++) g[m2] = arguments[m2 + 2];
        d.children = g;
      }
      return { $$typeof: l$1, type: a2.type, key: c2, ref: k2, props: d, _owner: h };
    };
    react_production_min.createContext = function(a2) {
      a2 = { $$typeof: u, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
      a2.Provider = { $$typeof: t, _context: a2 };
      return a2.Consumer = a2;
    };
    react_production_min.createElement = M$1;
    react_production_min.createFactory = function(a2) {
      var b = M$1.bind(null, a2);
      b.type = a2;
      return b;
    };
    react_production_min.createRef = function() {
      return { current: null };
    };
    react_production_min.forwardRef = function(a2) {
      return { $$typeof: v$1, render: a2 };
    };
    react_production_min.isValidElement = O$2;
    react_production_min.lazy = function(a2) {
      return { $$typeof: y$1, _payload: { _status: -1, _result: a2 }, _init: T$1 };
    };
    react_production_min.memo = function(a2, b) {
      return { $$typeof: x$1, type: a2, compare: void 0 === b ? null : b };
    };
    react_production_min.startTransition = function(a2) {
      var b = V$1.transition;
      V$1.transition = {};
      try {
        a2();
      } finally {
        V$1.transition = b;
      }
    };
    react_production_min.unstable_act = X$2;
    react_production_min.useCallback = function(a2, b) {
      return U$1.current.useCallback(a2, b);
    };
    react_production_min.useContext = function(a2) {
      return U$1.current.useContext(a2);
    };
    react_production_min.useDebugValue = function() {
    };
    react_production_min.useDeferredValue = function(a2) {
      return U$1.current.useDeferredValue(a2);
    };
    react_production_min.useEffect = function(a2, b) {
      return U$1.current.useEffect(a2, b);
    };
    react_production_min.useId = function() {
      return U$1.current.useId();
    };
    react_production_min.useImperativeHandle = function(a2, b, e) {
      return U$1.current.useImperativeHandle(a2, b, e);
    };
    react_production_min.useInsertionEffect = function(a2, b) {
      return U$1.current.useInsertionEffect(a2, b);
    };
    react_production_min.useLayoutEffect = function(a2, b) {
      return U$1.current.useLayoutEffect(a2, b);
    };
    react_production_min.useMemo = function(a2, b) {
      return U$1.current.useMemo(a2, b);
    };
    react_production_min.useReducer = function(a2, b, e) {
      return U$1.current.useReducer(a2, b, e);
    };
    react_production_min.useRef = function(a2) {
      return U$1.current.useRef(a2);
    };
    react_production_min.useState = function(a2) {
      return U$1.current.useState(a2);
    };
    react_production_min.useSyncExternalStore = function(a2, b, e) {
      return U$1.current.useSyncExternalStore(a2, b, e);
    };
    react_production_min.useTransition = function() {
      return U$1.current.useTransition();
    };
    react_production_min.version = "18.3.1";
    {
      react.exports = react_production_min;
    }
    var reactExports = react.exports;
    const React$3 = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
    const React$4 = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      default: React$3
    }, [reactExports]);
    /**
     * @license React
     * react-jsx-runtime.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var f = reactExports, k$1 = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m$1 = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$1 = { key: true, ref: true, __self: true, __source: true };
    function q(c2, a2, g) {
      var b, d = {}, e = null, h = null;
      void 0 !== g && (e = "" + g);
      void 0 !== a2.key && (e = "" + a2.key);
      void 0 !== a2.ref && (h = a2.ref);
      for (b in a2) m$1.call(a2, b) && !p$1.hasOwnProperty(b) && (d[b] = a2[b]);
      if (c2 && c2.defaultProps) for (b in a2 = c2.defaultProps, a2) void 0 === d[b] && (d[b] = a2[b]);
      return { $$typeof: k$1, type: c2, key: e, ref: h, props: d, _owner: n.current };
    }
    reactJsxRuntime_production_min.Fragment = l;
    reactJsxRuntime_production_min.jsx = q;
    reactJsxRuntime_production_min.jsxs = q;
    {
      jsxRuntime.exports = reactJsxRuntime_production_min;
    }
    var jsxRuntimeExports = jsxRuntime.exports;
    var client = {};
    var reactDom = { exports: {} };
    var reactDom_production_min = {};
    var scheduler = { exports: {} };
    var scheduler_production_min = {};
    /**
     * @license React
     * scheduler.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    (function(exports$1) {
      function f2(a2, b) {
        var c2 = a2.length;
        a2.push(b);
        a: for (; 0 < c2; ) {
          var d = c2 - 1 >>> 1, e = a2[d];
          if (0 < g(e, b)) a2[d] = b, a2[c2] = e, c2 = d;
          else break a;
        }
      }
      function h(a2) {
        return 0 === a2.length ? null : a2[0];
      }
      function k2(a2) {
        if (0 === a2.length) return null;
        var b = a2[0], c2 = a2.pop();
        if (c2 !== b) {
          a2[0] = c2;
          a: for (var d = 0, e = a2.length, w2 = e >>> 1; d < w2; ) {
            var m2 = 2 * (d + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x2 = a2[n2];
            if (0 > g(C2, c2)) n2 < e && 0 > g(x2, C2) ? (a2[d] = x2, a2[n2] = c2, d = n2) : (a2[d] = C2, a2[m2] = c2, d = m2);
            else if (n2 < e && 0 > g(x2, c2)) a2[d] = x2, a2[n2] = c2, d = n2;
            else break a;
          }
        }
        return b;
      }
      function g(a2, b) {
        var c2 = a2.sortIndex - b.sortIndex;
        return 0 !== c2 ? c2 : a2.id - b.id;
      }
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var l2 = performance;
        exports$1.unstable_now = function() {
          return l2.now();
        };
      } else {
        var p2 = Date, q2 = p2.now();
        exports$1.unstable_now = function() {
          return p2.now() - q2;
        };
      }
      var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
      "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function G2(a2) {
        for (var b = h(t2); null !== b; ) {
          if (null === b.callback) k2(t2);
          else if (b.startTime <= a2) k2(t2), b.sortIndex = b.expirationTime, f2(r2, b);
          else break;
          b = h(t2);
        }
      }
      function H2(a2) {
        B2 = false;
        G2(a2);
        if (!A2) if (null !== h(r2)) A2 = true, I2(J2);
        else {
          var b = h(t2);
          null !== b && K2(H2, b.startTime - a2);
        }
      }
      function J2(a2, b) {
        A2 = false;
        B2 && (B2 = false, E2(L2), L2 = -1);
        z2 = true;
        var c2 = y2;
        try {
          G2(b);
          for (v2 = h(r2); null !== v2 && (!(v2.expirationTime > b) || a2 && !M2()); ) {
            var d = v2.callback;
            if ("function" === typeof d) {
              v2.callback = null;
              y2 = v2.priorityLevel;
              var e = d(v2.expirationTime <= b);
              b = exports$1.unstable_now();
              "function" === typeof e ? v2.callback = e : v2 === h(r2) && k2(r2);
              G2(b);
            } else k2(r2);
            v2 = h(r2);
          }
          if (null !== v2) var w2 = true;
          else {
            var m2 = h(t2);
            null !== m2 && K2(H2, m2.startTime - b);
            w2 = false;
          }
          return w2;
        } finally {
          v2 = null, y2 = c2, z2 = false;
        }
      }
      var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
      function M2() {
        return exports$1.unstable_now() - Q2 < P2 ? false : true;
      }
      function R2() {
        if (null !== O2) {
          var a2 = exports$1.unstable_now();
          Q2 = a2;
          var b = true;
          try {
            b = O2(true, a2);
          } finally {
            b ? S2() : (N2 = false, O2 = null);
          }
        } else N2 = false;
      }
      var S2;
      if ("function" === typeof F2) S2 = function() {
        F2(R2);
      };
      else if ("undefined" !== typeof MessageChannel) {
        var T2 = new MessageChannel(), U2 = T2.port2;
        T2.port1.onmessage = R2;
        S2 = function() {
          U2.postMessage(null);
        };
      } else S2 = function() {
        D2(R2, 0);
      };
      function I2(a2) {
        O2 = a2;
        N2 || (N2 = true, S2());
      }
      function K2(a2, b) {
        L2 = D2(function() {
          a2(exports$1.unstable_now());
        }, b);
      }
      exports$1.unstable_IdlePriority = 5;
      exports$1.unstable_ImmediatePriority = 1;
      exports$1.unstable_LowPriority = 4;
      exports$1.unstable_NormalPriority = 3;
      exports$1.unstable_Profiling = null;
      exports$1.unstable_UserBlockingPriority = 2;
      exports$1.unstable_cancelCallback = function(a2) {
        a2.callback = null;
      };
      exports$1.unstable_continueExecution = function() {
        A2 || z2 || (A2 = true, I2(J2));
      };
      exports$1.unstable_forceFrameRate = function(a2) {
        0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
      };
      exports$1.unstable_getCurrentPriorityLevel = function() {
        return y2;
      };
      exports$1.unstable_getFirstCallbackNode = function() {
        return h(r2);
      };
      exports$1.unstable_next = function(a2) {
        switch (y2) {
          case 1:
          case 2:
          case 3:
            var b = 3;
            break;
          default:
            b = y2;
        }
        var c2 = y2;
        y2 = b;
        try {
          return a2();
        } finally {
          y2 = c2;
        }
      };
      exports$1.unstable_pauseExecution = function() {
      };
      exports$1.unstable_requestPaint = function() {
      };
      exports$1.unstable_runWithPriority = function(a2, b) {
        switch (a2) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a2 = 3;
        }
        var c2 = y2;
        y2 = a2;
        try {
          return b();
        } finally {
          y2 = c2;
        }
      };
      exports$1.unstable_scheduleCallback = function(a2, b, c2) {
        var d = exports$1.unstable_now();
        "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d + c2 : d) : c2 = d;
        switch (a2) {
          case 1:
            var e = -1;
            break;
          case 2:
            e = 250;
            break;
          case 5:
            e = 1073741823;
            break;
          case 4:
            e = 1e4;
            break;
          default:
            e = 5e3;
        }
        e = c2 + e;
        a2 = { id: u2++, callback: b, priorityLevel: a2, startTime: c2, expirationTime: e, sortIndex: -1 };
        c2 > d ? (a2.sortIndex = c2, f2(t2, a2), null === h(r2) && a2 === h(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d))) : (a2.sortIndex = e, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
        return a2;
      };
      exports$1.unstable_shouldYield = M2;
      exports$1.unstable_wrapCallback = function(a2) {
        var b = y2;
        return function() {
          var c2 = y2;
          y2 = b;
          try {
            return a2.apply(this, arguments);
          } finally {
            y2 = c2;
          }
        };
      };
    })(scheduler_production_min);
    {
      scheduler.exports = scheduler_production_min;
    }
    var schedulerExports = scheduler.exports;
    /**
     * @license React
     * react-dom.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var aa = reactExports, ca = schedulerExports;
    function p(a2) {
      for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++) b += "&args[]=" + encodeURIComponent(arguments[c2]);
      return "Minified React error #" + a2 + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var da = /* @__PURE__ */ new Set(), ea = {};
    function fa(a2, b) {
      ha(a2, b);
      ha(a2 + "Capture", b);
    }
    function ha(a2, b) {
      ea[a2] = b;
      for (a2 = 0; a2 < b.length; a2++) da.add(b[a2]);
    }
    var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka$1 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
    function oa(a2) {
      if (ja.call(ma, a2)) return true;
      if (ja.call(la, a2)) return false;
      if (ka$1.test(a2)) return ma[a2] = true;
      la[a2] = true;
      return false;
    }
    function pa(a2, b, c2, d) {
      if (null !== c2 && 0 === c2.type) return false;
      switch (typeof b) {
        case "function":
        case "symbol":
          return true;
        case "boolean":
          if (d) return false;
          if (null !== c2) return !c2.acceptsBooleans;
          a2 = a2.toLowerCase().slice(0, 5);
          return "data-" !== a2 && "aria-" !== a2;
        default:
          return false;
      }
    }
    function qa(a2, b, c2, d) {
      if (null === b || "undefined" === typeof b || pa(a2, b, c2, d)) return true;
      if (d) return false;
      if (null !== c2) switch (c2.type) {
        case 3:
          return !b;
        case 4:
          return false === b;
        case 5:
          return isNaN(b);
        case 6:
          return isNaN(b) || 1 > b;
      }
      return false;
    }
    function v(a2, b, c2, d, e, f2, g) {
      this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
      this.attributeName = d;
      this.attributeNamespace = e;
      this.mustUseProperty = c2;
      this.propertyName = a2;
      this.type = b;
      this.sanitizeURL = f2;
      this.removeEmptyString = g;
    }
    var z = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
      z[a2] = new v(a2, 0, false, a2, null, false, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
      var b = a2[0];
      z[b] = new v(b, 1, false, a2[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
      z[a2] = new v(a2, 2, false, a2.toLowerCase(), null, false, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
      z[a2] = new v(a2, 2, false, a2, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
      z[a2] = new v(a2, 3, false, a2.toLowerCase(), null, false, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a2) {
      z[a2] = new v(a2, 3, true, a2, null, false, false);
    });
    ["capture", "download"].forEach(function(a2) {
      z[a2] = new v(a2, 4, false, a2, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a2) {
      z[a2] = new v(a2, 6, false, a2, null, false, false);
    });
    ["rowSpan", "start"].forEach(function(a2) {
      z[a2] = new v(a2, 5, false, a2.toLowerCase(), null, false, false);
    });
    var ra = /[\-:]([a-z])/g;
    function sa(a2) {
      return a2[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
      var b = a2.replace(
        ra,
        sa
      );
      z[b] = new v(b, 1, false, a2, null, false, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
      var b = a2.replace(ra, sa);
      z[b] = new v(b, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
      var b = a2.replace(ra, sa);
      z[b] = new v(b, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a2) {
      z[a2] = new v(a2, 1, false, a2.toLowerCase(), null, false, false);
    });
    z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
    ["src", "href", "action", "formAction"].forEach(function(a2) {
      z[a2] = new v(a2, 1, false, a2.toLowerCase(), null, true, true);
    });
    function ta(a2, b, c2, d) {
      var e = z.hasOwnProperty(b) ? z[b] : null;
      if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c2, e, d) && (c2 = null), d || null === e ? oa(b) && (null === c2 ? a2.removeAttribute(b) : a2.setAttribute(b, "" + c2)) : e.mustUseProperty ? a2[e.propertyName] = null === c2 ? 3 === e.type ? false : "" : c2 : (b = e.attributeName, d = e.attributeNamespace, null === c2 ? a2.removeAttribute(b) : (e = e.type, c2 = 3 === e || 4 === e && true === c2 ? "" : "" + c2, d ? a2.setAttributeNS(d, b, c2) : a2.setAttribute(b, c2)));
    }
    var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
    var Ia = Symbol.for("react.offscreen");
    var Ja = Symbol.iterator;
    function Ka(a2) {
      if (null === a2 || "object" !== typeof a2) return null;
      a2 = Ja && a2[Ja] || a2["@@iterator"];
      return "function" === typeof a2 ? a2 : null;
    }
    var A = Object.assign, La;
    function Ma(a2) {
      if (void 0 === La) try {
        throw Error();
      } catch (c2) {
        var b = c2.stack.trim().match(/\n( *(at )?)/);
        La = b && b[1] || "";
      }
      return "\n" + La + a2;
    }
    var Na = false;
    function Oa(a2, b) {
      if (!a2 || Na) return "";
      Na = true;
      var c2 = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (b) if (b = function() {
          throw Error();
        }, Object.defineProperty(b.prototype, "props", { set: function() {
          throw Error();
        } }), "object" === typeof Reflect && Reflect.construct) {
          try {
            Reflect.construct(b, []);
          } catch (l2) {
            var d = l2;
          }
          Reflect.construct(a2, [], b);
        } else {
          try {
            b.call();
          } catch (l2) {
            d = l2;
          }
          a2.call(b.prototype);
        }
        else {
          try {
            throw Error();
          } catch (l2) {
            d = l2;
          }
          a2();
        }
      } catch (l2) {
        if (l2 && d && "string" === typeof l2.stack) {
          for (var e = l2.stack.split("\n"), f2 = d.stack.split("\n"), g = e.length - 1, h = f2.length - 1; 1 <= g && 0 <= h && e[g] !== f2[h]; ) h--;
          for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f2[h]) {
            if (1 !== g || 1 !== h) {
              do
                if (g--, h--, 0 > h || e[g] !== f2[h]) {
                  var k2 = "\n" + e[g].replace(" at new ", " at ");
                  a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                  return k2;
                }
              while (1 <= g && 0 <= h);
            }
            break;
          }
        }
      } finally {
        Na = false, Error.prepareStackTrace = c2;
      }
      return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
    }
    function Pa(a2) {
      switch (a2.tag) {
        case 5:
          return Ma(a2.type);
        case 16:
          return Ma("Lazy");
        case 13:
          return Ma("Suspense");
        case 19:
          return Ma("SuspenseList");
        case 0:
        case 2:
        case 15:
          return a2 = Oa(a2.type, false), a2;
        case 11:
          return a2 = Oa(a2.type.render, false), a2;
        case 1:
          return a2 = Oa(a2.type, true), a2;
        default:
          return "";
      }
    }
    function Qa(a2) {
      if (null == a2) return null;
      if ("function" === typeof a2) return a2.displayName || a2.name || null;
      if ("string" === typeof a2) return a2;
      switch (a2) {
        case ya:
          return "Fragment";
        case wa:
          return "Portal";
        case Aa:
          return "Profiler";
        case za:
          return "StrictMode";
        case Ea:
          return "Suspense";
        case Fa:
          return "SuspenseList";
      }
      if ("object" === typeof a2) switch (a2.$$typeof) {
        case Ca:
          return (a2.displayName || "Context") + ".Consumer";
        case Ba:
          return (a2._context.displayName || "Context") + ".Provider";
        case Da:
          var b = a2.render;
          a2 = a2.displayName;
          a2 || (a2 = b.displayName || b.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
          return a2;
        case Ga:
          return b = a2.displayName || null, null !== b ? b : Qa(a2.type) || "Memo";
        case Ha:
          b = a2._payload;
          a2 = a2._init;
          try {
            return Qa(a2(b));
          } catch (c2) {
          }
      }
      return null;
    }
    function Ra(a2) {
      var b = a2.type;
      switch (a2.tag) {
        case 24:
          return "Cache";
        case 9:
          return (b.displayName || "Context") + ".Consumer";
        case 10:
          return (b._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return a2 = b.render, a2 = a2.displayName || a2.name || "", b.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return b;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return Qa(b);
        case 8:
          return b === za ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if ("function" === typeof b) return b.displayName || b.name || null;
          if ("string" === typeof b) return b;
      }
      return null;
    }
    function Sa(a2) {
      switch (typeof a2) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return a2;
        case "object":
          return a2;
        default:
          return "";
      }
    }
    function Ta(a2) {
      var b = a2.type;
      return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b || "radio" === b);
    }
    function Ua(a2) {
      var b = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b), d = "" + a2[b];
      if (!a2.hasOwnProperty(b) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
        var e = c2.get, f2 = c2.set;
        Object.defineProperty(a2, b, { configurable: true, get: function() {
          return e.call(this);
        }, set: function(a3) {
          d = "" + a3;
          f2.call(this, a3);
        } });
        Object.defineProperty(a2, b, { enumerable: c2.enumerable });
        return { getValue: function() {
          return d;
        }, setValue: function(a3) {
          d = "" + a3;
        }, stopTracking: function() {
          a2._valueTracker = null;
          delete a2[b];
        } };
      }
    }
    function Va(a2) {
      a2._valueTracker || (a2._valueTracker = Ua(a2));
    }
    function Wa(a2) {
      if (!a2) return false;
      var b = a2._valueTracker;
      if (!b) return true;
      var c2 = b.getValue();
      var d = "";
      a2 && (d = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
      a2 = d;
      return a2 !== c2 ? (b.setValue(a2), true) : false;
    }
    function Xa(a2) {
      a2 = a2 || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof a2) return null;
      try {
        return a2.activeElement || a2.body;
      } catch (b) {
        return a2.body;
      }
    }
    function Ya(a2, b) {
      var c2 = b.checked;
      return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
    }
    function Za(a2, b) {
      var c2 = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
      c2 = Sa(null != b.value ? b.value : c2);
      a2._wrapperState = { initialChecked: d, initialValue: c2, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
    }
    function ab(a2, b) {
      b = b.checked;
      null != b && ta(a2, "checked", b, false);
    }
    function bb(a2, b) {
      ab(a2, b);
      var c2 = Sa(b.value), d = b.type;
      if (null != c2) if ("number" === d) {
        if (0 === c2 && "" === a2.value || a2.value != c2) a2.value = "" + c2;
      } else a2.value !== "" + c2 && (a2.value = "" + c2);
      else if ("submit" === d || "reset" === d) {
        a2.removeAttribute("value");
        return;
      }
      b.hasOwnProperty("value") ? cb(a2, b.type, c2) : b.hasOwnProperty("defaultValue") && cb(a2, b.type, Sa(b.defaultValue));
      null == b.checked && null != b.defaultChecked && (a2.defaultChecked = !!b.defaultChecked);
    }
    function db(a2, b, c2) {
      if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
        var d = b.type;
        if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
        b = "" + a2._wrapperState.initialValue;
        c2 || b === a2.value || (a2.value = b);
        a2.defaultValue = b;
      }
      c2 = a2.name;
      "" !== c2 && (a2.name = "");
      a2.defaultChecked = !!a2._wrapperState.initialChecked;
      "" !== c2 && (a2.name = c2);
    }
    function cb(a2, b, c2) {
      if ("number" !== b || Xa(a2.ownerDocument) !== a2) null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
    }
    var eb = Array.isArray;
    function fb(a2, b, c2, d) {
      a2 = a2.options;
      if (b) {
        b = {};
        for (var e = 0; e < c2.length; e++) b["$" + c2[e]] = true;
        for (c2 = 0; c2 < a2.length; c2++) e = b.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e && (a2[c2].selected = e), e && d && (a2[c2].defaultSelected = true);
      } else {
        c2 = "" + Sa(c2);
        b = null;
        for (e = 0; e < a2.length; e++) {
          if (a2[e].value === c2) {
            a2[e].selected = true;
            d && (a2[e].defaultSelected = true);
            return;
          }
          null !== b || a2[e].disabled || (b = a2[e]);
        }
        null !== b && (b.selected = true);
      }
    }
    function gb(a2, b) {
      if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
      return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
    }
    function hb(a2, b) {
      var c2 = b.value;
      if (null == c2) {
        c2 = b.children;
        b = b.defaultValue;
        if (null != c2) {
          if (null != b) throw Error(p(92));
          if (eb(c2)) {
            if (1 < c2.length) throw Error(p(93));
            c2 = c2[0];
          }
          b = c2;
        }
        null == b && (b = "");
        c2 = b;
      }
      a2._wrapperState = { initialValue: Sa(c2) };
    }
    function ib(a2, b) {
      var c2 = Sa(b.value), d = Sa(b.defaultValue);
      null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
      null != d && (a2.defaultValue = "" + d);
    }
    function jb(a2) {
      var b = a2.textContent;
      b === a2._wrapperState.initialValue && "" !== b && null !== b && (a2.value = b);
    }
    function kb(a2) {
      switch (a2) {
        case "svg":
          return "http://www.w3.org/2000/svg";
        case "math":
          return "http://www.w3.org/1998/Math/MathML";
        default:
          return "http://www.w3.org/1999/xhtml";
      }
    }
    function lb(a2, b) {
      return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a2;
    }
    var mb, nb = function(a2) {
      return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c2, d, e) {
        MSApp.execUnsafeLocalFunction(function() {
          return a2(b, c2, d, e);
        });
      } : a2;
    }(function(a2, b) {
      if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2) a2.innerHTML = b;
      else {
        mb = mb || document.createElement("div");
        mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
        for (b = mb.firstChild; a2.firstChild; ) a2.removeChild(a2.firstChild);
        for (; b.firstChild; ) a2.appendChild(b.firstChild);
      }
    });
    function ob(a2, b) {
      if (b) {
        var c2 = a2.firstChild;
        if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
          c2.nodeValue = b;
          return;
        }
      }
      a2.textContent = b;
    }
    var pb = {
      animationIterationCount: true,
      aspectRatio: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    }, qb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(pb).forEach(function(a2) {
      qb.forEach(function(b) {
        b = b + a2.charAt(0).toUpperCase() + a2.substring(1);
        pb[b] = pb[a2];
      });
    });
    function rb(a2, b, c2) {
      return null == b || "boolean" === typeof b || "" === b ? "" : c2 || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b).trim() : b + "px";
    }
    function sb(a2, b) {
      a2 = a2.style;
      for (var c2 in b) if (b.hasOwnProperty(c2)) {
        var d = 0 === c2.indexOf("--"), e = rb(c2, b[c2], d);
        "float" === c2 && (c2 = "cssFloat");
        d ? a2.setProperty(c2, e) : a2[c2] = e;
      }
    }
    var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
    function ub(a2, b) {
      if (b) {
        if (tb[a2] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a2));
        if (null != b.dangerouslySetInnerHTML) {
          if (null != b.children) throw Error(p(60));
          if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
        }
        if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
      }
    }
    function vb(a2, b) {
      if (-1 === a2.indexOf("-")) return "string" === typeof b.is;
      switch (a2) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var wb = null;
    function xb(a2) {
      a2 = a2.target || a2.srcElement || window;
      a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
      return 3 === a2.nodeType ? a2.parentNode : a2;
    }
    var yb = null, zb = null, Ab = null;
    function Bb(a2) {
      if (a2 = Cb(a2)) {
        if ("function" !== typeof yb) throw Error(p(280));
        var b = a2.stateNode;
        b && (b = Db(b), yb(a2.stateNode, a2.type, b));
      }
    }
    function Eb(a2) {
      zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
    }
    function Fb() {
      if (zb) {
        var a2 = zb, b = Ab;
        Ab = zb = null;
        Bb(a2);
        if (b) for (a2 = 0; a2 < b.length; a2++) Bb(b[a2]);
      }
    }
    function Gb(a2, b) {
      return a2(b);
    }
    function Hb() {
    }
    var Ib = false;
    function Jb(a2, b, c2) {
      if (Ib) return a2(b, c2);
      Ib = true;
      try {
        return Gb(a2, b, c2);
      } finally {
        if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
      }
    }
    function Kb(a2, b) {
      var c2 = a2.stateNode;
      if (null === c2) return null;
      var d = Db(c2);
      if (null === d) return null;
      c2 = d[b];
      a: switch (b) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (d = !d.disabled) || (a2 = a2.type, d = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
          a2 = !d;
          break a;
        default:
          a2 = false;
      }
      if (a2) return null;
      if (c2 && "function" !== typeof c2) throw Error(p(231, b, typeof c2));
      return c2;
    }
    var Lb = false;
    if (ia) try {
      var Mb = {};
      Object.defineProperty(Mb, "passive", { get: function() {
        Lb = true;
      } });
      window.addEventListener("test", Mb, Mb);
      window.removeEventListener("test", Mb, Mb);
    } catch (a2) {
      Lb = false;
    }
    function Nb(a2, b, c2, d, e, f2, g, h, k2) {
      var l2 = Array.prototype.slice.call(arguments, 3);
      try {
        b.apply(c2, l2);
      } catch (m2) {
        this.onError(m2);
      }
    }
    var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
      Ob = true;
      Pb = a2;
    } };
    function Tb(a2, b, c2, d, e, f2, g, h, k2) {
      Ob = false;
      Pb = null;
      Nb.apply(Sb, arguments);
    }
    function Ub(a2, b, c2, d, e, f2, g, h, k2) {
      Tb.apply(this, arguments);
      if (Ob) {
        if (Ob) {
          var l2 = Pb;
          Ob = false;
          Pb = null;
        } else throw Error(p(198));
        Qb || (Qb = true, Rb = l2);
      }
    }
    function Vb(a2) {
      var b = a2, c2 = a2;
      if (a2.alternate) for (; b.return; ) b = b.return;
      else {
        a2 = b;
        do
          b = a2, 0 !== (b.flags & 4098) && (c2 = b.return), a2 = b.return;
        while (a2);
      }
      return 3 === b.tag ? c2 : null;
    }
    function Wb(a2) {
      if (13 === a2.tag) {
        var b = a2.memoizedState;
        null === b && (a2 = a2.alternate, null !== a2 && (b = a2.memoizedState));
        if (null !== b) return b.dehydrated;
      }
      return null;
    }
    function Xb(a2) {
      if (Vb(a2) !== a2) throw Error(p(188));
    }
    function Yb(a2) {
      var b = a2.alternate;
      if (!b) {
        b = Vb(a2);
        if (null === b) throw Error(p(188));
        return b !== a2 ? null : a2;
      }
      for (var c2 = a2, d = b; ; ) {
        var e = c2.return;
        if (null === e) break;
        var f2 = e.alternate;
        if (null === f2) {
          d = e.return;
          if (null !== d) {
            c2 = d;
            continue;
          }
          break;
        }
        if (e.child === f2.child) {
          for (f2 = e.child; f2; ) {
            if (f2 === c2) return Xb(e), a2;
            if (f2 === d) return Xb(e), b;
            f2 = f2.sibling;
          }
          throw Error(p(188));
        }
        if (c2.return !== d.return) c2 = e, d = f2;
        else {
          for (var g = false, h = e.child; h; ) {
            if (h === c2) {
              g = true;
              c2 = e;
              d = f2;
              break;
            }
            if (h === d) {
              g = true;
              d = e;
              c2 = f2;
              break;
            }
            h = h.sibling;
          }
          if (!g) {
            for (h = f2.child; h; ) {
              if (h === c2) {
                g = true;
                c2 = f2;
                d = e;
                break;
              }
              if (h === d) {
                g = true;
                d = f2;
                c2 = e;
                break;
              }
              h = h.sibling;
            }
            if (!g) throw Error(p(189));
          }
        }
        if (c2.alternate !== d) throw Error(p(190));
      }
      if (3 !== c2.tag) throw Error(p(188));
      return c2.stateNode.current === c2 ? a2 : b;
    }
    function Zb(a2) {
      a2 = Yb(a2);
      return null !== a2 ? $b(a2) : null;
    }
    function $b(a2) {
      if (5 === a2.tag || 6 === a2.tag) return a2;
      for (a2 = a2.child; null !== a2; ) {
        var b = $b(a2);
        if (null !== b) return b;
        a2 = a2.sibling;
      }
      return null;
    }
    var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
    function mc(a2) {
      if (lc && "function" === typeof lc.onCommitFiberRoot) try {
        lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
      } catch (b) {
      }
    }
    var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
    function nc(a2) {
      a2 >>>= 0;
      return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
    }
    var rc = 64, sc = 4194304;
    function tc(a2) {
      switch (a2 & -a2) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return a2 & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return a2 & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return a2;
      }
    }
    function uc(a2, b) {
      var c2 = a2.pendingLanes;
      if (0 === c2) return 0;
      var d = 0, e = a2.suspendedLanes, f2 = a2.pingedLanes, g = c2 & 268435455;
      if (0 !== g) {
        var h = g & ~e;
        0 !== h ? d = tc(h) : (f2 &= g, 0 !== f2 && (d = tc(f2)));
      } else g = c2 & ~e, 0 !== g ? d = tc(g) : 0 !== f2 && (d = tc(f2));
      if (0 === d) return 0;
      if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f2 = b & -b, e >= f2 || 16 === e && 0 !== (f2 & 4194240))) return b;
      0 !== (d & 4) && (d |= c2 & 16);
      b = a2.entangledLanes;
      if (0 !== b) for (a2 = a2.entanglements, b &= d; 0 < b; ) c2 = 31 - oc(b), e = 1 << c2, d |= a2[c2], b &= ~e;
      return d;
    }
    function vc(a2, b) {
      switch (a2) {
        case 1:
        case 2:
        case 4:
          return b + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return b + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function wc(a2, b) {
      for (var c2 = a2.suspendedLanes, d = a2.pingedLanes, e = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
        var g = 31 - oc(f2), h = 1 << g, k2 = e[g];
        if (-1 === k2) {
          if (0 === (h & c2) || 0 !== (h & d)) e[g] = vc(h, b);
        } else k2 <= b && (a2.expiredLanes |= h);
        f2 &= ~h;
      }
    }
    function xc(a2) {
      a2 = a2.pendingLanes & -1073741825;
      return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
    }
    function yc() {
      var a2 = rc;
      rc <<= 1;
      0 === (rc & 4194240) && (rc = 64);
      return a2;
    }
    function zc(a2) {
      for (var b = [], c2 = 0; 31 > c2; c2++) b.push(a2);
      return b;
    }
    function Ac(a2, b, c2) {
      a2.pendingLanes |= b;
      536870912 !== b && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
      a2 = a2.eventTimes;
      b = 31 - oc(b);
      a2[b] = c2;
    }
    function Bc(a2, b) {
      var c2 = a2.pendingLanes & ~b;
      a2.pendingLanes = b;
      a2.suspendedLanes = 0;
      a2.pingedLanes = 0;
      a2.expiredLanes &= b;
      a2.mutableReadLanes &= b;
      a2.entangledLanes &= b;
      b = a2.entanglements;
      var d = a2.eventTimes;
      for (a2 = a2.expirationTimes; 0 < c2; ) {
        var e = 31 - oc(c2), f2 = 1 << e;
        b[e] = 0;
        d[e] = -1;
        a2[e] = -1;
        c2 &= ~f2;
      }
    }
    function Cc(a2, b) {
      var c2 = a2.entangledLanes |= b;
      for (a2 = a2.entanglements; c2; ) {
        var d = 31 - oc(c2), e = 1 << d;
        e & b | a2[d] & b && (a2[d] |= b);
        c2 &= ~e;
      }
    }
    var C = 0;
    function Dc(a2) {
      a2 &= -a2;
      return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
    }
    var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function Sc(a2, b) {
      switch (a2) {
        case "focusin":
        case "focusout":
          Lc = null;
          break;
        case "dragenter":
        case "dragleave":
          Mc = null;
          break;
        case "mouseover":
        case "mouseout":
          Nc = null;
          break;
        case "pointerover":
        case "pointerout":
          Oc.delete(b.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Pc.delete(b.pointerId);
      }
    }
    function Tc(a2, b, c2, d, e, f2) {
      if (null === a2 || a2.nativeEvent !== f2) return a2 = { blockedOn: b, domEventName: c2, eventSystemFlags: d, nativeEvent: f2, targetContainers: [e] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a2;
      a2.eventSystemFlags |= d;
      b = a2.targetContainers;
      null !== e && -1 === b.indexOf(e) && b.push(e);
      return a2;
    }
    function Uc(a2, b, c2, d, e) {
      switch (b) {
        case "focusin":
          return Lc = Tc(Lc, a2, b, c2, d, e), true;
        case "dragenter":
          return Mc = Tc(Mc, a2, b, c2, d, e), true;
        case "mouseover":
          return Nc = Tc(Nc, a2, b, c2, d, e), true;
        case "pointerover":
          var f2 = e.pointerId;
          Oc.set(f2, Tc(Oc.get(f2) || null, a2, b, c2, d, e));
          return true;
        case "gotpointercapture":
          return f2 = e.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b, c2, d, e)), true;
      }
      return false;
    }
    function Vc(a2) {
      var b = Wc(a2.target);
      if (null !== b) {
        var c2 = Vb(b);
        if (null !== c2) {
          if (b = c2.tag, 13 === b) {
            if (b = Wb(c2), null !== b) {
              a2.blockedOn = b;
              Ic(a2.priority, function() {
                Gc(c2);
              });
              return;
            }
          } else if (3 === b && c2.stateNode.current.memoizedState.isDehydrated) {
            a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
            return;
          }
        }
      }
      a2.blockedOn = null;
    }
    function Xc(a2) {
      if (null !== a2.blockedOn) return false;
      for (var b = a2.targetContainers; 0 < b.length; ) {
        var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b[0], a2.nativeEvent);
        if (null === c2) {
          c2 = a2.nativeEvent;
          var d = new c2.constructor(c2.type, c2);
          wb = d;
          c2.target.dispatchEvent(d);
          wb = null;
        } else return b = Cb(c2), null !== b && Fc(b), a2.blockedOn = c2, false;
        b.shift();
      }
      return true;
    }
    function Zc(a2, b, c2) {
      Xc(a2) && c2.delete(b);
    }
    function $c() {
      Jc = false;
      null !== Lc && Xc(Lc) && (Lc = null);
      null !== Mc && Xc(Mc) && (Mc = null);
      null !== Nc && Xc(Nc) && (Nc = null);
      Oc.forEach(Zc);
      Pc.forEach(Zc);
    }
    function ad(a2, b) {
      a2.blockedOn === b && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
    }
    function bd(a2) {
      function b(b2) {
        return ad(b2, a2);
      }
      if (0 < Kc.length) {
        ad(Kc[0], a2);
        for (var c2 = 1; c2 < Kc.length; c2++) {
          var d = Kc[c2];
          d.blockedOn === a2 && (d.blockedOn = null);
        }
      }
      null !== Lc && ad(Lc, a2);
      null !== Mc && ad(Mc, a2);
      null !== Nc && ad(Nc, a2);
      Oc.forEach(b);
      Pc.forEach(b);
      for (c2 = 0; c2 < Qc.length; c2++) d = Qc[c2], d.blockedOn === a2 && (d.blockedOn = null);
      for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); ) Vc(c2), null === c2.blockedOn && Qc.shift();
    }
    var cd = ua.ReactCurrentBatchConfig, dd = true;
    function ed(a2, b, c2, d) {
      var e = C, f2 = cd.transition;
      cd.transition = null;
      try {
        C = 1, fd(a2, b, c2, d);
      } finally {
        C = e, cd.transition = f2;
      }
    }
    function gd(a2, b, c2, d) {
      var e = C, f2 = cd.transition;
      cd.transition = null;
      try {
        C = 4, fd(a2, b, c2, d);
      } finally {
        C = e, cd.transition = f2;
      }
    }
    function fd(a2, b, c2, d) {
      if (dd) {
        var e = Yc(a2, b, c2, d);
        if (null === e) hd(a2, b, d, id, c2), Sc(a2, d);
        else if (Uc(e, a2, b, c2, d)) d.stopPropagation();
        else if (Sc(a2, d), b & 4 && -1 < Rc.indexOf(a2)) {
          for (; null !== e; ) {
            var f2 = Cb(e);
            null !== f2 && Ec(f2);
            f2 = Yc(a2, b, c2, d);
            null === f2 && hd(a2, b, d, id, c2);
            if (f2 === e) break;
            e = f2;
          }
          null !== e && d.stopPropagation();
        } else hd(a2, b, d, null, c2);
      }
    }
    var id = null;
    function Yc(a2, b, c2, d) {
      id = null;
      a2 = xb(d);
      a2 = Wc(a2);
      if (null !== a2) if (b = Vb(a2), null === b) a2 = null;
      else if (c2 = b.tag, 13 === c2) {
        a2 = Wb(b);
        if (null !== a2) return a2;
        a2 = null;
      } else if (3 === c2) {
        if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
        a2 = null;
      } else b !== a2 && (a2 = null);
      id = a2;
      return null;
    }
    function jd(a2) {
      switch (a2) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 4;
        case "message":
          switch (ec()) {
            case fc:
              return 1;
            case gc:
              return 4;
            case hc:
            case ic:
              return 16;
            case jc:
              return 536870912;
            default:
              return 16;
          }
        default:
          return 16;
      }
    }
    var kd = null, ld = null, md = null;
    function nd() {
      if (md) return md;
      var a2, b = ld, c2 = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f2 = e.length;
      for (a2 = 0; a2 < c2 && b[a2] === e[a2]; a2++) ;
      var g = c2 - a2;
      for (d = 1; d <= g && b[c2 - d] === e[f2 - d]; d++) ;
      return md = e.slice(a2, 1 < d ? 1 - d : void 0);
    }
    function od(a2) {
      var b = a2.keyCode;
      "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b && (a2 = 13)) : a2 = b;
      10 === a2 && (a2 = 13);
      return 32 <= a2 || 13 === a2 ? a2 : 0;
    }
    function pd() {
      return true;
    }
    function qd() {
      return false;
    }
    function rd(a2) {
      function b(b2, d, e, f2, g) {
        this._reactName = b2;
        this._targetInst = e;
        this.type = d;
        this.nativeEvent = f2;
        this.target = g;
        this.currentTarget = null;
        for (var c2 in a2) a2.hasOwnProperty(c2) && (b2 = a2[c2], this[c2] = b2 ? b2(f2) : f2[c2]);
        this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
        this.isPropagationStopped = qd;
        return this;
      }
      A(b.prototype, { preventDefault: function() {
        this.defaultPrevented = true;
        var a3 = this.nativeEvent;
        a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
      }, stopPropagation: function() {
        var a3 = this.nativeEvent;
        a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
      }, persist: function() {
      }, isPersistent: pd });
      return b;
    }
    var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
      return a2.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
      return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
    }, movementX: function(a2) {
      if ("movementX" in a2) return a2.movementX;
      a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
      return wd;
    }, movementY: function(a2) {
      return "movementY" in a2 ? a2.movementY : xd;
    } }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A({}, sd, { clipboardData: function(a2) {
      return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
    } }), Jd = rd(Id), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Nd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function Pd(a2) {
      var b = this.nativeEvent;
      return b.getModifierState ? b.getModifierState(a2) : (a2 = Od[a2]) ? !!b[a2] : false;
    }
    function zd() {
      return Pd;
    }
    var Qd = A({}, ud, { key: function(a2) {
      if (a2.key) {
        var b = Md[a2.key] || a2.key;
        if ("Unidentified" !== b) return b;
      }
      return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
    }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
      return "keypress" === a2.type ? od(a2) : 0;
    }, keyCode: function(a2) {
      return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
    }, which: function(a2) {
      return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
    } }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
      deltaX: function(a2) {
        return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
      },
      deltaY: function(a2) {
        return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
    ia && "documentMode" in document && (be = document.documentMode);
    var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
    function ge(a2, b) {
      switch (a2) {
        case "keyup":
          return -1 !== $d.indexOf(b.keyCode);
        case "keydown":
          return 229 !== b.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function he(a2) {
      a2 = a2.detail;
      return "object" === typeof a2 && "data" in a2 ? a2.data : null;
    }
    var ie = false;
    function je(a2, b) {
      switch (a2) {
        case "compositionend":
          return he(b);
        case "keypress":
          if (32 !== b.which) return null;
          fe = true;
          return ee;
        case "textInput":
          return a2 = b.data, a2 === ee && fe ? null : a2;
        default:
          return null;
      }
    }
    function ke(a2, b) {
      if (ie) return "compositionend" === a2 || !ae && ge(a2, b) ? (a2 = nd(), md = ld = kd = null, ie = false, a2) : null;
      switch (a2) {
        case "paste":
          return null;
        case "keypress":
          if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
            if (b.char && 1 < b.char.length) return b.char;
            if (b.which) return String.fromCharCode(b.which);
          }
          return null;
        case "compositionend":
          return de && "ko" !== b.locale ? null : b.data;
        default:
          return null;
      }
    }
    var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
    function me(a2) {
      var b = a2 && a2.nodeName && a2.nodeName.toLowerCase();
      return "input" === b ? !!le[a2.type] : "textarea" === b ? true : false;
    }
    function ne(a2, b, c2, d) {
      Eb(d);
      b = oe(b, "onChange");
      0 < b.length && (c2 = new td("onChange", "change", null, c2, d), a2.push({ event: c2, listeners: b }));
    }
    var pe = null, qe = null;
    function re$1(a2) {
      se(a2, 0);
    }
    function te(a2) {
      var b = ue(a2);
      if (Wa(b)) return a2;
    }
    function ve(a2, b) {
      if ("change" === a2) return b;
    }
    var we = false;
    if (ia) {
      var xe;
      if (ia) {
        var ye = "oninput" in document;
        if (!ye) {
          var ze = document.createElement("div");
          ze.setAttribute("oninput", "return;");
          ye = "function" === typeof ze.oninput;
        }
        xe = ye;
      } else xe = false;
      we = xe && (!document.documentMode || 9 < document.documentMode);
    }
    function Ae() {
      pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
    }
    function Be(a2) {
      if ("value" === a2.propertyName && te(qe)) {
        var b = [];
        ne(b, qe, a2, xb(a2));
        Jb(re$1, b);
      }
    }
    function Ce(a2, b, c2) {
      "focusin" === a2 ? (Ae(), pe = b, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a2 && Ae();
    }
    function De(a2) {
      if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2) return te(qe);
    }
    function Ee(a2, b) {
      if ("click" === a2) return te(b);
    }
    function Fe(a2, b) {
      if ("input" === a2 || "change" === a2) return te(b);
    }
    function Ge(a2, b) {
      return a2 === b && (0 !== a2 || 1 / a2 === 1 / b) || a2 !== a2 && b !== b;
    }
    var He = "function" === typeof Object.is ? Object.is : Ge;
    function Ie(a2, b) {
      if (He(a2, b)) return true;
      if ("object" !== typeof a2 || null === a2 || "object" !== typeof b || null === b) return false;
      var c2 = Object.keys(a2), d = Object.keys(b);
      if (c2.length !== d.length) return false;
      for (d = 0; d < c2.length; d++) {
        var e = c2[d];
        if (!ja.call(b, e) || !He(a2[e], b[e])) return false;
      }
      return true;
    }
    function Je(a2) {
      for (; a2 && a2.firstChild; ) a2 = a2.firstChild;
      return a2;
    }
    function Ke(a2, b) {
      var c2 = Je(a2);
      a2 = 0;
      for (var d; c2; ) {
        if (3 === c2.nodeType) {
          d = a2 + c2.textContent.length;
          if (a2 <= b && d >= b) return { node: c2, offset: b - a2 };
          a2 = d;
        }
        a: {
          for (; c2; ) {
            if (c2.nextSibling) {
              c2 = c2.nextSibling;
              break a;
            }
            c2 = c2.parentNode;
          }
          c2 = void 0;
        }
        c2 = Je(c2);
      }
    }
    function Le(a2, b) {
      return a2 && b ? a2 === b ? true : a2 && 3 === a2.nodeType ? false : b && 3 === b.nodeType ? Le(a2, b.parentNode) : "contains" in a2 ? a2.contains(b) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b) & 16) : false : false;
    }
    function Me() {
      for (var a2 = window, b = Xa(); b instanceof a2.HTMLIFrameElement; ) {
        try {
          var c2 = "string" === typeof b.contentWindow.location.href;
        } catch (d) {
          c2 = false;
        }
        if (c2) a2 = b.contentWindow;
        else break;
        b = Xa(a2.document);
      }
      return b;
    }
    function Ne(a2) {
      var b = a2 && a2.nodeName && a2.nodeName.toLowerCase();
      return b && ("input" === b && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b || "true" === a2.contentEditable);
    }
    function Oe(a2) {
      var b = Me(), c2 = a2.focusedElem, d = a2.selectionRange;
      if (b !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
        if (null !== d && Ne(c2)) {
          if (b = d.start, a2 = d.end, void 0 === a2 && (a2 = b), "selectionStart" in c2) c2.selectionStart = b, c2.selectionEnd = Math.min(a2, c2.value.length);
          else if (a2 = (b = c2.ownerDocument || document) && b.defaultView || window, a2.getSelection) {
            a2 = a2.getSelection();
            var e = c2.textContent.length, f2 = Math.min(d.start, e);
            d = void 0 === d.end ? f2 : Math.min(d.end, e);
            !a2.extend && f2 > d && (e = d, d = f2, f2 = e);
            e = Ke(c2, f2);
            var g = Ke(
              c2,
              d
            );
            e && g && (1 !== a2.rangeCount || a2.anchorNode !== e.node || a2.anchorOffset !== e.offset || a2.focusNode !== g.node || a2.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a2.removeAllRanges(), f2 > d ? (a2.addRange(b), a2.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a2.addRange(b)));
          }
        }
        b = [];
        for (a2 = c2; a2 = a2.parentNode; ) 1 === a2.nodeType && b.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
        "function" === typeof c2.focus && c2.focus();
        for (c2 = 0; c2 < b.length; c2++) a2 = b[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
      }
    }
    var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
    function Ue(a2, b, c2) {
      var d = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
      Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c2), a2.push({ event: b, listeners: d }), b.target = Qe)));
    }
    function Ve(a2, b) {
      var c2 = {};
      c2[a2.toLowerCase()] = b.toLowerCase();
      c2["Webkit" + a2] = "webkit" + b;
      c2["Moz" + a2] = "moz" + b;
      return c2;
    }
    var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
    ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
    function Ze(a2) {
      if (Xe[a2]) return Xe[a2];
      if (!We[a2]) return a2;
      var b = We[a2], c2;
      for (c2 in b) if (b.hasOwnProperty(c2) && c2 in Ye) return Xe[a2] = b[c2];
      return a2;
    }
    var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    function ff(a2, b) {
      df.set(a2, b);
      fa(b, [a2]);
    }
    for (var gf = 0; gf < ef.length; gf++) {
      var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
      ff(jf, "on" + kf);
    }
    ff($e, "onAnimationEnd");
    ff(af, "onAnimationIteration");
    ff(bf, "onAnimationStart");
    ff("dblclick", "onDoubleClick");
    ff("focusin", "onFocus");
    ff("focusout", "onBlur");
    ff(cf, "onTransitionEnd");
    ha("onMouseEnter", ["mouseout", "mouseover"]);
    ha("onMouseLeave", ["mouseout", "mouseover"]);
    ha("onPointerEnter", ["pointerout", "pointerover"]);
    ha("onPointerLeave", ["pointerout", "pointerover"]);
    fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
    function nf(a2, b, c2) {
      var d = a2.type || "unknown-event";
      a2.currentTarget = c2;
      Ub(d, b, void 0, a2);
      a2.currentTarget = null;
    }
    function se(a2, b) {
      b = 0 !== (b & 4);
      for (var c2 = 0; c2 < a2.length; c2++) {
        var d = a2[c2], e = d.event;
        d = d.listeners;
        a: {
          var f2 = void 0;
          if (b) for (var g = d.length - 1; 0 <= g; g--) {
            var h = d[g], k2 = h.instance, l2 = h.currentTarget;
            h = h.listener;
            if (k2 !== f2 && e.isPropagationStopped()) break a;
            nf(e, h, l2);
            f2 = k2;
          }
          else for (g = 0; g < d.length; g++) {
            h = d[g];
            k2 = h.instance;
            l2 = h.currentTarget;
            h = h.listener;
            if (k2 !== f2 && e.isPropagationStopped()) break a;
            nf(e, h, l2);
            f2 = k2;
          }
        }
      }
      if (Qb) throw a2 = Rb, Qb = false, Rb = null, a2;
    }
    function D(a2, b) {
      var c2 = b[of];
      void 0 === c2 && (c2 = b[of] = /* @__PURE__ */ new Set());
      var d = a2 + "__bubble";
      c2.has(d) || (pf(b, a2, 2, false), c2.add(d));
    }
    function qf(a2, b, c2) {
      var d = 0;
      b && (d |= 4);
      pf(c2, a2, d, b);
    }
    var rf = "_reactListening" + Math.random().toString(36).slice(2);
    function sf(a2) {
      if (!a2[rf]) {
        a2[rf] = true;
        da.forEach(function(b2) {
          "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a2), qf(b2, true, a2));
        });
        var b = 9 === a2.nodeType ? a2 : a2.ownerDocument;
        null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
      }
    }
    function pf(a2, b, c2, d) {
      switch (jd(b)) {
        case 1:
          var e = ed;
          break;
        case 4:
          e = gd;
          break;
        default:
          e = fd;
      }
      c2 = e.bind(null, b, c2, a2);
      e = void 0;
      !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
      d ? void 0 !== e ? a2.addEventListener(b, c2, { capture: true, passive: e }) : a2.addEventListener(b, c2, true) : void 0 !== e ? a2.addEventListener(b, c2, { passive: e }) : a2.addEventListener(b, c2, false);
    }
    function hd(a2, b, c2, d, e) {
      var f2 = d;
      if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (; ; ) {
        if (null === d) return;
        var g = d.tag;
        if (3 === g || 4 === g) {
          var h = d.stateNode.containerInfo;
          if (h === e || 8 === h.nodeType && h.parentNode === e) break;
          if (4 === g) for (g = d.return; null !== g; ) {
            var k2 = g.tag;
            if (3 === k2 || 4 === k2) {
              if (k2 = g.stateNode.containerInfo, k2 === e || 8 === k2.nodeType && k2.parentNode === e) return;
            }
            g = g.return;
          }
          for (; null !== h; ) {
            g = Wc(h);
            if (null === g) return;
            k2 = g.tag;
            if (5 === k2 || 6 === k2) {
              d = f2 = g;
              continue a;
            }
            h = h.parentNode;
          }
        }
        d = d.return;
      }
      Jb(function() {
        var d2 = f2, e3 = xb(c2), g2 = [];
        a: {
          var h2 = df.get(a2);
          if (void 0 !== h2) {
            var k3 = td, n2 = a2;
            switch (a2) {
              case "keypress":
                if (0 === od(c2)) break a;
              case "keydown":
              case "keyup":
                k3 = Rd;
                break;
              case "focusin":
                n2 = "focus";
                k3 = Fd;
                break;
              case "focusout":
                n2 = "blur";
                k3 = Fd;
                break;
              case "beforeblur":
              case "afterblur":
                k3 = Fd;
                break;
              case "click":
                if (2 === c2.button) break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                k3 = Bd;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                k3 = Dd;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                k3 = Vd;
                break;
              case $e:
              case af:
              case bf:
                k3 = Hd;
                break;
              case cf:
                k3 = Xd;
                break;
              case "scroll":
                k3 = vd;
                break;
              case "wheel":
                k3 = Zd;
                break;
              case "copy":
              case "cut":
              case "paste":
                k3 = Jd;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                k3 = Td;
            }
            var t2 = 0 !== (b & 4), J2 = !t2 && "scroll" === a2, x2 = t2 ? null !== h2 ? h2 + "Capture" : null : h2;
            t2 = [];
            for (var w2 = d2, u2; null !== w2; ) {
              u2 = w2;
              var F2 = u2.stateNode;
              5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
              if (J2) break;
              w2 = w2.return;
            }
            0 < t2.length && (h2 = new k3(h2, n2, null, c2, e3), g2.push({ event: h2, listeners: t2 }));
          }
        }
        if (0 === (b & 7)) {
          a: {
            h2 = "mouseover" === a2 || "pointerover" === a2;
            k3 = "mouseout" === a2 || "pointerout" === a2;
            if (h2 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf])) break a;
            if (k3 || h2) {
              h2 = e3.window === e3 ? e3 : (h2 = e3.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
              if (k3) {
                if (n2 = c2.relatedTarget || c2.toElement, k3 = d2, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag)) n2 = null;
              } else k3 = null, n2 = d2;
              if (k3 !== n2) {
                t2 = Bd;
                F2 = "onMouseLeave";
                x2 = "onMouseEnter";
                w2 = "mouse";
                if ("pointerout" === a2 || "pointerover" === a2) t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
                J2 = null == k3 ? h2 : ue(k3);
                u2 = null == n2 ? h2 : ue(n2);
                h2 = new t2(F2, w2 + "leave", k3, c2, e3);
                h2.target = J2;
                h2.relatedTarget = u2;
                F2 = null;
                Wc(e3) === d2 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
                J2 = F2;
                if (k3 && n2) b: {
                  t2 = k3;
                  x2 = n2;
                  w2 = 0;
                  for (u2 = t2; u2; u2 = vf(u2)) w2++;
                  u2 = 0;
                  for (F2 = x2; F2; F2 = vf(F2)) u2++;
                  for (; 0 < w2 - u2; ) t2 = vf(t2), w2--;
                  for (; 0 < u2 - w2; ) x2 = vf(x2), u2--;
                  for (; w2--; ) {
                    if (t2 === x2 || null !== x2 && t2 === x2.alternate) break b;
                    t2 = vf(t2);
                    x2 = vf(x2);
                  }
                  t2 = null;
                }
                else t2 = null;
                null !== k3 && wf(g2, h2, k3, t2, false);
                null !== n2 && null !== J2 && wf(g2, J2, n2, t2, true);
              }
            }
          }
          a: {
            h2 = d2 ? ue(d2) : window;
            k3 = h2.nodeName && h2.nodeName.toLowerCase();
            if ("select" === k3 || "input" === k3 && "file" === h2.type) var na = ve;
            else if (me(h2)) if (we) na = Fe;
            else {
              na = De;
              var xa = Ce;
            }
            else (k3 = h2.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (na = Ee);
            if (na && (na = na(a2, d2))) {
              ne(g2, na, c2, e3);
              break a;
            }
            xa && xa(a2, h2, d2);
            "focusout" === a2 && (xa = h2._wrapperState) && xa.controlled && "number" === h2.type && cb(h2, "number", h2.value);
          }
          xa = d2 ? ue(d2) : window;
          switch (a2) {
            case "focusin":
              if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d2, Se = null;
              break;
            case "focusout":
              Se = Re = Qe = null;
              break;
            case "mousedown":
              Te = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Te = false;
              Ue(g2, c2, e3);
              break;
            case "selectionchange":
              if (Pe) break;
            case "keydown":
            case "keyup":
              Ue(g2, c2, e3);
          }
          var $a;
          if (ae) b: {
            switch (a2) {
              case "compositionstart":
                var ba = "onCompositionStart";
                break b;
              case "compositionend":
                ba = "onCompositionEnd";
                break b;
              case "compositionupdate":
                ba = "onCompositionUpdate";
                break b;
            }
            ba = void 0;
          }
          else ie ? ge(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
          ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
          if ($a = ce ? je(a2, c2) : ke(a2, c2)) d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g2.push({ event: e3, listeners: d2 }), e3.data = $a);
        }
        se(g2, b);
      });
    }
    function tf(a2, b, c2) {
      return { instance: a2, listener: b, currentTarget: c2 };
    }
    function oe(a2, b) {
      for (var c2 = b + "Capture", d = []; null !== a2; ) {
        var e = a2, f2 = e.stateNode;
        5 === e.tag && null !== f2 && (e = f2, f2 = Kb(a2, c2), null != f2 && d.unshift(tf(a2, f2, e)), f2 = Kb(a2, b), null != f2 && d.push(tf(a2, f2, e)));
        a2 = a2.return;
      }
      return d;
    }
    function vf(a2) {
      if (null === a2) return null;
      do
        a2 = a2.return;
      while (a2 && 5 !== a2.tag);
      return a2 ? a2 : null;
    }
    function wf(a2, b, c2, d, e) {
      for (var f2 = b._reactName, g = []; null !== c2 && c2 !== d; ) {
        var h = c2, k2 = h.alternate, l2 = h.stateNode;
        if (null !== k2 && k2 === d) break;
        5 === h.tag && null !== l2 && (h = l2, e ? (k2 = Kb(c2, f2), null != k2 && g.unshift(tf(c2, k2, h))) : e || (k2 = Kb(c2, f2), null != k2 && g.push(tf(c2, k2, h))));
        c2 = c2.return;
      }
      0 !== g.length && a2.push({ event: b, listeners: g });
    }
    var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
    function zf(a2) {
      return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
    }
    function Af(a2, b, c2) {
      b = zf(b);
      if (zf(a2) !== b && c2) throw Error(p(425));
    }
    function Bf() {
    }
    var Cf = null, Df = null;
    function Ef(a2, b) {
      return "textarea" === a2 || "noscript" === a2 || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
    }
    var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
      return Hf.resolve(null).then(a2).catch(If);
    } : Ff;
    function If(a2) {
      setTimeout(function() {
        throw a2;
      });
    }
    function Kf(a2, b) {
      var c2 = b, d = 0;
      do {
        var e = c2.nextSibling;
        a2.removeChild(c2);
        if (e && 8 === e.nodeType) if (c2 = e.data, "/$" === c2) {
          if (0 === d) {
            a2.removeChild(e);
            bd(b);
            return;
          }
          d--;
        } else "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d++;
        c2 = e;
      } while (c2);
      bd(b);
    }
    function Lf(a2) {
      for (; null != a2; a2 = a2.nextSibling) {
        var b = a2.nodeType;
        if (1 === b || 3 === b) break;
        if (8 === b) {
          b = a2.data;
          if ("$" === b || "$!" === b || "$?" === b) break;
          if ("/$" === b) return null;
        }
      }
      return a2;
    }
    function Mf(a2) {
      a2 = a2.previousSibling;
      for (var b = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("$" === c2 || "$!" === c2 || "$?" === c2) {
            if (0 === b) return a2;
            b--;
          } else "/$" === c2 && b++;
        }
        a2 = a2.previousSibling;
      }
      return null;
    }
    var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
    function Wc(a2) {
      var b = a2[Of];
      if (b) return b;
      for (var c2 = a2.parentNode; c2; ) {
        if (b = c2[uf] || c2[Of]) {
          c2 = b.alternate;
          if (null !== b.child || null !== c2 && null !== c2.child) for (a2 = Mf(a2); null !== a2; ) {
            if (c2 = a2[Of]) return c2;
            a2 = Mf(a2);
          }
          return b;
        }
        a2 = c2;
        c2 = a2.parentNode;
      }
      return null;
    }
    function Cb(a2) {
      a2 = a2[Of] || a2[uf];
      return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
    }
    function ue(a2) {
      if (5 === a2.tag || 6 === a2.tag) return a2.stateNode;
      throw Error(p(33));
    }
    function Db(a2) {
      return a2[Pf] || null;
    }
    var Sf = [], Tf = -1;
    function Uf(a2) {
      return { current: a2 };
    }
    function E(a2) {
      0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
    }
    function G(a2, b) {
      Tf++;
      Sf[Tf] = a2.current;
      a2.current = b;
    }
    var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
    function Yf(a2, b) {
      var c2 = a2.type.contextTypes;
      if (!c2) return Vf;
      var d = a2.stateNode;
      if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
      var e = {}, f2;
      for (f2 in c2) e[f2] = b[f2];
      d && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b, a2.__reactInternalMemoizedMaskedChildContext = e);
      return e;
    }
    function Zf(a2) {
      a2 = a2.childContextTypes;
      return null !== a2 && void 0 !== a2;
    }
    function $f() {
      E(Wf);
      E(H);
    }
    function ag(a2, b, c2) {
      if (H.current !== Vf) throw Error(p(168));
      G(H, b);
      G(Wf, c2);
    }
    function bg(a2, b, c2) {
      var d = a2.stateNode;
      b = b.childContextTypes;
      if ("function" !== typeof d.getChildContext) return c2;
      d = d.getChildContext();
      for (var e in d) if (!(e in b)) throw Error(p(108, Ra(a2) || "Unknown", e));
      return A({}, c2, d);
    }
    function cg(a2) {
      a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
      Xf = H.current;
      G(H, a2);
      G(Wf, Wf.current);
      return true;
    }
    function dg(a2, b, c2) {
      var d = a2.stateNode;
      if (!d) throw Error(p(169));
      c2 ? (a2 = bg(a2, b, Xf), d.__reactInternalMemoizedMergedChildContext = a2, E(Wf), E(H), G(H, a2)) : E(Wf);
      G(Wf, c2);
    }
    var eg = null, fg = false, gg = false;
    function hg(a2) {
      null === eg ? eg = [a2] : eg.push(a2);
    }
    function ig(a2) {
      fg = true;
      hg(a2);
    }
    function jg() {
      if (!gg && null !== eg) {
        gg = true;
        var a2 = 0, b = C;
        try {
          var c2 = eg;
          for (C = 1; a2 < c2.length; a2++) {
            var d = c2[a2];
            do
              d = d(true);
            while (null !== d);
          }
          eg = null;
          fg = false;
        } catch (e) {
          throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e;
        } finally {
          C = b, gg = false;
        }
      }
      return null;
    }
    var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
    function tg(a2, b) {
      kg[lg++] = ng;
      kg[lg++] = mg;
      mg = a2;
      ng = b;
    }
    function ug(a2, b, c2) {
      og[pg++] = rg;
      og[pg++] = sg;
      og[pg++] = qg;
      qg = a2;
      var d = rg;
      a2 = sg;
      var e = 32 - oc(d) - 1;
      d &= ~(1 << e);
      c2 += 1;
      var f2 = 32 - oc(b) + e;
      if (30 < f2) {
        var g = e - e % 5;
        f2 = (d & (1 << g) - 1).toString(32);
        d >>= g;
        e -= g;
        rg = 1 << 32 - oc(b) + e | c2 << e | d;
        sg = f2 + a2;
      } else rg = 1 << f2 | c2 << e | d, sg = a2;
    }
    function vg(a2) {
      null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
    }
    function wg(a2) {
      for (; a2 === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
      for (; a2 === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
    }
    var xg = null, yg = null, I = false, zg = null;
    function Ag(a2, b) {
      var c2 = Bg(5, null, null, 0);
      c2.elementType = "DELETED";
      c2.stateNode = b;
      c2.return = a2;
      b = a2.deletions;
      null === b ? (a2.deletions = [c2], a2.flags |= 16) : b.push(c2);
    }
    function Cg(a2, b) {
      switch (a2.tag) {
        case 5:
          var c2 = a2.type;
          b = 1 !== b.nodeType || c2.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
          return null !== b ? (a2.stateNode = b, xg = a2, yg = Lf(b.firstChild), true) : false;
        case 6:
          return b = "" === a2.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a2.stateNode = b, xg = a2, yg = null, true) : false;
        case 13:
          return b = 8 !== b.nodeType ? null : b, null !== b ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
        default:
          return false;
      }
    }
    function Dg(a2) {
      return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
    }
    function Eg(a2) {
      if (I) {
        var b = yg;
        if (b) {
          var c2 = b;
          if (!Cg(a2, b)) {
            if (Dg(a2)) throw Error(p(418));
            b = Lf(c2.nextSibling);
            var d = xg;
            b && Cg(a2, b) ? Ag(d, c2) : (a2.flags = a2.flags & -4097 | 2, I = false, xg = a2);
          }
        } else {
          if (Dg(a2)) throw Error(p(418));
          a2.flags = a2.flags & -4097 | 2;
          I = false;
          xg = a2;
        }
      }
    }
    function Fg(a2) {
      for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; ) a2 = a2.return;
      xg = a2;
    }
    function Gg(a2) {
      if (a2 !== xg) return false;
      if (!I) return Fg(a2), I = true, false;
      var b;
      (b = 3 !== a2.tag) && !(b = 5 !== a2.tag) && (b = a2.type, b = "head" !== b && "body" !== b && !Ef(a2.type, a2.memoizedProps));
      if (b && (b = yg)) {
        if (Dg(a2)) throw Hg(), Error(p(418));
        for (; b; ) Ag(a2, b), b = Lf(b.nextSibling);
      }
      Fg(a2);
      if (13 === a2.tag) {
        a2 = a2.memoizedState;
        a2 = null !== a2 ? a2.dehydrated : null;
        if (!a2) throw Error(p(317));
        a: {
          a2 = a2.nextSibling;
          for (b = 0; a2; ) {
            if (8 === a2.nodeType) {
              var c2 = a2.data;
              if ("/$" === c2) {
                if (0 === b) {
                  yg = Lf(a2.nextSibling);
                  break a;
                }
                b--;
              } else "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b++;
            }
            a2 = a2.nextSibling;
          }
          yg = null;
        }
      } else yg = xg ? Lf(a2.stateNode.nextSibling) : null;
      return true;
    }
    function Hg() {
      for (var a2 = yg; a2; ) a2 = Lf(a2.nextSibling);
    }
    function Ig() {
      yg = xg = null;
      I = false;
    }
    function Jg(a2) {
      null === zg ? zg = [a2] : zg.push(a2);
    }
    var Kg = ua.ReactCurrentBatchConfig;
    function Lg(a2, b, c2) {
      a2 = c2.ref;
      if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
        if (c2._owner) {
          c2 = c2._owner;
          if (c2) {
            if (1 !== c2.tag) throw Error(p(309));
            var d = c2.stateNode;
          }
          if (!d) throw Error(p(147, a2));
          var e = d, f2 = "" + a2;
          if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f2) return b.ref;
          b = function(a3) {
            var b2 = e.refs;
            null === a3 ? delete b2[f2] : b2[f2] = a3;
          };
          b._stringRef = f2;
          return b;
        }
        if ("string" !== typeof a2) throw Error(p(284));
        if (!c2._owner) throw Error(p(290, a2));
      }
      return a2;
    }
    function Mg(a2, b) {
      a2 = Object.prototype.toString.call(b);
      throw Error(p(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b).join(", ") + "}" : a2));
    }
    function Ng(a2) {
      var b = a2._init;
      return b(a2._payload);
    }
    function Og(a2) {
      function b(b2, c3) {
        if (a2) {
          var d2 = b2.deletions;
          null === d2 ? (b2.deletions = [c3], b2.flags |= 16) : d2.push(c3);
        }
      }
      function c2(c3, d2) {
        if (!a2) return null;
        for (; null !== d2; ) b(c3, d2), d2 = d2.sibling;
        return null;
      }
      function d(a3, b2) {
        for (a3 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a3.set(b2.key, b2) : a3.set(b2.index, b2), b2 = b2.sibling;
        return a3;
      }
      function e(a3, b2) {
        a3 = Pg(a3, b2);
        a3.index = 0;
        a3.sibling = null;
        return a3;
      }
      function f2(b2, c3, d2) {
        b2.index = d2;
        if (!a2) return b2.flags |= 1048576, c3;
        d2 = b2.alternate;
        if (null !== d2) return d2 = d2.index, d2 < c3 ? (b2.flags |= 2, c3) : d2;
        b2.flags |= 2;
        return c3;
      }
      function g(b2) {
        a2 && null === b2.alternate && (b2.flags |= 2);
        return b2;
      }
      function h(a3, b2, c3, d2) {
        if (null === b2 || 6 !== b2.tag) return b2 = Qg(c3, a3.mode, d2), b2.return = a3, b2;
        b2 = e(b2, c3);
        b2.return = a3;
        return b2;
      }
      function k2(a3, b2, c3, d2) {
        var f3 = c3.type;
        if (f3 === ya) return m2(a3, b2, c3.props.children, d2, c3.key);
        if (null !== b2 && (b2.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && Ng(f3) === b2.type)) return d2 = e(b2, c3.props), d2.ref = Lg(a3, b2, c3), d2.return = a3, d2;
        d2 = Rg(c3.type, c3.key, c3.props, null, a3.mode, d2);
        d2.ref = Lg(a3, b2, c3);
        d2.return = a3;
        return d2;
      }
      function l2(a3, b2, c3, d2) {
        if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c3.containerInfo || b2.stateNode.implementation !== c3.implementation) return b2 = Sg(c3, a3.mode, d2), b2.return = a3, b2;
        b2 = e(b2, c3.children || []);
        b2.return = a3;
        return b2;
      }
      function m2(a3, b2, c3, d2, f3) {
        if (null === b2 || 7 !== b2.tag) return b2 = Tg(c3, a3.mode, d2, f3), b2.return = a3, b2;
        b2 = e(b2, c3);
        b2.return = a3;
        return b2;
      }
      function q2(a3, b2, c3) {
        if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2) return b2 = Qg("" + b2, a3.mode, c3), b2.return = a3, b2;
        if ("object" === typeof b2 && null !== b2) {
          switch (b2.$$typeof) {
            case va:
              return c3 = Rg(b2.type, b2.key, b2.props, null, a3.mode, c3), c3.ref = Lg(a3, null, b2), c3.return = a3, c3;
            case wa:
              return b2 = Sg(b2, a3.mode, c3), b2.return = a3, b2;
            case Ha:
              var d2 = b2._init;
              return q2(a3, d2(b2._payload), c3);
          }
          if (eb(b2) || Ka(b2)) return b2 = Tg(b2, a3.mode, c3, null), b2.return = a3, b2;
          Mg(a3, b2);
        }
        return null;
      }
      function r2(a3, b2, c3, d2) {
        var e3 = null !== b2 ? b2.key : null;
        if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3) return null !== e3 ? null : h(a3, b2, "" + c3, d2);
        if ("object" === typeof c3 && null !== c3) {
          switch (c3.$$typeof) {
            case va:
              return c3.key === e3 ? k2(a3, b2, c3, d2) : null;
            case wa:
              return c3.key === e3 ? l2(a3, b2, c3, d2) : null;
            case Ha:
              return e3 = c3._init, r2(
                a3,
                b2,
                e3(c3._payload),
                d2
              );
          }
          if (eb(c3) || Ka(c3)) return null !== e3 ? null : m2(a3, b2, c3, d2, null);
          Mg(a3, c3);
        }
        return null;
      }
      function y2(a3, b2, c3, d2, e3) {
        if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2) return a3 = a3.get(c3) || null, h(b2, a3, "" + d2, e3);
        if ("object" === typeof d2 && null !== d2) {
          switch (d2.$$typeof) {
            case va:
              return a3 = a3.get(null === d2.key ? c3 : d2.key) || null, k2(b2, a3, d2, e3);
            case wa:
              return a3 = a3.get(null === d2.key ? c3 : d2.key) || null, l2(b2, a3, d2, e3);
            case Ha:
              var f3 = d2._init;
              return y2(a3, b2, c3, f3(d2._payload), e3);
          }
          if (eb(d2) || Ka(d2)) return a3 = a3.get(c3) || null, m2(b2, a3, d2, e3, null);
          Mg(b2, d2);
        }
        return null;
      }
      function n2(e3, g2, h2, k3) {
        for (var l3 = null, m3 = null, u2 = g2, w2 = g2 = 0, x2 = null; null !== u2 && w2 < h2.length; w2++) {
          u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
          var n3 = r2(e3, u2, h2[w2], k3);
          if (null === n3) {
            null === u2 && (u2 = x2);
            break;
          }
          a2 && u2 && null === n3.alternate && b(e3, u2);
          g2 = f2(n3, g2, w2);
          null === m3 ? l3 = n3 : m3.sibling = n3;
          m3 = n3;
          u2 = x2;
        }
        if (w2 === h2.length) return c2(e3, u2), I && tg(e3, w2), l3;
        if (null === u2) {
          for (; w2 < h2.length; w2++) u2 = q2(e3, h2[w2], k3), null !== u2 && (g2 = f2(u2, g2, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
          I && tg(e3, w2);
          return l3;
        }
        for (u2 = d(e3, u2); w2 < h2.length; w2++) x2 = y2(u2, e3, w2, h2[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g2 = f2(x2, g2, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
        a2 && u2.forEach(function(a3) {
          return b(e3, a3);
        });
        I && tg(e3, w2);
        return l3;
      }
      function t2(e3, g2, h2, k3) {
        var l3 = Ka(h2);
        if ("function" !== typeof l3) throw Error(p(150));
        h2 = l3.call(h2);
        if (null == h2) throw Error(p(151));
        for (var u2 = l3 = null, m3 = g2, w2 = g2 = 0, x2 = null, n3 = h2.next(); null !== m3 && !n3.done; w2++, n3 = h2.next()) {
          m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
          var t3 = r2(e3, m3, n3.value, k3);
          if (null === t3) {
            null === m3 && (m3 = x2);
            break;
          }
          a2 && m3 && null === t3.alternate && b(e3, m3);
          g2 = f2(t3, g2, w2);
          null === u2 ? l3 = t3 : u2.sibling = t3;
          u2 = t3;
          m3 = x2;
        }
        if (n3.done) return c2(
          e3,
          m3
        ), I && tg(e3, w2), l3;
        if (null === m3) {
          for (; !n3.done; w2++, n3 = h2.next()) n3 = q2(e3, n3.value, k3), null !== n3 && (g2 = f2(n3, g2, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
          I && tg(e3, w2);
          return l3;
        }
        for (m3 = d(e3, m3); !n3.done; w2++, n3 = h2.next()) n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g2 = f2(n3, g2, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
        a2 && m3.forEach(function(a3) {
          return b(e3, a3);
        });
        I && tg(e3, w2);
        return l3;
      }
      function J2(a3, d2, f3, h2) {
        "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
        if ("object" === typeof f3 && null !== f3) {
          switch (f3.$$typeof) {
            case va:
              a: {
                for (var k3 = f3.key, l3 = d2; null !== l3; ) {
                  if (l3.key === k3) {
                    k3 = f3.type;
                    if (k3 === ya) {
                      if (7 === l3.tag) {
                        c2(a3, l3.sibling);
                        d2 = e(l3, f3.props.children);
                        d2.return = a3;
                        a3 = d2;
                        break a;
                      }
                    } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && Ng(k3) === l3.type) {
                      c2(a3, l3.sibling);
                      d2 = e(l3, f3.props);
                      d2.ref = Lg(a3, l3, f3);
                      d2.return = a3;
                      a3 = d2;
                      break a;
                    }
                    c2(a3, l3);
                    break;
                  } else b(a3, l3);
                  l3 = l3.sibling;
                }
                f3.type === ya ? (d2 = Tg(f3.props.children, a3.mode, h2, f3.key), d2.return = a3, a3 = d2) : (h2 = Rg(f3.type, f3.key, f3.props, null, a3.mode, h2), h2.ref = Lg(a3, d2, f3), h2.return = a3, a3 = h2);
              }
              return g(a3);
            case wa:
              a: {
                for (l3 = f3.key; null !== d2; ) {
                  if (d2.key === l3) if (4 === d2.tag && d2.stateNode.containerInfo === f3.containerInfo && d2.stateNode.implementation === f3.implementation) {
                    c2(a3, d2.sibling);
                    d2 = e(d2, f3.children || []);
                    d2.return = a3;
                    a3 = d2;
                    break a;
                  } else {
                    c2(a3, d2);
                    break;
                  }
                  else b(a3, d2);
                  d2 = d2.sibling;
                }
                d2 = Sg(f3, a3.mode, h2);
                d2.return = a3;
                a3 = d2;
              }
              return g(a3);
            case Ha:
              return l3 = f3._init, J2(a3, d2, l3(f3._payload), h2);
          }
          if (eb(f3)) return n2(a3, d2, f3, h2);
          if (Ka(f3)) return t2(a3, d2, f3, h2);
          Mg(a3, f3);
        }
        return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d2 && 6 === d2.tag ? (c2(a3, d2.sibling), d2 = e(d2, f3), d2.return = a3, a3 = d2) : (c2(a3, d2), d2 = Qg(f3, a3.mode, h2), d2.return = a3, a3 = d2), g(a3)) : c2(a3, d2);
      }
      return J2;
    }
    var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
    function $g() {
      Zg = Yg = Xg = null;
    }
    function ah(a2) {
      var b = Wg.current;
      E(Wg);
      a2._currentValue = b;
    }
    function bh(a2, b, c2) {
      for (; null !== a2; ) {
        var d = a2.alternate;
        (a2.childLanes & b) !== b ? (a2.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
        if (a2 === c2) break;
        a2 = a2.return;
      }
    }
    function ch(a2, b) {
      Xg = a2;
      Zg = Yg = null;
      a2 = a2.dependencies;
      null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b) && (dh = true), a2.firstContext = null);
    }
    function eh(a2) {
      var b = a2._currentValue;
      if (Zg !== a2) if (a2 = { context: a2, memoizedValue: b, next: null }, null === Yg) {
        if (null === Xg) throw Error(p(308));
        Yg = a2;
        Xg.dependencies = { lanes: 0, firstContext: a2 };
      } else Yg = Yg.next = a2;
      return b;
    }
    var fh = null;
    function gh(a2) {
      null === fh ? fh = [a2] : fh.push(a2);
    }
    function hh(a2, b, c2, d) {
      var e = b.interleaved;
      null === e ? (c2.next = c2, gh(b)) : (c2.next = e.next, e.next = c2);
      b.interleaved = c2;
      return ih(a2, d);
    }
    function ih(a2, b) {
      a2.lanes |= b;
      var c2 = a2.alternate;
      null !== c2 && (c2.lanes |= b);
      c2 = a2;
      for (a2 = a2.return; null !== a2; ) a2.childLanes |= b, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b), c2 = a2, a2 = a2.return;
      return 3 === c2.tag ? c2.stateNode : null;
    }
    var jh = false;
    function kh(a2) {
      a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function lh(a2, b) {
      a2 = a2.updateQueue;
      b.updateQueue === a2 && (b.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
    }
    function mh(a2, b) {
      return { eventTime: a2, lane: b, tag: 0, payload: null, callback: null, next: null };
    }
    function nh(a2, b, c2) {
      var d = a2.updateQueue;
      if (null === d) return null;
      d = d.shared;
      if (0 !== (K & 2)) {
        var e = d.pending;
        null === e ? b.next = b : (b.next = e.next, e.next = b);
        d.pending = b;
        return ih(a2, c2);
      }
      e = d.interleaved;
      null === e ? (b.next = b, gh(d)) : (b.next = e.next, e.next = b);
      d.interleaved = b;
      return ih(a2, c2);
    }
    function oh(a2, b, c2) {
      b = b.updateQueue;
      if (null !== b && (b = b.shared, 0 !== (c2 & 4194240))) {
        var d = b.lanes;
        d &= a2.pendingLanes;
        c2 |= d;
        b.lanes = c2;
        Cc(a2, c2);
      }
    }
    function ph(a2, b) {
      var c2 = a2.updateQueue, d = a2.alternate;
      if (null !== d && (d = d.updateQueue, c2 === d)) {
        var e = null, f2 = null;
        c2 = c2.firstBaseUpdate;
        if (null !== c2) {
          do {
            var g = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
            null === f2 ? e = f2 = g : f2 = f2.next = g;
            c2 = c2.next;
          } while (null !== c2);
          null === f2 ? e = f2 = b : f2 = f2.next = b;
        } else e = f2 = b;
        c2 = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f2, shared: d.shared, effects: d.effects };
        a2.updateQueue = c2;
        return;
      }
      a2 = c2.lastBaseUpdate;
      null === a2 ? c2.firstBaseUpdate = b : a2.next = b;
      c2.lastBaseUpdate = b;
    }
    function qh(a2, b, c2, d) {
      var e = a2.updateQueue;
      jh = false;
      var f2 = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
      if (null !== h) {
        e.shared.pending = null;
        var k2 = h, l2 = k2.next;
        k2.next = null;
        null === g ? f2 = l2 : g.next = l2;
        g = k2;
        var m2 = a2.alternate;
        null !== m2 && (m2 = m2.updateQueue, h = m2.lastBaseUpdate, h !== g && (null === h ? m2.firstBaseUpdate = l2 : h.next = l2, m2.lastBaseUpdate = k2));
      }
      if (null !== f2) {
        var q2 = e.baseState;
        g = 0;
        m2 = l2 = k2 = null;
        h = f2;
        do {
          var r2 = h.lane, y2 = h.eventTime;
          if ((d & r2) === r2) {
            null !== m2 && (m2 = m2.next = {
              eventTime: y2,
              lane: 0,
              tag: h.tag,
              payload: h.payload,
              callback: h.callback,
              next: null
            });
            a: {
              var n2 = a2, t2 = h;
              r2 = b;
              y2 = c2;
              switch (t2.tag) {
                case 1:
                  n2 = t2.payload;
                  if ("function" === typeof n2) {
                    q2 = n2.call(y2, q2, r2);
                    break a;
                  }
                  q2 = n2;
                  break a;
                case 3:
                  n2.flags = n2.flags & -65537 | 128;
                case 0:
                  n2 = t2.payload;
                  r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
                  if (null === r2 || void 0 === r2) break a;
                  q2 = A({}, q2, r2);
                  break a;
                case 2:
                  jh = true;
              }
            }
            null !== h.callback && 0 !== h.lane && (a2.flags |= 64, r2 = e.effects, null === r2 ? e.effects = [h] : r2.push(h));
          } else y2 = { eventTime: y2, lane: r2, tag: h.tag, payload: h.payload, callback: h.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g |= r2;
          h = h.next;
          if (null === h) if (h = e.shared.pending, null === h) break;
          else r2 = h, h = r2.next, r2.next = null, e.lastBaseUpdate = r2, e.shared.pending = null;
        } while (1);
        null === m2 && (k2 = q2);
        e.baseState = k2;
        e.firstBaseUpdate = l2;
        e.lastBaseUpdate = m2;
        b = e.shared.interleaved;
        if (null !== b) {
          e = b;
          do
            g |= e.lane, e = e.next;
          while (e !== b);
        } else null === f2 && (e.shared.lanes = 0);
        rh |= g;
        a2.lanes = g;
        a2.memoizedState = q2;
      }
    }
    function sh(a2, b, c2) {
      a2 = b.effects;
      b.effects = null;
      if (null !== a2) for (b = 0; b < a2.length; b++) {
        var d = a2[b], e = d.callback;
        if (null !== e) {
          d.callback = null;
          d = c2;
          if ("function" !== typeof e) throw Error(p(191, e));
          e.call(d);
        }
      }
    }
    var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
    function xh(a2) {
      if (a2 === th) throw Error(p(174));
      return a2;
    }
    function yh(a2, b) {
      G(wh, b);
      G(vh, a2);
      G(uh, th);
      a2 = b.nodeType;
      switch (a2) {
        case 9:
        case 11:
          b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
          break;
        default:
          a2 = 8 === a2 ? b.parentNode : b, b = a2.namespaceURI || null, a2 = a2.tagName, b = lb(b, a2);
      }
      E(uh);
      G(uh, b);
    }
    function zh() {
      E(uh);
      E(vh);
      E(wh);
    }
    function Ah(a2) {
      xh(wh.current);
      var b = xh(uh.current);
      var c2 = lb(b, a2.type);
      b !== c2 && (G(vh, a2), G(uh, c2));
    }
    function Bh(a2) {
      vh.current === a2 && (E(uh), E(vh));
    }
    var L$2 = Uf(0);
    function Ch(a2) {
      for (var b = a2; null !== b; ) {
        if (13 === b.tag) {
          var c2 = b.memoizedState;
          if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data)) return b;
        } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
          if (0 !== (b.flags & 128)) return b;
        } else if (null !== b.child) {
          b.child.return = b;
          b = b.child;
          continue;
        }
        if (b === a2) break;
        for (; null === b.sibling; ) {
          if (null === b.return || b.return === a2) return null;
          b = b.return;
        }
        b.sibling.return = b.return;
        b = b.sibling;
      }
      return null;
    }
    var Dh = [];
    function Eh() {
      for (var a2 = 0; a2 < Dh.length; a2++) Dh[a2]._workInProgressVersionPrimary = null;
      Dh.length = 0;
    }
    var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O$1 = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
    function P$1() {
      throw Error(p(321));
    }
    function Mh(a2, b) {
      if (null === b) return false;
      for (var c2 = 0; c2 < b.length && c2 < a2.length; c2++) if (!He(a2[c2], b[c2])) return false;
      return true;
    }
    function Nh(a2, b, c2, d, e, f2) {
      Hh = f2;
      M = b;
      b.memoizedState = null;
      b.updateQueue = null;
      b.lanes = 0;
      Fh.current = null === a2 || null === a2.memoizedState ? Oh : Ph;
      a2 = c2(d, e);
      if (Jh) {
        f2 = 0;
        do {
          Jh = false;
          Kh = 0;
          if (25 <= f2) throw Error(p(301));
          f2 += 1;
          O$1 = N = null;
          b.updateQueue = null;
          Fh.current = Qh;
          a2 = c2(d, e);
        } while (Jh);
      }
      Fh.current = Rh;
      b = null !== N && null !== N.next;
      Hh = 0;
      O$1 = N = M = null;
      Ih = false;
      if (b) throw Error(p(300));
      return a2;
    }
    function Sh() {
      var a2 = 0 !== Kh;
      Kh = 0;
      return a2;
    }
    function Th() {
      var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      null === O$1 ? M.memoizedState = O$1 = a2 : O$1 = O$1.next = a2;
      return O$1;
    }
    function Uh() {
      if (null === N) {
        var a2 = M.alternate;
        a2 = null !== a2 ? a2.memoizedState : null;
      } else a2 = N.next;
      var b = null === O$1 ? M.memoizedState : O$1.next;
      if (null !== b) O$1 = b, N = a2;
      else {
        if (null === a2) throw Error(p(310));
        N = a2;
        a2 = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
        null === O$1 ? M.memoizedState = O$1 = a2 : O$1 = O$1.next = a2;
      }
      return O$1;
    }
    function Vh(a2, b) {
      return "function" === typeof b ? b(a2) : b;
    }
    function Wh(a2) {
      var b = Uh(), c2 = b.queue;
      if (null === c2) throw Error(p(311));
      c2.lastRenderedReducer = a2;
      var d = N, e = d.baseQueue, f2 = c2.pending;
      if (null !== f2) {
        if (null !== e) {
          var g = e.next;
          e.next = f2.next;
          f2.next = g;
        }
        d.baseQueue = e = f2;
        c2.pending = null;
      }
      if (null !== e) {
        f2 = e.next;
        d = d.baseState;
        var h = g = null, k2 = null, l2 = f2;
        do {
          var m2 = l2.lane;
          if ((Hh & m2) === m2) null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d = l2.hasEagerState ? l2.eagerState : a2(d, l2.action);
          else {
            var q2 = {
              lane: m2,
              action: l2.action,
              hasEagerState: l2.hasEagerState,
              eagerState: l2.eagerState,
              next: null
            };
            null === k2 ? (h = k2 = q2, g = d) : k2 = k2.next = q2;
            M.lanes |= m2;
            rh |= m2;
          }
          l2 = l2.next;
        } while (null !== l2 && l2 !== f2);
        null === k2 ? g = d : k2.next = h;
        He(d, b.memoizedState) || (dh = true);
        b.memoizedState = d;
        b.baseState = g;
        b.baseQueue = k2;
        c2.lastRenderedState = d;
      }
      a2 = c2.interleaved;
      if (null !== a2) {
        e = a2;
        do
          f2 = e.lane, M.lanes |= f2, rh |= f2, e = e.next;
        while (e !== a2);
      } else null === e && (c2.lanes = 0);
      return [b.memoizedState, c2.dispatch];
    }
    function Xh(a2) {
      var b = Uh(), c2 = b.queue;
      if (null === c2) throw Error(p(311));
      c2.lastRenderedReducer = a2;
      var d = c2.dispatch, e = c2.pending, f2 = b.memoizedState;
      if (null !== e) {
        c2.pending = null;
        var g = e = e.next;
        do
          f2 = a2(f2, g.action), g = g.next;
        while (g !== e);
        He(f2, b.memoizedState) || (dh = true);
        b.memoizedState = f2;
        null === b.baseQueue && (b.baseState = f2);
        c2.lastRenderedState = f2;
      }
      return [f2, d];
    }
    function Yh() {
    }
    function Zh(a2, b) {
      var c2 = M, d = Uh(), e = b(), f2 = !He(d.memoizedState, e);
      f2 && (d.memoizedState = e, dh = true);
      d = d.queue;
      $h(ai.bind(null, c2, d, a2), [a2]);
      if (d.getSnapshot !== b || f2 || null !== O$1 && O$1.memoizedState.tag & 1) {
        c2.flags |= 2048;
        bi(9, ci.bind(null, c2, d, e, b), void 0, null);
        if (null === Q) throw Error(p(349));
        0 !== (Hh & 30) || di(c2, b, e);
      }
      return e;
    }
    function di(a2, b, c2) {
      a2.flags |= 16384;
      a2 = { getSnapshot: b, value: c2 };
      b = M.updateQueue;
      null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.stores = [a2]) : (c2 = b.stores, null === c2 ? b.stores = [a2] : c2.push(a2));
    }
    function ci(a2, b, c2, d) {
      b.value = c2;
      b.getSnapshot = d;
      ei(b) && fi(a2);
    }
    function ai(a2, b, c2) {
      return c2(function() {
        ei(b) && fi(a2);
      });
    }
    function ei(a2) {
      var b = a2.getSnapshot;
      a2 = a2.value;
      try {
        var c2 = b();
        return !He(a2, c2);
      } catch (d) {
        return true;
      }
    }
    function fi(a2) {
      var b = ih(a2, 1);
      null !== b && gi(b, a2, 1, -1);
    }
    function hi(a2) {
      var b = Th();
      "function" === typeof a2 && (a2 = a2());
      b.memoizedState = b.baseState = a2;
      a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a2 };
      b.queue = a2;
      a2 = a2.dispatch = ii.bind(null, M, a2);
      return [b.memoizedState, a2];
    }
    function bi(a2, b, c2, d) {
      a2 = { tag: a2, create: b, destroy: c2, deps: d, next: null };
      b = M.updateQueue;
      null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.lastEffect = a2.next = a2) : (c2 = b.lastEffect, null === c2 ? b.lastEffect = a2.next = a2 : (d = c2.next, c2.next = a2, a2.next = d, b.lastEffect = a2));
      return a2;
    }
    function ji() {
      return Uh().memoizedState;
    }
    function ki(a2, b, c2, d) {
      var e = Th();
      M.flags |= a2;
      e.memoizedState = bi(1 | b, c2, void 0, void 0 === d ? null : d);
    }
    function li(a2, b, c2, d) {
      var e = Uh();
      d = void 0 === d ? null : d;
      var f2 = void 0;
      if (null !== N) {
        var g = N.memoizedState;
        f2 = g.destroy;
        if (null !== d && Mh(d, g.deps)) {
          e.memoizedState = bi(b, c2, f2, d);
          return;
        }
      }
      M.flags |= a2;
      e.memoizedState = bi(1 | b, c2, f2, d);
    }
    function mi(a2, b) {
      return ki(8390656, 8, a2, b);
    }
    function $h(a2, b) {
      return li(2048, 8, a2, b);
    }
    function ni(a2, b) {
      return li(4, 2, a2, b);
    }
    function oi(a2, b) {
      return li(4, 4, a2, b);
    }
    function pi$2(a2, b) {
      if ("function" === typeof b) return a2 = a2(), b(a2), function() {
        b(null);
      };
      if (null !== b && void 0 !== b) return a2 = a2(), b.current = a2, function() {
        b.current = null;
      };
    }
    function qi(a2, b, c2) {
      c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
      return li(4, 4, pi$2.bind(null, b, a2), c2);
    }
    function ri() {
    }
    function si(a2, b) {
      var c2 = Uh();
      b = void 0 === b ? null : b;
      var d = c2.memoizedState;
      if (null !== d && null !== b && Mh(b, d[1])) return d[0];
      c2.memoizedState = [a2, b];
      return a2;
    }
    function ti(a2, b) {
      var c2 = Uh();
      b = void 0 === b ? null : b;
      var d = c2.memoizedState;
      if (null !== d && null !== b && Mh(b, d[1])) return d[0];
      a2 = a2();
      c2.memoizedState = [a2, b];
      return a2;
    }
    function ui(a2, b, c2) {
      if (0 === (Hh & 21)) return a2.baseState && (a2.baseState = false, dh = true), a2.memoizedState = c2;
      He(c2, b) || (c2 = yc(), M.lanes |= c2, rh |= c2, a2.baseState = true);
      return b;
    }
    function vi(a2, b) {
      var c2 = C;
      C = 0 !== c2 && 4 > c2 ? c2 : 4;
      a2(true);
      var d = Gh.transition;
      Gh.transition = {};
      try {
        a2(false), b();
      } finally {
        C = c2, Gh.transition = d;
      }
    }
    function wi() {
      return Uh().memoizedState;
    }
    function xi(a2, b, c2) {
      var d = yi(a2);
      c2 = { lane: d, action: c2, hasEagerState: false, eagerState: null, next: null };
      if (zi(a2)) Ai(b, c2);
      else if (c2 = hh(a2, b, c2, d), null !== c2) {
        var e = R();
        gi(c2, a2, d, e);
        Bi(c2, b, d);
      }
    }
    function ii(a2, b, c2) {
      var d = yi(a2), e = { lane: d, action: c2, hasEagerState: false, eagerState: null, next: null };
      if (zi(a2)) Ai(b, e);
      else {
        var f2 = a2.alternate;
        if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b.lastRenderedReducer, null !== f2)) try {
          var g = b.lastRenderedState, h = f2(g, c2);
          e.hasEagerState = true;
          e.eagerState = h;
          if (He(h, g)) {
            var k2 = b.interleaved;
            null === k2 ? (e.next = e, gh(b)) : (e.next = k2.next, k2.next = e);
            b.interleaved = e;
            return;
          }
        } catch (l2) {
        } finally {
        }
        c2 = hh(a2, b, e, d);
        null !== c2 && (e = R(), gi(c2, a2, d, e), Bi(c2, b, d));
      }
    }
    function zi(a2) {
      var b = a2.alternate;
      return a2 === M || null !== b && b === M;
    }
    function Ai(a2, b) {
      Jh = Ih = true;
      var c2 = a2.pending;
      null === c2 ? b.next = b : (b.next = c2.next, c2.next = b);
      a2.pending = b;
    }
    function Bi(a2, b, c2) {
      if (0 !== (c2 & 4194240)) {
        var d = b.lanes;
        d &= a2.pendingLanes;
        c2 |= d;
        b.lanes = c2;
        Cc(a2, c2);
      }
    }
    var Rh = { readContext: eh, useCallback: P$1, useContext: P$1, useEffect: P$1, useImperativeHandle: P$1, useInsertionEffect: P$1, useLayoutEffect: P$1, useMemo: P$1, useReducer: P$1, useRef: P$1, useState: P$1, useDebugValue: P$1, useDeferredValue: P$1, useTransition: P$1, useMutableSource: P$1, useSyncExternalStore: P$1, useId: P$1, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a2, b) {
      Th().memoizedState = [a2, void 0 === b ? null : b];
      return a2;
    }, useContext: eh, useEffect: mi, useImperativeHandle: function(a2, b, c2) {
      c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
      return ki(
        4194308,
        4,
        pi$2.bind(null, b, a2),
        c2
      );
    }, useLayoutEffect: function(a2, b) {
      return ki(4194308, 4, a2, b);
    }, useInsertionEffect: function(a2, b) {
      return ki(4, 2, a2, b);
    }, useMemo: function(a2, b) {
      var c2 = Th();
      b = void 0 === b ? null : b;
      a2 = a2();
      c2.memoizedState = [a2, b];
      return a2;
    }, useReducer: function(a2, b, c2) {
      var d = Th();
      b = void 0 !== c2 ? c2(b) : b;
      d.memoizedState = d.baseState = b;
      a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b };
      d.queue = a2;
      a2 = a2.dispatch = xi.bind(null, M, a2);
      return [d.memoizedState, a2];
    }, useRef: function(a2) {
      var b = Th();
      a2 = { current: a2 };
      return b.memoizedState = a2;
    }, useState: hi, useDebugValue: ri, useDeferredValue: function(a2) {
      return Th().memoizedState = a2;
    }, useTransition: function() {
      var a2 = hi(false), b = a2[0];
      a2 = vi.bind(null, a2[1]);
      Th().memoizedState = a2;
      return [b, a2];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(a2, b, c2) {
      var d = M, e = Th();
      if (I) {
        if (void 0 === c2) throw Error(p(407));
        c2 = c2();
      } else {
        c2 = b();
        if (null === Q) throw Error(p(349));
        0 !== (Hh & 30) || di(d, b, c2);
      }
      e.memoizedState = c2;
      var f2 = { value: c2, getSnapshot: b };
      e.queue = f2;
      mi(ai.bind(
        null,
        d,
        f2,
        a2
      ), [a2]);
      d.flags |= 2048;
      bi(9, ci.bind(null, d, f2, c2, b), void 0, null);
      return c2;
    }, useId: function() {
      var a2 = Th(), b = Q.identifierPrefix;
      if (I) {
        var c2 = sg;
        var d = rg;
        c2 = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c2;
        b = ":" + b + "R" + c2;
        c2 = Kh++;
        0 < c2 && (b += "H" + c2.toString(32));
        b += ":";
      } else c2 = Lh++, b = ":" + b + "r" + c2.toString(32) + ":";
      return a2.memoizedState = b;
    }, unstable_isNewReconciler: false }, Ph = {
      readContext: eh,
      useCallback: si,
      useContext: eh,
      useEffect: $h,
      useImperativeHandle: qi,
      useInsertionEffect: ni,
      useLayoutEffect: oi,
      useMemo: ti,
      useReducer: Wh,
      useRef: ji,
      useState: function() {
        return Wh(Vh);
      },
      useDebugValue: ri,
      useDeferredValue: function(a2) {
        var b = Uh();
        return ui(b, N.memoizedState, a2);
      },
      useTransition: function() {
        var a2 = Wh(Vh)[0], b = Uh().memoizedState;
        return [a2, b];
      },
      useMutableSource: Yh,
      useSyncExternalStore: Zh,
      useId: wi,
      unstable_isNewReconciler: false
    }, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
      return Xh(Vh);
    }, useDebugValue: ri, useDeferredValue: function(a2) {
      var b = Uh();
      return null === N ? b.memoizedState = a2 : ui(b, N.memoizedState, a2);
    }, useTransition: function() {
      var a2 = Xh(Vh)[0], b = Uh().memoizedState;
      return [a2, b];
    }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
    function Ci(a2, b) {
      if (a2 && a2.defaultProps) {
        b = A({}, b);
        a2 = a2.defaultProps;
        for (var c2 in a2) void 0 === b[c2] && (b[c2] = a2[c2]);
        return b;
      }
      return b;
    }
    function Di(a2, b, c2, d) {
      b = a2.memoizedState;
      c2 = c2(d, b);
      c2 = null === c2 || void 0 === c2 ? b : A({}, b, c2);
      a2.memoizedState = c2;
      0 === a2.lanes && (a2.updateQueue.baseState = c2);
    }
    var Ei = { isMounted: function(a2) {
      return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
    }, enqueueSetState: function(a2, b, c2) {
      a2 = a2._reactInternals;
      var d = R(), e = yi(a2), f2 = mh(d, e);
      f2.payload = b;
      void 0 !== c2 && null !== c2 && (f2.callback = c2);
      b = nh(a2, f2, e);
      null !== b && (gi(b, a2, e, d), oh(b, a2, e));
    }, enqueueReplaceState: function(a2, b, c2) {
      a2 = a2._reactInternals;
      var d = R(), e = yi(a2), f2 = mh(d, e);
      f2.tag = 1;
      f2.payload = b;
      void 0 !== c2 && null !== c2 && (f2.callback = c2);
      b = nh(a2, f2, e);
      null !== b && (gi(b, a2, e, d), oh(b, a2, e));
    }, enqueueForceUpdate: function(a2, b) {
      a2 = a2._reactInternals;
      var c2 = R(), d = yi(a2), e = mh(c2, d);
      e.tag = 2;
      void 0 !== b && null !== b && (e.callback = b);
      b = nh(a2, e, d);
      null !== b && (gi(b, a2, d, c2), oh(b, a2, d));
    } };
    function Fi(a2, b, c2, d, e, f2, g) {
      a2 = a2.stateNode;
      return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d, f2, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c2, d) || !Ie(e, f2) : true;
    }
    function Gi(a2, b, c2) {
      var d = false, e = Vf;
      var f2 = b.contextType;
      "object" === typeof f2 && null !== f2 ? f2 = eh(f2) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f2 = (d = null !== d && void 0 !== d) ? Yf(a2, e) : Vf);
      b = new b(c2, f2);
      a2.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
      b.updater = Ei;
      a2.stateNode = b;
      b._reactInternals = a2;
      d && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e, a2.__reactInternalMemoizedMaskedChildContext = f2);
      return b;
    }
    function Hi(a2, b, c2, d) {
      a2 = b.state;
      "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c2, d);
      "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c2, d);
      b.state !== a2 && Ei.enqueueReplaceState(b, b.state, null);
    }
    function Ii(a2, b, c2, d) {
      var e = a2.stateNode;
      e.props = c2;
      e.state = a2.memoizedState;
      e.refs = {};
      kh(a2);
      var f2 = b.contextType;
      "object" === typeof f2 && null !== f2 ? e.context = eh(f2) : (f2 = Zf(b) ? Xf : H.current, e.context = Yf(a2, f2));
      e.state = a2.memoizedState;
      f2 = b.getDerivedStateFromProps;
      "function" === typeof f2 && (Di(a2, b, f2, c2), e.state = a2.memoizedState);
      "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Ei.enqueueReplaceState(e, e.state, null), qh(a2, c2, e, d), e.state = a2.memoizedState);
      "function" === typeof e.componentDidMount && (a2.flags |= 4194308);
    }
    function Ji(a2, b) {
      try {
        var c2 = "", d = b;
        do
          c2 += Pa(d), d = d.return;
        while (d);
        var e = c2;
      } catch (f2) {
        e = "\nError generating stack: " + f2.message + "\n" + f2.stack;
      }
      return { value: a2, source: b, stack: e, digest: null };
    }
    function Ki(a2, b, c2) {
      return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b ? b : null };
    }
    function Li(a2, b) {
      try {
        console.error(b.value);
      } catch (c2) {
        setTimeout(function() {
          throw c2;
        });
      }
    }
    var Mi = "function" === typeof WeakMap ? WeakMap : Map;
    function Ni(a2, b, c2) {
      c2 = mh(-1, c2);
      c2.tag = 3;
      c2.payload = { element: null };
      var d = b.value;
      c2.callback = function() {
        Oi || (Oi = true, Pi = d);
        Li(a2, b);
      };
      return c2;
    }
    function Qi(a2, b, c2) {
      c2 = mh(-1, c2);
      c2.tag = 3;
      var d = a2.type.getDerivedStateFromError;
      if ("function" === typeof d) {
        var e = b.value;
        c2.payload = function() {
          return d(e);
        };
        c2.callback = function() {
          Li(a2, b);
        };
      }
      var f2 = a2.stateNode;
      null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
        Li(a2, b);
        "function" !== typeof d && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
        var c3 = b.stack;
        this.componentDidCatch(b.value, { componentStack: null !== c3 ? c3 : "" });
      });
      return c2;
    }
    function Si(a2, b, c2) {
      var d = a2.pingCache;
      if (null === d) {
        d = a2.pingCache = new Mi();
        var e = /* @__PURE__ */ new Set();
        d.set(b, e);
      } else e = d.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d.set(b, e));
      e.has(c2) || (e.add(c2), a2 = Ti.bind(null, a2, b, c2), b.then(a2, a2));
    }
    function Ui(a2) {
      do {
        var b;
        if (b = 13 === a2.tag) b = a2.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
        if (b) return a2;
        a2 = a2.return;
      } while (null !== a2);
      return null;
    }
    function Vi(a2, b, c2, d, e) {
      if (0 === (a2.mode & 1)) return a2 === b ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c2, b, 1))), c2.lanes |= 1), a2;
      a2.flags |= 65536;
      a2.lanes = e;
      return a2;
    }
    var Wi = ua.ReactCurrentOwner, dh = false;
    function Xi(a2, b, c2, d) {
      b.child = null === a2 ? Vg(b, null, c2, d) : Ug(b, a2.child, c2, d);
    }
    function Yi(a2, b, c2, d, e) {
      c2 = c2.render;
      var f2 = b.ref;
      ch(b, e);
      d = Nh(a2, b, c2, d, f2, e);
      c2 = Sh();
      if (null !== a2 && !dh) return b.updateQueue = a2.updateQueue, b.flags &= -2053, a2.lanes &= ~e, Zi(a2, b, e);
      I && c2 && vg(b);
      b.flags |= 1;
      Xi(a2, b, d, e);
      return b.child;
    }
    function $i(a2, b, c2, d, e) {
      if (null === a2) {
        var f2 = c2.type;
        if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps) return b.tag = 15, b.type = f2, bj(a2, b, f2, d, e);
        a2 = Rg(c2.type, null, d, b, b.mode, e);
        a2.ref = b.ref;
        a2.return = b;
        return b.child = a2;
      }
      f2 = a2.child;
      if (0 === (a2.lanes & e)) {
        var g = f2.memoizedProps;
        c2 = c2.compare;
        c2 = null !== c2 ? c2 : Ie;
        if (c2(g, d) && a2.ref === b.ref) return Zi(a2, b, e);
      }
      b.flags |= 1;
      a2 = Pg(f2, d);
      a2.ref = b.ref;
      a2.return = b;
      return b.child = a2;
    }
    function bj(a2, b, c2, d, e) {
      if (null !== a2) {
        var f2 = a2.memoizedProps;
        if (Ie(f2, d) && a2.ref === b.ref) if (dh = false, b.pendingProps = d = f2, 0 !== (a2.lanes & e)) 0 !== (a2.flags & 131072) && (dh = true);
        else return b.lanes = a2.lanes, Zi(a2, b, e);
      }
      return cj(a2, b, c2, d, e);
    }
    function dj(a2, b, c2) {
      var d = b.pendingProps, e = d.children, f2 = null !== a2 ? a2.memoizedState : null;
      if ("hidden" === d.mode) if (0 === (b.mode & 1)) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c2;
      else {
        if (0 === (c2 & 1073741824)) return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b.updateQueue = null, G(ej, fj), fj |= a2, null;
        b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
        d = null !== f2 ? f2.baseLanes : c2;
        G(ej, fj);
        fj |= d;
      }
      else null !== f2 ? (d = f2.baseLanes | c2, b.memoizedState = null) : d = c2, G(ej, fj), fj |= d;
      Xi(a2, b, e, c2);
      return b.child;
    }
    function gj(a2, b) {
      var c2 = b.ref;
      if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2) b.flags |= 512, b.flags |= 2097152;
    }
    function cj(a2, b, c2, d, e) {
      var f2 = Zf(c2) ? Xf : H.current;
      f2 = Yf(b, f2);
      ch(b, e);
      c2 = Nh(a2, b, c2, d, f2, e);
      d = Sh();
      if (null !== a2 && !dh) return b.updateQueue = a2.updateQueue, b.flags &= -2053, a2.lanes &= ~e, Zi(a2, b, e);
      I && d && vg(b);
      b.flags |= 1;
      Xi(a2, b, c2, e);
      return b.child;
    }
    function hj(a2, b, c2, d, e) {
      if (Zf(c2)) {
        var f2 = true;
        cg(b);
      } else f2 = false;
      ch(b, e);
      if (null === b.stateNode) ij(a2, b), Gi(b, c2, d), Ii(b, c2, d, e), d = true;
      else if (null === a2) {
        var g = b.stateNode, h = b.memoizedProps;
        g.props = h;
        var k2 = g.context, l2 = c2.contextType;
        "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c2) ? Xf : H.current, l2 = Yf(b, l2));
        var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g.getSnapshotBeforeUpdate;
        q2 || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k2 !== l2) && Hi(b, g, d, l2);
        jh = false;
        var r2 = b.memoizedState;
        g.state = r2;
        qh(b, d, g, e);
        k2 = b.memoizedState;
        h !== d || r2 !== k2 || Wf.current || jh ? ("function" === typeof m2 && (Di(b, c2, m2, d), k2 = b.memoizedState), (h = jh || Fi(b, c2, h, d, r2, k2, l2)) ? (q2 || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k2), g.props = d, g.state = k2, g.context = l2, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
      } else {
        g = b.stateNode;
        lh(a2, b);
        h = b.memoizedProps;
        l2 = b.type === b.elementType ? h : Ci(b.type, h);
        g.props = l2;
        q2 = b.pendingProps;
        r2 = g.context;
        k2 = c2.contextType;
        "object" === typeof k2 && null !== k2 ? k2 = eh(k2) : (k2 = Zf(c2) ? Xf : H.current, k2 = Yf(b, k2));
        var y2 = c2.getDerivedStateFromProps;
        (m2 = "function" === typeof y2 || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q2 || r2 !== k2) && Hi(b, g, d, k2);
        jh = false;
        r2 = b.memoizedState;
        g.state = r2;
        qh(b, d, g, e);
        var n2 = b.memoizedState;
        h !== q2 || r2 !== n2 || Wf.current || jh ? ("function" === typeof y2 && (Di(b, c2, y2, d), n2 = b.memoizedState), (l2 = jh || Fi(b, c2, l2, d, r2, n2, k2) || false) ? (m2 || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n2, k2), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n2, k2)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a2.memoizedProps && r2 === a2.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a2.memoizedProps && r2 === a2.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n2), g.props = d, g.state = n2, g.context = k2, d = l2) : ("function" !== typeof g.componentDidUpdate || h === a2.memoizedProps && r2 === a2.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a2.memoizedProps && r2 === a2.memoizedState || (b.flags |= 1024), d = false);
      }
      return jj(a2, b, c2, d, f2, e);
    }
    function jj(a2, b, c2, d, e, f2) {
      gj(a2, b);
      var g = 0 !== (b.flags & 128);
      if (!d && !g) return e && dg(b, c2, false), Zi(a2, b, f2);
      d = b.stateNode;
      Wi.current = b;
      var h = g && "function" !== typeof c2.getDerivedStateFromError ? null : d.render();
      b.flags |= 1;
      null !== a2 && g ? (b.child = Ug(b, a2.child, null, f2), b.child = Ug(b, null, h, f2)) : Xi(a2, b, h, f2);
      b.memoizedState = d.state;
      e && dg(b, c2, true);
      return b.child;
    }
    function kj(a2) {
      var b = a2.stateNode;
      b.pendingContext ? ag(a2, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a2, b.context, false);
      yh(a2, b.containerInfo);
    }
    function lj(a2, b, c2, d, e) {
      Ig();
      Jg(e);
      b.flags |= 256;
      Xi(a2, b, c2, d);
      return b.child;
    }
    var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
    function nj(a2) {
      return { baseLanes: a2, cachePool: null, transitions: null };
    }
    function oj(a2, b, c2) {
      var d = b.pendingProps, e = L$2.current, f2 = false, g = 0 !== (b.flags & 128), h;
      (h = g) || (h = null !== a2 && null === a2.memoizedState ? false : 0 !== (e & 2));
      if (h) f2 = true, b.flags &= -129;
      else if (null === a2 || null !== a2.memoizedState) e |= 1;
      G(L$2, e & 1);
      if (null === a2) {
        Eg(b);
        a2 = b.memoizedState;
        if (null !== a2 && (a2 = a2.dehydrated, null !== a2)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a2.data ? b.lanes = 8 : b.lanes = 1073741824, null;
        g = d.children;
        a2 = d.fallback;
        return f2 ? (d = b.mode, f2 = b.child, g = { mode: "hidden", children: g }, 0 === (d & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g) : f2 = pj(g, d, 0, null), a2 = Tg(a2, d, c2, null), f2.return = b, a2.return = b, f2.sibling = a2, b.child = f2, b.child.memoizedState = nj(c2), b.memoizedState = mj, a2) : qj(b, g);
      }
      e = a2.memoizedState;
      if (null !== e && (h = e.dehydrated, null !== h)) return rj(a2, b, g, d, h, e, c2);
      if (f2) {
        f2 = d.fallback;
        g = b.mode;
        e = a2.child;
        h = e.sibling;
        var k2 = { mode: "hidden", children: d.children };
        0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k2, b.deletions = null) : (d = Pg(e, k2), d.subtreeFlags = e.subtreeFlags & 14680064);
        null !== h ? f2 = Pg(h, f2) : (f2 = Tg(f2, g, c2, null), f2.flags |= 2);
        f2.return = b;
        d.return = b;
        d.sibling = f2;
        b.child = d;
        d = f2;
        f2 = b.child;
        g = a2.child.memoizedState;
        g = null === g ? nj(c2) : { baseLanes: g.baseLanes | c2, cachePool: null, transitions: g.transitions };
        f2.memoizedState = g;
        f2.childLanes = a2.childLanes & ~c2;
        b.memoizedState = mj;
        return d;
      }
      f2 = a2.child;
      a2 = f2.sibling;
      d = Pg(f2, { mode: "visible", children: d.children });
      0 === (b.mode & 1) && (d.lanes = c2);
      d.return = b;
      d.sibling = null;
      null !== a2 && (c2 = b.deletions, null === c2 ? (b.deletions = [a2], b.flags |= 16) : c2.push(a2));
      b.child = d;
      b.memoizedState = null;
      return d;
    }
    function qj(a2, b) {
      b = pj({ mode: "visible", children: b }, a2.mode, 0, null);
      b.return = a2;
      return a2.child = b;
    }
    function sj(a2, b, c2, d) {
      null !== d && Jg(d);
      Ug(b, a2.child, null, c2);
      a2 = qj(b, b.pendingProps.children);
      a2.flags |= 2;
      b.memoizedState = null;
      return a2;
    }
    function rj(a2, b, c2, d, e, f2, g) {
      if (c2) {
        if (b.flags & 256) return b.flags &= -257, d = Ki(Error(p(422))), sj(a2, b, g, d);
        if (null !== b.memoizedState) return b.child = a2.child, b.flags |= 128, null;
        f2 = d.fallback;
        e = b.mode;
        d = pj({ mode: "visible", children: d.children }, e, 0, null);
        f2 = Tg(f2, e, g, null);
        f2.flags |= 2;
        d.return = b;
        f2.return = b;
        d.sibling = f2;
        b.child = d;
        0 !== (b.mode & 1) && Ug(b, a2.child, null, g);
        b.child.memoizedState = nj(g);
        b.memoizedState = mj;
        return f2;
      }
      if (0 === (b.mode & 1)) return sj(a2, b, g, null);
      if ("$!" === e.data) {
        d = e.nextSibling && e.nextSibling.dataset;
        if (d) var h = d.dgst;
        d = h;
        f2 = Error(p(419));
        d = Ki(f2, d, void 0);
        return sj(a2, b, g, d);
      }
      h = 0 !== (g & a2.childLanes);
      if (dh || h) {
        d = Q;
        if (null !== d) {
          switch (g & -g) {
            case 4:
              e = 2;
              break;
            case 16:
              e = 8;
              break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              e = 32;
              break;
            case 536870912:
              e = 268435456;
              break;
            default:
              e = 0;
          }
          e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
          0 !== e && e !== f2.retryLane && (f2.retryLane = e, ih(a2, e), gi(d, a2, e, -1));
        }
        tj();
        d = Ki(Error(p(421)));
        return sj(a2, b, g, d);
      }
      if ("$?" === e.data) return b.flags |= 128, b.child = a2.child, b = uj.bind(null, a2), e._reactRetry = b, null;
      a2 = f2.treeContext;
      yg = Lf(e.nextSibling);
      xg = b;
      I = true;
      zg = null;
      null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b);
      b = qj(b, d.children);
      b.flags |= 4096;
      return b;
    }
    function vj(a2, b, c2) {
      a2.lanes |= b;
      var d = a2.alternate;
      null !== d && (d.lanes |= b);
      bh(a2.return, b, c2);
    }
    function wj(a2, b, c2, d, e) {
      var f2 = a2.memoizedState;
      null === f2 ? a2.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c2, tailMode: e } : (f2.isBackwards = b, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d, f2.tail = c2, f2.tailMode = e);
    }
    function xj(a2, b, c2) {
      var d = b.pendingProps, e = d.revealOrder, f2 = d.tail;
      Xi(a2, b, d.children, c2);
      d = L$2.current;
      if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;
      else {
        if (null !== a2 && 0 !== (a2.flags & 128)) a: for (a2 = b.child; null !== a2; ) {
          if (13 === a2.tag) null !== a2.memoizedState && vj(a2, c2, b);
          else if (19 === a2.tag) vj(a2, c2, b);
          else if (null !== a2.child) {
            a2.child.return = a2;
            a2 = a2.child;
            continue;
          }
          if (a2 === b) break a;
          for (; null === a2.sibling; ) {
            if (null === a2.return || a2.return === b) break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          a2 = a2.sibling;
        }
        d &= 1;
      }
      G(L$2, d);
      if (0 === (b.mode & 1)) b.memoizedState = null;
      else switch (e) {
        case "forwards":
          c2 = b.child;
          for (e = null; null !== c2; ) a2 = c2.alternate, null !== a2 && null === Ch(a2) && (e = c2), c2 = c2.sibling;
          c2 = e;
          null === c2 ? (e = b.child, b.child = null) : (e = c2.sibling, c2.sibling = null);
          wj(b, false, e, c2, f2);
          break;
        case "backwards":
          c2 = null;
          e = b.child;
          for (b.child = null; null !== e; ) {
            a2 = e.alternate;
            if (null !== a2 && null === Ch(a2)) {
              b.child = e;
              break;
            }
            a2 = e.sibling;
            e.sibling = c2;
            c2 = e;
            e = a2;
          }
          wj(b, true, c2, null, f2);
          break;
        case "together":
          wj(b, false, null, null, void 0);
          break;
        default:
          b.memoizedState = null;
      }
      return b.child;
    }
    function ij(a2, b) {
      0 === (b.mode & 1) && null !== a2 && (a2.alternate = null, b.alternate = null, b.flags |= 2);
    }
    function Zi(a2, b, c2) {
      null !== a2 && (b.dependencies = a2.dependencies);
      rh |= b.lanes;
      if (0 === (c2 & b.childLanes)) return null;
      if (null !== a2 && b.child !== a2.child) throw Error(p(153));
      if (null !== b.child) {
        a2 = b.child;
        c2 = Pg(a2, a2.pendingProps);
        b.child = c2;
        for (c2.return = b; null !== a2.sibling; ) a2 = a2.sibling, c2 = c2.sibling = Pg(a2, a2.pendingProps), c2.return = b;
        c2.sibling = null;
      }
      return b.child;
    }
    function yj(a2, b, c2) {
      switch (b.tag) {
        case 3:
          kj(b);
          Ig();
          break;
        case 5:
          Ah(b);
          break;
        case 1:
          Zf(b.type) && cg(b);
          break;
        case 4:
          yh(b, b.stateNode.containerInfo);
          break;
        case 10:
          var d = b.type._context, e = b.memoizedProps.value;
          G(Wg, d._currentValue);
          d._currentValue = e;
          break;
        case 13:
          d = b.memoizedState;
          if (null !== d) {
            if (null !== d.dehydrated) return G(L$2, L$2.current & 1), b.flags |= 128, null;
            if (0 !== (c2 & b.child.childLanes)) return oj(a2, b, c2);
            G(L$2, L$2.current & 1);
            a2 = Zi(a2, b, c2);
            return null !== a2 ? a2.sibling : null;
          }
          G(L$2, L$2.current & 1);
          break;
        case 19:
          d = 0 !== (c2 & b.childLanes);
          if (0 !== (a2.flags & 128)) {
            if (d) return xj(a2, b, c2);
            b.flags |= 128;
          }
          e = b.memoizedState;
          null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
          G(L$2, L$2.current);
          if (d) break;
          else return null;
        case 22:
        case 23:
          return b.lanes = 0, dj(a2, b, c2);
      }
      return Zi(a2, b, c2);
    }
    var zj, Aj, Bj, Cj;
    zj = function(a2, b) {
      for (var c2 = b.child; null !== c2; ) {
        if (5 === c2.tag || 6 === c2.tag) a2.appendChild(c2.stateNode);
        else if (4 !== c2.tag && null !== c2.child) {
          c2.child.return = c2;
          c2 = c2.child;
          continue;
        }
        if (c2 === b) break;
        for (; null === c2.sibling; ) {
          if (null === c2.return || c2.return === b) return;
          c2 = c2.return;
        }
        c2.sibling.return = c2.return;
        c2 = c2.sibling;
      }
    };
    Aj = function() {
    };
    Bj = function(a2, b, c2, d) {
      var e = a2.memoizedProps;
      if (e !== d) {
        a2 = b.stateNode;
        xh(uh.current);
        var f2 = null;
        switch (c2) {
          case "input":
            e = Ya(a2, e);
            d = Ya(a2, d);
            f2 = [];
            break;
          case "select":
            e = A({}, e, { value: void 0 });
            d = A({}, d, { value: void 0 });
            f2 = [];
            break;
          case "textarea":
            e = gb(a2, e);
            d = gb(a2, d);
            f2 = [];
            break;
          default:
            "function" !== typeof e.onClick && "function" === typeof d.onClick && (a2.onclick = Bf);
        }
        ub(c2, d);
        var g;
        c2 = null;
        for (l2 in e) if (!d.hasOwnProperty(l2) && e.hasOwnProperty(l2) && null != e[l2]) if ("style" === l2) {
          var h = e[l2];
          for (g in h) h.hasOwnProperty(g) && (c2 || (c2 = {}), c2[g] = "");
        } else "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
        for (l2 in d) {
          var k2 = d[l2];
          h = null != e ? e[l2] : void 0;
          if (d.hasOwnProperty(l2) && k2 !== h && (null != k2 || null != h)) if ("style" === l2) if (h) {
            for (g in h) !h.hasOwnProperty(g) || k2 && k2.hasOwnProperty(g) || (c2 || (c2 = {}), c2[g] = "");
            for (g in k2) k2.hasOwnProperty(g) && h[g] !== k2[g] && (c2 || (c2 = {}), c2[g] = k2[g]);
          } else c2 || (f2 || (f2 = []), f2.push(
            l2,
            c2
          )), c2 = k2;
          else "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h = h ? h.__html : void 0, null != k2 && h !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a2), f2 || h === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
        }
        c2 && (f2 = f2 || []).push("style", c2);
        var l2 = f2;
        if (b.updateQueue = l2) b.flags |= 4;
      }
    };
    Cj = function(a2, b, c2, d) {
      c2 !== d && (b.flags |= 4);
    };
    function Dj(a2, b) {
      if (!I) switch (a2.tailMode) {
        case "hidden":
          b = a2.tail;
          for (var c2 = null; null !== b; ) null !== b.alternate && (c2 = b), b = b.sibling;
          null === c2 ? a2.tail = null : c2.sibling = null;
          break;
        case "collapsed":
          c2 = a2.tail;
          for (var d = null; null !== c2; ) null !== c2.alternate && (d = c2), c2 = c2.sibling;
          null === d ? b || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d.sibling = null;
      }
    }
    function S(a2) {
      var b = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d = 0;
      if (b) for (var e = a2.child; null !== e; ) c2 |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a2, e = e.sibling;
      else for (e = a2.child; null !== e; ) c2 |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a2, e = e.sibling;
      a2.subtreeFlags |= d;
      a2.childLanes = c2;
      return b;
    }
    function Ej(a2, b, c2) {
      var d = b.pendingProps;
      wg(b);
      switch (b.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return S(b), null;
        case 1:
          return Zf(b.type) && $f(), S(b), null;
        case 3:
          d = b.stateNode;
          zh();
          E(Wf);
          E(H);
          Eh();
          d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
          if (null === a2 || null === a2.child) Gg(b) ? b.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Fj(zg), zg = null));
          Aj(a2, b);
          S(b);
          return null;
        case 5:
          Bh(b);
          var e = xh(wh.current);
          c2 = b.type;
          if (null !== a2 && null != b.stateNode) Bj(a2, b, c2, d, e), a2.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
          else {
            if (!d) {
              if (null === b.stateNode) throw Error(p(166));
              S(b);
              return null;
            }
            a2 = xh(uh.current);
            if (Gg(b)) {
              d = b.stateNode;
              c2 = b.type;
              var f2 = b.memoizedProps;
              d[Of] = b;
              d[Pf] = f2;
              a2 = 0 !== (b.mode & 1);
              switch (c2) {
                case "dialog":
                  D("cancel", d);
                  D("close", d);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", d);
                  break;
                case "video":
                case "audio":
                  for (e = 0; e < lf.length; e++) D(lf[e], d);
                  break;
                case "source":
                  D("error", d);
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    d
                  );
                  D("load", d);
                  break;
                case "details":
                  D("toggle", d);
                  break;
                case "input":
                  Za(d, f2);
                  D("invalid", d);
                  break;
                case "select":
                  d._wrapperState = { wasMultiple: !!f2.multiple };
                  D("invalid", d);
                  break;
                case "textarea":
                  hb(d, f2), D("invalid", d);
              }
              ub(c2, f2);
              e = null;
              for (var g in f2) if (f2.hasOwnProperty(g)) {
                var h = f2[g];
                "children" === g ? "string" === typeof h ? d.textContent !== h && (true !== f2.suppressHydrationWarning && Af(d.textContent, h, a2), e = ["children", h]) : "number" === typeof h && d.textContent !== "" + h && (true !== f2.suppressHydrationWarning && Af(
                  d.textContent,
                  h,
                  a2
                ), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
              }
              switch (c2) {
                case "input":
                  Va(d);
                  db(d, f2, true);
                  break;
                case "textarea":
                  Va(d);
                  jb(d);
                  break;
                case "select":
                case "option":
                  break;
                default:
                  "function" === typeof f2.onClick && (d.onclick = Bf);
              }
              d = e;
              b.updateQueue = d;
              null !== d && (b.flags |= 4);
            } else {
              g = 9 === e.nodeType ? e : e.ownerDocument;
              "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
              "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d.is ? a2 = g.createElement(c2, { is: d.is }) : (a2 = g.createElement(c2), "select" === c2 && (g = a2, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a2 = g.createElementNS(a2, c2);
              a2[Of] = b;
              a2[Pf] = d;
              zj(a2, b, false, false);
              b.stateNode = a2;
              a: {
                g = vb(c2, d);
                switch (c2) {
                  case "dialog":
                    D("cancel", a2);
                    D("close", a2);
                    e = d;
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D("load", a2);
                    e = d;
                    break;
                  case "video":
                  case "audio":
                    for (e = 0; e < lf.length; e++) D(lf[e], a2);
                    e = d;
                    break;
                  case "source":
                    D("error", a2);
                    e = d;
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D(
                      "error",
                      a2
                    );
                    D("load", a2);
                    e = d;
                    break;
                  case "details":
                    D("toggle", a2);
                    e = d;
                    break;
                  case "input":
                    Za(a2, d);
                    e = Ya(a2, d);
                    D("invalid", a2);
                    break;
                  case "option":
                    e = d;
                    break;
                  case "select":
                    a2._wrapperState = { wasMultiple: !!d.multiple };
                    e = A({}, d, { value: void 0 });
                    D("invalid", a2);
                    break;
                  case "textarea":
                    hb(a2, d);
                    e = gb(a2, d);
                    D("invalid", a2);
                    break;
                  default:
                    e = d;
                }
                ub(c2, e);
                h = e;
                for (f2 in h) if (h.hasOwnProperty(f2)) {
                  var k2 = h[f2];
                  "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a2) : null != k2 && ta(a2, f2, k2, g));
                }
                switch (c2) {
                  case "input":
                    Va(a2);
                    db(a2, d, false);
                    break;
                  case "textarea":
                    Va(a2);
                    jb(a2);
                    break;
                  case "option":
                    null != d.value && a2.setAttribute("value", "" + Sa(d.value));
                    break;
                  case "select":
                    a2.multiple = !!d.multiple;
                    f2 = d.value;
                    null != f2 ? fb(a2, !!d.multiple, f2, false) : null != d.defaultValue && fb(
                      a2,
                      !!d.multiple,
                      d.defaultValue,
                      true
                    );
                    break;
                  default:
                    "function" === typeof e.onClick && (a2.onclick = Bf);
                }
                switch (c2) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    d = !!d.autoFocus;
                    break a;
                  case "img":
                    d = true;
                    break a;
                  default:
                    d = false;
                }
              }
              d && (b.flags |= 4);
            }
            null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
          }
          S(b);
          return null;
        case 6:
          if (a2 && null != b.stateNode) Cj(a2, b, a2.memoizedProps, d);
          else {
            if ("string" !== typeof d && null === b.stateNode) throw Error(p(166));
            c2 = xh(wh.current);
            xh(uh.current);
            if (Gg(b)) {
              d = b.stateNode;
              c2 = b.memoizedProps;
              d[Of] = b;
              if (f2 = d.nodeValue !== c2) {
                if (a2 = xg, null !== a2) switch (a2.tag) {
                  case 3:
                    Af(d.nodeValue, c2, 0 !== (a2.mode & 1));
                    break;
                  case 5:
                    true !== a2.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c2, 0 !== (a2.mode & 1));
                }
              }
              f2 && (b.flags |= 4);
            } else d = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
          }
          S(b);
          return null;
        case 13:
          E(L$2);
          d = b.memoizedState;
          if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
            if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f2 = false;
            else if (f2 = Gg(b), null !== d && null !== d.dehydrated) {
              if (null === a2) {
                if (!f2) throw Error(p(318));
                f2 = b.memoizedState;
                f2 = null !== f2 ? f2.dehydrated : null;
                if (!f2) throw Error(p(317));
                f2[Of] = b;
              } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
              S(b);
              f2 = false;
            } else null !== zg && (Fj(zg), zg = null), f2 = true;
            if (!f2) return b.flags & 65536 ? b : null;
          }
          if (0 !== (b.flags & 128)) return b.lanes = c2, b;
          d = null !== d;
          d !== (null !== a2 && null !== a2.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a2 || 0 !== (L$2.current & 1) ? 0 === T && (T = 3) : tj()));
          null !== b.updateQueue && (b.flags |= 4);
          S(b);
          return null;
        case 4:
          return zh(), Aj(a2, b), null === a2 && sf(b.stateNode.containerInfo), S(b), null;
        case 10:
          return ah(b.type._context), S(b), null;
        case 17:
          return Zf(b.type) && $f(), S(b), null;
        case 19:
          E(L$2);
          f2 = b.memoizedState;
          if (null === f2) return S(b), null;
          d = 0 !== (b.flags & 128);
          g = f2.rendering;
          if (null === g) if (d) Dj(f2, false);
          else {
            if (0 !== T || null !== a2 && 0 !== (a2.flags & 128)) for (a2 = b.child; null !== a2; ) {
              g = Ch(a2);
              if (null !== g) {
                b.flags |= 128;
                Dj(f2, false);
                d = g.updateQueue;
                null !== d && (b.updateQueue = d, b.flags |= 4);
                b.subtreeFlags = 0;
                d = c2;
                for (c2 = b.child; null !== c2; ) f2 = c2, a2 = d, f2.flags &= 14680066, g = f2.alternate, null === g ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g.childLanes, f2.lanes = g.lanes, f2.child = g.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g.memoizedProps, f2.memoizedState = g.memoizedState, f2.updateQueue = g.updateQueue, f2.type = g.type, a2 = g.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                G(L$2, L$2.current & 1 | 2);
                return b.child;
              }
              a2 = a2.sibling;
            }
            null !== f2.tail && B() > Gj && (b.flags |= 128, d = true, Dj(f2, false), b.lanes = 4194304);
          }
          else {
            if (!d) if (a2 = Ch(g), null !== a2) {
              if (b.flags |= 128, d = true, c2 = a2.updateQueue, null !== c2 && (b.updateQueue = c2, b.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g.alternate && !I) return S(b), null;
            } else 2 * B() - f2.renderingStartTime > Gj && 1073741824 !== c2 && (b.flags |= 128, d = true, Dj(f2, false), b.lanes = 4194304);
            f2.isBackwards ? (g.sibling = b.child, b.child = g) : (c2 = f2.last, null !== c2 ? c2.sibling = g : b.child = g, f2.last = g);
          }
          if (null !== f2.tail) return b = f2.tail, f2.rendering = b, f2.tail = b.sibling, f2.renderingStartTime = B(), b.sibling = null, c2 = L$2.current, G(L$2, d ? c2 & 1 | 2 : c2 & 1), b;
          S(b);
          return null;
        case 22:
        case 23:
          return Hj(), d = null !== b.memoizedState, null !== a2 && null !== a2.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(p(156, b.tag));
    }
    function Ij(a2, b) {
      wg(b);
      switch (b.tag) {
        case 1:
          return Zf(b.type) && $f(), a2 = b.flags, a2 & 65536 ? (b.flags = a2 & -65537 | 128, b) : null;
        case 3:
          return zh(), E(Wf), E(H), Eh(), a2 = b.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b.flags = a2 & -65537 | 128, b) : null;
        case 5:
          return Bh(b), null;
        case 13:
          E(L$2);
          a2 = b.memoizedState;
          if (null !== a2 && null !== a2.dehydrated) {
            if (null === b.alternate) throw Error(p(340));
            Ig();
          }
          a2 = b.flags;
          return a2 & 65536 ? (b.flags = a2 & -65537 | 128, b) : null;
        case 19:
          return E(L$2), null;
        case 4:
          return zh(), null;
        case 10:
          return ah(b.type._context), null;
        case 22:
        case 23:
          return Hj(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
    function Lj(a2, b) {
      var c2 = a2.ref;
      if (null !== c2) if ("function" === typeof c2) try {
        c2(null);
      } catch (d) {
        W(a2, b, d);
      }
      else c2.current = null;
    }
    function Mj(a2, b, c2) {
      try {
        c2();
      } catch (d) {
        W(a2, b, d);
      }
    }
    var Nj = false;
    function Oj(a2, b) {
      Cf = dd;
      a2 = Me();
      if (Ne(a2)) {
        if ("selectionStart" in a2) var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
        else a: {
          c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
          var d = c2.getSelection && c2.getSelection();
          if (d && 0 !== d.rangeCount) {
            c2 = d.anchorNode;
            var e = d.anchorOffset, f2 = d.focusNode;
            d = d.focusOffset;
            try {
              c2.nodeType, f2.nodeType;
            } catch (F2) {
              c2 = null;
              break a;
            }
            var g = 0, h = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
            b: for (; ; ) {
              for (var y2; ; ) {
                q2 !== c2 || 0 !== e && 3 !== q2.nodeType || (h = g + e);
                q2 !== f2 || 0 !== d && 3 !== q2.nodeType || (k2 = g + d);
                3 === q2.nodeType && (g += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild)) break;
                r2 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a2) break b;
                r2 === c2 && ++l2 === e && (h = g);
                r2 === f2 && ++m2 === d && (k2 = g);
                if (null !== (y2 = q2.nextSibling)) break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y2;
            }
            c2 = -1 === h || -1 === k2 ? null : { start: h, end: k2 };
          } else c2 = null;
        }
        c2 = c2 || { start: 0, end: 0 };
      } else c2 = null;
      Df = { focusedElem: a2, selectionRange: c2 };
      dd = false;
      for (V = b; null !== V; ) if (b = V, a2 = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a2) a2.return = b, V = a2;
      else for (; null !== V; ) {
        b = V;
        try {
          var n2 = b.alternate;
          if (0 !== (b.flags & 1024)) switch (b.tag) {
            case 0:
            case 11:
            case 15:
              break;
            case 1:
              if (null !== n2) {
                var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b.stateNode, w2 = x2.getSnapshotBeforeUpdate(b.elementType === b.type ? t2 : Ci(b.type, t2), J2);
                x2.__reactInternalSnapshotBeforeUpdate = w2;
              }
              break;
            case 3:
              var u2 = b.stateNode.containerInfo;
              1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
              break;
            case 5:
            case 6:
            case 4:
            case 17:
              break;
            default:
              throw Error(p(163));
          }
        } catch (F2) {
          W(b, b.return, F2);
        }
        a2 = b.sibling;
        if (null !== a2) {
          a2.return = b.return;
          V = a2;
          break;
        }
        V = b.return;
      }
      n2 = Nj;
      Nj = false;
      return n2;
    }
    function Pj(a2, b, c2) {
      var d = b.updateQueue;
      d = null !== d ? d.lastEffect : null;
      if (null !== d) {
        var e = d = d.next;
        do {
          if ((e.tag & a2) === a2) {
            var f2 = e.destroy;
            e.destroy = void 0;
            void 0 !== f2 && Mj(b, c2, f2);
          }
          e = e.next;
        } while (e !== d);
      }
    }
    function Qj(a2, b) {
      b = b.updateQueue;
      b = null !== b ? b.lastEffect : null;
      if (null !== b) {
        var c2 = b = b.next;
        do {
          if ((c2.tag & a2) === a2) {
            var d = c2.create;
            c2.destroy = d();
          }
          c2 = c2.next;
        } while (c2 !== b);
      }
    }
    function Rj(a2) {
      var b = a2.ref;
      if (null !== b) {
        var c2 = a2.stateNode;
        switch (a2.tag) {
          case 5:
            a2 = c2;
            break;
          default:
            a2 = c2;
        }
        "function" === typeof b ? b(a2) : b.current = a2;
      }
    }
    function Sj(a2) {
      var b = a2.alternate;
      null !== b && (a2.alternate = null, Sj(b));
      a2.child = null;
      a2.deletions = null;
      a2.sibling = null;
      5 === a2.tag && (b = a2.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
      a2.stateNode = null;
      a2.return = null;
      a2.dependencies = null;
      a2.memoizedProps = null;
      a2.memoizedState = null;
      a2.pendingProps = null;
      a2.stateNode = null;
      a2.updateQueue = null;
    }
    function Tj(a2) {
      return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
    }
    function Uj(a2) {
      a: for (; ; ) {
        for (; null === a2.sibling; ) {
          if (null === a2.return || Tj(a2.return)) return null;
          a2 = a2.return;
        }
        a2.sibling.return = a2.return;
        for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
          if (a2.flags & 2) continue a;
          if (null === a2.child || 4 === a2.tag) continue a;
          else a2.child.return = a2, a2 = a2.child;
        }
        if (!(a2.flags & 2)) return a2.stateNode;
      }
    }
    function Vj(a2, b, c2) {
      var d = a2.tag;
      if (5 === d || 6 === d) a2 = a2.stateNode, b ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b) : c2.insertBefore(a2, b) : (8 === c2.nodeType ? (b = c2.parentNode, b.insertBefore(a2, c2)) : (b = c2, b.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b.onclick || (b.onclick = Bf));
      else if (4 !== d && (a2 = a2.child, null !== a2)) for (Vj(a2, b, c2), a2 = a2.sibling; null !== a2; ) Vj(a2, b, c2), a2 = a2.sibling;
    }
    function Wj(a2, b, c2) {
      var d = a2.tag;
      if (5 === d || 6 === d) a2 = a2.stateNode, b ? c2.insertBefore(a2, b) : c2.appendChild(a2);
      else if (4 !== d && (a2 = a2.child, null !== a2)) for (Wj(a2, b, c2), a2 = a2.sibling; null !== a2; ) Wj(a2, b, c2), a2 = a2.sibling;
    }
    var X$1 = null, Xj = false;
    function Yj(a2, b, c2) {
      for (c2 = c2.child; null !== c2; ) Zj(a2, b, c2), c2 = c2.sibling;
    }
    function Zj(a2, b, c2) {
      if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
        lc.onCommitFiberUnmount(kc, c2);
      } catch (h) {
      }
      switch (c2.tag) {
        case 5:
          U || Lj(c2, b);
        case 6:
          var d = X$1, e = Xj;
          X$1 = null;
          Yj(a2, b, c2);
          X$1 = d;
          Xj = e;
          null !== X$1 && (Xj ? (a2 = X$1, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X$1.removeChild(c2.stateNode));
          break;
        case 18:
          null !== X$1 && (Xj ? (a2 = X$1, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X$1, c2.stateNode));
          break;
        case 4:
          d = X$1;
          e = Xj;
          X$1 = c2.stateNode.containerInfo;
          Xj = true;
          Yj(a2, b, c2);
          X$1 = d;
          Xj = e;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          if (!U && (d = c2.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
            e = d = d.next;
            do {
              var f2 = e, g = f2.destroy;
              f2 = f2.tag;
              void 0 !== g && (0 !== (f2 & 2) ? Mj(c2, b, g) : 0 !== (f2 & 4) && Mj(c2, b, g));
              e = e.next;
            } while (e !== d);
          }
          Yj(a2, b, c2);
          break;
        case 1:
          if (!U && (Lj(c2, b), d = c2.stateNode, "function" === typeof d.componentWillUnmount)) try {
            d.props = c2.memoizedProps, d.state = c2.memoizedState, d.componentWillUnmount();
          } catch (h) {
            W(c2, b, h);
          }
          Yj(a2, b, c2);
          break;
        case 21:
          Yj(a2, b, c2);
          break;
        case 22:
          c2.mode & 1 ? (U = (d = U) || null !== c2.memoizedState, Yj(a2, b, c2), U = d) : Yj(a2, b, c2);
          break;
        default:
          Yj(a2, b, c2);
      }
    }
    function ak(a2) {
      var b = a2.updateQueue;
      if (null !== b) {
        a2.updateQueue = null;
        var c2 = a2.stateNode;
        null === c2 && (c2 = a2.stateNode = new Kj());
        b.forEach(function(b2) {
          var d = bk.bind(null, a2, b2);
          c2.has(b2) || (c2.add(b2), b2.then(d, d));
        });
      }
    }
    function ck(a2, b) {
      var c2 = b.deletions;
      if (null !== c2) for (var d = 0; d < c2.length; d++) {
        var e = c2[d];
        try {
          var f2 = a2, g = b, h = g;
          a: for (; null !== h; ) {
            switch (h.tag) {
              case 5:
                X$1 = h.stateNode;
                Xj = false;
                break a;
              case 3:
                X$1 = h.stateNode.containerInfo;
                Xj = true;
                break a;
              case 4:
                X$1 = h.stateNode.containerInfo;
                Xj = true;
                break a;
            }
            h = h.return;
          }
          if (null === X$1) throw Error(p(160));
          Zj(f2, g, e);
          X$1 = null;
          Xj = false;
          var k2 = e.alternate;
          null !== k2 && (k2.return = null);
          e.return = null;
        } catch (l2) {
          W(e, b, l2);
        }
      }
      if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) dk(b, a2), b = b.sibling;
    }
    function dk(a2, b) {
      var c2 = a2.alternate, d = a2.flags;
      switch (a2.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          ck(b, a2);
          ek(a2);
          if (d & 4) {
            try {
              Pj(3, a2, a2.return), Qj(3, a2);
            } catch (t2) {
              W(a2, a2.return, t2);
            }
            try {
              Pj(5, a2, a2.return);
            } catch (t2) {
              W(a2, a2.return, t2);
            }
          }
          break;
        case 1:
          ck(b, a2);
          ek(a2);
          d & 512 && null !== c2 && Lj(c2, c2.return);
          break;
        case 5:
          ck(b, a2);
          ek(a2);
          d & 512 && null !== c2 && Lj(c2, c2.return);
          if (a2.flags & 32) {
            var e = a2.stateNode;
            try {
              ob(e, "");
            } catch (t2) {
              W(a2, a2.return, t2);
            }
          }
          if (d & 4 && (e = a2.stateNode, null != e)) {
            var f2 = a2.memoizedProps, g = null !== c2 ? c2.memoizedProps : f2, h = a2.type, k2 = a2.updateQueue;
            a2.updateQueue = null;
            if (null !== k2) try {
              "input" === h && "radio" === f2.type && null != f2.name && ab(e, f2);
              vb(h, g);
              var l2 = vb(h, f2);
              for (g = 0; g < k2.length; g += 2) {
                var m2 = k2[g], q2 = k2[g + 1];
                "style" === m2 ? sb(e, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e, q2) : "children" === m2 ? ob(e, q2) : ta(e, m2, q2, l2);
              }
              switch (h) {
                case "input":
                  bb(e, f2);
                  break;
                case "textarea":
                  ib(e, f2);
                  break;
                case "select":
                  var r2 = e._wrapperState.wasMultiple;
                  e._wrapperState.wasMultiple = !!f2.multiple;
                  var y2 = f2.value;
                  null != y2 ? fb(e, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                    e,
                    !!f2.multiple,
                    f2.defaultValue,
                    true
                  ) : fb(e, !!f2.multiple, f2.multiple ? [] : "", false));
              }
              e[Pf] = f2;
            } catch (t2) {
              W(a2, a2.return, t2);
            }
          }
          break;
        case 6:
          ck(b, a2);
          ek(a2);
          if (d & 4) {
            if (null === a2.stateNode) throw Error(p(162));
            e = a2.stateNode;
            f2 = a2.memoizedProps;
            try {
              e.nodeValue = f2;
            } catch (t2) {
              W(a2, a2.return, t2);
            }
          }
          break;
        case 3:
          ck(b, a2);
          ek(a2);
          if (d & 4 && null !== c2 && c2.memoizedState.isDehydrated) try {
            bd(b.containerInfo);
          } catch (t2) {
            W(a2, a2.return, t2);
          }
          break;
        case 4:
          ck(b, a2);
          ek(a2);
          break;
        case 13:
          ck(b, a2);
          ek(a2);
          e = a2.child;
          e.flags & 8192 && (f2 = null !== e.memoizedState, e.stateNode.isHidden = f2, !f2 || null !== e.alternate && null !== e.alternate.memoizedState || (fk = B()));
          d & 4 && ak(a2);
          break;
        case 22:
          m2 = null !== c2 && null !== c2.memoizedState;
          a2.mode & 1 ? (U = (l2 = U) || m2, ck(b, a2), U = l2) : ck(b, a2);
          ek(a2);
          if (d & 8192) {
            l2 = null !== a2.memoizedState;
            if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1)) for (V = a2, m2 = a2.child; null !== m2; ) {
              for (q2 = V = m2; null !== V; ) {
                r2 = V;
                y2 = r2.child;
                switch (r2.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Pj(4, r2, r2.return);
                    break;
                  case 1:
                    Lj(r2, r2.return);
                    var n2 = r2.stateNode;
                    if ("function" === typeof n2.componentWillUnmount) {
                      d = r2;
                      c2 = r2.return;
                      try {
                        b = d, n2.props = b.memoizedProps, n2.state = b.memoizedState, n2.componentWillUnmount();
                      } catch (t2) {
                        W(d, c2, t2);
                      }
                    }
                    break;
                  case 5:
                    Lj(r2, r2.return);
                    break;
                  case 22:
                    if (null !== r2.memoizedState) {
                      gk(q2);
                      continue;
                    }
                }
                null !== y2 ? (y2.return = r2, V = y2) : gk(q2);
              }
              m2 = m2.sibling;
            }
            a: for (m2 = null, q2 = a2; ; ) {
              if (5 === q2.tag) {
                if (null === m2) {
                  m2 = q2;
                  try {
                    e = q2.stateNode, l2 ? (f2 = e.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h = q2.stateNode, k2 = q2.memoizedProps.style, g = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h.style.display = rb("display", g));
                  } catch (t2) {
                    W(a2, a2.return, t2);
                  }
                }
              } else if (6 === q2.tag) {
                if (null === m2) try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W(a2, a2.return, t2);
                }
              } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
                q2.child.return = q2;
                q2 = q2.child;
                continue;
              }
              if (q2 === a2) break a;
              for (; null === q2.sibling; ) {
                if (null === q2.return || q2.return === a2) break a;
                m2 === q2 && (m2 = null);
                q2 = q2.return;
              }
              m2 === q2 && (m2 = null);
              q2.sibling.return = q2.return;
              q2 = q2.sibling;
            }
          }
          break;
        case 19:
          ck(b, a2);
          ek(a2);
          d & 4 && ak(a2);
          break;
        case 21:
          break;
        default:
          ck(
            b,
            a2
          ), ek(a2);
      }
    }
    function ek(a2) {
      var b = a2.flags;
      if (b & 2) {
        try {
          a: {
            for (var c2 = a2.return; null !== c2; ) {
              if (Tj(c2)) {
                var d = c2;
                break a;
              }
              c2 = c2.return;
            }
            throw Error(p(160));
          }
          switch (d.tag) {
            case 5:
              var e = d.stateNode;
              d.flags & 32 && (ob(e, ""), d.flags &= -33);
              var f2 = Uj(a2);
              Wj(a2, f2, e);
              break;
            case 3:
            case 4:
              var g = d.stateNode.containerInfo, h = Uj(a2);
              Vj(a2, h, g);
              break;
            default:
              throw Error(p(161));
          }
        } catch (k2) {
          W(a2, a2.return, k2);
        }
        a2.flags &= -3;
      }
      b & 4096 && (a2.flags &= -4097);
    }
    function hk(a2, b, c2) {
      V = a2;
      ik(a2);
    }
    function ik(a2, b, c2) {
      for (var d = 0 !== (a2.mode & 1); null !== V; ) {
        var e = V, f2 = e.child;
        if (22 === e.tag && d) {
          var g = null !== e.memoizedState || Jj;
          if (!g) {
            var h = e.alternate, k2 = null !== h && null !== h.memoizedState || U;
            h = Jj;
            var l2 = U;
            Jj = g;
            if ((U = k2) && !l2) for (V = e; null !== V; ) g = V, k2 = g.child, 22 === g.tag && null !== g.memoizedState ? jk(e) : null !== k2 ? (k2.return = g, V = k2) : jk(e);
            for (; null !== f2; ) V = f2, ik(f2), f2 = f2.sibling;
            V = e;
            Jj = h;
            U = l2;
          }
          kk(a2);
        } else 0 !== (e.subtreeFlags & 8772) && null !== f2 ? (f2.return = e, V = f2) : kk(a2);
      }
    }
    function kk(a2) {
      for (; null !== V; ) {
        var b = V;
        if (0 !== (b.flags & 8772)) {
          var c2 = b.alternate;
          try {
            if (0 !== (b.flags & 8772)) switch (b.tag) {
              case 0:
              case 11:
              case 15:
                U || Qj(5, b);
                break;
              case 1:
                var d = b.stateNode;
                if (b.flags & 4 && !U) if (null === c2) d.componentDidMount();
                else {
                  var e = b.elementType === b.type ? c2.memoizedProps : Ci(b.type, c2.memoizedProps);
                  d.componentDidUpdate(e, c2.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                }
                var f2 = b.updateQueue;
                null !== f2 && sh(b, f2, d);
                break;
              case 3:
                var g = b.updateQueue;
                if (null !== g) {
                  c2 = null;
                  if (null !== b.child) switch (b.child.tag) {
                    case 5:
                      c2 = b.child.stateNode;
                      break;
                    case 1:
                      c2 = b.child.stateNode;
                  }
                  sh(b, g, c2);
                }
                break;
              case 5:
                var h = b.stateNode;
                if (null === c2 && b.flags & 4) {
                  c2 = h;
                  var k2 = b.memoizedProps;
                  switch (b.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      k2.autoFocus && c2.focus();
                      break;
                    case "img":
                      k2.src && (c2.src = k2.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (null === b.memoizedState) {
                  var l2 = b.alternate;
                  if (null !== l2) {
                    var m2 = l2.memoizedState;
                    if (null !== m2) {
                      var q2 = m2.dehydrated;
                      null !== q2 && bd(q2);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(p(163));
            }
            U || b.flags & 512 && Rj(b);
          } catch (r2) {
            W(b, b.return, r2);
          }
        }
        if (b === a2) {
          V = null;
          break;
        }
        c2 = b.sibling;
        if (null !== c2) {
          c2.return = b.return;
          V = c2;
          break;
        }
        V = b.return;
      }
    }
    function gk(a2) {
      for (; null !== V; ) {
        var b = V;
        if (b === a2) {
          V = null;
          break;
        }
        var c2 = b.sibling;
        if (null !== c2) {
          c2.return = b.return;
          V = c2;
          break;
        }
        V = b.return;
      }
    }
    function jk(a2) {
      for (; null !== V; ) {
        var b = V;
        try {
          switch (b.tag) {
            case 0:
            case 11:
            case 15:
              var c2 = b.return;
              try {
                Qj(4, b);
              } catch (k2) {
                W(b, c2, k2);
              }
              break;
            case 1:
              var d = b.stateNode;
              if ("function" === typeof d.componentDidMount) {
                var e = b.return;
                try {
                  d.componentDidMount();
                } catch (k2) {
                  W(b, e, k2);
                }
              }
              var f2 = b.return;
              try {
                Rj(b);
              } catch (k2) {
                W(b, f2, k2);
              }
              break;
            case 5:
              var g = b.return;
              try {
                Rj(b);
              } catch (k2) {
                W(b, g, k2);
              }
          }
        } catch (k2) {
          W(b, b.return, k2);
        }
        if (b === a2) {
          V = null;
          break;
        }
        var h = b.sibling;
        if (null !== h) {
          h.return = b.return;
          V = h;
          break;
        }
        V = b.return;
      }
    }
    var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
    function R() {
      return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
    }
    function yi(a2) {
      if (0 === (a2.mode & 1)) return 1;
      if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
      if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
      a2 = C;
      if (0 !== a2) return a2;
      a2 = window.event;
      a2 = void 0 === a2 ? 16 : jd(a2.type);
      return a2;
    }
    function gi(a2, b, c2, d) {
      if (50 < yk) throw yk = 0, zk = null, Error(p(185));
      Ac(a2, c2, d);
      if (0 === (K & 2) || a2 !== Q) a2 === Q && (0 === (K & 2) && (qk |= c2), 4 === T && Ck(a2, Z)), Dk(a2, d), 1 === c2 && 0 === K && 0 === (b.mode & 1) && (Gj = B() + 500, fg && jg());
    }
    function Dk(a2, b) {
      var c2 = a2.callbackNode;
      wc(a2, b);
      var d = uc(a2, a2 === Q ? Z : 0);
      if (0 === d) null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
      else if (b = d & -d, a2.callbackPriority !== b) {
        null != c2 && bc(c2);
        if (1 === b) 0 === a2.tag ? ig(Ek.bind(null, a2)) : hg(Ek.bind(null, a2)), Jf(function() {
          0 === (K & 6) && jg();
        }), c2 = null;
        else {
          switch (Dc(d)) {
            case 1:
              c2 = fc;
              break;
            case 4:
              c2 = gc;
              break;
            case 16:
              c2 = hc;
              break;
            case 536870912:
              c2 = jc;
              break;
            default:
              c2 = hc;
          }
          c2 = Fk(c2, Gk.bind(null, a2));
        }
        a2.callbackPriority = b;
        a2.callbackNode = c2;
      }
    }
    function Gk(a2, b) {
      Ak = -1;
      Bk = 0;
      if (0 !== (K & 6)) throw Error(p(327));
      var c2 = a2.callbackNode;
      if (Hk() && a2.callbackNode !== c2) return null;
      var d = uc(a2, a2 === Q ? Z : 0);
      if (0 === d) return null;
      if (0 !== (d & 30) || 0 !== (d & a2.expiredLanes) || b) b = Ik(a2, d);
      else {
        b = d;
        var e = K;
        K |= 2;
        var f2 = Jk();
        if (Q !== a2 || Z !== b) uk = null, Gj = B() + 500, Kk(a2, b);
        do
          try {
            Lk();
            break;
          } catch (h) {
            Mk(a2, h);
          }
        while (1);
        $g();
        mk.current = f2;
        K = e;
        null !== Y ? b = 0 : (Q = null, Z = 0, b = T);
      }
      if (0 !== b) {
        2 === b && (e = xc(a2), 0 !== e && (d = e, b = Nk(a2, e)));
        if (1 === b) throw c2 = pk, Kk(a2, 0), Ck(a2, d), Dk(a2, B()), c2;
        if (6 === b) Ck(a2, d);
        else {
          e = a2.current.alternate;
          if (0 === (d & 30) && !Ok(e) && (b = Ik(a2, d), 2 === b && (f2 = xc(a2), 0 !== f2 && (d = f2, b = Nk(a2, f2))), 1 === b)) throw c2 = pk, Kk(a2, 0), Ck(a2, d), Dk(a2, B()), c2;
          a2.finishedWork = e;
          a2.finishedLanes = d;
          switch (b) {
            case 0:
            case 1:
              throw Error(p(345));
            case 2:
              Pk(a2, tk, uk);
              break;
            case 3:
              Ck(a2, d);
              if ((d & 130023424) === d && (b = fk + 500 - B(), 10 < b)) {
                if (0 !== uc(a2, 0)) break;
                e = a2.suspendedLanes;
                if ((e & d) !== d) {
                  R();
                  a2.pingedLanes |= a2.suspendedLanes & e;
                  break;
                }
                a2.timeoutHandle = Ff(Pk.bind(null, a2, tk, uk), b);
                break;
              }
              Pk(a2, tk, uk);
              break;
            case 4:
              Ck(a2, d);
              if ((d & 4194240) === d) break;
              b = a2.eventTimes;
              for (e = -1; 0 < d; ) {
                var g = 31 - oc(d);
                f2 = 1 << g;
                g = b[g];
                g > e && (e = g);
                d &= ~f2;
              }
              d = e;
              d = B() - d;
              d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d;
              if (10 < d) {
                a2.timeoutHandle = Ff(Pk.bind(null, a2, tk, uk), d);
                break;
              }
              Pk(a2, tk, uk);
              break;
            case 5:
              Pk(a2, tk, uk);
              break;
            default:
              throw Error(p(329));
          }
        }
      }
      Dk(a2, B());
      return a2.callbackNode === c2 ? Gk.bind(null, a2) : null;
    }
    function Nk(a2, b) {
      var c2 = sk;
      a2.current.memoizedState.isDehydrated && (Kk(a2, b).flags |= 256);
      a2 = Ik(a2, b);
      2 !== a2 && (b = tk, tk = c2, null !== b && Fj(b));
      return a2;
    }
    function Fj(a2) {
      null === tk ? tk = a2 : tk.push.apply(tk, a2);
    }
    function Ok(a2) {
      for (var b = a2; ; ) {
        if (b.flags & 16384) {
          var c2 = b.updateQueue;
          if (null !== c2 && (c2 = c2.stores, null !== c2)) for (var d = 0; d < c2.length; d++) {
            var e = c2[d], f2 = e.getSnapshot;
            e = e.value;
            try {
              if (!He(f2(), e)) return false;
            } catch (g) {
              return false;
            }
          }
        }
        c2 = b.child;
        if (b.subtreeFlags & 16384 && null !== c2) c2.return = b, b = c2;
        else {
          if (b === a2) break;
          for (; null === b.sibling; ) {
            if (null === b.return || b.return === a2) return true;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
      }
      return true;
    }
    function Ck(a2, b) {
      b &= ~rk;
      b &= ~qk;
      a2.suspendedLanes |= b;
      a2.pingedLanes &= ~b;
      for (a2 = a2.expirationTimes; 0 < b; ) {
        var c2 = 31 - oc(b), d = 1 << c2;
        a2[c2] = -1;
        b &= ~d;
      }
    }
    function Ek(a2) {
      if (0 !== (K & 6)) throw Error(p(327));
      Hk();
      var b = uc(a2, 0);
      if (0 === (b & 1)) return Dk(a2, B()), null;
      var c2 = Ik(a2, b);
      if (0 !== a2.tag && 2 === c2) {
        var d = xc(a2);
        0 !== d && (b = d, c2 = Nk(a2, d));
      }
      if (1 === c2) throw c2 = pk, Kk(a2, 0), Ck(a2, b), Dk(a2, B()), c2;
      if (6 === c2) throw Error(p(345));
      a2.finishedWork = a2.current.alternate;
      a2.finishedLanes = b;
      Pk(a2, tk, uk);
      Dk(a2, B());
      return null;
    }
    function Qk(a2, b) {
      var c2 = K;
      K |= 1;
      try {
        return a2(b);
      } finally {
        K = c2, 0 === K && (Gj = B() + 500, fg && jg());
      }
    }
    function Rk(a2) {
      null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
      var b = K;
      K |= 1;
      var c2 = ok.transition, d = C;
      try {
        if (ok.transition = null, C = 1, a2) return a2();
      } finally {
        C = d, ok.transition = c2, K = b, 0 === (K & 6) && jg();
      }
    }
    function Hj() {
      fj = ej.current;
      E(ej);
    }
    function Kk(a2, b) {
      a2.finishedWork = null;
      a2.finishedLanes = 0;
      var c2 = a2.timeoutHandle;
      -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
      if (null !== Y) for (c2 = Y.return; null !== c2; ) {
        var d = c2;
        wg(d);
        switch (d.tag) {
          case 1:
            d = d.type.childContextTypes;
            null !== d && void 0 !== d && $f();
            break;
          case 3:
            zh();
            E(Wf);
            E(H);
            Eh();
            break;
          case 5:
            Bh(d);
            break;
          case 4:
            zh();
            break;
          case 13:
            E(L$2);
            break;
          case 19:
            E(L$2);
            break;
          case 10:
            ah(d.type._context);
            break;
          case 22:
          case 23:
            Hj();
        }
        c2 = c2.return;
      }
      Q = a2;
      Y = a2 = Pg(a2.current, null);
      Z = fj = b;
      T = 0;
      pk = null;
      rk = qk = rh = 0;
      tk = sk = null;
      if (null !== fh) {
        for (b = 0; b < fh.length; b++) if (c2 = fh[b], d = c2.interleaved, null !== d) {
          c2.interleaved = null;
          var e = d.next, f2 = c2.pending;
          if (null !== f2) {
            var g = f2.next;
            f2.next = e;
            d.next = g;
          }
          c2.pending = d;
        }
        fh = null;
      }
      return a2;
    }
    function Mk(a2, b) {
      do {
        var c2 = Y;
        try {
          $g();
          Fh.current = Rh;
          if (Ih) {
            for (var d = M.memoizedState; null !== d; ) {
              var e = d.queue;
              null !== e && (e.pending = null);
              d = d.next;
            }
            Ih = false;
          }
          Hh = 0;
          O$1 = N = M = null;
          Jh = false;
          Kh = 0;
          nk.current = null;
          if (null === c2 || null === c2.return) {
            T = 1;
            pk = b;
            Y = null;
            break;
          }
          a: {
            var f2 = a2, g = c2.return, h = c2, k2 = b;
            b = Z;
            h.flags |= 32768;
            if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
              var l2 = k2, m2 = h, q2 = m2.tag;
              if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
                var r2 = m2.alternate;
                r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
              }
              var y2 = Ui(g);
              if (null !== y2) {
                y2.flags &= -257;
                Vi(y2, g, h, f2, b);
                y2.mode & 1 && Si(f2, l2, b);
                b = y2;
                k2 = l2;
                var n2 = b.updateQueue;
                if (null === n2) {
                  var t2 = /* @__PURE__ */ new Set();
                  t2.add(k2);
                  b.updateQueue = t2;
                } else n2.add(k2);
                break a;
              } else {
                if (0 === (b & 1)) {
                  Si(f2, l2, b);
                  tj();
                  break a;
                }
                k2 = Error(p(426));
              }
            } else if (I && h.mode & 1) {
              var J2 = Ui(g);
              if (null !== J2) {
                0 === (J2.flags & 65536) && (J2.flags |= 256);
                Vi(J2, g, h, f2, b);
                Jg(Ji(k2, h));
                break a;
              }
            }
            f2 = k2 = Ji(k2, h);
            4 !== T && (T = 2);
            null === sk ? sk = [f2] : sk.push(f2);
            f2 = g;
            do {
              switch (f2.tag) {
                case 3:
                  f2.flags |= 65536;
                  b &= -b;
                  f2.lanes |= b;
                  var x2 = Ni(f2, k2, b);
                  ph(f2, x2);
                  break a;
                case 1:
                  h = k2;
                  var w2 = f2.type, u2 = f2.stateNode;
                  if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Ri || !Ri.has(u2)))) {
                    f2.flags |= 65536;
                    b &= -b;
                    f2.lanes |= b;
                    var F2 = Qi(f2, h, b);
                    ph(f2, F2);
                    break a;
                  }
              }
              f2 = f2.return;
            } while (null !== f2);
          }
          Sk(c2);
        } catch (na) {
          b = na;
          Y === c2 && null !== c2 && (Y = c2 = c2.return);
          continue;
        }
        break;
      } while (1);
    }
    function Jk() {
      var a2 = mk.current;
      mk.current = Rh;
      return null === a2 ? Rh : a2;
    }
    function tj() {
      if (0 === T || 3 === T || 2 === T) T = 4;
      null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
    }
    function Ik(a2, b) {
      var c2 = K;
      K |= 2;
      var d = Jk();
      if (Q !== a2 || Z !== b) uk = null, Kk(a2, b);
      do
        try {
          Tk();
          break;
        } catch (e) {
          Mk(a2, e);
        }
      while (1);
      $g();
      K = c2;
      mk.current = d;
      if (null !== Y) throw Error(p(261));
      Q = null;
      Z = 0;
      return T;
    }
    function Tk() {
      for (; null !== Y; ) Uk(Y);
    }
    function Lk() {
      for (; null !== Y && !cc(); ) Uk(Y);
    }
    function Uk(a2) {
      var b = Vk(a2.alternate, a2, fj);
      a2.memoizedProps = a2.pendingProps;
      null === b ? Sk(a2) : Y = b;
      nk.current = null;
    }
    function Sk(a2) {
      var b = a2;
      do {
        var c2 = b.alternate;
        a2 = b.return;
        if (0 === (b.flags & 32768)) {
          if (c2 = Ej(c2, b, fj), null !== c2) {
            Y = c2;
            return;
          }
        } else {
          c2 = Ij(c2, b);
          if (null !== c2) {
            c2.flags &= 32767;
            Y = c2;
            return;
          }
          if (null !== a2) a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
          else {
            T = 6;
            Y = null;
            return;
          }
        }
        b = b.sibling;
        if (null !== b) {
          Y = b;
          return;
        }
        Y = b = a2;
      } while (null !== b);
      0 === T && (T = 5);
    }
    function Pk(a2, b, c2) {
      var d = C, e = ok.transition;
      try {
        ok.transition = null, C = 1, Wk(a2, b, c2, d);
      } finally {
        ok.transition = e, C = d;
      }
      return null;
    }
    function Wk(a2, b, c2, d) {
      do
        Hk();
      while (null !== wk);
      if (0 !== (K & 6)) throw Error(p(327));
      c2 = a2.finishedWork;
      var e = a2.finishedLanes;
      if (null === c2) return null;
      a2.finishedWork = null;
      a2.finishedLanes = 0;
      if (c2 === a2.current) throw Error(p(177));
      a2.callbackNode = null;
      a2.callbackPriority = 0;
      var f2 = c2.lanes | c2.childLanes;
      Bc(a2, f2);
      a2 === Q && (Y = Q = null, Z = 0);
      0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || vk || (vk = true, Fk(hc, function() {
        Hk();
        return null;
      }));
      f2 = 0 !== (c2.flags & 15990);
      if (0 !== (c2.subtreeFlags & 15990) || f2) {
        f2 = ok.transition;
        ok.transition = null;
        var g = C;
        C = 1;
        var h = K;
        K |= 4;
        nk.current = null;
        Oj(a2, c2);
        dk(c2, a2);
        Oe(Df);
        dd = !!Cf;
        Df = Cf = null;
        a2.current = c2;
        hk(c2);
        dc();
        K = h;
        C = g;
        ok.transition = f2;
      } else a2.current = c2;
      vk && (vk = false, wk = a2, xk = e);
      f2 = a2.pendingLanes;
      0 === f2 && (Ri = null);
      mc(c2.stateNode);
      Dk(a2, B());
      if (null !== b) for (d = a2.onRecoverableError, c2 = 0; c2 < b.length; c2++) e = b[c2], d(e.value, { componentStack: e.stack, digest: e.digest });
      if (Oi) throw Oi = false, a2 = Pi, Pi = null, a2;
      0 !== (xk & 1) && 0 !== a2.tag && Hk();
      f2 = a2.pendingLanes;
      0 !== (f2 & 1) ? a2 === zk ? yk++ : (yk = 0, zk = a2) : yk = 0;
      jg();
      return null;
    }
    function Hk() {
      if (null !== wk) {
        var a2 = Dc(xk), b = ok.transition, c2 = C;
        try {
          ok.transition = null;
          C = 16 > a2 ? 16 : a2;
          if (null === wk) var d = false;
          else {
            a2 = wk;
            wk = null;
            xk = 0;
            if (0 !== (K & 6)) throw Error(p(331));
            var e = K;
            K |= 4;
            for (V = a2.current; null !== V; ) {
              var f2 = V, g = f2.child;
              if (0 !== (V.flags & 16)) {
                var h = f2.deletions;
                if (null !== h) {
                  for (var k2 = 0; k2 < h.length; k2++) {
                    var l2 = h[k2];
                    for (V = l2; null !== V; ) {
                      var m2 = V;
                      switch (m2.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Pj(8, m2, f2);
                      }
                      var q2 = m2.child;
                      if (null !== q2) q2.return = m2, V = q2;
                      else for (; null !== V; ) {
                        m2 = V;
                        var r2 = m2.sibling, y2 = m2.return;
                        Sj(m2);
                        if (m2 === l2) {
                          V = null;
                          break;
                        }
                        if (null !== r2) {
                          r2.return = y2;
                          V = r2;
                          break;
                        }
                        V = y2;
                      }
                    }
                  }
                  var n2 = f2.alternate;
                  if (null !== n2) {
                    var t2 = n2.child;
                    if (null !== t2) {
                      n2.child = null;
                      do {
                        var J2 = t2.sibling;
                        t2.sibling = null;
                        t2 = J2;
                      } while (null !== t2);
                    }
                  }
                  V = f2;
                }
              }
              if (0 !== (f2.subtreeFlags & 2064) && null !== g) g.return = f2, V = g;
              else b: for (; null !== V; ) {
                f2 = V;
                if (0 !== (f2.flags & 2048)) switch (f2.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Pj(9, f2, f2.return);
                }
                var x2 = f2.sibling;
                if (null !== x2) {
                  x2.return = f2.return;
                  V = x2;
                  break b;
                }
                V = f2.return;
              }
            }
            var w2 = a2.current;
            for (V = w2; null !== V; ) {
              g = V;
              var u2 = g.child;
              if (0 !== (g.subtreeFlags & 2064) && null !== u2) u2.return = g, V = u2;
              else b: for (g = w2; null !== V; ) {
                h = V;
                if (0 !== (h.flags & 2048)) try {
                  switch (h.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, h);
                  }
                } catch (na) {
                  W(h, h.return, na);
                }
                if (h === g) {
                  V = null;
                  break b;
                }
                var F2 = h.sibling;
                if (null !== F2) {
                  F2.return = h.return;
                  V = F2;
                  break b;
                }
                V = h.return;
              }
            }
            K = e;
            jg();
            if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
              lc.onPostCommitFiberRoot(kc, a2);
            } catch (na) {
            }
            d = true;
          }
          return d;
        } finally {
          C = c2, ok.transition = b;
        }
      }
      return false;
    }
    function Xk(a2, b, c2) {
      b = Ji(c2, b);
      b = Ni(a2, b, 1);
      a2 = nh(a2, b, 1);
      b = R();
      null !== a2 && (Ac(a2, 1, b), Dk(a2, b));
    }
    function W(a2, b, c2) {
      if (3 === a2.tag) Xk(a2, a2, c2);
      else for (; null !== b; ) {
        if (3 === b.tag) {
          Xk(b, a2, c2);
          break;
        } else if (1 === b.tag) {
          var d = b.stateNode;
          if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ri || !Ri.has(d))) {
            a2 = Ji(c2, a2);
            a2 = Qi(b, a2, 1);
            b = nh(b, a2, 1);
            a2 = R();
            null !== b && (Ac(b, 1, a2), Dk(b, a2));
            break;
          }
        }
        b = b.return;
      }
    }
    function Ti(a2, b, c2) {
      var d = a2.pingCache;
      null !== d && d.delete(b);
      b = R();
      a2.pingedLanes |= a2.suspendedLanes & c2;
      Q === a2 && (Z & c2) === c2 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a2, 0) : rk |= c2);
      Dk(a2, b);
    }
    function Yk(a2, b) {
      0 === b && (0 === (a2.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
      var c2 = R();
      a2 = ih(a2, b);
      null !== a2 && (Ac(a2, b, c2), Dk(a2, c2));
    }
    function uj(a2) {
      var b = a2.memoizedState, c2 = 0;
      null !== b && (c2 = b.retryLane);
      Yk(a2, c2);
    }
    function bk(a2, b) {
      var c2 = 0;
      switch (a2.tag) {
        case 13:
          var d = a2.stateNode;
          var e = a2.memoizedState;
          null !== e && (c2 = e.retryLane);
          break;
        case 19:
          d = a2.stateNode;
          break;
        default:
          throw Error(p(314));
      }
      null !== d && d.delete(b);
      Yk(a2, c2);
    }
    var Vk;
    Vk = function(a2, b, c2) {
      if (null !== a2) if (a2.memoizedProps !== b.pendingProps || Wf.current) dh = true;
      else {
        if (0 === (a2.lanes & c2) && 0 === (b.flags & 128)) return dh = false, yj(a2, b, c2);
        dh = 0 !== (a2.flags & 131072) ? true : false;
      }
      else dh = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
      b.lanes = 0;
      switch (b.tag) {
        case 2:
          var d = b.type;
          ij(a2, b);
          a2 = b.pendingProps;
          var e = Yf(b, H.current);
          ch(b, c2);
          e = Nh(null, b, d, a2, e, c2);
          var f2 = Sh();
          b.flags |= 1;
          "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f2 = true, cg(b)) : f2 = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, kh(b), e.updater = Ei, b.stateNode = e, e._reactInternals = b, Ii(b, d, a2, c2), b = jj(null, b, d, true, f2, c2)) : (b.tag = 0, I && f2 && vg(b), Xi(null, b, e, c2), b = b.child);
          return b;
        case 16:
          d = b.elementType;
          a: {
            ij(a2, b);
            a2 = b.pendingProps;
            e = d._init;
            d = e(d._payload);
            b.type = d;
            e = b.tag = Zk(d);
            a2 = Ci(d, a2);
            switch (e) {
              case 0:
                b = cj(null, b, d, a2, c2);
                break a;
              case 1:
                b = hj(null, b, d, a2, c2);
                break a;
              case 11:
                b = Yi(null, b, d, a2, c2);
                break a;
              case 14:
                b = $i(null, b, d, Ci(d.type, a2), c2);
                break a;
            }
            throw Error(p(
              306,
              d,
              ""
            ));
          }
          return b;
        case 0:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), cj(a2, b, d, e, c2);
        case 1:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), hj(a2, b, d, e, c2);
        case 3:
          a: {
            kj(b);
            if (null === a2) throw Error(p(387));
            d = b.pendingProps;
            f2 = b.memoizedState;
            e = f2.element;
            lh(a2, b);
            qh(b, d, null, c2);
            var g = b.memoizedState;
            d = g.element;
            if (f2.isDehydrated) if (f2 = { element: d, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f2, b.memoizedState = f2, b.flags & 256) {
              e = Ji(Error(p(423)), b);
              b = lj(a2, b, d, c2, e);
              break a;
            } else if (d !== e) {
              e = Ji(Error(p(424)), b);
              b = lj(a2, b, d, c2, e);
              break a;
            } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c2 = Vg(b, null, d, c2), b.child = c2; c2; ) c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
            else {
              Ig();
              if (d === e) {
                b = Zi(a2, b, c2);
                break a;
              }
              Xi(a2, b, d, c2);
            }
            b = b.child;
          }
          return b;
        case 5:
          return Ah(b), null === a2 && Eg(b), d = b.type, e = b.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f2 && Ef(d, f2) && (b.flags |= 32), gj(a2, b), Xi(a2, b, g, c2), b.child;
        case 6:
          return null === a2 && Eg(b), null;
        case 13:
          return oj(a2, b, c2);
        case 4:
          return yh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a2 ? b.child = Ug(b, null, d, c2) : Xi(a2, b, d, c2), b.child;
        case 11:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), Yi(a2, b, d, e, c2);
        case 7:
          return Xi(a2, b, b.pendingProps, c2), b.child;
        case 8:
          return Xi(a2, b, b.pendingProps.children, c2), b.child;
        case 12:
          return Xi(a2, b, b.pendingProps.children, c2), b.child;
        case 10:
          a: {
            d = b.type._context;
            e = b.pendingProps;
            f2 = b.memoizedProps;
            g = e.value;
            G(Wg, d._currentValue);
            d._currentValue = g;
            if (null !== f2) if (He(f2.value, g)) {
              if (f2.children === e.children && !Wf.current) {
                b = Zi(a2, b, c2);
                break a;
              }
            } else for (f2 = b.child, null !== f2 && (f2.return = b); null !== f2; ) {
              var h = f2.dependencies;
              if (null !== h) {
                g = f2.child;
                for (var k2 = h.firstContext; null !== k2; ) {
                  if (k2.context === d) {
                    if (1 === f2.tag) {
                      k2 = mh(-1, c2 & -c2);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c2;
                    k2 = f2.alternate;
                    null !== k2 && (k2.lanes |= c2);
                    bh(
                      f2.return,
                      c2,
                      b
                    );
                    h.lanes |= c2;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (10 === f2.tag) g = f2.type === b.type ? null : f2.child;
              else if (18 === f2.tag) {
                g = f2.return;
                if (null === g) throw Error(p(341));
                g.lanes |= c2;
                h = g.alternate;
                null !== h && (h.lanes |= c2);
                bh(g, c2, b);
                g = f2.sibling;
              } else g = f2.child;
              if (null !== g) g.return = f2;
              else for (g = f2; null !== g; ) {
                if (g === b) {
                  g = null;
                  break;
                }
                f2 = g.sibling;
                if (null !== f2) {
                  f2.return = g.return;
                  g = f2;
                  break;
                }
                g = g.return;
              }
              f2 = g;
            }
            Xi(a2, b, e.children, c2);
            b = b.child;
          }
          return b;
        case 9:
          return e = b.type, d = b.pendingProps.children, ch(b, c2), e = eh(e), d = d(e), b.flags |= 1, Xi(a2, b, d, c2), b.child;
        case 14:
          return d = b.type, e = Ci(d, b.pendingProps), e = Ci(d.type, e), $i(a2, b, d, e, c2);
        case 15:
          return bj(a2, b, b.type, b.pendingProps, c2);
        case 17:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), ij(a2, b), b.tag = 1, Zf(d) ? (a2 = true, cg(b)) : a2 = false, ch(b, c2), Gi(b, d, e), Ii(b, d, e, c2), jj(null, b, d, true, a2, c2);
        case 19:
          return xj(a2, b, c2);
        case 22:
          return dj(a2, b, c2);
      }
      throw Error(p(156, b.tag));
    };
    function Fk(a2, b) {
      return ac(a2, b);
    }
    function $k(a2, b, c2, d) {
      this.tag = a2;
      this.key = c2;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = d;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function Bg(a2, b, c2, d) {
      return new $k(a2, b, c2, d);
    }
    function aj(a2) {
      a2 = a2.prototype;
      return !(!a2 || !a2.isReactComponent);
    }
    function Zk(a2) {
      if ("function" === typeof a2) return aj(a2) ? 1 : 0;
      if (void 0 !== a2 && null !== a2) {
        a2 = a2.$$typeof;
        if (a2 === Da) return 11;
        if (a2 === Ga) return 14;
      }
      return 2;
    }
    function Pg(a2, b) {
      var c2 = a2.alternate;
      null === c2 ? (c2 = Bg(a2.tag, b, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
      c2.flags = a2.flags & 14680064;
      c2.childLanes = a2.childLanes;
      c2.lanes = a2.lanes;
      c2.child = a2.child;
      c2.memoizedProps = a2.memoizedProps;
      c2.memoizedState = a2.memoizedState;
      c2.updateQueue = a2.updateQueue;
      b = a2.dependencies;
      c2.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
      c2.sibling = a2.sibling;
      c2.index = a2.index;
      c2.ref = a2.ref;
      return c2;
    }
    function Rg(a2, b, c2, d, e, f2) {
      var g = 2;
      d = a2;
      if ("function" === typeof a2) aj(a2) && (g = 1);
      else if ("string" === typeof a2) g = 5;
      else a: switch (a2) {
        case ya:
          return Tg(c2.children, e, f2, b);
        case za:
          g = 8;
          e |= 8;
          break;
        case Aa:
          return a2 = Bg(12, c2, b, e | 2), a2.elementType = Aa, a2.lanes = f2, a2;
        case Ea:
          return a2 = Bg(13, c2, b, e), a2.elementType = Ea, a2.lanes = f2, a2;
        case Fa:
          return a2 = Bg(19, c2, b, e), a2.elementType = Fa, a2.lanes = f2, a2;
        case Ia:
          return pj(c2, e, f2, b);
        default:
          if ("object" === typeof a2 && null !== a2) switch (a2.$$typeof) {
            case Ba:
              g = 10;
              break a;
            case Ca:
              g = 9;
              break a;
            case Da:
              g = 11;
              break a;
            case Ga:
              g = 14;
              break a;
            case Ha:
              g = 16;
              d = null;
              break a;
          }
          throw Error(p(130, null == a2 ? a2 : typeof a2, ""));
      }
      b = Bg(g, c2, b, e);
      b.elementType = a2;
      b.type = d;
      b.lanes = f2;
      return b;
    }
    function Tg(a2, b, c2, d) {
      a2 = Bg(7, a2, d, b);
      a2.lanes = c2;
      return a2;
    }
    function pj(a2, b, c2, d) {
      a2 = Bg(22, a2, d, b);
      a2.elementType = Ia;
      a2.lanes = c2;
      a2.stateNode = { isHidden: false };
      return a2;
    }
    function Qg(a2, b, c2) {
      a2 = Bg(6, a2, null, b);
      a2.lanes = c2;
      return a2;
    }
    function Sg(a2, b, c2) {
      b = Bg(4, null !== a2.children ? a2.children : [], a2.key, b);
      b.lanes = c2;
      b.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
      return b;
    }
    function al(a2, b, c2, d, e) {
      this.tag = b;
      this.containerInfo = a2;
      this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.callbackNode = this.pendingContext = this.context = null;
      this.callbackPriority = 0;
      this.eventTimes = zc(0);
      this.expirationTimes = zc(-1);
      this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = zc(0);
      this.identifierPrefix = d;
      this.onRecoverableError = e;
      this.mutableSourceEagerHydrationData = null;
    }
    function bl(a2, b, c2, d, e, f2, g, h, k2) {
      a2 = new al(a2, b, c2, h, k2);
      1 === b ? (b = 1, true === f2 && (b |= 8)) : b = 0;
      f2 = Bg(3, null, null, b);
      a2.current = f2;
      f2.stateNode = a2;
      f2.memoizedState = { element: d, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
      kh(f2);
      return a2;
    }
    function cl(a2, b, c2) {
      var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return { $$typeof: wa, key: null == d ? null : "" + d, children: a2, containerInfo: b, implementation: c2 };
    }
    function dl(a2) {
      if (!a2) return Vf;
      a2 = a2._reactInternals;
      a: {
        if (Vb(a2) !== a2 || 1 !== a2.tag) throw Error(p(170));
        var b = a2;
        do {
          switch (b.tag) {
            case 3:
              b = b.stateNode.context;
              break a;
            case 1:
              if (Zf(b.type)) {
                b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                break a;
              }
          }
          b = b.return;
        } while (null !== b);
        throw Error(p(171));
      }
      if (1 === a2.tag) {
        var c2 = a2.type;
        if (Zf(c2)) return bg(a2, c2, b);
      }
      return b;
    }
    function el(a2, b, c2, d, e, f2, g, h, k2) {
      a2 = bl(c2, d, true, a2, e, f2, g, h, k2);
      a2.context = dl(null);
      c2 = a2.current;
      d = R();
      e = yi(c2);
      f2 = mh(d, e);
      f2.callback = void 0 !== b && null !== b ? b : null;
      nh(c2, f2, e);
      a2.current.lanes = e;
      Ac(a2, e, d);
      Dk(a2, d);
      return a2;
    }
    function fl(a2, b, c2, d) {
      var e = b.current, f2 = R(), g = yi(e);
      c2 = dl(c2);
      null === b.context ? b.context = c2 : b.pendingContext = c2;
      b = mh(f2, g);
      b.payload = { element: a2 };
      d = void 0 === d ? null : d;
      null !== d && (b.callback = d);
      a2 = nh(e, b, g);
      null !== a2 && (gi(a2, e, g, f2), oh(a2, e, g));
      return g;
    }
    function gl(a2) {
      a2 = a2.current;
      if (!a2.child) return null;
      switch (a2.child.tag) {
        case 5:
          return a2.child.stateNode;
        default:
          return a2.child.stateNode;
      }
    }
    function hl(a2, b) {
      a2 = a2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        var c2 = a2.retryLane;
        a2.retryLane = 0 !== c2 && c2 < b ? c2 : b;
      }
    }
    function il(a2, b) {
      hl(a2, b);
      (a2 = a2.alternate) && hl(a2, b);
    }
    function jl() {
      return null;
    }
    var kl = "function" === typeof reportError ? reportError : function(a2) {
      console.error(a2);
    };
    function ll(a2) {
      this._internalRoot = a2;
    }
    ml.prototype.render = ll.prototype.render = function(a2) {
      var b = this._internalRoot;
      if (null === b) throw Error(p(409));
      fl(a2, b, null, null);
    };
    ml.prototype.unmount = ll.prototype.unmount = function() {
      var a2 = this._internalRoot;
      if (null !== a2) {
        this._internalRoot = null;
        var b = a2.containerInfo;
        Rk(function() {
          fl(null, a2, null, null);
        });
        b[uf] = null;
      }
    };
    function ml(a2) {
      this._internalRoot = a2;
    }
    ml.prototype.unstable_scheduleHydration = function(a2) {
      if (a2) {
        var b = Hc();
        a2 = { blockedOn: null, target: a2, priority: b };
        for (var c2 = 0; c2 < Qc.length && 0 !== b && b < Qc[c2].priority; c2++) ;
        Qc.splice(c2, 0, a2);
        0 === c2 && Vc(a2);
      }
    };
    function nl(a2) {
      return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
    }
    function ol(a2) {
      return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
    }
    function pl() {
    }
    function ql(a2, b, c2, d, e) {
      if (e) {
        if ("function" === typeof d) {
          var f2 = d;
          d = function() {
            var a3 = gl(g);
            f2.call(a3);
          };
        }
        var g = el(b, d, a2, 0, null, false, false, "", pl);
        a2._reactRootContainer = g;
        a2[uf] = g.current;
        sf(8 === a2.nodeType ? a2.parentNode : a2);
        Rk();
        return g;
      }
      for (; e = a2.lastChild; ) a2.removeChild(e);
      if ("function" === typeof d) {
        var h = d;
        d = function() {
          var a3 = gl(k2);
          h.call(a3);
        };
      }
      var k2 = bl(a2, 0, false, null, null, false, false, "", pl);
      a2._reactRootContainer = k2;
      a2[uf] = k2.current;
      sf(8 === a2.nodeType ? a2.parentNode : a2);
      Rk(function() {
        fl(b, k2, c2, d);
      });
      return k2;
    }
    function rl(a2, b, c2, d, e) {
      var f2 = c2._reactRootContainer;
      if (f2) {
        var g = f2;
        if ("function" === typeof e) {
          var h = e;
          e = function() {
            var a3 = gl(g);
            h.call(a3);
          };
        }
        fl(b, g, a2, e);
      } else g = ql(c2, b, a2, e, d);
      return gl(g);
    }
    Ec = function(a2) {
      switch (a2.tag) {
        case 3:
          var b = a2.stateNode;
          if (b.current.memoizedState.isDehydrated) {
            var c2 = tc(b.pendingLanes);
            0 !== c2 && (Cc(b, c2 | 1), Dk(b, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
          }
          break;
        case 13:
          Rk(function() {
            var b2 = ih(a2, 1);
            if (null !== b2) {
              var c3 = R();
              gi(b2, a2, 1, c3);
            }
          }), il(a2, 1);
      }
    };
    Fc = function(a2) {
      if (13 === a2.tag) {
        var b = ih(a2, 134217728);
        if (null !== b) {
          var c2 = R();
          gi(b, a2, 134217728, c2);
        }
        il(a2, 134217728);
      }
    };
    Gc = function(a2) {
      if (13 === a2.tag) {
        var b = yi(a2), c2 = ih(a2, b);
        if (null !== c2) {
          var d = R();
          gi(c2, a2, b, d);
        }
        il(a2, b);
      }
    };
    Hc = function() {
      return C;
    };
    Ic = function(a2, b) {
      var c2 = C;
      try {
        return C = a2, b();
      } finally {
        C = c2;
      }
    };
    yb = function(a2, b, c2) {
      switch (b) {
        case "input":
          bb(a2, c2);
          b = c2.name;
          if ("radio" === c2.type && null != b) {
            for (c2 = a2; c2.parentNode; ) c2 = c2.parentNode;
            c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
            for (b = 0; b < c2.length; b++) {
              var d = c2[b];
              if (d !== a2 && d.form === a2.form) {
                var e = Db(d);
                if (!e) throw Error(p(90));
                Wa(d);
                bb(d, e);
              }
            }
          }
          break;
        case "textarea":
          ib(a2, c2);
          break;
        case "select":
          b = c2.value, null != b && fb(a2, !!c2.multiple, b, false);
      }
    };
    Gb = Qk;
    Hb = Rk;
    var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
    var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
      a2 = Zb(a2);
      return null === a2 ? null : a2.stateNode;
    }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!vl.isDisabled && vl.supportsFiber) try {
        kc = vl.inject(ul), lc = vl;
      } catch (a2) {
      }
    }
    reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
    reactDom_production_min.createPortal = function(a2, b) {
      var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!nl(b)) throw Error(p(200));
      return cl(a2, b, null, c2);
    };
    reactDom_production_min.createRoot = function(a2, b) {
      if (!nl(a2)) throw Error(p(299));
      var c2 = false, d = "", e = kl;
      null !== b && void 0 !== b && (true === b.unstable_strictMode && (c2 = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
      b = bl(a2, 1, false, null, null, c2, false, d, e);
      a2[uf] = b.current;
      sf(8 === a2.nodeType ? a2.parentNode : a2);
      return new ll(b);
    };
    reactDom_production_min.findDOMNode = function(a2) {
      if (null == a2) return null;
      if (1 === a2.nodeType) return a2;
      var b = a2._reactInternals;
      if (void 0 === b) {
        if ("function" === typeof a2.render) throw Error(p(188));
        a2 = Object.keys(a2).join(",");
        throw Error(p(268, a2));
      }
      a2 = Zb(b);
      a2 = null === a2 ? null : a2.stateNode;
      return a2;
    };
    reactDom_production_min.flushSync = function(a2) {
      return Rk(a2);
    };
    reactDom_production_min.hydrate = function(a2, b, c2) {
      if (!ol(b)) throw Error(p(200));
      return rl(null, a2, b, true, c2);
    };
    reactDom_production_min.hydrateRoot = function(a2, b, c2) {
      if (!nl(a2)) throw Error(p(405));
      var d = null != c2 && c2.hydratedSources || null, e = false, f2 = "", g = kl;
      null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g = c2.onRecoverableError));
      b = el(b, null, a2, 1, null != c2 ? c2 : null, e, false, f2, g);
      a2[uf] = b.current;
      sf(a2);
      if (d) for (a2 = 0; a2 < d.length; a2++) c2 = d[a2], e = c2._getVersion, e = e(c2._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c2, e] : b.mutableSourceEagerHydrationData.push(
        c2,
        e
      );
      return new ml(b);
    };
    reactDom_production_min.render = function(a2, b, c2) {
      if (!ol(b)) throw Error(p(200));
      return rl(null, a2, b, false, c2);
    };
    reactDom_production_min.unmountComponentAtNode = function(a2) {
      if (!ol(a2)) throw Error(p(40));
      return a2._reactRootContainer ? (Rk(function() {
        rl(null, null, a2, false, function() {
          a2._reactRootContainer = null;
          a2[uf] = null;
        });
      }), true) : false;
    };
    reactDom_production_min.unstable_batchedUpdates = Qk;
    reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b, c2, d) {
      if (!ol(c2)) throw Error(p(200));
      if (null == a2 || void 0 === a2._reactInternals) throw Error(p(38));
      return rl(a2, b, c2, false, d);
    };
    reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        console.error(err);
      }
    }
    {
      checkDCE();
      reactDom.exports = reactDom_production_min;
    }
    var reactDomExports = reactDom.exports;
    var m = reactDomExports;
    {
      client.createRoot = m.createRoot;
      client.hydrateRoot = m.hydrateRoot;
    }
    /**
     * @remix-run/router v1.23.1
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    function _extends$y() {
      _extends$y = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$y.apply(this, arguments);
    }
    var Action;
    (function(Action2) {
      Action2["Pop"] = "POP";
      Action2["Push"] = "PUSH";
      Action2["Replace"] = "REPLACE";
    })(Action || (Action = {}));
    const PopStateEventType = "popstate";
    function createHashHistory(options) {
      if (options === void 0) {
        options = {};
      }
      function createHashLocation(window2, globalHistory) {
        let {
          pathname = "/",
          search = "",
          hash = ""
        } = parsePath(window2.location.hash.substr(1));
        if (!pathname.startsWith("/") && !pathname.startsWith(".")) {
          pathname = "/" + pathname;
        }
        return createLocation(
          "",
          {
            pathname,
            search,
            hash
          },
          // state defaults to `null` because `window.history.state` does
          globalHistory.state && globalHistory.state.usr || null,
          globalHistory.state && globalHistory.state.key || "default"
        );
      }
      function createHashHref(window2, to2) {
        let base = window2.document.querySelector("base");
        let href = "";
        if (base && base.getAttribute("href")) {
          let url = window2.location.href;
          let hashIndex = url.indexOf("#");
          href = hashIndex === -1 ? url : url.slice(0, hashIndex);
        }
        return href + "#" + (typeof to2 === "string" ? to2 : createPath(to2));
      }
      function validateHashLocation(location, to2) {
        warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to2) + ")");
      }
      return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
    }
    function invariant$1(value, message) {
      if (value === false || value === null || typeof value === "undefined") {
        throw new Error(message);
      }
    }
    function warning(cond, message) {
      if (!cond) {
        if (typeof console !== "undefined") console.warn(message);
        try {
          throw new Error(message);
        } catch (e) {
        }
      }
    }
    function createKey() {
      return Math.random().toString(36).substr(2, 8);
    }
    function getHistoryState(location, index) {
      return {
        usr: location.state,
        key: location.key,
        idx: index
      };
    }
    function createLocation(current2, to2, state, key) {
      if (state === void 0) {
        state = null;
      }
      let location = _extends$y({
        pathname: typeof current2 === "string" ? current2 : current2.pathname,
        search: "",
        hash: ""
      }, typeof to2 === "string" ? parsePath(to2) : to2, {
        state,
        // TODO: This could be cleaned up.  push/replace should probably just take
        // full Locations now and avoid the need to run through this flow at all
        // But that's a pretty big refactor to the current test suite so going to
        // keep as is for the time being and just let any incoming keys take precedence
        key: to2 && to2.key || key || createKey()
      });
      return location;
    }
    function createPath(_ref2) {
      let {
        pathname = "/",
        search = "",
        hash = ""
      } = _ref2;
      if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
      if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
      return pathname;
    }
    function parsePath(path) {
      let parsedPath = {};
      if (path) {
        let hashIndex = path.indexOf("#");
        if (hashIndex >= 0) {
          parsedPath.hash = path.substr(hashIndex);
          path = path.substr(0, hashIndex);
        }
        let searchIndex = path.indexOf("?");
        if (searchIndex >= 0) {
          parsedPath.search = path.substr(searchIndex);
          path = path.substr(0, searchIndex);
        }
        if (path) {
          parsedPath.pathname = path;
        }
      }
      return parsedPath;
    }
    function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
      if (options === void 0) {
        options = {};
      }
      let {
        window: window2 = document.defaultView,
        v5Compat = false
      } = options;
      let globalHistory = window2.history;
      let action = Action.Pop;
      let listener2 = null;
      let index = getIndex();
      if (index == null) {
        index = 0;
        globalHistory.replaceState(_extends$y({}, globalHistory.state, {
          idx: index
        }), "");
      }
      function getIndex() {
        let state = globalHistory.state || {
          idx: null
        };
        return state.idx;
      }
      function handlePop() {
        action = Action.Pop;
        let nextIndex = getIndex();
        let delta = nextIndex == null ? null : nextIndex - index;
        index = nextIndex;
        if (listener2) {
          listener2({
            action,
            location: history.location,
            delta
          });
        }
      }
      function push(to2, state) {
        action = Action.Push;
        let location = createLocation(history.location, to2, state);
        if (validateLocation) validateLocation(location, to2);
        index = getIndex() + 1;
        let historyState = getHistoryState(location, index);
        let url = history.createHref(location);
        try {
          globalHistory.pushState(historyState, "", url);
        } catch (error) {
          if (error instanceof DOMException && error.name === "DataCloneError") {
            throw error;
          }
          window2.location.assign(url);
        }
        if (v5Compat && listener2) {
          listener2({
            action,
            location: history.location,
            delta: 1
          });
        }
      }
      function replace(to2, state) {
        action = Action.Replace;
        let location = createLocation(history.location, to2, state);
        if (validateLocation) validateLocation(location, to2);
        index = getIndex();
        let historyState = getHistoryState(location, index);
        let url = history.createHref(location);
        globalHistory.replaceState(historyState, "", url);
        if (v5Compat && listener2) {
          listener2({
            action,
            location: history.location,
            delta: 0
          });
        }
      }
      function createURL(to2) {
        let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
        let href = typeof to2 === "string" ? to2 : createPath(to2);
        href = href.replace(/ $/, "%20");
        invariant$1(base, "No window.location.(origin|href) available to create URL for href: " + href);
        return new URL(href, base);
      }
      let history = {
        get action() {
          return action;
        },
        get location() {
          return getLocation(window2, globalHistory);
        },
        listen(fn) {
          if (listener2) {
            throw new Error("A history only accepts one active listener");
          }
          window2.addEventListener(PopStateEventType, handlePop);
          listener2 = fn;
          return () => {
            window2.removeEventListener(PopStateEventType, handlePop);
            listener2 = null;
          };
        },
        createHref(to2) {
          return createHref(window2, to2);
        },
        createURL,
        encodeLocation(to2) {
          let url = createURL(to2);
          return {
            pathname: url.pathname,
            search: url.search,
            hash: url.hash
          };
        },
        push,
        replace,
        go(n2) {
          return globalHistory.go(n2);
        }
      };
      return history;
    }
    var ResultType;
    (function(ResultType2) {
      ResultType2["data"] = "data";
      ResultType2["deferred"] = "deferred";
      ResultType2["redirect"] = "redirect";
      ResultType2["error"] = "error";
    })(ResultType || (ResultType = {}));
    function matchRoutes(routes, locationArg, basename) {
      if (basename === void 0) {
        basename = "/";
      }
      return matchRoutesImpl(routes, locationArg, basename);
    }
    function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
      let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
      let pathname = stripBasename(location.pathname || "/", basename);
      if (pathname == null) {
        return null;
      }
      let branches = flattenRoutes(routes);
      rankRouteBranches(branches);
      let matches2 = null;
      for (let i = 0; matches2 == null && i < branches.length; ++i) {
        let decoded = decodePath(pathname);
        matches2 = matchRouteBranch(branches[i], decoded);
      }
      return matches2;
    }
    function flattenRoutes(routes, branches, parentsMeta, parentPath) {
      if (branches === void 0) {
        branches = [];
      }
      if (parentsMeta === void 0) {
        parentsMeta = [];
      }
      if (parentPath === void 0) {
        parentPath = "";
      }
      let flattenRoute = (route, index, relativePath) => {
        let meta = {
          relativePath: relativePath === void 0 ? route.path || "" : relativePath,
          caseSensitive: route.caseSensitive === true,
          childrenIndex: index,
          route
        };
        if (meta.relativePath.startsWith("/")) {
          invariant$1(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
          meta.relativePath = meta.relativePath.slice(parentPath.length);
        }
        let path = joinPaths([parentPath, meta.relativePath]);
        let routesMeta = parentsMeta.concat(meta);
        if (route.children && route.children.length > 0) {
          invariant$1(
            // Our types know better, but runtime JS may not!
            // @ts-expect-error
            route.index !== true,
            "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
          );
          flattenRoutes(route.children, branches, routesMeta, path);
        }
        if (route.path == null && !route.index) {
          return;
        }
        branches.push({
          path,
          score: computeScore(path, route.index),
          routesMeta
        });
      };
      routes.forEach((route, index) => {
        var _route$path;
        if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
          flattenRoute(route, index);
        } else {
          for (let exploded of explodeOptionalSegments(route.path)) {
            flattenRoute(route, index, exploded);
          }
        }
      });
      return branches;
    }
    function explodeOptionalSegments(path) {
      let segments = path.split("/");
      if (segments.length === 0) return [];
      let [first, ...rest] = segments;
      let isOptional = first.endsWith("?");
      let required = first.replace(/\?$/, "");
      if (rest.length === 0) {
        return isOptional ? [required, ""] : [required];
      }
      let restExploded = explodeOptionalSegments(rest.join("/"));
      let result = [];
      result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
      if (isOptional) {
        result.push(...restExploded);
      }
      return result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
    }
    function rankRouteBranches(branches) {
      branches.sort((a2, b) => a2.score !== b.score ? b.score - a2.score : compareIndexes(a2.routesMeta.map((meta) => meta.childrenIndex), b.routesMeta.map((meta) => meta.childrenIndex)));
    }
    const paramRe = /^:[\w-]+$/;
    const dynamicSegmentValue = 3;
    const indexRouteValue = 2;
    const emptySegmentValue = 1;
    const staticSegmentValue = 10;
    const splatPenalty = -2;
    const isSplat = (s2) => s2 === "*";
    function computeScore(path, index) {
      let segments = path.split("/");
      let initialScore = segments.length;
      if (segments.some(isSplat)) {
        initialScore += splatPenalty;
      }
      if (index) {
        initialScore += indexRouteValue;
      }
      return segments.filter((s2) => !isSplat(s2)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
    }
    function compareIndexes(a2, b) {
      let siblings = a2.length === b.length && a2.slice(0, -1).every((n2, i) => n2 === b[i]);
      return siblings ? (
        // If two routes are siblings, we should try to match the earlier sibling
        // first. This allows people to have fine-grained control over the matching
        // behavior by simply putting routes with identical paths in the order they
        // want them tried.
        a2[a2.length - 1] - b[b.length - 1]
      ) : (
        // Otherwise, it doesn't really make sense to rank non-siblings by index,
        // so they sort equally.
        0
      );
    }
    function matchRouteBranch(branch, pathname, allowPartial) {
      let {
        routesMeta
      } = branch;
      let matchedParams = {};
      let matchedPathname = "/";
      let matches2 = [];
      for (let i = 0; i < routesMeta.length; ++i) {
        let meta = routesMeta[i];
        let end = i === routesMeta.length - 1;
        let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
        let match = matchPath({
          path: meta.relativePath,
          caseSensitive: meta.caseSensitive,
          end
        }, remainingPathname);
        let route = meta.route;
        if (!match) {
          return null;
        }
        Object.assign(matchedParams, match.params);
        matches2.push({
          // TODO: Can this as be avoided?
          params: matchedParams,
          pathname: joinPaths([matchedPathname, match.pathname]),
          pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
          route
        });
        if (match.pathnameBase !== "/") {
          matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
        }
      }
      return matches2;
    }
    function matchPath(pattern, pathname) {
      if (typeof pattern === "string") {
        pattern = {
          path: pattern,
          caseSensitive: false,
          end: true
        };
      }
      let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
      let match = pathname.match(matcher);
      if (!match) return null;
      let matchedPathname = match[0];
      let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
      let captureGroups = match.slice(1);
      let params = compiledParams.reduce((memo, _ref2, index) => {
        let {
          paramName,
          isOptional
        } = _ref2;
        if (paramName === "*") {
          let splatValue = captureGroups[index] || "";
          pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
        }
        const value = captureGroups[index];
        if (isOptional && !value) {
          memo[paramName] = void 0;
        } else {
          memo[paramName] = (value || "").replace(/%2F/g, "/");
        }
        return memo;
      }, {});
      return {
        params,
        pathname: matchedPathname,
        pathnameBase,
        pattern
      };
    }
    function compilePath(path, caseSensitive, end) {
      if (caseSensitive === void 0) {
        caseSensitive = false;
      }
      if (end === void 0) {
        end = true;
      }
      warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
      let params = [];
      let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (_, paramName, isOptional) => {
        params.push({
          paramName,
          isOptional: isOptional != null
        });
        return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
      });
      if (path.endsWith("*")) {
        params.push({
          paramName: "*"
        });
        regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
      } else if (end) {
        regexpSource += "\\/*$";
      } else if (path !== "" && path !== "/") {
        regexpSource += "(?:(?=\\/|$))";
      } else ;
      let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
      return [matcher, params];
    }
    function decodePath(value) {
      try {
        return value.split("/").map((v2) => decodeURIComponent(v2).replace(/\//g, "%2F")).join("/");
      } catch (error) {
        warning(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
        return value;
      }
    }
    function stripBasename(pathname, basename) {
      if (basename === "/") return pathname;
      if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
        return null;
      }
      let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
      let nextChar = pathname.charAt(startIndex);
      if (nextChar && nextChar !== "/") {
        return null;
      }
      return pathname.slice(startIndex) || "/";
    }
    const ABSOLUTE_URL_REGEX$1 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
    const isAbsoluteUrl = (url) => ABSOLUTE_URL_REGEX$1.test(url);
    function resolvePath(to2, fromPathname) {
      if (fromPathname === void 0) {
        fromPathname = "/";
      }
      let {
        pathname: toPathname,
        search = "",
        hash = ""
      } = typeof to2 === "string" ? parsePath(to2) : to2;
      let pathname;
      if (toPathname) {
        if (isAbsoluteUrl(toPathname)) {
          pathname = toPathname;
        } else {
          if (toPathname.includes("//")) {
            let oldPathname = toPathname;
            toPathname = toPathname.replace(/\/\/+/g, "/");
            warning(false, "Pathnames cannot have embedded double slashes - normalizing " + (oldPathname + " -> " + toPathname));
          }
          if (toPathname.startsWith("/")) {
            pathname = resolvePathname(toPathname.substring(1), "/");
          } else {
            pathname = resolvePathname(toPathname, fromPathname);
          }
        }
      } else {
        pathname = fromPathname;
      }
      return {
        pathname,
        search: normalizeSearch(search),
        hash: normalizeHash(hash)
      };
    }
    function resolvePathname(relativePath, fromPathname) {
      let segments = fromPathname.replace(/\/+$/, "").split("/");
      let relativeSegments = relativePath.split("/");
      relativeSegments.forEach((segment) => {
        if (segment === "..") {
          if (segments.length > 1) segments.pop();
        } else if (segment !== ".") {
          segments.push(segment);
        }
      });
      return segments.length > 1 ? segments.join("/") : "/";
    }
    function getInvalidPathError(char, field, dest, path) {
      return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
    }
    function getPathContributingMatches(matches2) {
      return matches2.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);
    }
    function getResolveToMatches(matches2, v7_relativeSplatPath) {
      let pathMatches = getPathContributingMatches(matches2);
      if (v7_relativeSplatPath) {
        return pathMatches.map((match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase);
      }
      return pathMatches.map((match) => match.pathnameBase);
    }
    function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
      if (isPathRelative === void 0) {
        isPathRelative = false;
      }
      let to2;
      if (typeof toArg === "string") {
        to2 = parsePath(toArg);
      } else {
        to2 = _extends$y({}, toArg);
        invariant$1(!to2.pathname || !to2.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to2));
        invariant$1(!to2.pathname || !to2.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to2));
        invariant$1(!to2.search || !to2.search.includes("#"), getInvalidPathError("#", "search", "hash", to2));
      }
      let isEmptyPath = toArg === "" || to2.pathname === "";
      let toPathname = isEmptyPath ? "/" : to2.pathname;
      let from2;
      if (toPathname == null) {
        from2 = locationPathname;
      } else {
        let routePathnameIndex = routePathnames.length - 1;
        if (!isPathRelative && toPathname.startsWith("..")) {
          let toSegments = toPathname.split("/");
          while (toSegments[0] === "..") {
            toSegments.shift();
            routePathnameIndex -= 1;
          }
          to2.pathname = toSegments.join("/");
        }
        from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
      }
      let path = resolvePath(to2, from2);
      let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
      let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
      if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
        path.pathname += "/";
      }
      return path;
    }
    const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
    const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
    const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
    const normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
    function isRouteErrorResponse(error) {
      return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
    }
    const validMutationMethodsArr = ["post", "put", "patch", "delete"];
    new Set(validMutationMethodsArr);
    const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
    new Set(validRequestMethodsArr);
    /**
     * React Router v6.30.2
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    function _extends$x() {
      _extends$x = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$x.apply(this, arguments);
    }
    const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
    const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
    const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
    const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
    const RouteContext = /* @__PURE__ */ reactExports.createContext({
      outlet: null,
      matches: [],
      isDataRoute: false
    });
    const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
    function useHref(to2, _temp) {
      let {
        relative
      } = _temp === void 0 ? {} : _temp;
      !useInRouterContext() ? invariant$1(false) : void 0;
      let {
        basename,
        navigator: navigator2
      } = reactExports.useContext(NavigationContext);
      let {
        hash,
        pathname,
        search
      } = useResolvedPath(to2, {
        relative
      });
      let joinedPathname = pathname;
      if (basename !== "/") {
        joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
      }
      return navigator2.createHref({
        pathname: joinedPathname,
        search,
        hash
      });
    }
    function useInRouterContext() {
      return reactExports.useContext(LocationContext) != null;
    }
    function useLocation() {
      !useInRouterContext() ? invariant$1(false) : void 0;
      return reactExports.useContext(LocationContext).location;
    }
    function useIsomorphicLayoutEffect$1(cb2) {
      let isStatic = reactExports.useContext(NavigationContext).static;
      if (!isStatic) {
        reactExports.useLayoutEffect(cb2);
      }
    }
    function useNavigate() {
      let {
        isDataRoute
      } = reactExports.useContext(RouteContext);
      return isDataRoute ? useNavigateStable() : useNavigateUnstable();
    }
    function useNavigateUnstable() {
      !useInRouterContext() ? invariant$1(false) : void 0;
      let dataRouterContext = reactExports.useContext(DataRouterContext);
      let {
        basename,
        future,
        navigator: navigator2
      } = reactExports.useContext(NavigationContext);
      let {
        matches: matches2
      } = reactExports.useContext(RouteContext);
      let {
        pathname: locationPathname
      } = useLocation();
      let routePathnamesJson = JSON.stringify(getResolveToMatches(matches2, future.v7_relativeSplatPath));
      let activeRef = reactExports.useRef(false);
      useIsomorphicLayoutEffect$1(() => {
        activeRef.current = true;
      });
      let navigate = reactExports.useCallback(function(to2, options) {
        if (options === void 0) {
          options = {};
        }
        if (!activeRef.current) return;
        if (typeof to2 === "number") {
          navigator2.go(to2);
          return;
        }
        let path = resolveTo(to2, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
        if (dataRouterContext == null && basename !== "/") {
          path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
        }
        (!!options.replace ? navigator2.replace : navigator2.push)(path, options.state, options);
      }, [basename, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
      return navigate;
    }
    const OutletContext = /* @__PURE__ */ reactExports.createContext(null);
    function useOutlet(context) {
      let outlet = reactExports.useContext(RouteContext).outlet;
      if (outlet) {
        return /* @__PURE__ */ reactExports.createElement(OutletContext.Provider, {
          value: context
        }, outlet);
      }
      return outlet;
    }
    function useParams() {
      let {
        matches: matches2
      } = reactExports.useContext(RouteContext);
      let routeMatch = matches2[matches2.length - 1];
      return routeMatch ? routeMatch.params : {};
    }
    function useResolvedPath(to2, _temp2) {
      let {
        relative
      } = _temp2 === void 0 ? {} : _temp2;
      let {
        future
      } = reactExports.useContext(NavigationContext);
      let {
        matches: matches2
      } = reactExports.useContext(RouteContext);
      let {
        pathname: locationPathname
      } = useLocation();
      let routePathnamesJson = JSON.stringify(getResolveToMatches(matches2, future.v7_relativeSplatPath));
      return reactExports.useMemo(() => resolveTo(to2, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to2, routePathnamesJson, locationPathname, relative]);
    }
    function useRoutes(routes, locationArg) {
      return useRoutesImpl(routes, locationArg);
    }
    function useRoutesImpl(routes, locationArg, dataRouterState, future) {
      !useInRouterContext() ? invariant$1(false) : void 0;
      let {
        navigator: navigator2
      } = reactExports.useContext(NavigationContext);
      let {
        matches: parentMatches
      } = reactExports.useContext(RouteContext);
      let routeMatch = parentMatches[parentMatches.length - 1];
      let parentParams = routeMatch ? routeMatch.params : {};
      routeMatch ? routeMatch.pathname : "/";
      let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
      routeMatch && routeMatch.route;
      let locationFromContext = useLocation();
      let location;
      if (locationArg) {
        var _parsedLocationArg$pa;
        let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
        !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant$1(false) : void 0;
        location = parsedLocationArg;
      } else {
        location = locationFromContext;
      }
      let pathname = location.pathname || "/";
      let remainingPathname = pathname;
      if (parentPathnameBase !== "/") {
        let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
        let segments = pathname.replace(/^\//, "").split("/");
        remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
      }
      let matches2 = matchRoutes(routes, {
        pathname: remainingPathname
      });
      let renderedMatches = _renderMatches(matches2 && matches2.map((match) => Object.assign({}, match, {
        params: Object.assign({}, parentParams, match.params),
        pathname: joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes
          navigator2.encodeLocation ? navigator2.encodeLocation(match.pathname).pathname : match.pathname
        ]),
        pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes
          navigator2.encodeLocation ? navigator2.encodeLocation(match.pathnameBase).pathname : match.pathnameBase
        ])
      })), parentMatches, dataRouterState, future);
      if (locationArg && renderedMatches) {
        return /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
          value: {
            location: _extends$x({
              pathname: "/",
              search: "",
              hash: "",
              state: null,
              key: "default"
            }, location),
            navigationType: Action.Pop
          }
        }, renderedMatches);
      }
      return renderedMatches;
    }
    function DefaultErrorComponent() {
      let error = useRouteError();
      let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
      let stack = error instanceof Error ? error.stack : null;
      let lightgrey = "rgba(200,200,200, 0.5)";
      let preStyles = {
        padding: "0.5rem",
        backgroundColor: lightgrey
      };
      let devInfo = null;
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
        style: {
          fontStyle: "italic"
        }
      }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
        style: preStyles
      }, stack) : null, devInfo);
    }
    const defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
    class RenderErrorBoundary extends reactExports.Component {
      constructor(props) {
        super(props);
        this.state = {
          location: props.location,
          revalidation: props.revalidation,
          error: props.error
        };
      }
      static getDerivedStateFromError(error) {
        return {
          error
        };
      }
      static getDerivedStateFromProps(props, state) {
        if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
          return {
            error: props.error,
            location: props.location,
            revalidation: props.revalidation
          };
        }
        return {
          error: props.error !== void 0 ? props.error : state.error,
          location: state.location,
          revalidation: props.revalidation || state.revalidation
        };
      }
      componentDidCatch(error, errorInfo) {
        console.error("React Router caught the following error during render", error, errorInfo);
      }
      render() {
        return this.state.error !== void 0 ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
          value: this.props.routeContext
        }, /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
          value: this.state.error,
          children: this.props.component
        })) : this.props.children;
      }
    }
    function RenderedRoute(_ref2) {
      let {
        routeContext,
        match,
        children
      } = _ref2;
      let dataRouterContext = reactExports.useContext(DataRouterContext);
      if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
        dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
      }
      return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
        value: routeContext
      }, children);
    }
    function _renderMatches(matches2, parentMatches, dataRouterState, future) {
      var _dataRouterState;
      if (parentMatches === void 0) {
        parentMatches = [];
      }
      if (dataRouterState === void 0) {
        dataRouterState = null;
      }
      if (future === void 0) {
        future = null;
      }
      if (matches2 == null) {
        var _future;
        if (!dataRouterState) {
          return null;
        }
        if (dataRouterState.errors) {
          matches2 = dataRouterState.matches;
        } else if ((_future = future) != null && _future.v7_partialHydration && parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
          matches2 = dataRouterState.matches;
        } else {
          return null;
        }
      }
      let renderedMatches = matches2;
      let errors = (_dataRouterState = dataRouterState) == null ? void 0 : _dataRouterState.errors;
      if (errors != null) {
        let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]) !== void 0);
        !(errorIndex >= 0) ? invariant$1(false) : void 0;
        renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
      }
      let renderFallback = false;
      let fallbackIndex = -1;
      if (dataRouterState && future && future.v7_partialHydration) {
        for (let i = 0; i < renderedMatches.length; i++) {
          let match = renderedMatches[i];
          if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
            fallbackIndex = i;
          }
          if (match.route.id) {
            let {
              loaderData,
              errors: errors2
            } = dataRouterState;
            let needsToRunLoader = match.route.loader && loaderData[match.route.id] === void 0 && (!errors2 || errors2[match.route.id] === void 0);
            if (match.route.lazy || needsToRunLoader) {
              renderFallback = true;
              if (fallbackIndex >= 0) {
                renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
              } else {
                renderedMatches = [renderedMatches[0]];
              }
              break;
            }
          }
        }
      }
      return renderedMatches.reduceRight((outlet, match, index) => {
        let error;
        let shouldRenderHydrateFallback = false;
        let errorElement = null;
        let hydrateFallbackElement = null;
        if (dataRouterState) {
          error = errors && match.route.id ? errors[match.route.id] : void 0;
          errorElement = match.route.errorElement || defaultErrorElement;
          if (renderFallback) {
            if (fallbackIndex < 0 && index === 0) {
              warningOnce("route-fallback");
              shouldRenderHydrateFallback = true;
              hydrateFallbackElement = null;
            } else if (fallbackIndex === index) {
              shouldRenderHydrateFallback = true;
              hydrateFallbackElement = match.route.hydrateFallbackElement || null;
            }
          }
        }
        let matches22 = parentMatches.concat(renderedMatches.slice(0, index + 1));
        let getChildren = () => {
          let children;
          if (error) {
            children = errorElement;
          } else if (shouldRenderHydrateFallback) {
            children = hydrateFallbackElement;
          } else if (match.route.Component) {
            children = /* @__PURE__ */ reactExports.createElement(match.route.Component, null);
          } else if (match.route.element) {
            children = match.route.element;
          } else {
            children = outlet;
          }
          return /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
            match,
            routeContext: {
              outlet,
              matches: matches22,
              isDataRoute: dataRouterState != null
            },
            children
          });
        };
        return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
          location: dataRouterState.location,
          revalidation: dataRouterState.revalidation,
          component: errorElement,
          error,
          children: getChildren(),
          routeContext: {
            outlet: null,
            matches: matches22,
            isDataRoute: true
          }
        }) : getChildren();
      }, null);
    }
    var DataRouterHook$1 = /* @__PURE__ */ function(DataRouterHook2) {
      DataRouterHook2["UseBlocker"] = "useBlocker";
      DataRouterHook2["UseRevalidator"] = "useRevalidator";
      DataRouterHook2["UseNavigateStable"] = "useNavigate";
      return DataRouterHook2;
    }(DataRouterHook$1 || {});
    var DataRouterStateHook$1 = /* @__PURE__ */ function(DataRouterStateHook2) {
      DataRouterStateHook2["UseBlocker"] = "useBlocker";
      DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
      DataRouterStateHook2["UseActionData"] = "useActionData";
      DataRouterStateHook2["UseRouteError"] = "useRouteError";
      DataRouterStateHook2["UseNavigation"] = "useNavigation";
      DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
      DataRouterStateHook2["UseMatches"] = "useMatches";
      DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
      DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
      DataRouterStateHook2["UseRouteId"] = "useRouteId";
      return DataRouterStateHook2;
    }(DataRouterStateHook$1 || {});
    function useDataRouterContext(hookName) {
      let ctx = reactExports.useContext(DataRouterContext);
      !ctx ? invariant$1(false) : void 0;
      return ctx;
    }
    function useDataRouterState(hookName) {
      let state = reactExports.useContext(DataRouterStateContext);
      !state ? invariant$1(false) : void 0;
      return state;
    }
    function useRouteContext(hookName) {
      let route = reactExports.useContext(RouteContext);
      !route ? invariant$1(false) : void 0;
      return route;
    }
    function useCurrentRouteId(hookName) {
      let route = useRouteContext();
      let thisRoute = route.matches[route.matches.length - 1];
      !thisRoute.route.id ? invariant$1(false) : void 0;
      return thisRoute.route.id;
    }
    function useRouteError() {
      var _state$errors;
      let error = reactExports.useContext(RouteErrorContext);
      let state = useDataRouterState();
      let routeId = useCurrentRouteId();
      if (error !== void 0) {
        return error;
      }
      return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
    }
    function useNavigateStable() {
      let {
        router
      } = useDataRouterContext(DataRouterHook$1.UseNavigateStable);
      let id2 = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable);
      let activeRef = reactExports.useRef(false);
      useIsomorphicLayoutEffect$1(() => {
        activeRef.current = true;
      });
      let navigate = reactExports.useCallback(function(to2, options) {
        if (options === void 0) {
          options = {};
        }
        if (!activeRef.current) return;
        if (typeof to2 === "number") {
          router.navigate(to2);
        } else {
          router.navigate(to2, _extends$x({
            fromRouteId: id2
          }, options));
        }
      }, [router, id2]);
      return navigate;
    }
    const alreadyWarned$1 = {};
    function warningOnce(key, cond, message) {
      if (!alreadyWarned$1[key]) {
        alreadyWarned$1[key] = true;
      }
    }
    function logV6DeprecationWarnings(renderFuture, routerFuture) {
      if ((renderFuture == null ? void 0 : renderFuture.v7_startTransition) === void 0) ;
      if ((renderFuture == null ? void 0 : renderFuture.v7_relativeSplatPath) === void 0 && true) ;
    }
    function Navigate(_ref4) {
      let {
        to: to2,
        replace: replace2,
        state,
        relative
      } = _ref4;
      !useInRouterContext() ? invariant$1(false) : void 0;
      let {
        future,
        static: isStatic
      } = reactExports.useContext(NavigationContext);
      let {
        matches: matches2
      } = reactExports.useContext(RouteContext);
      let {
        pathname: locationPathname
      } = useLocation();
      let navigate = useNavigate();
      let path = resolveTo(to2, getResolveToMatches(matches2, future.v7_relativeSplatPath), locationPathname, relative === "path");
      let jsonPath = JSON.stringify(path);
      reactExports.useEffect(() => navigate(JSON.parse(jsonPath), {
        replace: replace2,
        state,
        relative
      }), [navigate, jsonPath, relative, replace2, state]);
      return null;
    }
    function Outlet(props) {
      return useOutlet(props.context);
    }
    function Route(_props) {
      invariant$1(false);
    }
    function Router(_ref5) {
      let {
        basename: basenameProp = "/",
        children = null,
        location: locationProp,
        navigationType = Action.Pop,
        navigator: navigator2,
        static: staticProp = false,
        future
      } = _ref5;
      !!useInRouterContext() ? invariant$1(false) : void 0;
      let basename = basenameProp.replace(/^\/*/, "/");
      let navigationContext = reactExports.useMemo(() => ({
        basename,
        navigator: navigator2,
        static: staticProp,
        future: _extends$x({
          v7_relativeSplatPath: false
        }, future)
      }), [basename, future, navigator2, staticProp]);
      if (typeof locationProp === "string") {
        locationProp = parsePath(locationProp);
      }
      let {
        pathname = "/",
        search = "",
        hash = "",
        state = null,
        key = "default"
      } = locationProp;
      let locationContext = reactExports.useMemo(() => {
        let trailingPathname = stripBasename(pathname, basename);
        if (trailingPathname == null) {
          return null;
        }
        return {
          location: {
            pathname: trailingPathname,
            search,
            hash,
            state,
            key
          },
          navigationType
        };
      }, [basename, pathname, search, hash, state, key, navigationType]);
      if (locationContext == null) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
        value: navigationContext
      }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
        children,
        value: locationContext
      }));
    }
    function Routes(_ref6) {
      let {
        children,
        location
      } = _ref6;
      return useRoutes(createRoutesFromChildren(children), location);
    }
    new Promise(() => {
    });
    function createRoutesFromChildren(children, parentPath) {
      if (parentPath === void 0) {
        parentPath = [];
      }
      let routes = [];
      reactExports.Children.forEach(children, (element, index) => {
        if (!/* @__PURE__ */ reactExports.isValidElement(element)) {
          return;
        }
        let treePath = [...parentPath, index];
        if (element.type === reactExports.Fragment) {
          routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
          return;
        }
        !(element.type === Route) ? invariant$1(false) : void 0;
        !(!element.props.index || !element.props.children) ? invariant$1(false) : void 0;
        let route = {
          id: element.props.id || treePath.join("-"),
          caseSensitive: element.props.caseSensitive,
          element: element.props.element,
          Component: element.props.Component,
          index: element.props.index,
          path: element.props.path,
          loader: element.props.loader,
          action: element.props.action,
          errorElement: element.props.errorElement,
          ErrorBoundary: element.props.ErrorBoundary,
          hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
          shouldRevalidate: element.props.shouldRevalidate,
          handle: element.props.handle,
          lazy: element.props.lazy
        };
        if (element.props.children) {
          route.children = createRoutesFromChildren(element.props.children, treePath);
        }
        routes.push(route);
      });
      return routes;
    }
    /**
     * React Router DOM v6.30.2
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    function _extends$w() {
      _extends$w = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$w.apply(this, arguments);
    }
    function _objectWithoutPropertiesLoose$q(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }
      return target;
    }
    function isModifiedEvent(event) {
      return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
    }
    function shouldProcessLinkClick(event, target) {
      return event.button === 0 && // Ignore everything but left clicks
      (!target || target === "_self") && // Let browser handle "target=_blank" etc.
      !isModifiedEvent(event);
    }
    const _excluded$q = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"];
    const REACT_ROUTER_VERSION = "6";
    try {
      window.__reactRouterVersion = REACT_ROUTER_VERSION;
    } catch (e) {
    }
    const START_TRANSITION = "startTransition";
    const startTransitionImpl = React$4[START_TRANSITION];
    function HashRouter(_ref5) {
      let {
        basename,
        children,
        future,
        window: window2
      } = _ref5;
      let historyRef = reactExports.useRef();
      if (historyRef.current == null) {
        historyRef.current = createHashHistory({
          window: window2,
          v5Compat: true
        });
      }
      let history = historyRef.current;
      let [state, setStateImpl] = reactExports.useState({
        action: history.action,
        location: history.location
      });
      let {
        v7_startTransition
      } = future || {};
      let setState = reactExports.useCallback((newState) => {
        v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
      }, [setStateImpl, v7_startTransition]);
      reactExports.useLayoutEffect(() => history.listen(setState), [history, setState]);
      reactExports.useEffect(() => logV6DeprecationWarnings(future), [future]);
      return /* @__PURE__ */ reactExports.createElement(Router, {
        basename,
        children,
        location: state.location,
        navigationType: state.action,
        navigator: history,
        future
      });
    }
    const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
    const Link = /* @__PURE__ */ reactExports.forwardRef(function LinkWithRef(_ref7, ref) {
      let {
        onClick,
        relative,
        reloadDocument,
        replace: replace2,
        state,
        target,
        to: to2,
        preventScrollReset,
        viewTransition
      } = _ref7, rest = _objectWithoutPropertiesLoose$q(_ref7, _excluded$q);
      let {
        basename
      } = reactExports.useContext(NavigationContext);
      let absoluteHref;
      let isExternal = false;
      if (typeof to2 === "string" && ABSOLUTE_URL_REGEX.test(to2)) {
        absoluteHref = to2;
        if (isBrowser) {
          try {
            let currentUrl = new URL(window.location.href);
            let targetUrl = to2.startsWith("//") ? new URL(currentUrl.protocol + to2) : new URL(to2);
            let path = stripBasename(targetUrl.pathname, basename);
            if (targetUrl.origin === currentUrl.origin && path != null) {
              to2 = path + targetUrl.search + targetUrl.hash;
            } else {
              isExternal = true;
            }
          } catch (e) {
          }
        }
      }
      let href = useHref(to2, {
        relative
      });
      let internalOnClick = useLinkClickHandler(to2, {
        replace: replace2,
        state,
        target,
        preventScrollReset,
        relative,
        viewTransition
      });
      function handleClick(event) {
        if (onClick) onClick(event);
        if (!event.defaultPrevented) {
          internalOnClick(event);
        }
      }
      return (
        // eslint-disable-next-line jsx-a11y/anchor-has-content
        /* @__PURE__ */ reactExports.createElement("a", _extends$w({}, rest, {
          href: absoluteHref || href,
          onClick: isExternal || reloadDocument ? onClick : handleClick,
          ref,
          target
        }))
      );
    });
    var DataRouterHook;
    (function(DataRouterHook2) {
      DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
      DataRouterHook2["UseSubmit"] = "useSubmit";
      DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
      DataRouterHook2["UseFetcher"] = "useFetcher";
      DataRouterHook2["useViewTransitionState"] = "useViewTransitionState";
    })(DataRouterHook || (DataRouterHook = {}));
    var DataRouterStateHook;
    (function(DataRouterStateHook2) {
      DataRouterStateHook2["UseFetcher"] = "useFetcher";
      DataRouterStateHook2["UseFetchers"] = "useFetchers";
      DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
    })(DataRouterStateHook || (DataRouterStateHook = {}));
    function useLinkClickHandler(to2, _temp) {
      let {
        target,
        replace: replaceProp,
        state,
        preventScrollReset,
        relative,
        viewTransition
      } = _temp === void 0 ? {} : _temp;
      let navigate = useNavigate();
      let location = useLocation();
      let path = useResolvedPath(to2, {
        relative
      });
      return reactExports.useCallback((event) => {
        if (shouldProcessLinkClick(event, target)) {
          event.preventDefault();
          let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
          navigate(to2, {
            replace: replace2,
            state,
            preventScrollReset,
            relative,
            viewTransition
          });
        }
      }, [location, navigate, path, replaceProp, state, target, to2, preventScrollReset, relative, viewTransition]);
    }
    const translations = {
      en: {
        appTitle: "TNCSC RiskGuard",
        subtitle: "Advanced Weather-Based Food Security Decision Support System",
        operationalDistrict: "Operational in 38 Districts",
        launchDashboard: "Launch Command Center",
        fieldOfficerLogin: "Field Officer Login",
        dashboard: "Dashboard Overview",
        riskMap: "Real-Time Risk Overview",
        inventory: "Godown Inventory",
        analytics: "Impact Analytics",
        signOut: "Sign Out",
        uploadReport: "Upload Field Report",
        uploadWeekend: "Upload Weekend Data",
        fieldDashboard: "Field Operations",
        godownId: "Godown ID",
        date: "Date",
        status: "Status",
        issues: "Issues Found",
        photo: "Upload Photo Evidence",
        cancel: "Cancel",
        submit: "Submit Report",
        weekNumber: "Week Number",
        stockLevel: "Current Stock (MT)",
        staffAttendance: "Staff Attendance (%)",
        maintenance: "Maintenance Issues",
        // Analytics
        highRiskGodowns: "High Risk Godowns",
        stockAtRisk: "Stock Value at Risk",
        incidentsToday: "Incidents Today",
        slaBreaches: "SLA Breaches",
        riskTrend: "Risk Incident Trends (7 Days)",
        districtRisk: "District Risk Profile",
        activeAlerts: "Active Alerts Queue",
        // Movement & Admin
        stockLogistics: "Stock & Logistics",
        adminPanel: "Administration",
        inwardMovement: "Inward (Procurement)",
        outwardMovement: "Outward (FPS/Processing)",
        inspectStock: "Inspect Stock Lots",
        truckNo: "Truck No",
        commodity: "Commodity",
        quantity: "Quantity",
        viewManifest: "View Manifest",
        userManagement: "User Management",
        riskConfig: "Risk Configuration",
        humidityThreshold: "Max Humidity Allowed",
        moistureThreshold: "Max Grain Moisture",
        stockAge: "Stock Aging Alert",
        saveConfig: "Update Configuration",
        // Rail
        railConsignments: "Rail Consignments",
        trainNo: "Train No",
        wagons: "Wagons",
        eta: "ETA",
        expectedRail: "Expected Rail Arrivals",
        source: "Source",
        // Official
        tncscFull: "Tamil Nadu Civil Supplies Corporation",
        fieldOps: "Field Operations",
        govtTN: "Government of Tamil Nadu",
        resources: "Resources & Compliance",
        sop: "Standard Operating Procedures (SOP)",
        circulars: "Latest Circulars",
        // Landing Page - Hero
        heroTitle: "TNCSC RiskGuard",
        heroSubtitle: "AI-Powered Risk Management & Decision Support System for Food Security",
        heroProblem: "Protecting 20M+ beneficiaries by digitizing Grain Storage & Movement",
        tryDemo: "Try Live Demo",
        viewProblem: "View Problem Statement",
        // Landing Page - Problem
        problemTitle: "The Challenge",
        problemDesc: "Manual tracking of 250+ Godowns leads to grain spoilage, theft, and operational inefficiencies.",
        problem1: "Grain Spoilage Risk",
        problem1Desc: "Moisture & pests cause significant yearly loss.",
        problem2: "Operational Blindspots",
        problem2Desc: "Lack of real-time visibility into stock and movement.",
        problem3: "Slow Response",
        problem3Desc: "Delays in reporting incidents from field to HQ.",
        // Landing Page - Solution
        solutionTitle: "The Solution: RiskGuard",
        solutionDesc: "A unified command center integrating IoT, AI, and Blockchain.",
        feature1: "Real-Time Risk Map",
        feature1Desc: "Live monitoring of flood, fire, and pest risks.",
        feature2: "Immutable Ledger",
        feature2Desc: "Blockchain-backed audit trail for all stock movement.",
        feature3: "Field App",
        feature3Desc: "Offline-first mobile tool for inspection officers.",
        feature4: "AI Analytics",
        feature4Desc: "Predictive models for spoilage and demand.",
        // Impact
        impactTitle: "Projected Impact",
        metric1: "Godowns Monitored",
        metric2: "Incidents Prevented",
        metric3: "Value Protected",
        // Footer/About
        // Roadmap
        roadmapTitle: "Development Roadmap",
        phase1: "Phase 1: Pilot (Current)",
        phase1Desc: "Live Risk Mapping, Digital Inspections, Basic Analytics.",
        phase2: "Phase 2: Integration (Q1 2026)",
        phase2Desc: "API Integration with TNCSC ERP, ePDS, and e-DPC.",
        phase3: "Phase 3: Intelligence (Q3 2026)",
        phase3Desc: "Predictive AI Models for Spoilage & Demand Forecasting.",
        // Footer/About
        builtBy: "Built by Pradeep",
        forSIH: "",
        contact: "Contact Us",
        forms: "Forms & Templates",
        escalation: "Escalation Matrix",
        // Navigation
        navOverview: "Overview",
        navNetwork: "Godown Network",
        navInventory: "Inventory & Aging",
        navAlerts: "Alerts & Tasks",
        navAnalytics: "Impact Analytics",
        navSettings: "Settings",
        // Overview KPIs
        totalGodowns: "Total Godowns",
        atRiskGodowns: "At-Risk Godowns",
        estSpoilageSaved: "Est. Spoilage Saved",
        seasonProcurement: "Season Procurement",
        riskHeatmap: "Risk Heatmap",
        spoilageTrends: "Spoilage vs Saved Trends",
        topRiskGodowns: "Top High-Risk Godowns",
        viewAll: "View All Network",
        // Inspection Module
        inspectionReport: "Inspection Report",
        metadata: "Inspection Metadata",
        checklist: "Scope & Checklist",
        compliance: "Compliance & Governance",
        action: "Action & Escalation",
        // Field Labels
        district: "District",
        taluk: "Taluk",
        designation: "Designation",
        teamMembers: "Team Members",
        inspectionType: "Inspection Type",
        // Checklist Items
        stockPosition: "Stock Position Verified?",
        qualityCondition: "Quality Condition Good?",
        storageSafety: "Storage Safety Norms Followed?",
        recordsMaintained: "Records (Stock/CRC) Up-to-date?",
        cleanliness: "Premises Cleanliness",
        grievances: "Citizen Grievances Pending?",
        // Compliance
        rulesFollowed: "Statutory Rules Followed?",
        irregularities: "Irregularities Observed",
        nfsaCompliance: "NFSA Compliance",
        // Action
        recommendations: "Recommendations",
        deadline: "Compliance Deadline",
        disciplinary: "Disciplinary Action Recommended?",
        // Options
        yes: "Yes",
        no: "No",
        routine: "Routine",
        surprise: "Surprise",
        special: "Special Drive",
        inspector: "Inspector",
        tso: "Taluk Supply Officer",
        dso: "District Supply Officer"
      },
      ta: {
        appTitle: "   ",
        subtitle: "     ",
        operationalDistrict: "38  ",
        launchDashboard: "  ",
        fieldOfficerLogin: "  ",
        dashboard: "",
        riskMap: "  ",
        inventory: " ",
        analytics: " ",
        signOut: "",
        uploadReport: "  ",
        uploadWeekend: "  ",
        fieldDashboard: "",
        godownId: " ",
        date: "",
        status: "",
        issues: " ",
        photo: " ",
        cancel: "",
        submit: "",
        weekNumber: " ",
        stockLevel: "  (MT)",
        staffAttendance: "  (%)",
        maintenance: " ",
        // Analytics
        highRiskGodowns: "  ",
        stockAtRisk: "  ",
        incidentsToday: " ",
        slaBreaches: "",
        riskTrend: "  (7 )",
        districtRisk: "   ",
        activeAlerts: "  ",
        // Movement & Admin
        stockLogistics: " & ",
        adminPanel: "",
        inwardMovement: " ()",
        outwardMovement: " (FPS/)",
        inspectStock: " ",
        truckNo: " ",
        commodity: "",
        quantity: "",
        viewManifest: " ",
        userManagement: " ",
        riskConfig: " ",
        humidityThreshold: " ",
        moistureThreshold: " ",
        stockAge: "  ",
        saveConfig: " ",
        // Rail
        railConsignments: " ",
        trainNo: " ",
        wagons: "",
        eta: " ",
        expectedRail: "  ",
        source: "",
        // Official
        tncscFull: "   ",
        fieldOps: " ",
        govtTN: " ",
        resources: " & ",
        sop: "   (SOP)",
        circulars: " ",
        // Landing Page - Hero
        heroTitle: "TNCSC ",
        heroSubtitle: "    ",
        heroProblem: "     ",
        tryDemo: " ",
        viewProblem: " ",
        // Landing Page - Problem
        problemTitle: "",
        problemDesc: "      .",
        problem1: "  ",
        problem1Desc: "    .",
        problem2: " ",
        problem2Desc: "     .",
        problem3: " ",
        problem3Desc: "   .",
        // Landing Page - Solution
        solutionTitle: ": ",
        solutionDesc: "IoT, AI  Blockchain   .",
        feature1: "  ",
        feature1Desc: ",     .",
        feature2: " ",
        feature2Desc: "   Blockchain .",
        feature3: " ",
        feature3Desc: "   .",
        feature4: "AI ",
        feature4Desc: "   .",
        // Impact
        impactTitle: "",
        metric1: " ",
        metric2: " ",
        metric3: " ",
        // Roadmap
        roadmapTitle: " ",
        phase1: " 1:   ()",
        phase1Desc: " ,  ,  .",
        phase2: " 2:  (Q1 2026)",
        phase2Desc: "TNCSC ERP, ePDS  e-DPC  API .",
        phase3: " 3:  (Q3 2026)",
        phase3Desc: " AI    .",
        // Footer/About
        builtBy: ": ",
        forSIH: "",
        contact: "",
        forms: " & ",
        escalation: "  ",
        // Navigation
        navOverview: "",
        navNetwork: " ",
        navInventory: " & ",
        navAlerts: "",
        navAnalytics: " ",
        navSettings: "",
        // Overview KPIs
        totalGodowns: " ",
        atRiskGodowns: "  ",
        estSpoilageSaved: "  ",
        seasonProcurement: " ",
        riskHeatmap: " ",
        spoilageTrends: " vs  ",
        topRiskGodowns: "  ",
        viewAll: " ",
        // Inspection Module
        inspectionReport: " ",
        metadata: " ",
        checklist: " ",
        compliance: " ",
        action: " & ",
        // Field Labels
        district: "",
        taluk: "",
        designation: "",
        teamMembers: " ",
        inspectionType: " ",
        // Checklist Items
        stockPosition: " ?",
        qualityCondition: "  ?",
        storageSafety: "  ?",
        recordsMaintained: " ?",
        cleanliness: " ",
        grievances: "  ?",
        // Compliance
        rulesFollowed: " ?",
        irregularities: " ",
        nfsaCompliance: "NFSA ",
        // Action
        recommendations: "",
        deadline: " ",
        disciplinary: "  ?",
        // Options
        yes: "",
        no: "",
        routine: "",
        surprise: " ",
        special: " ",
        inspector: "",
        tso: "  ",
        dso: "  "
      }
    };
    const LanguageContext = reactExports.createContext();
    const LanguageProvider = ({ children }) => {
      const [language, setLanguage] = reactExports.useState("en");
      const toggleLanguage = () => {
        setLanguage((prev) => prev === "en" ? "ta" : "en");
      };
      const t2 = (key) => {
        return translations[language][key] || key;
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageContext.Provider, { value: { language, toggleLanguage, t: t2 }, children });
    };
    const useLanguage = () => reactExports.useContext(LanguageContext);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    var defaultAttributes = {
      xmlns: "http://www.w3.org/2000/svg",
      width: 24,
      height: 24,
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: 2,
      strokeLinecap: "round",
      strokeLinejoin: "round"
    };
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const toKebabCase = (string2) => string2.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase().trim();
    const createLucideIcon = (iconName, iconNode) => {
      const Component = reactExports.forwardRef(
        (_a, ref) => {
          var _b = _a, { color: color2 = "currentColor", size = 24, strokeWidth = 2, absoluteStrokeWidth, className = "", children } = _b, rest = __objRest(_b, ["color", "size", "strokeWidth", "absoluteStrokeWidth", "className", "children"]);
          return reactExports.createElement(
            "svg",
            __spreadValues(__spreadProps(__spreadValues({
              ref
            }, defaultAttributes), {
              width: size,
              height: size,
              stroke: color2,
              strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
              className: ["lucide", `lucide-${toKebabCase(iconName)}`, className].join(" ")
            }), rest),
            [
              ...iconNode.map(([tag, attrs]) => reactExports.createElement(tag, attrs)),
              ...Array.isArray(children) ? children : [children]
            ]
          );
        }
      );
      Component.displayName = `${iconName}`;
      return Component;
    };
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Activity = createLucideIcon("Activity", [
      ["path", { d: "M22 12h-4l-3 9L9 3l-3 9H2", key: "d5dnw9" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const AlertTriangle = createLucideIcon("AlertTriangle", [
      [
        "path",
        {
          d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z",
          key: "c3ski4"
        }
      ],
      ["path", { d: "M12 9v4", key: "juzpu7" }],
      ["path", { d: "M12 17h.01", key: "p32p05" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const ArrowUpDown = createLucideIcon("ArrowUpDown", [
      ["path", { d: "m21 16-4 4-4-4", key: "f6ql7i" }],
      ["path", { d: "M17 20V4", key: "1ejh1v" }],
      ["path", { d: "m3 8 4-4 4 4", key: "11wl7u" }],
      ["path", { d: "M7 4v16", key: "1glfcx" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const BarChart3 = createLucideIcon("BarChart3", [
      ["path", { d: "M3 3v18h18", key: "1s2lah" }],
      ["path", { d: "M18 17V9", key: "2bz60n" }],
      ["path", { d: "M13 17V5", key: "1frdt8" }],
      ["path", { d: "M8 17v-3", key: "17ska0" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Bell = createLucideIcon("Bell", [
      ["path", { d: "M6 8a6 6 0 0 1 12 0c0 7 3 9 3 9H3s3-2 3-9", key: "1qo2s2" }],
      ["path", { d: "M10.3 21a1.94 1.94 0 0 0 3.4 0", key: "qgo35s" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Calendar = createLucideIcon("Calendar", [
      ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2", ry: "2", key: "eu3xkr" }],
      ["line", { x1: "16", x2: "16", y1: "2", y2: "6", key: "m3sa8f" }],
      ["line", { x1: "8", x2: "8", y1: "2", y2: "6", key: "18kwsl" }],
      ["line", { x1: "3", x2: "21", y1: "10", y2: "10", key: "xt86sb" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Camera = createLucideIcon("Camera", [
      [
        "path",
        {
          d: "M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z",
          key: "1tc9qg"
        }
      ],
      ["circle", { cx: "12", cy: "13", r: "3", key: "1vg3eu" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const CheckCircle2 = createLucideIcon("CheckCircle2", [
      ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
      ["path", { d: "m9 12 2 2 4-4", key: "dzmm74" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const CheckCircle = createLucideIcon("CheckCircle", [
      ["path", { d: "M22 11.08V12a10 10 0 1 1-5.93-9.14", key: "g774vq" }],
      ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const ChevronDown = createLucideIcon("ChevronDown", [
      ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const ChevronLeft = createLucideIcon("ChevronLeft", [
      ["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const ChevronRight = createLucideIcon("ChevronRight", [
      ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Circle = createLucideIcon("Circle", [
      ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Clock = createLucideIcon("Clock", [
      ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
      ["polyline", { points: "12 6 12 12 16 14", key: "68esgv" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const CloudRain = createLucideIcon("CloudRain", [
      ["path", { d: "M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242", key: "1pljnt" }],
      ["path", { d: "M16 14v6", key: "1j4efv" }],
      ["path", { d: "M8 14v6", key: "17c4r9" }],
      ["path", { d: "M12 16v6", key: "c8a4gj" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const CreditCard = createLucideIcon("CreditCard", [
      ["rect", { width: "20", height: "14", x: "2", y: "5", rx: "2", key: "ynyp8z" }],
      ["line", { x1: "2", x2: "22", y1: "10", y2: "10", key: "1b3vmo" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Database = createLucideIcon("Database", [
      ["ellipse", { cx: "12", cy: "5", rx: "9", ry: "3", key: "msslwz" }],
      ["path", { d: "M3 5V19A9 3 0 0 0 21 19V5", key: "1wlel7" }],
      ["path", { d: "M3 12A9 3 0 0 0 21 12", key: "mv7ke4" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Download = createLucideIcon("Download", [
      ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
      ["polyline", { points: "7 10 12 15 17 10", key: "2ggqvy" }],
      ["line", { x1: "12", x2: "12", y1: "15", y2: "3", key: "1vk2je" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Eye = createLucideIcon("Eye", [
      ["path", { d: "M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z", key: "rwhkz3" }],
      ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Filter = createLucideIcon("Filter", [
      ["polygon", { points: "22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3", key: "1yg77f" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Globe = createLucideIcon("Globe", [
      ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
      ["path", { d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20", key: "13o1zl" }],
      ["path", { d: "M2 12h20", key: "9i4pu4" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Layers = createLucideIcon("Layers", [
      [
        "path",
        {
          d: "m12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83Z",
          key: "8b97xw"
        }
      ],
      ["path", { d: "m22 17.65-9.17 4.16a2 2 0 0 1-1.66 0L2 17.65", key: "dd6zsq" }],
      ["path", { d: "m22 12.65-9.17 4.16a2 2 0 0 1-1.66 0L2 12.65", key: "ep9fru" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const LayoutDashboard = createLucideIcon("LayoutDashboard", [
      ["rect", { width: "7", height: "9", x: "3", y: "3", rx: "1", key: "10lvy0" }],
      ["rect", { width: "7", height: "5", x: "14", y: "3", rx: "1", key: "16une8" }],
      ["rect", { width: "7", height: "9", x: "14", y: "12", rx: "1", key: "1hutg5" }],
      ["rect", { width: "7", height: "5", x: "3", y: "16", rx: "1", key: "ldoo1y" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Lock = createLucideIcon("Lock", [
      ["rect", { width: "18", height: "11", x: "3", y: "11", rx: "2", ry: "2", key: "1w4ew1" }],
      ["path", { d: "M7 11V7a5 5 0 0 1 10 0v4", key: "fwvmzm" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const LogOut = createLucideIcon("LogOut", [
      ["path", { d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4", key: "1uf3rs" }],
      ["polyline", { points: "16 17 21 12 16 7", key: "1gabdz" }],
      ["line", { x1: "21", x2: "9", y1: "12", y2: "12", key: "1uyos4" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const MapPin = createLucideIcon("MapPin", [
      ["path", { d: "M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z", key: "2oe9fu" }],
      ["circle", { cx: "12", cy: "10", r: "3", key: "ilqhr7" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Map$1 = createLucideIcon("Map", [
      ["polygon", { points: "3 6 9 3 15 6 21 3 21 18 15 21 9 18 3 21", key: "ok2ie8" }],
      ["line", { x1: "9", x2: "9", y1: "3", y2: "18", key: "w34qz5" }],
      ["line", { x1: "15", x2: "15", y1: "6", y2: "21", key: "volv9a" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Menu = createLucideIcon("Menu", [
      ["line", { x1: "4", x2: "20", y1: "12", y2: "12", key: "1e0a9i" }],
      ["line", { x1: "4", x2: "20", y1: "6", y2: "6", key: "1owob3" }],
      ["line", { x1: "4", x2: "20", y1: "18", y2: "18", key: "yk5zj1" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const MoreHorizontal = createLucideIcon("MoreHorizontal", [
      ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
      ["circle", { cx: "19", cy: "12", r: "1", key: "1wjl8i" }],
      ["circle", { cx: "5", cy: "12", r: "1", key: "1pcz8c" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const MoreVertical = createLucideIcon("MoreVertical", [
      ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
      ["circle", { cx: "12", cy: "5", r: "1", key: "gxeob9" }],
      ["circle", { cx: "12", cy: "19", r: "1", key: "lyex9k" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Network = createLucideIcon("Network", [
      ["rect", { x: "16", y: "16", width: "6", height: "6", rx: "1", key: "4q2zg0" }],
      ["rect", { x: "2", y: "16", width: "6", height: "6", rx: "1", key: "8cvhb9" }],
      ["rect", { x: "9", y: "2", width: "6", height: "6", rx: "1", key: "1egb70" }],
      ["path", { d: "M5 16v-3a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v3", key: "1jsf9p" }],
      ["path", { d: "M12 12V8", key: "2874zd" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Package = createLucideIcon("Package", [
      ["path", { d: "m7.5 4.27 9 5.15", key: "1c824w" }],
      [
        "path",
        {
          d: "M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z",
          key: "hh9hay"
        }
      ],
      ["path", { d: "m3.3 7 8.7 5 8.7-5", key: "g66t2b" }],
      ["path", { d: "M12 22V12", key: "d0xqtd" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Printer = createLucideIcon("Printer", [
      ["polyline", { points: "6 9 6 2 18 2 18 9", key: "1306q4" }],
      [
        "path",
        {
          d: "M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2",
          key: "143wyd"
        }
      ],
      ["rect", { width: "12", height: "8", x: "6", y: "14", key: "5ipwut" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const RefreshCw = createLucideIcon("RefreshCw", [
      ["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8", key: "v9h5vc" }],
      ["path", { d: "M21 3v5h-5", key: "1q7to0" }],
      ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16", key: "3uifl3" }],
      ["path", { d: "M8 16H3v5", key: "1cv678" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Save = createLucideIcon("Save", [
      ["path", { d: "M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z", key: "1owoqh" }],
      ["polyline", { points: "17 21 17 13 7 13 7 21", key: "1md35c" }],
      ["polyline", { points: "7 3 7 8 15 8", key: "8nz8an" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Search = createLucideIcon("Search", [
      ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
      ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Send = createLucideIcon("Send", [
      ["path", { d: "m22 2-7 20-4-9-9-4Z", key: "1q3vgg" }],
      ["path", { d: "M22 2 11 13", key: "nzbqef" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Server = createLucideIcon("Server", [
      ["rect", { width: "20", height: "8", x: "2", y: "2", rx: "2", ry: "2", key: "ngkwjq" }],
      ["rect", { width: "20", height: "8", x: "2", y: "14", rx: "2", ry: "2", key: "iecqi9" }],
      ["line", { x1: "6", x2: "6.01", y1: "6", y2: "6", key: "16zg32" }],
      ["line", { x1: "6", x2: "6.01", y1: "18", y2: "18", key: "nzw8ys" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Settings = createLucideIcon("Settings", [
      [
        "path",
        {
          d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",
          key: "1qme2f"
        }
      ],
      ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Share2 = createLucideIcon("Share2", [
      ["circle", { cx: "18", cy: "5", r: "3", key: "gq8acd" }],
      ["circle", { cx: "6", cy: "12", r: "3", key: "w7nqdw" }],
      ["circle", { cx: "18", cy: "19", r: "3", key: "1xt0gg" }],
      ["line", { x1: "8.59", x2: "15.42", y1: "13.51", y2: "17.49", key: "47mynk" }],
      ["line", { x1: "15.41", x2: "8.59", y1: "6.51", y2: "10.49", key: "1n3mei" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Shield = createLucideIcon("Shield", [
      ["path", { d: "M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10", key: "1irkt0" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Smartphone = createLucideIcon("Smartphone", [
      ["rect", { width: "14", height: "20", x: "5", y: "2", rx: "2", ry: "2", key: "1yt0o3" }],
      ["path", { d: "M12 18h.01", key: "mhygvu" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Sprout = createLucideIcon("Sprout", [
      ["path", { d: "M7 20h10", key: "e6iznv" }],
      ["path", { d: "M10 20c5.5-2.5.8-6.4 3-10", key: "161w41" }],
      [
        "path",
        {
          d: "M9.5 9.4c1.1.8 1.8 2.2 2.3 3.7-2 .4-3.5.4-4.8-.3-1.2-.6-2.3-1.9-3-4.2 2.8-.5 4.4 0 5.5.8z",
          key: "9gtqwd"
        }
      ],
      [
        "path",
        {
          d: "M14.1 6a7 7 0 0 0-1.1 4c1.9-.1 3.3-.6 4.3-1.4 1-1 1.6-2.3 1.7-4.6-2.7.1-4 1-4.9 2z",
          key: "bkxnd2"
        }
      ]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const TrendingDown = createLucideIcon("TrendingDown", [
      ["polyline", { points: "22 17 13.5 8.5 8.5 13.5 2 7", key: "1r2t7k" }],
      ["polyline", { points: "16 17 22 17 22 11", key: "11uiuu" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const TrendingUp = createLucideIcon("TrendingUp", [
      ["polyline", { points: "22 7 13.5 15.5 8.5 10.5 2 17", key: "126l90" }],
      ["polyline", { points: "16 7 22 7 22 13", key: "kwv8wd" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Truck = createLucideIcon("Truck", [
      ["path", { d: "M5 18H3c-.6 0-1-.4-1-1V7c0-.6.4-1 1-1h10c.6 0 1 .4 1 1v11", key: "hs4xqm" }],
      ["path", { d: "M14 9h4l4 4v4c0 .6-.4 1-1 1h-2", key: "11fp61" }],
      ["circle", { cx: "7", cy: "18", r: "2", key: "19iecd" }],
      ["path", { d: "M15 18H9", key: "1lyqi6" }],
      ["circle", { cx: "17", cy: "18", r: "2", key: "332jqn" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const User = createLucideIcon("User", [
      ["path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2", key: "975kel" }],
      ["circle", { cx: "12", cy: "7", r: "4", key: "17ys0d" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Users = createLucideIcon("Users", [
      ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
      ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }],
      ["path", { d: "M22 21v-2a4 4 0 0 0-3-3.87", key: "kshegd" }],
      ["path", { d: "M16 3.13a4 4 0 0 1 0 7.75", key: "1da9ce" }]
    ]);
    /**
     * @license lucide-react v0.294.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const X = createLucideIcon("X", [
      ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
      ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
    ]);
    const logo = "/pradeep/assets/logo-BK9nBmly.png";
    const GradientText = ({ children, className = "" }) => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `bg-clip-text text-transparent bg-gradient-to-r from-emerald-400 to-cyan-400 ${className}`, children });
    const LandingPage = () => {
      const navigate = useNavigate();
      const { t: t2, language, toggleLanguage } = useLanguage();
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen bg-[#0f172a] text-slate-100 font-sans selection:bg-emerald-500/30", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("nav", { className: "fixed w-full z-50 bg-[#0f172a]/80 backdrop-blur-md border-b border-white/5", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-6 h-20 flex justify-between items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: logo,
                alt: "TN Emblem",
                className: "w-10 h-10 drop-shadow-[0_0_10px_rgba(255,255,255,0.2)]"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-xl font-bold tracking-tight text-white leading-none", children: t2("tncscFull") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-[10px] text-emerald-400 uppercase tracking-[0.2em] font-bold mt-1", children: t2("govtTN") })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4 items-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: toggleLanguage,
                className: "px-4 py-2 text-xs font-bold rounded-lg border border-white/10 hover:bg-white/5 transition-all uppercase tracking-wider text-slate-400 hover:text-white",
                children: language === "en" ? "" : "English"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => navigate("/login"),
                className: "hidden md:block px-5 py-2 text-sm font-semibold text-slate-300 hover:text-white transition-colors",
                children: t2("fieldOfficerLogin")
              }
            )
          ] })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "relative pt-32 pb-20 overflow-hidden", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-[radial-gradient(ellipse_at_top,_var(--tw-gradient-stops))] from-emerald-900/20 via-[#0f172a] to-[#0f172a]" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container mx-auto px-6 relative z-10", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-4xl mx-auto text-center space-y-8", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex items-center gap-2 px-4 py-1.5 rounded-full bg-emerald-500/10 text-emerald-400 border border-emerald-500/20 text-xs font-bold uppercase tracking-widest animate-fade-in-up", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "w-2 h-2 rounded-full bg-emerald-500 animate-pulse shadow-[0_0_10px_#10b981]" }),
              t2("operationalDistrict")
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("h1", { className: "text-5xl md:text-7xl font-bold leading-tight tracking-tight", children: [
              t2("heroTitle"),
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx(GradientText, { children: t2("heroSubtitle") })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-lg md:text-xl text-slate-400 leading-relaxed max-w-2xl mx-auto", children: t2("heroProblem") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col sm:flex-row gap-4 justify-center pt-8", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  onClick: () => navigate("/dashboard/overview"),
                  className: "px-8 py-4 bg-emerald-600 hover:bg-emerald-500 text-white font-bold rounded-xl transition-all shadow-[0_0_20px_rgba(16,185,129,0.3)] hover:shadow-[0_0_30px_rgba(16,185,129,0.5)] transform hover:-translate-y-1 flex items-center justify-center gap-2 group focus:outline-none focus:ring-4 focus:ring-emerald-500/50",
                  children: [
                    t2("tryDemo"),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, { className: "w-5 h-5 group-hover:translate-x-1 transition-transform" })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => document.getElementById("problem").scrollIntoView({ behavior: "smooth" }),
                  className: "px-8 py-4 bg-white/5 hover:bg-white/10 text-slate-300 font-bold rounded-xl border border-white/10 transition-all hover:border-white/20 focus:outline-none focus:ring-4 focus:ring-emerald-500/30",
                  children: t2("viewProblem")
                }
              )
            ] })
          ] }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { id: "problem", className: "py-20 bg-slate-900/50 border-y border-white/5", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center mb-16", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl font-bold mb-4", children: t2("problemTitle") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-400 max-w-2xl mx-auto", children: t2("problemDesc") })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid md:grid-cols-3 gap-8", children: [
            { title: "problem1", desc: "problem1Desc", icon: CloudRain, color: "text-blue-400" },
            { title: "problem2", desc: "problem2Desc", icon: Activity, color: "text-orange-400" },
            { title: "problem3", desc: "problem3Desc", icon: AlertTriangle, color: "text-red-400" }
          ].map((item, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-8 rounded-2xl bg-white/5 border border-white/5 hover:border-white/10 transition-all hover:bg-white/[0.07]", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(item.icon, { className: `${item.color} w-10 h-10 mb-6` }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold mb-3 text-slate-200", children: t2(item.title) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-400 leading-relaxed", children: t2(item.desc) })
          ] }, idx)) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "py-24 bg-[#0B1120] relative overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-16 text-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-emerald-500 font-bold tracking-widest uppercase text-xs mb-2 block", children: "Real-time Visibility" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "text-3xl md:text-4xl font-bold text-white mb-4", children: [
              "Tamil Nadu ",
              /* @__PURE__ */ jsxRuntimeExports.jsx(GradientText, { children: "Risk Map & Stock Flow" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-400 max-w-2xl mx-auto", children: "Live visualization of commodity movements across all 38 districts." })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-[#1e293b]/50 border border-slate-700/50 rounded-3xl p-8 md:p-12 relative overflow-hidden", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 opacity-20 pointer-events-none", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "w-full h-full", viewBox: "0 0 800 600", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M400 100 Q 450 150 420 200 T 500 300 T 450 450 T 350 500 T 250 400 T 300 250 T 400 100", stroke: "#10b981", strokeWidth: "2", strokeDasharray: "10 10", className: "animate-pulse" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "400", cy: "100", r: "4", className: "fill-emerald-500" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "420", cy: "200", r: "4", className: "fill-emerald-500" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "500", cy: "300", r: "4", className: "fill-emerald-500" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "350", cy: "500", r: "4", className: "fill-emerald-500" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-3 gap-12 relative z-10", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lg:col-span-2 min-h-[400px] relative bg-[#0f172a] rounded-2xl border border-slate-700 p-6 shadow-2xl overflow-hidden group", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute top-4 left-4 z-20 bg-slate-800/80 backdrop-blur px-4 py-2 rounded-lg border border-white/10", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-emerald-400 text-xs font-bold uppercase tracking-wider mb-1", children: "Active Commodity Routes" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-4 text-[10px] text-slate-300", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2 h-2 rounded-full bg-white" }),
                      " Rice (Delta)"
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2 h-2 rounded-full bg-amber-400" }),
                      " Wheat"
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2 h-2 rounded-full bg-yellow-600" }),
                      " Palm Oil"
                    ] })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 p-8 grid grid-cols-4 md:grid-cols-6 gap-4 content-center opacity-80", children: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""].map((dist, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-[10px] md:text-xs text-slate-500 hover:text-emerald-400 transition-colors cursor-default select-none flex items-center justify-center p-2 rounded-lg hover:bg-white/5 border border-transparent hover:border-white/10", children: dist }, i)) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute inset-0 pointer-events-none", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-[60%] left-[60%] w-1 h-1 bg-white rounded-full shadow-[0_0_10px_white] animate-[flow_3s_infinite_linear]", style: { "--tx": "-100px", "--ty": "-200px" } }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-[60%] left-[60%] w-[100px] h-[200px] border-t-2 border-l-2 border-white/20 rounded-tl-full transform -rotate-12 translate-x-[-100px] translate-y-[-200px]" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-[70%] left-[40%] w-1 h-1 bg-amber-400 rounded-full shadow-[0_0_10px_orange] animate-[flow_4s_infinite_linear_1s]", style: { "--tx": "50px", "--ty": "100px" } })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6 bg-slate-800/50 rounded-2xl border border-slate-700", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start justify-between mb-4", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-slate-400 uppercase tracking-wider mb-1", children: "Total Stock Movement" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-2xl font-bold text-white", children: "42,500 MT" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Activity, { className: "text-emerald-500", size: 20 })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full bg-slate-700 h-1.5 rounded-full overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[75%] h-full bg-emerald-500 rounded-full" }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-3 text-xs text-slate-400 flex justify-between", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Capacity Utilization" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-emerald-400", children: "75%" })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6 bg-slate-800/50 rounded-2xl border border-slate-700", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start justify-between mb-4", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-slate-400 uppercase tracking-wider mb-1", children: "Active Alerts" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-2xl font-bold text-white", children: "12" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(AlertTriangle, { className: "text-amber-500", size: 20 })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 text-xs text-slate-300", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "w-1.5 h-1.5 rounded-full bg-red-500" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Weather Risk: coastal (Nagai)" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 text-xs text-slate-300", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "w-1.5 h-1.5 rounded-full bg-amber-500" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Delay: Trichy to Madurai" })
                    ] })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6 bg-gradient-to-br from-emerald-600 to-teal-700 rounded-2xl shadow-lg text-white", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-3 mb-3", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Truck, { size: 20 }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-sm", children: "Live Fleet" })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-3xl font-bold mb-1", children: "1,240" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-emerald-100 text-xs opacity-80", children: "Trucks on road right now" })
                ] })
              ] })
            ] })
          ] })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "py-20 relative overflow-hidden", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-0 right-0 w-1/3 h-full bg-emerald-500/5 blur-3xl rounded-full" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-6 relative z-10", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-16", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl font-bold mb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(GradientText, { children: t2("solutionTitle") }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-400 max-w-2xl", children: t2("solutionDesc") })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid md:grid-cols-2 lg:grid-cols-4 gap-6", children: [
              { title: "feature1", desc: "feature1Desc", icon: Map, bg: "bg-emerald-500/10", border: "border-emerald-500/20" },
              { title: "feature2", desc: "feature2Desc", icon: Lock, bg: "bg-blue-500/10", border: "border-blue-500/20" },
              { title: "feature3", desc: "feature3Desc", icon: Smartphone, bg: "bg-purple-500/10", border: "border-purple-500/20" },
              { title: "feature4", desc: "feature4Desc", icon: Database, bg: "bg-orange-500/10", border: "border-orange-500/20" }
            ].map((feature, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `p-6 rounded-2xl border ${feature.border} ${feature.bg} backdrop-blur-sm`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(feature.icon, { className: "w-8 h-8 text-white mb-4" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-bold text-lg mb-2", children: t2(feature.title) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-slate-300 opacity-80", children: t2(feature.desc) })
            ] }, idx)) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-20 pt-10 border-t border-white/5 flex flex-wrap justify-center gap-8 md:gap-16 opacity-50 grayscale hover:grayscale-0 transition-all duration-500", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2 h-2 bg-blue-400 rounded-full" }),
                " React 18"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2 h-2 bg-green-500 rounded-full" }),
                " Node.js"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2 h-2 bg-yellow-400 rounded-full" }),
                " Firebase"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2 h-2 bg-purple-500 rounded-full" }),
                " Ledger Logic"
              ] })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "py-20 bg-slate-900 border-y border-white/5", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center mb-16", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex items-center gap-2 px-3 py-1 rounded-full bg-blue-500/10 text-blue-400 text-xs font-bold uppercase tracking-wider border border-blue-500/20 mb-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Layers, { size: 14 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Interoperable Architecture" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "text-3xl font-bold text-white mb-4", children: [
              "Built for ",
              /* @__PURE__ */ jsxRuntimeExports.jsx(GradientText, { children: "Tamil Nadu Stack" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-400 max-w-2xl mx-auto", children: "Seamlessly integrated with existing state infrastructure for unified governance." })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid md:grid-cols-3 gap-8", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-8 rounded-2xl bg-[#0f172a] border border-slate-700 hover:border-emerald-500/50 transition-all group", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-12 h-12 bg-blue-500/10 rounded-xl flex items-center justify-center text-blue-400 mb-6 group-hover:scale-110 transition-transform", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CreditCard, { size: 24 }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-bold text-white mb-3", children: "ePDS Integration" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-400 text-sm leading-relaxed mb-4", children: "Authenticates ration-card entitlements and verifies shop-level disbursement data in real-time." }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "px-2 py-1 rounded bg-slate-800 text-[10px] text-slate-300 border border-slate-700", children: "Verify Card" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "px-2 py-1 rounded bg-slate-800 text-[10px] text-slate-300 border border-slate-700", children: "Stock Sync" })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-8 rounded-2xl bg-[#0f172a] border border-slate-700 hover:border-emerald-500/50 transition-all group", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-12 h-12 bg-green-500/10 rounded-xl flex items-center justify-center text-green-400 mb-6 group-hover:scale-110 transition-transform", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Sprout, { size: 24 }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-bold text-white mb-3", children: "e-DPC Connection" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-400 text-sm leading-relaxed mb-4", children: "Syncs farmer procurement data directly from Direct Purchase Centers to godown inventory logs." }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "px-2 py-1 rounded bg-slate-800 text-[10px] text-slate-300 border border-slate-700", children: "Farmer Pay" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "px-2 py-1 rounded bg-slate-800 text-[10px] text-slate-300 border border-slate-700", children: "Paddy Inflow" })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-8 rounded-2xl bg-[#0f172a] border border-slate-700 hover:border-emerald-500/50 transition-all group", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-12 h-12 bg-purple-500/10 rounded-xl flex items-center justify-center text-purple-400 mb-6 group-hover:scale-110 transition-transform", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Server, { size: 24 }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-bold text-white mb-3", children: "TNeGA Data Exchange" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-400 text-sm leading-relaxed mb-4", children: "Compliant with State API policies for secure, encrypted cross-departmental data sharing." }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "px-2 py-1 rounded bg-slate-800 text-[10px] text-slate-300 border border-slate-700", children: "Secure API" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "px-2 py-1 rounded bg-slate-800 text-[10px] text-slate-300 border border-slate-700", children: "Zero Copy" })
              ] })
            ] })
          ] })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "py-20 bg-slate-800/50 border-y border-white/5", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container mx-auto px-6", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col md:flex-row items-center gap-12", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 space-y-6", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex items-center gap-2 px-3 py-1 rounded-full bg-blue-500/10 text-blue-400 text-xs font-bold uppercase tracking-wider border border-blue-500/20", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, { size: 14 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "AIS-140 Compliant" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "text-3xl font-bold text-white", children: [
              "Driver Empowerment & ",
              /* @__PURE__ */ jsxRuntimeExports.jsx(GradientText, { children: "Theft Protection" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-400 text-lg leading-relaxed", children: "A dedicated mobile app for TNCSC truck drivers, transforming every vehicle into a smart, trackable asset." }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4 p-4 rounded-xl bg-white/5 border border-white/5 hover:bg-white/10 transition-colors", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-3 bg-emerald-500/10 rounded-lg text-emerald-400 h-fit", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Map, { size: 24 }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-bold text-slate-200", children: "Live GPS Tracking" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-slate-400 mt-1", children: "Real-time location sharing with HQ. Eliminates unapproved stops and route deviations." })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4 p-4 rounded-xl bg-white/5 border border-white/5 hover:bg-white/10 transition-colors", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-3 bg-red-500/10 rounded-lg text-red-400 h-fit", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Lock, { size: 24 }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-bold text-slate-200", children: "Anti-Theft Geofencing" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-slate-400 mt-1", children: "Instant alerts if a truck exits the approved corridor or halts unexpectedly." })
                ] })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "mt-6 px-6 py-3 bg-slate-700 hover:bg-slate-600 text-white font-bold rounded-lg flex items-center gap-2 transition-all", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Smartphone, { size: 20 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Download Driver App" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 relative", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-gradient-to-tr from-emerald-500/20 to-blue-500/20 blur-3xl rounded-full" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative z-10 bg-slate-900 border border-slate-700 rounded-3xl p-6 shadow-2xl max-w-sm mx-auto transform rotate-[-2deg] hover:rotate-0 transition-transform duration-500", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-6 border-b border-slate-800 pb-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs font-bold text-slate-500 uppercase", children: "Driver Mode" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2 h-2 bg-green-500 rounded-full animate-pulse" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-slate-800 p-4 rounded-xl border border-slate-700", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-slate-400 mb-1", children: "Current Route" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-bold text-white", children: "Thanjavur Hub  Chennai CPC" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-slate-800 p-4 rounded-xl border border-slate-700 flex justify-between items-center", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-slate-400 mb-1", children: "ETA" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-bold text-emerald-400", children: "2 hrs 15 mins" })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Map, { className: "text-slate-600" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 rounded-xl bg-red-500/10 border border-red-500/20 mt-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 text-red-400 font-bold text-sm mb-1", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, { size: 14 }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Secure Mode Active" })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-[10px] text-red-300/70", children: "Geofence lock enabled. Do not deviate." })
                ] })
              ] })
            ] })
          ] })
        ] }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "py-20 bg-emerald-950/30 border-t border-emerald-900/50", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container mx-auto px-6", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col lg:flex-row gap-16 items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lg:w-1/2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "text-3xl md:text-5xl font-bold text-white leading-tight mb-8 font-serif", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "block text-xl text-emerald-400 font-sans mb-2 font-bold tracking-wider uppercase", children: "Public Welfare" }),
              " TNCSC RiskGuard? ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "bg-clip-text text-transparent bg-gradient-to-r from-emerald-200 to-white text-2xl md:text-4xl mt-2 block", children: [
                "  ",
                /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                "  "
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-10 h-10 rounded-full bg-emerald-500/20 flex items-center justify-center text-emerald-400 shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, { size: 20 }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-slate-300 leading-relaxed text-lg", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-white block mb-1", children: "  " }),
                  "  , ,  , ,      24x7    ,  ."
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-10 h-10 rounded-full bg-blue-500/20 flex items-center justify-center text-blue-400 shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Map$1, { size: 20 }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-slate-300 leading-relaxed text-lg", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-white block mb-1", children: " " }),
                  ", ,       ;       ."
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-10 h-10 rounded-full bg-amber-500/20 flex items-center justify-center text-amber-400 shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Truck, { size: 20 }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-slate-300 leading-relaxed text-lg", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-white block mb-1", children: " " }),
                  "  GPS   ;  ,      ,   ."
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-10 h-10 rounded-full bg-purple-500/20 flex items-center justify-center text-purple-400 shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Users, { size: 20 }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-slate-300 leading-relaxed text-lg", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-white block mb-1", children: " " }),
                  " ,     ;        ."
                ] })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lg:w-1/2 relative", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-emerald-500/20 blur-3xl rounded-full" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative bg-[#0f172a] p-8 rounded-3xl border border-slate-700 shadow-2xl text-center space-y-8", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inline-block p-4 rounded-full bg-emerald-100/10 mb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: logo, alt: "TNCSC", className: "w-24 h-24 drop-shadow-[0_0_15px_rgba(16,185,129,0.5)]" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-2xl font-bold text-white", children: "   ..." }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-300 text-lg leading-relaxed italic", children: '"      ,   ;  RiskGuard ."' }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "w-full py-4 bg-emerald-600 hover:bg-emerald-500 text-white font-bold rounded-xl transition-all shadow-lg hover:shadow-emerald-500/25", children: "  (Learn More)" })
            ] })
          ] })
        ] }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "py-20 bg-emerald-900/10 border-y border-white/5", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-6 text-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold mb-12 uppercase tracking-widest text-emerald-400", children: t2("impactTitle") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-12", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-5xl font-bold text-white mb-2", children: "250+" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-slate-400 text-sm uppercase tracking-wider", children: t2("metric1") })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-5xl font-bold text-white mb-2", children: "94%" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-slate-400 text-sm uppercase tracking-wider", children: t2("metric2") })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-5xl font-bold text-white mb-2", children: "12Cr" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-slate-400 text-sm uppercase tracking-wider", children: t2("metric3") })
            ] })
          ] })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "py-20 relative", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl font-bold mb-12 text-center text-white", children: t2("roadmapTitle") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid md:grid-cols-3 gap-8 relative", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hidden md:block absolute top-12 left-0 w-full h-0.5 bg-gradient-to-r from-emerald-500/20 via-emerald-500/50 to-emerald-500/20" }),
            [
              { title: "phase1", desc: "phase1Desc", status: "current" },
              { title: "phase2", desc: "phase2Desc", status: "next" },
              { title: "phase3", desc: "phase3Desc", status: "future" }
            ].map((phase, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative pt-8 text-center group", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `w-8 h-8 rounded-full border-4 mx-auto mb-6 relative z-10 flex items-center justify-center ${phase.status === "current" ? "bg-emerald-500 border-emerald-900 shadow-[0_0_20px_#10b981]" : "bg-slate-900 border-slate-700"}`, children: phase.status === "current" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2 h-2 bg-white rounded-full animate-pulse" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: `text-xl font-bold mb-2 ${phase.status === "current" ? "text-emerald-400" : "text-slate-300"}`, children: t2(phase.title) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-400 text-sm", children: t2(phase.desc) })
            ] }, idx))
          ] })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("footer", { className: "py-12 bg-[#0f172a] border-t border-white/10 text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center gap-2 mb-6 opacity-50", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, { className: "w-5 h-5 text-emerald-500" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-lg tracking-tight", children: "TNCSC RiskGuard" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-500 text-sm mb-8", children: t2("heroSubtitle") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-slate-600 space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm font-medium text-slate-400", children: [
              "Developed by ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-transparent bg-clip-text bg-gradient-to-r from-emerald-400 to-cyan-400 font-bold text-base hover:scale-105 inline-block transition-transform cursor-default", children: "Sivapradeep Maharajan" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "pt-4 border-t border-slate-800 mt-4 text-slate-500 italic max-w-2xl mx-auto", children: '"Concept solution for TNCSC, aligned with Govt. of Tamil Nadu policies on digital PDS and GPS-based tracking. Not an official government platform."' })
          ] })
        ] }) })
      ] });
    };
    const LoginScreen = () => {
      const navigate = useNavigate();
      const [role, setRole] = reactExports.useState("field");
      const handleLogin = (e) => {
        e.preventDefault();
        if (role === "hq") navigate("/hq");
        else navigate("/field");
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-screen flex items-center justify-center bg-slate-100", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-8 rounded-xl shadow-lg w-full max-w-md", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold mb-6 text-center text-slate-800", children: "Login" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleLogin, className: "space-y-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-slate-700 mb-1", children: "Role" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "select",
              {
                value: role,
                onChange: (e) => setRole(e.target.value),
                className: "w-full border rounded-lg p-2",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "field", children: "Field Officer" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "hq", children: "HQ Admin" })
                ]
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-slate-700 mb-1", children: "Username" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "text", className: "w-full border rounded-lg p-2", placeholder: "Enter username" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-slate-700 mb-1", children: "Password" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "password", className: "w-full border rounded-lg p-2", placeholder: "Enter password" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "submit", className: "w-full bg-blue-600 text-white py-2 rounded-lg font-bold hover:bg-blue-700", children: "Sign In" })
        ] })
      ] }) });
    };
    const FieldReportForm = ({ onClose }) => {
      const { t: t2 } = useLanguage();
      const [step, setStep] = reactExports.useState(1);
      const [submitting, setSubmitting] = reactExports.useState(false);
      const [formData, setFormData] = reactExports.useState({
        metadata: {
          district: "Thanjavur",
          taluk: "",
          godownId: "",
          inspectionType: "Routine",
          officerName: "Ram Kumar",
          designation: "Inspector",
          teamMembers: ""
        },
        checklist: {
          stockPosition: "Yes",
          qualityCondition: "Yes",
          storageSafety: "Yes",
          recordsMaintained: "Yes",
          cleanliness: "Yes",
          grievances: "No",
          // "No" grievances pending is good
          remarks: ""
        },
        compliance: {
          rulesFollowed: "Yes",
          irregularities: [],
          nfsaCompliance: "High"
        },
        action: {
          recommendations: "",
          deadline: "",
          disciplinaryRecommended: false
        }
      });
      const updateField = (section, field, value) => {
        setFormData((prev) => __spreadProps(__spreadValues({}, prev), {
          [section]: __spreadProps(__spreadValues({}, prev[section]), {
            [field]: value
          })
        }));
      };
      const handleSubmit = (e) => __async(exports, null, function* () {
        e.preventDefault();
        setSubmitting(true);
        try {
          const response = yield fetch("/api/reports/field", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(formData)
          });
          if (response.ok) {
            alert(t2("inspectionReport") + " Submitted Successfully!");
            onClose();
          }
        } catch (error) {
          console.error(error);
        } finally {
          setSubmitting(false);
        }
      });
      const renderStep1_Metadata = () => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4 animate-in fade-in slide-in-from-right-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-bold text-emerald-800 border-b pb-2 mb-4", children: t2("metadata") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-bold text-gray-500 mb-1", children: t2("district") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "text", value: formData.metadata.district, readOnly: true, className: "w-full bg-gray-100 border rounded p-2 text-sm" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-bold text-gray-500 mb-1", children: t2("taluk") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                value: formData.metadata.taluk,
                onChange: (e) => updateField("metadata", "taluk", e.target.value),
                className: "w-full border rounded p-2 text-sm",
                placeholder: "Taluk Name"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-bold text-gray-500 mb-1", children: t2("godownId") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "select",
              {
                value: formData.metadata.godownId,
                onChange: (e) => updateField("metadata", "godownId", e.target.value),
                className: "w-full border rounded p-2 text-sm",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: "Select Godown..." }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "TNJ001", children: "TNJ001 - Thanjavur Main" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "TNJ002", children: "TNJ002 - Kumbakonam Central" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "MDU005", children: "MDU005 - Madurai Kappalur" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "CHE012", children: "CHE012 - Ambattur FCI" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "TVR008", children: "TVR008 - Mannargudi DPC" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "CBE003", children: "CBE003 - Coimbatore West" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "VPM004", children: "VPM004 - Villupuram Junction" })
                ]
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-bold text-gray-500 mb-1", children: "Upload Photo" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "cursor-pointer bg-blue-50 text-blue-600 px-3 py-2 rounded text-xs font-bold border border-blue-200 hover:bg-blue-100 flex items-center gap-1", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Camera, { size: 14 }),
                " Capture / Upload",
                /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "file", className: "hidden", accept: "image/*", onChange: (e) => updateField("metadata", "photo", e.target.files[0]) })
              ] }),
              formData.metadata.photo && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-green-600 font-bold", children: " Attached" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-bold text-gray-500 mb-1", children: t2("inspectionType") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "select",
              {
                value: formData.metadata.inspectionType,
                onChange: (e) => updateField("metadata", "inspectionType", e.target.value),
                className: "w-full border rounded p-2 text-sm",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "Routine", children: t2("routine") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "Surprise", children: t2("surprise") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "Special", children: t2("special") })
                ]
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-bold text-gray-500 mb-1", children: t2("designation") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "select",
              {
                value: formData.metadata.designation,
                onChange: (e) => updateField("metadata", "designation", e.target.value),
                className: "w-full border rounded p-2 text-sm",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "Inspector", children: t2("inspector") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "TSO", children: t2("tso") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "DSO", children: t2("dso") })
                ]
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-bold text-gray-500 mb-1", children: t2("teamMembers") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                value: formData.metadata.teamMembers,
                onChange: (e) => updateField("metadata", "teamMembers", e.target.value),
                className: "w-full border rounded p-2 text-sm",
                placeholder: "Names..."
              }
            )
          ] })
        ] })
      ] });
      const renderStep2_Checklist = () => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4 animate-in fade-in slide-in-from-right-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-bold text-blue-800 border-b pb-2 mb-4", children: t2("checklist") }),
        [
          { key: "stockPosition", label: t2("stockPosition") },
          { key: "qualityCondition", label: t2("qualityCondition") },
          { key: "storageSafety", label: t2("storageSafety") },
          { key: "recordsMaintained", label: t2("recordsMaintained") },
          { key: "cleanliness", label: t2("cleanliness") }
        ].map((item) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-2 bg-gray-50 rounded border", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium text-gray-700", children: item.label }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: () => updateField("checklist", item.key, "Yes"),
                className: `px-3 py-1 rounded text-xs font-bold ${formData.checklist[item.key] === "Yes" ? "bg-green-600 text-white" : "bg-gray-200 text-gray-600"}`,
                children: t2("yes")
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: () => updateField("checklist", item.key, "No"),
                className: `px-3 py-1 rounded text-xs font-bold ${formData.checklist[item.key] === "No" ? "bg-red-500 text-white" : "bg-gray-200 text-gray-600"}`,
                children: t2("no")
              }
            )
          ] })
        ] }, item.key)),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "textarea",
          {
            className: "w-full border rounded p-2 text-sm mt-4",
            rows: "2",
            placeholder: "Overall Remarks / Observations...",
            value: formData.checklist.remarks,
            onChange: (e) => updateField("checklist", "remarks", e.target.value)
          }
        )
      ] });
      const renderStep3_Compliance = () => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4 animate-in fade-in slide-in-from-right-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-bold text-orange-800 border-b pb-2 mb-4", children: t2("compliance") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-bold text-gray-700 mb-2", children: t2("rulesFollowed") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center gap-2 cursor-pointer", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "radio",
                  name: "rules",
                  checked: formData.compliance.rulesFollowed === "Yes",
                  onChange: () => updateField("compliance", "rulesFollowed", "Yes")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm", children: "Fully Compliant" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center gap-2 cursor-pointer", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "radio",
                  name: "rules",
                  checked: formData.compliance.rulesFollowed === "No",
                  onChange: () => updateField("compliance", "rulesFollowed", "No")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-bold text-red-600", children: "Deviations Found" })
            ] })
          ] })
        ] }),
        formData.compliance.rulesFollowed === "No" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-red-50 p-3 rounded border border-red-200", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-bold text-red-800 mb-1", children: t2("irregularities") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "select",
            {
              className: "w-full border rounded p-2 text-sm text-red-700 font-medium",
              onChange: (e) => {
                const val = e.target.value;
                if (val && !formData.compliance.irregularities.includes(val)) {
                  updateField("compliance", "irregularities", [...formData.compliance.irregularities, val]);
                }
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: "Select Irregularity Type..." }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "Shortage", children: "Stock Shortage (Physical vs Book)" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "Diversion", children: "Suspected Diversion" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "Quality", children: "Poor Quality / Adulteration" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "Records", children: "Record Tampering" })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap gap-2 mt-2", children: formData.compliance.irregularities.map((irr, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "bg-red-200 text-red-800 text-xs px-2 py-1 rounded-full font-bold flex items-center gap-1", children: [
            irr,
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", onClick: () => {
              const newList = formData.compliance.irregularities.filter((i) => i !== irr);
              updateField("compliance", "irregularities", newList);
            }, children: "" })
          ] }, idx)) })
        ] })
      ] });
      const renderStep4_Action = () => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4 animate-in fade-in slide-in-from-right-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-bold text-purple-800 border-b pb-2 mb-4", children: t2("action") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: t2("recommendations") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "textarea",
            {
              className: "w-full border rounded p-2 text-sm h-24",
              placeholder: "Directives given to Godown In-charge...",
              value: formData.action.recommendations,
              onChange: (e) => updateField("action", "recommendations", e.target.value)
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: t2("deadline") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "date",
              className: "w-full border rounded p-2 text-sm",
              value: formData.action.deadline,
              onChange: (e) => updateField("action", "deadline", e.target.value)
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3 mt-4 pt-4 border-t", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              id: "disciplinary",
              className: "w-5 h-5 text-red-600 rounded",
              checked: formData.action.disciplinaryRecommended,
              onChange: (e) => updateField("action", "disciplinaryRecommended", e.target.checked)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "disciplinary", className: "text-sm font-bold text-red-700 cursor-pointer", children: t2("disciplinary") })
        ] }),
        formData.action.disciplinaryRecommended && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-red-500 mt-1 pl-8", children: " This will escalate the report directly to the Vigilance Cell." })
      ] });
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl shadow-2xl w-full max-w-2xl overflow-hidden flex flex-col max-h-[90vh]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-5 border-b border-gray-100 flex justify-between items-center bg-slate-50", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-bold text-xl text-slate-800", children: t2("inspectionReport") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-slate-500 font-medium mt-1", children: [
              "Step ",
              step,
              " of 4: ",
              step === 1 ? t2("metadata") : step === 2 ? t2("checklist") : step === 3 ? t2("compliance") : t2("action")
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: onClose, className: "p-2 bg-white rounded-full hover:bg-red-50 text-slate-400 hover:text-red-500 transition-colors shadow-sm border border-slate-100", children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { size: 20 }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full bg-gray-100 h-1.5", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "bg-emerald-500 h-1.5 transition-all duration-300 ease-out",
            style: { width: `${step / 4 * 100}%` }
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, className: "flex-1 overflow-y-auto p-6 md:p-8", children: [
          step === 1 && renderStep1_Metadata(),
          step === 2 && renderStep2_Checklist(),
          step === 3 && renderStep3_Compliance(),
          step === 4 && renderStep4_Action()
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-5 border-t border-gray-100 bg-gray-50 flex justify-between items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              onClick: () => step > 1 ? setStep(step - 1) : onClose(),
              className: "px-6 py-2.5 rounded-lg text-sm font-bold text-slate-600 hover:bg-white hover:shadow-sm border border-transparent hover:border-slate-200 transition-all flex items-center gap-2",
              children: step > 1 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronLeft, { size: 16 }),
                " Back"
              ] }) : t2("cancel")
            }
          ),
          step < 4 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              type: "button",
              onClick: () => setStep(step + 1),
              className: "px-6 py-2.5 bg-slate-800 text-white rounded-lg text-sm font-bold hover:bg-slate-700 shadow-lg shadow-slate-200 transition-all flex items-center gap-2",
              children: [
                "Next ",
                /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, { size: 16 })
              ]
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: handleSubmit,
              disabled: submitting,
              className: "px-8 py-2.5 bg-emerald-600 text-white rounded-lg text-sm font-bold hover:bg-emerald-500 shadow-lg shadow-emerald-200 transition-all flex items-center gap-2",
              children: submitting ? "Submitting..." : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                t2("submit"),
                " ",
                /* @__PURE__ */ jsxRuntimeExports.jsx(Save, { size: 16 })
              ] })
            }
          )
        ] })
      ] }) });
    };
    const WeekendDataForm = ({ onClose }) => {
      const { t: t2 } = useLanguage();
      const [submitting, setSubmitting] = reactExports.useState(false);
      const handleSubmit = (e) => __async(exports, null, function* () {
        e.preventDefault();
        setSubmitting(true);
        const formData = new FormData(e.target);
        const data = Object.fromEntries(formData.entries());
        try {
          const response = yield fetch("/api/reports/weekend", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(data)
          });
          if (response.ok) {
            alert("Weekend Data Submitted Successfully");
            onClose();
          }
        } catch (error) {
          console.error("Submission failed", error);
        } finally {
          setSubmitting(false);
        }
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-lg shadow-xl w-full max-w-md overflow-hidden", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 border-b border-gray-200 flex justify-between items-center bg-blue-50", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-bold text-gray-800", children: t2("uploadWeekend") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: onClose, className: "text-gray-500 hover:text-gray-700", children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { size: 20 }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, className: "p-4 space-y-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: t2("weekNumber") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("input", { name: "weekNumber", type: "number", required: true, className: "w-full border rounded p-2 text-sm", placeholder: "e.g., 42" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: t2("godownId") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("input", { name: "godownId", type: "text", required: true, className: "w-full border rounded p-2 text-sm", placeholder: "e.g., ALL or Specific ID" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: t2("stockLevel") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("input", { name: "stockLevel", type: "number", required: true, className: "w-full border rounded p-2 text-sm" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: t2("staffAttendance") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("input", { name: "staffAttendance", type: "number", min: "0", max: "100", className: "w-full border rounded p-2 text-sm" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: t2("maintenance") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("textarea", { name: "maintenance", rows: "2", className: "w-full border rounded p-2 text-sm", placeholder: "Any maintenance required..." })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pt-2 flex gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: onClose,
                className: "flex-1 py-2 border border-gray-300 rounded text-gray-600 text-sm font-medium hover:bg-gray-50",
                children: t2("cancel")
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "submit",
                disabled: submitting,
                className: "flex-1 py-2 bg-blue-600 text-white rounded text-sm font-medium hover:bg-blue-700 disabled:opacity-50",
                children: submitting ? "Sending..." : t2("submit")
              }
            )
          ] })
        ] })
      ] }) });
    };
    const Icons = {
      Camera: () => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xl", children: "" }),
      Clock: () => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-400 text-xs", children: "" }),
      Back: () => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" })
    };
    const FieldDashboard = () => {
      var _a, _b, _c;
      const { t: t2, language, toggleLanguage } = useLanguage();
      const navigate = useNavigate();
      const handleLogout = () => navigate("/");
      const [filter, setFilter] = reactExports.useState("All");
      const [uploadedFile, setUploadedFile] = reactExports.useState(null);
      const [selectedTask, setSelectedTask] = reactExports.useState(null);
      const [remarks, setRemarks] = reactExports.useState("");
      const [showComplete, setShowComplete] = reactExports.useState(false);
      const [showUpload, setShowUpload] = reactExports.useState(false);
      const [showFieldReport, setShowFieldReport] = reactExports.useState(false);
      const [showWeekendReport, setShowWeekendReport] = reactExports.useState(false);
      const formatDate = (dateString) => {
        return new Date(dateString).toLocaleDateString("en-GB", {
          day: "2-digit",
          month: "short",
          year: "numeric"
        });
      };
      const [tasks, setTasks] = reactExports.useState([
        {
          id: 1,
          title: "Routine Inspection - TNJ001",
          location: "Thanjavur Main Godown",
          priority: "Normal",
          dueDate: "2025-12-15",
          status: "Pending",
          riskReason: "",
          instructions: "Verify stock position of Paddy (Common) and check for pest activity.",
          metrics: { stock: "12,400 MT", humidity: "13%", age: "24 Days" }
        },
        {
          id: 2,
          title: "Urgent: Moisture Alert - TVR008",
          location: "Mannargudi DPC",
          priority: "Critical",
          dueDate: "2025-12-14",
          status: "Pending",
          riskReason: "IoT Sensor reported 18% Moisture",
          instructions: "Inspect Stack 4 immediately. Check for roof leaks or improved ventilation needs.",
          metrics: { stock: "5,000 MT", humidity: "18% ", age: "12 Days" }
        },
        {
          id: 3,
          title: "Stock Audit - MDU005",
          location: "Madurai Kappalur",
          priority: "High",
          dueDate: "2025-12-16",
          status: "Pending",
          riskReason: "Discrepancy in SAP vs Physical",
          instructions: "Full physical weighment required for Wheat stock.",
          metrics: { stock: "12,000 MT", humidity: "11%", age: "45 Days" }
        },
        {
          id: 4,
          title: "Safety Compliance Check",
          location: "Coimbatore West",
          priority: "Normal",
          dueDate: "2025-12-13",
          status: "Completed",
          completedAt: "2025-12-13T10:30:00Z",
          remarks: "All safety norms followed. Fire extinguishers refilled.",
          riskReason: "",
          metrics: { stock: "10,000 MT", humidity: "12%", age: "60 Days" }
        }
      ]);
      const filteredTasks = tasks.filter((t22) => {
        if (filter === "All") return true;
        if (filter === "Critical") return t22.priority === "Critical";
        if (filter === "Pending") return t22.status === "Pending";
        if (filter === "Completed") return t22.status === "Completed";
        return true;
      });
      const handlePhotoUpload = (e) => {
        const file = e.target.files[0];
        if (file) {
          setUploadedFile(URL.createObjectURL(file));
        }
      };
      const submitCompletion = () => {
        const updatedTasks = tasks.map(
          (t22) => t22.id === selectedTask.id ? __spreadProps(__spreadValues({}, t22), { status: "Completed", completedAt: (/* @__PURE__ */ new Date()).toISOString(), remarks, photo: uploadedFile }) : t22
        );
        setTasks(updatedTasks);
        setShowComplete(false);
        setShowUpload(false);
        setSelectedTask(null);
        setUploadedFile(null);
        setRemarks("");
        alert("Task Synced to HQ!");
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "h-screen bg-gray-50 flex flex-col font-sans", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { className: "bg-green-700 text-white p-4 shadow flex justify-between items-center z-10", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "https://upload.wikimedia.org/wikipedia/commons/8/83/TamilNadu_Logo.svg", alt: "TN Emblem", className: "w-10 h-10 brightness-0 invert" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "font-bold text-sm leading-tight uppercase tracking-wide", children: t2("tncscFull") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "font-bold text-lg text-emerald-100", children: t2("fieldOps") })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: toggleLanguage,
                className: "text-xs bg-green-800 px-3 py-1 rounded border border-green-600 font-bold",
                children: language === "en" ? "TA" : "EN"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: handleLogout, className: "text-xs bg-green-800 px-3 py-1 rounded border border-green-600", children: t2("signOut") })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-3 flex gap-3 border-b overflow-x-auto", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: () => setShowFieldReport(true),
              className: "flex-1 bg-blue-50 text-blue-700 text-xs font-bold py-2 px-4 rounded border border-blue-100 whitespace-nowrap",
              children: [
                "+ ",
                t2("uploadReport")
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: () => setShowWeekendReport(true),
              className: "flex-1 bg-orange-50 text-orange-700 text-xs font-bold py-2 px-4 rounded border border-orange-100 whitespace-nowrap",
              children: [
                "+ ",
                t2("uploadWeekend")
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white p-2 flex gap-2 overflow-x-auto shadow-sm border-b", children: ["All", "Critical", "Pending", "Completed"].map((f2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => setFilter(f2),
            className: `px-3 py-1 rounded-full text-xs font-bold whitespace-nowrap ${filter === f2 ? "bg-green-100 text-green-800 border border-green-200" : "bg-gray-100 text-gray-600 border border-gray-200"}`,
            children: f2
          },
          f2
        )) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 overflow-y-auto p-4 space-y-3", children: filteredTasks.map((task2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            onClick: () => setSelectedTask(task2),
            className: `bg-white p-4 rounded-lg shadow-sm border-l-4 cursor-pointer active:scale-95 transition-transform ${task2.status === "Completed" ? "border-gray-400 opacity-60" : task2.priority === "Critical" ? "border-red-500" : task2.priority === "High" ? "border-orange-500" : "border-blue-500"}`,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-start mb-1", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs font-bold text-gray-500 uppercase tracking-wide", children: task2.location }),
                task2.status === "Completed" ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bg-gray-200 text-gray-600 text-[10px] px-2 py-0.5 rounded-full font-bold", children: "Done" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `text-[10px] px-2 py-0.5 rounded-full font-bold text-white ${task2.priority === "Critical" ? "bg-red-500" : task2.priority === "High" ? "bg-orange-500" : "bg-blue-500"}`, children: task2.priority })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-bold text-gray-800", children: task2.title }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 mt-2 text-xs text-gray-500", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Icons.Clock, {}),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                  "Due: ",
                  formatDate(task2.dueDate)
                ] })
              ] })
            ]
          },
          task2.id
        )) }),
        selectedTask && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed inset-0 bg-black bg-opacity-50 z-50 flex justify-end", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full max-w-md bg-white h-full shadow-2xl flex flex-col animate-slide-in", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 border-b flex items-center justify-between bg-gray-50", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: () => setSelectedTask(null), className: "p-2 hover:bg-gray-200 rounded-full", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Icons.Back, {}),
              " Back"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-gray-700", children: "Task Details" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-8" }),
            " "
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 overflow-y-auto p-5", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-800 mb-1", children: selectedTask.title }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-gray-500 mb-4 flex items-center gap-2", children: [
              " ",
              selectedTask.location,
              /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "#", className: "text-blue-600 text-xs underline ml-2", children: "View on Map" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-red-50 border border-red-200 p-3 rounded-md mb-6", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-red-800 font-bold text-xs uppercase mb-1", children: "Risk Factor" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-red-900 text-sm", children: selectedTask.riskReason || "Routine Inspection" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-3 mb-6", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gray-50 p-3 rounded text-center border", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-gray-500", children: "Stock" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-bold text-gray-800", children: (_a = selectedTask.metrics) == null ? void 0 : _a.stock })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gray-50 p-3 rounded text-center border", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-gray-500", children: "Humidity" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-bold text-gray-800", children: (_b = selectedTask.metrics) == null ? void 0 : _b.humidity })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gray-50 p-3 rounded text-center border", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-gray-500", children: "Age" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-bold text-gray-800", children: (_c = selectedTask.metrics) == null ? void 0 : _c.age })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-8", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-bold text-gray-700 mb-2", children: " Instructions" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 text-sm leading-relaxed p-3 bg-blue-50 rounded border border-blue-100", children: selectedTask.instructions || "No specific instructions. Perform standard verify." })
            ] }),
            selectedTask.status === "Completed" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-green-50 p-4 rounded border border-green-200 mb-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-green-800 font-bold text-sm", children: [
                " Completed on ",
                new Date(selectedTask.completedAt).toLocaleTimeString()
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-green-700 text-sm italic mt-1", children: [
                '"',
                selectedTask.remarks,
                '"'
              ] })
            ] })
          ] }),
          selectedTask.status !== "Completed" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 border-t bg-white flex gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                onClick: () => setShowUpload(true),
                className: "flex-1 bg-gray-100 text-gray-700 py-3 rounded-lg font-bold border border-gray-300 flex items-center justify-center gap-2",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Icons.Camera, {}),
                  " Photo"
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => setShowComplete(true),
                className: "flex-[2] bg-green-600 text-white py-3 rounded-lg font-bold shadow-lg hover:bg-green-700",
                children: "Mark Complete"
              }
            )
          ] })
        ] }) }),
        showUpload && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed inset-0 z-[60] bg-black bg-opacity-70 flex items-center justify-center p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white w-full max-w-sm rounded-xl p-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-bold text-lg mb-4", children: "Upload Evidence" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border-2 border-dashed border-gray-300 rounded-lg h-40 flex flex-col items-center justify-center bg-gray-50 mb-4 relative overflow-hidden", children: [
            uploadedFile ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: uploadedFile, alt: "Preview", className: "h-full w-full object-cover" }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-4xl opacity-20", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-400 text-sm mt-2", children: "Tap to capture" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "file", onChange: handlePhotoUpload, className: "absolute inset-0 opacity-0 w-full h-full cursor-pointer" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => setShowUpload(false), className: "px-4 py-2 text-gray-500 font-bold", children: "Cancel" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => setShowUpload(false), className: "px-4 py-2 bg-blue-600 text-white rounded font-bold", children: "Save" })
          ] })
        ] }) }),
        showComplete && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed inset-0 z-[60] bg-black bg-opacity-70 flex items-center justify-center p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white w-full max-w-sm rounded-xl p-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-bold text-lg mb-4", children: "Complete Task" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500 mb-4", children: "Please add a remark before closing this ticket." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "textarea",
            {
              className: "w-full border rounded-lg p-3 text-sm h-24 mb-4 focus:ring-2 focus:ring-green-500 outline-none",
              placeholder: "e.g., Covered stack with tarpaulin...",
              value: remarks,
              onChange: (e) => setRemarks(e.target.value)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => setShowComplete(false), className: "px-4 py-2 text-gray-500 font-bold", children: "Cancel" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: submitCompletion, className: "px-4 py-2 bg-green-600 text-white rounded font-bold", children: "Submit Report" })
          ] })
        ] }) }),
        showFieldReport && /* @__PURE__ */ jsxRuntimeExports.jsx(FieldReportForm, { onClose: () => setShowFieldReport(false) }),
        showWeekendReport && /* @__PURE__ */ jsxRuntimeExports.jsx(WeekendDataForm, { onClose: () => setShowWeekendReport(false) })
      ] });
    };
    const API_BASE_URL = "https://tncsc-risk-guard.onrender.com/api/v1";
    const MOCK_DATA = {
      "/godowns": {
        success: true,
        data: [
          { id: "TNJ001", name: "Thanjavur Central Godown", district: "Thanjavur", capacity: 5e3, riskScore: 85, lat: 10.787, lng: 79.1378, risk: "High", lastInspection: "2025-12-10", stock: 4250, humidity: 82 },
          { id: "MDU005", name: "Madurai North Godown", district: "Madurai", capacity: 3500, riskScore: 45, lat: 9.9252, lng: 78.1198, risk: "Medium", lastInspection: "2025-12-12", stock: 1200, humidity: 65 },
          { id: "CBE002", name: "Coimbatore Logistics Hub", district: "Coimbatore", capacity: 8e3, riskScore: 12, lat: 11.0168, lng: 76.9558, risk: "Low", lastInspection: "2025-12-14", stock: 6800, humidity: 55 },
          { id: "CHE009", name: "Chennai Harbor Storage", district: "Chennai", capacity: 12e3, riskScore: 92, lat: 13.0827, lng: 80.2707, risk: "High", lastInspection: "2025-12-08", stock: 11500, humidity: 88 },
          { id: "SAL003", name: "Salem Regional Warehouse", district: "Salem", capacity: 4200, riskScore: 30, lat: 11.6643, lng: 78.146, risk: "Low", lastInspection: "2025-12-11", stock: 2100, humidity: 60 }
        ]
      },
      "/stock/lots": [
        { id: 1, stackNo: "S-01", commodity: "Paddy", grade: "A", bags: 150, weight: 7.5, moisture: "13.2", age: 45 },
        { id: 2, stackNo: "S-02", commodity: "Rice", grade: "Common", bags: 200, weight: 10, moisture: "11.5", age: 12 },
        { id: 3, stackNo: "S-03", commodity: "Wheat", grade: "FAQ", bags: 120, weight: 6, moisture: "10.8", age: 95 },
        { id: 4, stackNo: "S-04", commodity: "Paddy", grade: "A", bags: 180, weight: 9, moisture: "14.5", age: 60 },
        { id: 5, stackNo: "S-05", commodity: "Rice", grade: "A", bags: 300, weight: 15, moisture: "11.2", age: 5 }
      ],
      "/reports/dashboard": {
        success: true,
        data: {
          totalGodowns: 342,
          highRiskGodowns: 15,
          spoilagePreventedValue: "4.2 Cr",
          procurementEfficiency: "94%"
        }
      },
      // Movement Mocks
      "/api/movement/inward": [
        { id: 1, date: "2025-12-14", truckNo: "TN-45-AZ-1234", commodity: "Paddy", bags: 450, weight: 22.5, from: "Thanjavur CPC", status: "Arrived" },
        { id: 2, date: "2025-12-14", truckNo: "TN-67-H-9876", commodity: "Wheat", bags: 200, weight: 10, from: "Madurai Center", status: "In Transit" }
      ],
      "/api/movement/outward": [
        { id: 101, date: "2025-12-14", truckNo: "TN-22-BY-5544", commodity: "Rice", bags: 300, weight: 15, to: "FPS-Trichy-001", status: "Dispatched" },
        { id: 102, date: "2025-12-13", truckNo: "TN-33-ZZ-9988", commodity: "Wheat", bags: 450, weight: 22.5, to: "FPS-Madurai-04", status: "Delivered" },
        { id: 103, date: "2025-12-12", truckNo: "TN-01-AB-1122", commodity: "Sugar", bags: 100, weight: 5, to: "FPS-Chennai-12", status: "Dispatched" }
      ],
      "/api/movement/rail": [
        { id: "R-7788", trainNo: "TK-Express", wagons: 42, commodity: "Rice", eta: "14:30", source: "Punjab", status: "On Time" },
        { id: "R-9900", trainNo: "Goods-404", wagons: 28, commodity: "Wheat", eta: "18:45", source: "Andhra", status: "Delayed" }
      ],
      // Analytics Mocks
      "/api/analytics/kpi": {
        riskScore: 72,
        activeAlerts: 12,
        pendingInspections: 8,
        storageUtilization: 84
      },
      "/api/analytics/risk-trend": [
        { month: "Jan", risk: 45 },
        { month: "Feb", risk: 52 },
        { month: "Mar", risk: 38 },
        { month: "Apr", risk: 65 },
        { month: "May", risk: 58 },
        { month: "Jun", risk: 72 }
      ],
      "/api/analytics/district-stats": [
        { name: "Thanjavur", risk: 85 },
        { name: "Madurai", risk: 60 },
        { name: "Chennai", risk: 40 },
        { name: "Trichy", risk: 55 },
        { name: "Salem", risk: 25 }
      ],
      "/api/analytics/alerts": [
        { id: 1, type: "Moisture", message: "High moisture (14.2%) details in TNJ001", severity: "Critical", time: "2 hrs ago" },
        { id: 2, type: "Stock", message: "Low stock warning in MDU005", severity: "Warning", time: "5 hrs ago" }
      ]
    };
    const api = {
      get: (endpoint) => __async(exports, null, function* () {
        try {
          if (window.location.hostname.includes("github.io") || window.location.hostname.includes("localhost")) {
            console.warn("Using Mock Data for:", endpoint);
            if (MOCK_DATA[endpoint]) return MOCK_DATA[endpoint];
            if (endpoint.includes("/api/godowns/")) {
              const id2 = endpoint.split("/").pop();
              const godownProxy = MOCK_DATA["/godowns"].data.find((g) => g.id === id2);
              if (godownProxy) return godownProxy;
              return MOCK_DATA["/godowns"].data[0];
            }
            if (endpoint.includes("/api/stock/lots/")) {
              return MOCK_DATA["/stock/lots"];
            }
            const partialKey = Object.keys(MOCK_DATA).find((k2) => endpoint.endsWith(k2));
            if (partialKey) return MOCK_DATA[partialKey];
          }
          const response = yield fetch(`${API_BASE_URL}${endpoint}`);
          if (!response.ok) throw new Error(`API Error: ${response.status}`);
          return yield response.json();
        } catch (error) {
          console.error("API Request Failed:", error);
          if (endpoint.includes("/godowns")) return MOCK_DATA["/godowns"];
          if (endpoint.includes("movement/outward")) return MOCK_DATA["/api/movement/outward"];
          if (endpoint.includes("movement/rail")) return MOCK_DATA["/api/movement/rail"];
          throw error;
        }
      }),
      post: (endpoint, data) => __async(exports, null, function* () {
        try {
          if (window.location.hostname.includes("github.io")) {
            console.log("Mock POST success");
            return { success: true, message: "Operation simulated successfully (Static Mode)" };
          }
          const response = yield fetch(`${API_BASE_URL}${endpoint}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(data)
          });
          if (!response.ok) throw new Error(`API Error: ${response.status}`);
          return yield response.json();
        } catch (error) {
          console.error("API Request Failed:", error);
          throw error;
        }
      })
    };
    const LoadingSpinner = ({ size = "md", text = "Loading..." }) => {
      const sizeClasses = {
        sm: "w-5 h-5",
        md: "w-8 h-8",
        lg: "w-12 h-12"
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center justify-center p-8 space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `relative ${sizeClasses[size]}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 border-4 border-slate-200 rounded-full" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 border-4 border-blue-600 rounded-full border-t-transparent animate-spin" })
        ] }),
        text && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-slate-500 font-medium text-sm animate-pulse", children: text })
      ] });
    };
    const RiskFactor = ({ label, level, details, icon: icon2 }) => {
      const getColor = (l2) => {
        if (l2 === "Critical") return "bg-red-100 text-red-700 border-red-200";
        if (l2 === "Moderate") return "bg-orange-100 text-orange-700 border-orange-200";
        return "bg-emerald-100 text-emerald-700 border-emerald-200";
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-4 rounded-xl border border-slate-200 shadow-sm flex items-start gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `p-3 rounded-lg ${getColor(level)} bg-opacity-20`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xl", children: icon2 }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-bold text-slate-800", children: label }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `inline-block px-2 py-0.5 rounded text-xs font-bold mt-1 mb-2 ${getColor(level)}`, children: [
            level,
            " Risk"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-slate-500 leading-relaxed", children: details })
        ] })
      ] });
    };
    const AssetInventoryWidget = ({ assets }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl border border-slate-200 shadow-sm overflow-hidden h-fit mt-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 border-b border-slate-100 flex justify-between items-center bg-slate-50", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "font-bold text-slate-800 flex items-center gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
          " Asset Inventory"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "text-xs text-blue-600 font-bold hover:underline", children: "Request Stock" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "divide-y divide-slate-100", children: assets.map((asset, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 flex items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-bold text-slate-700 text-sm", children: asset.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-slate-500 mt-1", children: [
            "Required: ",
            asset.required
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-right", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `font-bold text-lg ${asset.current < asset.required ? "text-red-600" : "text-emerald-600"}`, children: asset.current }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-[10px] font-bold text-slate-400 uppercase", children: "Available" })
        ] })
      ] }, index)) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-3 bg-red-50 text-red-700 text-xs font-bold text-center border-t border-red-100", children: " Low Stock Alert: Tarpaulins (15x30)" })
    ] });
    const GodownDetails = () => {
      const { id: id2 } = useParams();
      const navigate = useNavigate();
      const { t: t2 } = useLanguage();
      const [godown, setGodown] = reactExports.useState(null);
      const [lots, setLots] = reactExports.useState([]);
      const [movements, setMovements] = reactExports.useState([]);
      const [rail, setRail] = reactExports.useState([]);
      const riskFactors = [
        { label: "Pest Control", level: "Critical", icon: "", details: "Weevil infestation detected in Stack 4. Fumigation overdue by 5 days." },
        { label: "Moisture Levels", level: "Moderate", icon: "", details: "Slight elevation in Sector B (13.5%). Requires aeration." },
        { label: "Infrastructure", level: "Low", icon: "", details: "Roof integrity matches standards. No leaks reported in last rain." },
        { label: "Stack Safety", level: "Moderate", icon: "", details: "Stack #12 leaning slightly. Needs restacking protocol." }
      ];
      const assets = [
        { name: "Tarpaulins (15'x30')", current: 42, required: 60 },
        { name: "Moisture Meters", current: 5, required: 5 },
        { name: "Sprayers (Weedicide)", current: 2, required: 3 },
        { name: "Dunnage (Wooden)", current: 120, required: 150 }
      ];
      reactExports.useEffect(() => {
        api.get(`/api/godowns/${id2}`).then(setGodown).catch((e) => console.error(e));
        api.get(`/api/stock/lots/${id2}`).then(setLots).catch((e) => console.error(e));
        api.get("/api/movement/outward").then((data) => setMovements(data.slice(0, 3))).catch((e) => console.error(e));
        api.get("/api/movement/rail").then((data) => setRail(data.slice(0, 2))).catch((e) => console.error(e));
      }, [id2]);
      if (!godown) return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "min-h-screen flex items-center justify-center bg-slate-50", children: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, { text: "Fetching Godown Details...", size: "lg" }) });
      const getRiskColor = (risk) => {
        if (risk === "High") return "bg-red-500";
        if (risk === "Medium") return "bg-orange-500";
        return "bg-emerald-500";
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen bg-slate-50 font-sans text-slate-900 pb-12", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-slate-900 text-white p-6 shadow-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-7xl mx-auto flex justify-between items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => navigate(-1), className: "text-slate-400 hover:text-white transition-colors", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-2xl", children: "" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-2xl font-bold", children: godown.name }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 text-sm text-slate-400", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                  "ID: G-",
                  id2.padStart(3, "0")
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                  "Lat: ",
                  godown.lat,
                  ", Lng: ",
                  godown.lng
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "a",
                  {
                    href: `https://www.google.com/maps?layer=c&cbll=${godown.lat},${godown.lng}`,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    className: "ml-2 bg-blue-600 hover:bg-blue-500 text-white text-xs px-2 py-1 rounded-md font-bold no-underline inline-flex items-center gap-1",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
                      " Street View"
                    ]
                  }
                )
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `px-4 py-1 rounded-full text-sm font-bold ${getRiskColor(godown.risk)}`, children: [
              godown.risk,
              " Risk"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-right text-xs text-slate-400", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Last Inspection" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-bold text-white", children: godown.lastInspection })
            ] })
          ] })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-7xl mx-auto p-6 space-y-8", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "text-lg font-bold text-slate-800 mb-4 flex items-center gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-red-600", children: "" }),
              " Risk Factor Analysis"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4", children: riskFactors.map((factor, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(RiskFactor, __spreadValues({}, factor), index)) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(AssetInventoryWidget, { assets })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-4 gap-6", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-6 rounded-xl shadow-sm border border-slate-200", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-slate-500 font-bold uppercase mb-1", children: t2("stockLevel") || "Current Stock" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-3xl font-bold text-slate-800", children: [
                godown.stock,
                " MT"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-emerald-600 font-bold mt-2", children: " 12% vs Last Month" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-6 rounded-xl shadow-sm border border-slate-200", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-slate-500 font-bold uppercase mb-1", children: "Capacity Used" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-3xl font-bold text-blue-600", children: "85%" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full bg-slate-200 h-2 rounded-full mt-2 overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-blue-600 h-full w-[85%]" }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-6 rounded-xl shadow-sm border border-slate-200", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-slate-500 font-bold uppercase mb-1", children: t2("humidityThreshold") || "Avg Humidity" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `text-3xl font-bold ${godown.humidity > 80 ? "text-red-600" : "text-slate-800"}`, children: [
                godown.humidity,
                "%"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-slate-400 font-bold mt-2", children: "Sensor Active" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-6 rounded-xl shadow-sm border border-slate-200", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-slate-500 font-bold uppercase mb-1", children: "Stock Value" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-3xl font-bold text-slate-800", children: " 2.5 Cr" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-slate-400 font-bold mt-2", children: "Estimated" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6 border-b border-slate-100 flex justify-between items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-bold text-slate-800", children: t2("stockLots") || "Live Stock Position" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "px-4 py-2 bg-blue-50 text-blue-700 text-sm font-bold rounded-lg hover:bg-blue-100", children: "Download Report" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "w-full text-sm text-left", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { className: "text-xs text-slate-500 uppercase bg-slate-50 border-b", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: "Stack No" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: "Commodity" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: "Grade" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-right", children: "Bags" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-right", children: "Weight" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-center", children: "Moisture" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-center", children: "Age" })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { className: "divide-y divide-slate-100", children: lots.map((lot) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: "hover:bg-slate-50", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 font-mono font-bold text-slate-700", children: lot.stackNo }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 font-bold", children: lot.commodity }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bg-slate-100 px-2 py-1 rounded text-xs font-bold text-slate-600", children: lot.grade }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 text-right text-slate-600", children: lot.bags }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 text-right font-bold text-slate-800", children: lot.weight }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 text-center", children: lot.moisture === "N/A" ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-slate-400", children: "-" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `px-2 py-1 rounded text-xs font-bold ${parseFloat(lot.moisture) > 13 ? "bg-red-100 text-red-700" : "bg-green-100 text-green-700"}`, children: lot.moisture }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center gap-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `w-2 h-2 rounded-full ${parseInt(lot.age) > 90 ? "bg-red-500" : "bg-green-500"}` }),
                  lot.age
                ] }) })
              ] }, lot.id)) })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gradient-to-r from-orange-50 to-amber-50 rounded-xl shadow-sm border border-orange-100 overflow-hidden mb-6", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6 border-b border-orange-200/50 flex items-center justify-between", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-2xl", children: "" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-bold text-orange-900", children: t2("expectedRail") || "Expected Rail Arrivals" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs bg-orange-200 text-orange-800 px-2 py-1 rounded-lg font-bold", children: "GPS Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-0", children: rail.map((r2, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-4 border-b border-orange-200/50 last:border-0 hover:bg-orange-100/50", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "font-bold text-orange-950", children: [
                  r2.trainNo,
                  " - ",
                  r2.wagons,
                  " Wagons"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-orange-700", children: [
                  r2.commodity,
                  "  From ",
                  r2.source
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-right", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-bold text-orange-900", children: r2.eta }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-orange-600 italic", children: r2.status })
              ] })
            ] }, i)) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-6 border-b border-slate-100", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-bold text-slate-800", children: "Recent Movement" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-0", children: movements.map((move, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-4 border-b last:border-0 hover:bg-slate-50", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-10 h-10 rounded-full bg-blue-100 text-blue-600 flex items-center justify-center font-bold text-lg", children: "" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "font-bold text-slate-800", children: [
                    move.commodity,
                    " - ",
                    move.quantity
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-slate-500", children: [
                    move.truckNo,
                    "  ",
                    move.destination
                  ] })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-right", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs font-bold bg-slate-100 text-slate-600 px-2 py-1 rounded", children: move.status }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-slate-400 mt-1", children: move.date })
              ] })
            ] }, i)) })
          ] })
        ] })
      ] });
    };
    const SidebarItem = ({ icon: Icon2, label, path, isActive, onClick }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Link,
      {
        to: path,
        onClick,
        className: `flex items-center space-x-3 px-4 py-3 rounded-lg transition-colors ${isActive ? "bg-blue-50 text-blue-700" : "text-slate-600 hover:bg-slate-50 hover:text-slate-900"}`,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Icon2, { size: 20 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: label })
        ]
      }
    );
    const DashboardLayout = () => {
      var _a;
      const [isSidebarOpen, setIsSidebarOpen] = reactExports.useState(false);
      const location = useLocation();
      const { language, toggleLanguage, t: t2 } = useLanguage();
      const navItems = [
        { icon: LayoutDashboard, label: "navOverview", path: "/dashboard/overview" },
        { icon: Network, label: "navNetwork", path: "/dashboard/network" },
        { icon: Package, label: "navInventory", path: "/dashboard/inventory" },
        { icon: Truck, label: "Logistics", path: "/dashboard/logistics" },
        // New Sidebar Item
        { icon: Bell, label: "navAlerts", path: "/dashboard/alerts" },
        { icon: BarChart3, label: "navAnalytics", path: "/dashboard/analytics" },
        { icon: Settings, label: "navSettings", path: "/dashboard/settings" }
      ];
      const toggleSidebar = () => setIsSidebarOpen(!isSidebarOpen);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen bg-slate-50 flex flex-col md:flex-row", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "md:hidden bg-white border-b p-4 flex justify-between items-center z-20", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: logo, alt: "TNCSC", className: "w-8 h-8" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-slate-800", children: "TNCSC RiskGuard" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: toggleSidebar, className: "p-2 text-slate-600 hover:bg-slate-100 rounded", children: isSidebarOpen ? /* @__PURE__ */ jsxRuntimeExports.jsx(X, { size: 24 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Menu, { size: 24 }) })
        ] }),
        isSidebarOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "fixed inset-0 bg-black/50 z-30 md:hidden",
            onClick: () => setIsSidebarOpen(false)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "aside",
          {
            className: `fixed md:sticky top-0 inset-y-0 left-0 w-64 bg-white border-r z-40 transform transition-transform duration-200 ease-in-out md:translate-x-0 ${isSidebarOpen ? "translate-x-0" : "-translate-x-full"} h-screen flex flex-col`,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6 border-b flex items-center space-x-3", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    src: logo,
                    alt: "TN Emblem",
                    className: "w-10 h-10"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "font-bold text-slate-900 leading-none", children: "RiskGuard" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-[10px] text-emerald-600 uppercase tracking-widest font-bold mt-1", children: t2("govtTN") })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("nav", { className: "flex-1 p-4 space-y-1 overflow-y-auto", children: navItems.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                SidebarItem,
                {
                  icon: item.icon,
                  label: t2(item.label),
                  path: item.path,
                  isActive: location.pathname === item.path,
                  onClick: () => setIsSidebarOpen(false)
                },
                item.path
              )) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 border-t bg-slate-50 mt-auto", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex bg-white rounded-lg p-1 border border-slate-200 mb-4 shadow-sm", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      onClick: () => language !== "en" && toggleLanguage(),
                      className: `flex-1 text-xs font-bold py-1.5 rounded-md transition-all ${language === "en" ? "bg-slate-800 text-white shadow" : "text-slate-500 hover:bg-slate-50"}`,
                      children: "EN"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      onClick: () => language !== "ta" && toggleLanguage(),
                      className: `flex-1 text-xs font-bold py-1.5 rounded-md transition-all ${language === "ta" ? "bg-emerald-600 text-white shadow" : "text-slate-500 hover:bg-slate-50"}`,
                      children: ""
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3 mb-3", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-10 h-10 rounded-full bg-slate-200 flex items-center justify-center text-slate-600 border border-slate-300", children: /* @__PURE__ */ jsxRuntimeExports.jsx(User, { size: 20 }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "overflow-hidden", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-bold text-sm text-slate-900 truncate", children: "Regional Manager" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-slate-500 truncate", children: "Thanjavur Region" })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "flex items-center space-x-2 text-sm text-red-600 hover:text-red-700 w-full px-2 py-1.5 rounded hover:bg-red-50 transition-colors font-bold", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(LogOut, { size: 16 }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("signOut") })
                ] })
              ] })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("main", { className: "flex-1 overflow-y-auto h-[calc(100vh-64px)] md:h-screen", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { className: "hidden md:flex bg-white border-b h-16 items-center justify-between px-8 sticky top-0 z-10", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-semibold text-slate-800", children: t2(((_a = navItems.find((i) => i.path === location.pathname)) == null ? void 0 : _a.label) || "dashboard") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-slate-500", children: "Last updated: Today, 10:30 AM" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  onClick: toggleLanguage,
                  className: "flex items-center space-x-2 px-3 py-1.5 rounded-full bg-blue-50 text-blue-700 hover:bg-blue-100 transition-colors border border-blue-200 text-sm font-medium",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Globe, { size: 16 }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: language === "en" ? "" : "English" })
                  ]
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4 md:p-8 max-w-7xl mx-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Outlet, {}) })
        ] })
      ] });
    };
    function useAttribution(map2, attribution) {
      const attributionRef = reactExports.useRef(attribution);
      reactExports.useEffect(function updateAttribution() {
        if (attribution !== attributionRef.current && map2.attributionControl != null) {
          if (attributionRef.current != null) {
            map2.attributionControl.removeAttribution(attributionRef.current);
          }
          if (attribution != null) {
            map2.attributionControl.addAttribution(attribution);
          }
        }
        attributionRef.current = attribution;
      }, [
        map2,
        attribution
      ]);
    }
    function updateCircle(layer, props, prevProps) {
      if (props.center !== prevProps.center) {
        layer.setLatLng(props.center);
      }
      if (props.radius != null && props.radius !== prevProps.radius) {
        layer.setRadius(props.radius);
      }
    }
    const CONTEXT_VERSION = 1;
    function createLeafletContext(map2) {
      return Object.freeze({
        __version: CONTEXT_VERSION,
        map: map2
      });
    }
    function extendContext(source, extra) {
      return Object.freeze(__spreadValues(__spreadValues({}, source), extra));
    }
    const LeafletContext = reactExports.createContext(null);
    const LeafletProvider = LeafletContext.Provider;
    function useLeafletContext() {
      const context = reactExports.useContext(LeafletContext);
      if (context == null) {
        throw new Error("No context provided: useLeafletContext() can only be used in a descendant of <MapContainer>");
      }
      return context;
    }
    function createContainerComponent(useElement) {
      function ContainerComponent(props, forwardedRef) {
        const { instance, context } = useElement(props).current;
        reactExports.useImperativeHandle(forwardedRef, () => instance);
        return props.children == null ? null : /* @__PURE__ */ React$3.createElement(LeafletProvider, {
          value: context
        }, props.children);
      }
      return /* @__PURE__ */ reactExports.forwardRef(ContainerComponent);
    }
    function createDivOverlayComponent(useElement) {
      function OverlayComponent(props, forwardedRef) {
        const [isOpen, setOpen] = reactExports.useState(false);
        const { instance } = useElement(props, setOpen).current;
        reactExports.useImperativeHandle(forwardedRef, () => instance);
        reactExports.useEffect(function updateOverlay() {
          if (isOpen) {
            instance.update();
          }
        }, [
          instance,
          isOpen,
          props.children
        ]);
        const contentNode = instance._contentNode;
        return contentNode ? /* @__PURE__ */ reactDomExports.createPortal(props.children, contentNode) : null;
      }
      return /* @__PURE__ */ reactExports.forwardRef(OverlayComponent);
    }
    function createLeafComponent(useElement) {
      function LeafComponent(props, forwardedRef) {
        const { instance } = useElement(props).current;
        reactExports.useImperativeHandle(forwardedRef, () => instance);
        return null;
      }
      return /* @__PURE__ */ reactExports.forwardRef(LeafComponent);
    }
    function createControlHook(useElement) {
      return function useLeafletControl(props) {
        const context = useLeafletContext();
        const elementRef = useElement(props, context);
        const { instance } = elementRef.current;
        const positionRef = reactExports.useRef(props.position);
        const { position } = props;
        reactExports.useEffect(function addControl() {
          instance.addTo(context.map);
          return function removeControl() {
            instance.remove();
          };
        }, [
          context.map,
          instance
        ]);
        reactExports.useEffect(function updateControl() {
          if (position != null && position !== positionRef.current) {
            instance.setPosition(position);
            positionRef.current = position;
          }
        }, [
          instance,
          position
        ]);
        return elementRef;
      };
    }
    function useEventHandlers(element, eventHandlers) {
      const eventHandlersRef = reactExports.useRef();
      reactExports.useEffect(function addEventHandlers() {
        if (eventHandlers != null) {
          element.instance.on(eventHandlers);
        }
        eventHandlersRef.current = eventHandlers;
        return function removeEventHandlers() {
          if (eventHandlersRef.current != null) {
            element.instance.off(eventHandlersRef.current);
          }
          eventHandlersRef.current = null;
        };
      }, [
        element,
        eventHandlers
      ]);
    }
    function withPane(props, context) {
      var _a;
      const pane = (_a = props.pane) != null ? _a : context.pane;
      return pane ? __spreadProps(__spreadValues({}, props), {
        pane
      }) : props;
    }
    function createDivOverlayHook(useElement, useLifecycle) {
      return function useDivOverlay(props, setOpen) {
        const context = useLeafletContext();
        const elementRef = useElement(withPane(props, context), context);
        useAttribution(context.map, props.attribution);
        useEventHandlers(elementRef.current, props.eventHandlers);
        useLifecycle(elementRef.current, context, props, setOpen);
        return elementRef;
      };
    }
    var leafletSrc = { exports: {} };
    /* @preserve
     * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
     * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
     */
    (function(module2, exports$1) {
      (function(global2, factory) {
        factory(exports$1);
      })(commonjsGlobal, function(exports$12) {
        var version = "1.9.4";
        function extend2(dest) {
          var i, j, len, src;
          for (j = 1, len = arguments.length; j < len; j++) {
            src = arguments[j];
            for (i in src) {
              dest[i] = src[i];
            }
          }
          return dest;
        }
        var create$2 = Object.create || /* @__PURE__ */ function() {
          function F2() {
          }
          return function(proto) {
            F2.prototype = proto;
            return new F2();
          };
        }();
        function bind(fn, obj) {
          var slice = Array.prototype.slice;
          if (fn.bind) {
            return fn.bind.apply(fn, slice.call(arguments, 1));
          }
          var args = slice.call(arguments, 2);
          return function() {
            return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
          };
        }
        var lastId = 0;
        function stamp(obj) {
          if (!("_leaflet_id" in obj)) {
            obj["_leaflet_id"] = ++lastId;
          }
          return obj._leaflet_id;
        }
        function throttle2(fn, time2, context) {
          var lock, args, wrapperFn, later;
          later = function() {
            lock = false;
            if (args) {
              wrapperFn.apply(context, args);
              args = false;
            }
          };
          wrapperFn = function() {
            if (lock) {
              args = arguments;
            } else {
              fn.apply(context, arguments);
              setTimeout(later, time2);
              lock = true;
            }
          };
          return wrapperFn;
        }
        function wrapNum(x2, range2, includeMax) {
          var max2 = range2[1], min2 = range2[0], d = max2 - min2;
          return x2 === max2 && includeMax ? x2 : ((x2 - min2) % d + d) % d + min2;
        }
        function falseFn() {
          return false;
        }
        function formatNum(num, precision) {
          if (precision === false) {
            return num;
          }
          var pow2 = Math.pow(10, precision === void 0 ? 6 : precision);
          return Math.round(num * pow2) / pow2;
        }
        function trim(str) {
          return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
        }
        function splitWords(str) {
          return trim(str).split(/\s+/);
        }
        function setOptions(obj, options) {
          if (!Object.prototype.hasOwnProperty.call(obj, "options")) {
            obj.options = obj.options ? create$2(obj.options) : {};
          }
          for (var i in options) {
            obj.options[i] = options[i];
          }
          return obj.options;
        }
        function getParamString(obj, existingUrl, uppercase) {
          var params = [];
          for (var i in obj) {
            params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + "=" + encodeURIComponent(obj[i]));
          }
          return (!existingUrl || existingUrl.indexOf("?") === -1 ? "?" : "&") + params.join("&");
        }
        var templateRe = /\{ *([\w_ -]+) *\}/g;
        function template(str, data) {
          return str.replace(templateRe, function(str2, key) {
            var value = data[key];
            if (value === void 0) {
              throw new Error("No value provided for variable " + str2);
            } else if (typeof value === "function") {
              value = value(data);
            }
            return value;
          });
        }
        var isArray2 = Array.isArray || function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
        function indexOf(array2, el2) {
          for (var i = 0; i < array2.length; i++) {
            if (array2[i] === el2) {
              return i;
            }
          }
          return -1;
        }
        var emptyImageUrl = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
        function getPrefixed(name) {
          return window["webkit" + name] || window["moz" + name] || window["ms" + name];
        }
        var lastTime = 0;
        function timeoutDefer(fn) {
          var time2 = +/* @__PURE__ */ new Date(), timeToCall = Math.max(0, 16 - (time2 - lastTime));
          lastTime = time2 + timeToCall;
          return window.setTimeout(fn, timeToCall);
        }
        var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer;
        var cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id2) {
          window.clearTimeout(id2);
        };
        function requestAnimFrame(fn, context, immediate) {
          if (immediate && requestFn === timeoutDefer) {
            fn.call(context);
          } else {
            return requestFn.call(window, bind(fn, context));
          }
        }
        function cancelAnimFrame(id2) {
          if (id2) {
            cancelFn.call(window, id2);
          }
        }
        var Util = {
          __proto__: null,
          extend: extend2,
          create: create$2,
          bind,
          get lastId() {
            return lastId;
          },
          stamp,
          throttle: throttle2,
          wrapNum,
          falseFn,
          formatNum,
          trim,
          splitWords,
          setOptions,
          getParamString,
          template,
          isArray: isArray2,
          indexOf,
          emptyImageUrl,
          requestFn,
          cancelFn,
          requestAnimFrame,
          cancelAnimFrame
        };
        function Class() {
        }
        Class.extend = function(props) {
          var NewClass = function() {
            setOptions(this);
            if (this.initialize) {
              this.initialize.apply(this, arguments);
            }
            this.callInitHooks();
          };
          var parentProto = NewClass.__super__ = this.prototype;
          var proto = create$2(parentProto);
          proto.constructor = NewClass;
          NewClass.prototype = proto;
          for (var i in this) {
            if (Object.prototype.hasOwnProperty.call(this, i) && i !== "prototype" && i !== "__super__") {
              NewClass[i] = this[i];
            }
          }
          if (props.statics) {
            extend2(NewClass, props.statics);
          }
          if (props.includes) {
            checkDeprecatedMixinEvents(props.includes);
            extend2.apply(null, [proto].concat(props.includes));
          }
          extend2(proto, props);
          delete proto.statics;
          delete proto.includes;
          if (proto.options) {
            proto.options = parentProto.options ? create$2(parentProto.options) : {};
            extend2(proto.options, props.options);
          }
          proto._initHooks = [];
          proto.callInitHooks = function() {
            if (this._initHooksCalled) {
              return;
            }
            if (parentProto.callInitHooks) {
              parentProto.callInitHooks.call(this);
            }
            this._initHooksCalled = true;
            for (var i2 = 0, len = proto._initHooks.length; i2 < len; i2++) {
              proto._initHooks[i2].call(this);
            }
          };
          return NewClass;
        };
        Class.include = function(props) {
          var parentOptions = this.prototype.options;
          extend2(this.prototype, props);
          if (props.options) {
            this.prototype.options = parentOptions;
            this.mergeOptions(props.options);
          }
          return this;
        };
        Class.mergeOptions = function(options) {
          extend2(this.prototype.options, options);
          return this;
        };
        Class.addInitHook = function(fn) {
          var args = Array.prototype.slice.call(arguments, 1);
          var init = typeof fn === "function" ? fn : function() {
            this[fn].apply(this, args);
          };
          this.prototype._initHooks = this.prototype._initHooks || [];
          this.prototype._initHooks.push(init);
          return this;
        };
        function checkDeprecatedMixinEvents(includes) {
          if (typeof L === "undefined" || !L || !L.Mixin) {
            return;
          }
          includes = isArray2(includes) ? includes : [includes];
          for (var i = 0; i < includes.length; i++) {
            if (includes[i] === L.Mixin.Events) {
              console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
            }
          }
        }
        var Events = {
          /* @method on(type: String, fn: Function, context?: Object): this
           * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
           *
           * @alternative
           * @method on(eventMap: Object): this
           * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
           */
          on: function(types, fn, context) {
            if (typeof types === "object") {
              for (var type in types) {
                this._on(type, types[type], fn);
              }
            } else {
              types = splitWords(types);
              for (var i = 0, len = types.length; i < len; i++) {
                this._on(types[i], fn, context);
              }
            }
            return this;
          },
          /* @method off(type: String, fn?: Function, context?: Object): this
           * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
           *
           * @alternative
           * @method off(eventMap: Object): this
           * Removes a set of type/listener pairs.
           *
           * @alternative
           * @method off: this
           * Removes all listeners to all events on the object. This includes implicitly attached events.
           */
          off: function(types, fn, context) {
            if (!arguments.length) {
              delete this._events;
            } else if (typeof types === "object") {
              for (var type in types) {
                this._off(type, types[type], fn);
              }
            } else {
              types = splitWords(types);
              var removeAll = arguments.length === 1;
              for (var i = 0, len = types.length; i < len; i++) {
                if (removeAll) {
                  this._off(types[i]);
                } else {
                  this._off(types[i], fn, context);
                }
              }
            }
            return this;
          },
          // attach listener (without syntactic sugar now)
          _on: function(type, fn, context, _once) {
            if (typeof fn !== "function") {
              console.warn("wrong listener type: " + typeof fn);
              return;
            }
            if (this._listens(type, fn, context) !== false) {
              return;
            }
            if (context === this) {
              context = void 0;
            }
            var newListener = { fn, ctx: context };
            if (_once) {
              newListener.once = true;
            }
            this._events = this._events || {};
            this._events[type] = this._events[type] || [];
            this._events[type].push(newListener);
          },
          _off: function(type, fn, context) {
            var listeners, i, len;
            if (!this._events) {
              return;
            }
            listeners = this._events[type];
            if (!listeners) {
              return;
            }
            if (arguments.length === 1) {
              if (this._firingCount) {
                for (i = 0, len = listeners.length; i < len; i++) {
                  listeners[i].fn = falseFn;
                }
              }
              delete this._events[type];
              return;
            }
            if (typeof fn !== "function") {
              console.warn("wrong listener type: " + typeof fn);
              return;
            }
            var index2 = this._listens(type, fn, context);
            if (index2 !== false) {
              var listener2 = listeners[index2];
              if (this._firingCount) {
                listener2.fn = falseFn;
                this._events[type] = listeners = listeners.slice();
              }
              listeners.splice(index2, 1);
            }
          },
          // @method fire(type: String, data?: Object, propagate?: Boolean): this
          // Fires an event of the specified type. You can optionally provide a data
          // object  the first argument of the listener function will contain its
          // properties. The event can optionally be propagated to event parents.
          fire: function(type, data, propagate) {
            if (!this.listens(type, propagate)) {
              return this;
            }
            var event = extend2({}, data, {
              type,
              target: this,
              sourceTarget: data && data.sourceTarget || this
            });
            if (this._events) {
              var listeners = this._events[type];
              if (listeners) {
                this._firingCount = this._firingCount + 1 || 1;
                for (var i = 0, len = listeners.length; i < len; i++) {
                  var l2 = listeners[i];
                  var fn = l2.fn;
                  if (l2.once) {
                    this.off(type, fn, l2.ctx);
                  }
                  fn.call(l2.ctx || this, event);
                }
                this._firingCount--;
              }
            }
            if (propagate) {
              this._propagateEvent(event);
            }
            return this;
          },
          // @method listens(type: String, propagate?: Boolean): Boolean
          // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean
          // Returns `true` if a particular event type has any listeners attached to it.
          // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
          listens: function(type, fn, context, propagate) {
            if (typeof type !== "string") {
              console.warn('"string" type argument expected');
            }
            var _fn = fn;
            if (typeof fn !== "function") {
              propagate = !!fn;
              _fn = void 0;
              context = void 0;
            }
            var listeners = this._events && this._events[type];
            if (listeners && listeners.length) {
              if (this._listens(type, _fn, context) !== false) {
                return true;
              }
            }
            if (propagate) {
              for (var id2 in this._eventParents) {
                if (this._eventParents[id2].listens(type, fn, context, propagate)) {
                  return true;
                }
              }
            }
            return false;
          },
          // returns the index (number) or false
          _listens: function(type, fn, context) {
            if (!this._events) {
              return false;
            }
            var listeners = this._events[type] || [];
            if (!fn) {
              return !!listeners.length;
            }
            if (context === this) {
              context = void 0;
            }
            for (var i = 0, len = listeners.length; i < len; i++) {
              if (listeners[i].fn === fn && listeners[i].ctx === context) {
                return i;
              }
            }
            return false;
          },
          // @method once(): this
          // Behaves as [`on()`](#evented-on), except the listener will only get fired once and then removed.
          once: function(types, fn, context) {
            if (typeof types === "object") {
              for (var type in types) {
                this._on(type, types[type], fn, true);
              }
            } else {
              types = splitWords(types);
              for (var i = 0, len = types.length; i < len; i++) {
                this._on(types[i], fn, context, true);
              }
            }
            return this;
          },
          // @method addEventParent(obj: Evented): this
          // Adds an event parent - an `Evented` that will receive propagated events
          addEventParent: function(obj) {
            this._eventParents = this._eventParents || {};
            this._eventParents[stamp(obj)] = obj;
            return this;
          },
          // @method removeEventParent(obj: Evented): this
          // Removes an event parent, so it will stop receiving propagated events
          removeEventParent: function(obj) {
            if (this._eventParents) {
              delete this._eventParents[stamp(obj)];
            }
            return this;
          },
          _propagateEvent: function(e) {
            for (var id2 in this._eventParents) {
              this._eventParents[id2].fire(e.type, extend2({
                layer: e.target,
                propagatedFrom: e.target
              }, e), true);
            }
          }
        };
        Events.addEventListener = Events.on;
        Events.removeEventListener = Events.clearAllEventListeners = Events.off;
        Events.addOneTimeEventListener = Events.once;
        Events.fireEvent = Events.fire;
        Events.hasEventListeners = Events.listens;
        var Evented = Class.extend(Events);
        function Point(x2, y2, round2) {
          this.x = round2 ? Math.round(x2) : x2;
          this.y = round2 ? Math.round(y2) : y2;
        }
        var trunc = Math.trunc || function(v2) {
          return v2 > 0 ? Math.floor(v2) : Math.ceil(v2);
        };
        Point.prototype = {
          // @method clone(): Point
          // Returns a copy of the current point.
          clone: function() {
            return new Point(this.x, this.y);
          },
          // @method add(otherPoint: Point): Point
          // Returns the result of addition of the current and the given points.
          add: function(point2) {
            return this.clone()._add(toPoint(point2));
          },
          _add: function(point2) {
            this.x += point2.x;
            this.y += point2.y;
            return this;
          },
          // @method subtract(otherPoint: Point): Point
          // Returns the result of subtraction of the given point from the current.
          subtract: function(point2) {
            return this.clone()._subtract(toPoint(point2));
          },
          _subtract: function(point2) {
            this.x -= point2.x;
            this.y -= point2.y;
            return this;
          },
          // @method divideBy(num: Number): Point
          // Returns the result of division of the current point by the given number.
          divideBy: function(num) {
            return this.clone()._divideBy(num);
          },
          _divideBy: function(num) {
            this.x /= num;
            this.y /= num;
            return this;
          },
          // @method multiplyBy(num: Number): Point
          // Returns the result of multiplication of the current point by the given number.
          multiplyBy: function(num) {
            return this.clone()._multiplyBy(num);
          },
          _multiplyBy: function(num) {
            this.x *= num;
            this.y *= num;
            return this;
          },
          // @method scaleBy(scale: Point): Point
          // Multiply each coordinate of the current point by each coordinate of
          // `scale`. In linear algebra terms, multiply the point by the
          // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
          // defined by `scale`.
          scaleBy: function(point2) {
            return new Point(this.x * point2.x, this.y * point2.y);
          },
          // @method unscaleBy(scale: Point): Point
          // Inverse of `scaleBy`. Divide each coordinate of the current point by
          // each coordinate of `scale`.
          unscaleBy: function(point2) {
            return new Point(this.x / point2.x, this.y / point2.y);
          },
          // @method round(): Point
          // Returns a copy of the current point with rounded coordinates.
          round: function() {
            return this.clone()._round();
          },
          _round: function() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
          },
          // @method floor(): Point
          // Returns a copy of the current point with floored coordinates (rounded down).
          floor: function() {
            return this.clone()._floor();
          },
          _floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this;
          },
          // @method ceil(): Point
          // Returns a copy of the current point with ceiled coordinates (rounded up).
          ceil: function() {
            return this.clone()._ceil();
          },
          _ceil: function() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            return this;
          },
          // @method trunc(): Point
          // Returns a copy of the current point with truncated coordinates (rounded towards zero).
          trunc: function() {
            return this.clone()._trunc();
          },
          _trunc: function() {
            this.x = trunc(this.x);
            this.y = trunc(this.y);
            return this;
          },
          // @method distanceTo(otherPoint: Point): Number
          // Returns the cartesian distance between the current and the given points.
          distanceTo: function(point2) {
            point2 = toPoint(point2);
            var x2 = point2.x - this.x, y2 = point2.y - this.y;
            return Math.sqrt(x2 * x2 + y2 * y2);
          },
          // @method equals(otherPoint: Point): Boolean
          // Returns `true` if the given point has the same coordinates.
          equals: function(point2) {
            point2 = toPoint(point2);
            return point2.x === this.x && point2.y === this.y;
          },
          // @method contains(otherPoint: Point): Boolean
          // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
          contains: function(point2) {
            point2 = toPoint(point2);
            return Math.abs(point2.x) <= Math.abs(this.x) && Math.abs(point2.y) <= Math.abs(this.y);
          },
          // @method toString(): String
          // Returns a string representation of the point for debugging purposes.
          toString: function() {
            return "Point(" + formatNum(this.x) + ", " + formatNum(this.y) + ")";
          }
        };
        function toPoint(x2, y2, round2) {
          if (x2 instanceof Point) {
            return x2;
          }
          if (isArray2(x2)) {
            return new Point(x2[0], x2[1]);
          }
          if (x2 === void 0 || x2 === null) {
            return x2;
          }
          if (typeof x2 === "object" && "x" in x2 && "y" in x2) {
            return new Point(x2.x, x2.y);
          }
          return new Point(x2, y2, round2);
        }
        function Bounds(a2, b) {
          if (!a2) {
            return;
          }
          var points = b ? [a2, b] : a2;
          for (var i = 0, len = points.length; i < len; i++) {
            this.extend(points[i]);
          }
        }
        Bounds.prototype = {
          // @method extend(point: Point): this
          // Extends the bounds to contain the given point.
          // @alternative
          // @method extend(otherBounds: Bounds): this
          // Extend the bounds to contain the given bounds
          extend: function(obj) {
            var min2, max2;
            if (!obj) {
              return this;
            }
            if (obj instanceof Point || typeof obj[0] === "number" || "x" in obj) {
              min2 = max2 = toPoint(obj);
            } else {
              obj = toBounds(obj);
              min2 = obj.min;
              max2 = obj.max;
              if (!min2 || !max2) {
                return this;
              }
            }
            if (!this.min && !this.max) {
              this.min = min2.clone();
              this.max = max2.clone();
            } else {
              this.min.x = Math.min(min2.x, this.min.x);
              this.max.x = Math.max(max2.x, this.max.x);
              this.min.y = Math.min(min2.y, this.min.y);
              this.max.y = Math.max(max2.y, this.max.y);
            }
            return this;
          },
          // @method getCenter(round?: Boolean): Point
          // Returns the center point of the bounds.
          getCenter: function(round2) {
            return toPoint(
              (this.min.x + this.max.x) / 2,
              (this.min.y + this.max.y) / 2,
              round2
            );
          },
          // @method getBottomLeft(): Point
          // Returns the bottom-left point of the bounds.
          getBottomLeft: function() {
            return toPoint(this.min.x, this.max.y);
          },
          // @method getTopRight(): Point
          // Returns the top-right point of the bounds.
          getTopRight: function() {
            return toPoint(this.max.x, this.min.y);
          },
          // @method getTopLeft(): Point
          // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
          getTopLeft: function() {
            return this.min;
          },
          // @method getBottomRight(): Point
          // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
          getBottomRight: function() {
            return this.max;
          },
          // @method getSize(): Point
          // Returns the size of the given bounds
          getSize: function() {
            return this.max.subtract(this.min);
          },
          // @method contains(otherBounds: Bounds): Boolean
          // Returns `true` if the rectangle contains the given one.
          // @alternative
          // @method contains(point: Point): Boolean
          // Returns `true` if the rectangle contains the given point.
          contains: function(obj) {
            var min2, max2;
            if (typeof obj[0] === "number" || obj instanceof Point) {
              obj = toPoint(obj);
            } else {
              obj = toBounds(obj);
            }
            if (obj instanceof Bounds) {
              min2 = obj.min;
              max2 = obj.max;
            } else {
              min2 = max2 = obj;
            }
            return min2.x >= this.min.x && max2.x <= this.max.x && min2.y >= this.min.y && max2.y <= this.max.y;
          },
          // @method intersects(otherBounds: Bounds): Boolean
          // Returns `true` if the rectangle intersects the given bounds. Two bounds
          // intersect if they have at least one point in common.
          intersects: function(bounds) {
            bounds = toBounds(bounds);
            var min2 = this.min, max2 = this.max, min22 = bounds.min, max22 = bounds.max, xIntersects = max22.x >= min2.x && min22.x <= max2.x, yIntersects = max22.y >= min2.y && min22.y <= max2.y;
            return xIntersects && yIntersects;
          },
          // @method overlaps(otherBounds: Bounds): Boolean
          // Returns `true` if the rectangle overlaps the given bounds. Two bounds
          // overlap if their intersection is an area.
          overlaps: function(bounds) {
            bounds = toBounds(bounds);
            var min2 = this.min, max2 = this.max, min22 = bounds.min, max22 = bounds.max, xOverlaps = max22.x > min2.x && min22.x < max2.x, yOverlaps = max22.y > min2.y && min22.y < max2.y;
            return xOverlaps && yOverlaps;
          },
          // @method isValid(): Boolean
          // Returns `true` if the bounds are properly initialized.
          isValid: function() {
            return !!(this.min && this.max);
          },
          // @method pad(bufferRatio: Number): Bounds
          // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
          // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
          // Negative values will retract the bounds.
          pad: function(bufferRatio) {
            var min2 = this.min, max2 = this.max, heightBuffer = Math.abs(min2.x - max2.x) * bufferRatio, widthBuffer = Math.abs(min2.y - max2.y) * bufferRatio;
            return toBounds(
              toPoint(min2.x - heightBuffer, min2.y - widthBuffer),
              toPoint(max2.x + heightBuffer, max2.y + widthBuffer)
            );
          },
          // @method equals(otherBounds: Bounds): Boolean
          // Returns `true` if the rectangle is equivalent to the given bounds.
          equals: function(bounds) {
            if (!bounds) {
              return false;
            }
            bounds = toBounds(bounds);
            return this.min.equals(bounds.getTopLeft()) && this.max.equals(bounds.getBottomRight());
          }
        };
        function toBounds(a2, b) {
          if (!a2 || a2 instanceof Bounds) {
            return a2;
          }
          return new Bounds(a2, b);
        }
        function LatLngBounds(corner1, corner2) {
          if (!corner1) {
            return;
          }
          var latlngs = corner2 ? [corner1, corner2] : corner1;
          for (var i = 0, len = latlngs.length; i < len; i++) {
            this.extend(latlngs[i]);
          }
        }
        LatLngBounds.prototype = {
          // @method extend(latlng: LatLng): this
          // Extend the bounds to contain the given point
          // @alternative
          // @method extend(otherBounds: LatLngBounds): this
          // Extend the bounds to contain the given bounds
          extend: function(obj) {
            var sw = this._southWest, ne2 = this._northEast, sw2, ne22;
            if (obj instanceof LatLng) {
              sw2 = obj;
              ne22 = obj;
            } else if (obj instanceof LatLngBounds) {
              sw2 = obj._southWest;
              ne22 = obj._northEast;
              if (!sw2 || !ne22) {
                return this;
              }
            } else {
              return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
            }
            if (!sw && !ne2) {
              this._southWest = new LatLng(sw2.lat, sw2.lng);
              this._northEast = new LatLng(ne22.lat, ne22.lng);
            } else {
              sw.lat = Math.min(sw2.lat, sw.lat);
              sw.lng = Math.min(sw2.lng, sw.lng);
              ne2.lat = Math.max(ne22.lat, ne2.lat);
              ne2.lng = Math.max(ne22.lng, ne2.lng);
            }
            return this;
          },
          // @method pad(bufferRatio: Number): LatLngBounds
          // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
          // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
          // Negative values will retract the bounds.
          pad: function(bufferRatio) {
            var sw = this._southWest, ne2 = this._northEast, heightBuffer = Math.abs(sw.lat - ne2.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne2.lng) * bufferRatio;
            return new LatLngBounds(
              new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
              new LatLng(ne2.lat + heightBuffer, ne2.lng + widthBuffer)
            );
          },
          // @method getCenter(): LatLng
          // Returns the center point of the bounds.
          getCenter: function() {
            return new LatLng(
              (this._southWest.lat + this._northEast.lat) / 2,
              (this._southWest.lng + this._northEast.lng) / 2
            );
          },
          // @method getSouthWest(): LatLng
          // Returns the south-west point of the bounds.
          getSouthWest: function() {
            return this._southWest;
          },
          // @method getNorthEast(): LatLng
          // Returns the north-east point of the bounds.
          getNorthEast: function() {
            return this._northEast;
          },
          // @method getNorthWest(): LatLng
          // Returns the north-west point of the bounds.
          getNorthWest: function() {
            return new LatLng(this.getNorth(), this.getWest());
          },
          // @method getSouthEast(): LatLng
          // Returns the south-east point of the bounds.
          getSouthEast: function() {
            return new LatLng(this.getSouth(), this.getEast());
          },
          // @method getWest(): Number
          // Returns the west longitude of the bounds
          getWest: function() {
            return this._southWest.lng;
          },
          // @method getSouth(): Number
          // Returns the south latitude of the bounds
          getSouth: function() {
            return this._southWest.lat;
          },
          // @method getEast(): Number
          // Returns the east longitude of the bounds
          getEast: function() {
            return this._northEast.lng;
          },
          // @method getNorth(): Number
          // Returns the north latitude of the bounds
          getNorth: function() {
            return this._northEast.lat;
          },
          // @method contains(otherBounds: LatLngBounds): Boolean
          // Returns `true` if the rectangle contains the given one.
          // @alternative
          // @method contains (latlng: LatLng): Boolean
          // Returns `true` if the rectangle contains the given point.
          contains: function(obj) {
            if (typeof obj[0] === "number" || obj instanceof LatLng || "lat" in obj) {
              obj = toLatLng(obj);
            } else {
              obj = toLatLngBounds(obj);
            }
            var sw = this._southWest, ne2 = this._northEast, sw2, ne22;
            if (obj instanceof LatLngBounds) {
              sw2 = obj.getSouthWest();
              ne22 = obj.getNorthEast();
            } else {
              sw2 = ne22 = obj;
            }
            return sw2.lat >= sw.lat && ne22.lat <= ne2.lat && sw2.lng >= sw.lng && ne22.lng <= ne2.lng;
          },
          // @method intersects(otherBounds: LatLngBounds): Boolean
          // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
          intersects: function(bounds) {
            bounds = toLatLngBounds(bounds);
            var sw = this._southWest, ne2 = this._northEast, sw2 = bounds.getSouthWest(), ne22 = bounds.getNorthEast(), latIntersects = ne22.lat >= sw.lat && sw2.lat <= ne2.lat, lngIntersects = ne22.lng >= sw.lng && sw2.lng <= ne2.lng;
            return latIntersects && lngIntersects;
          },
          // @method overlaps(otherBounds: LatLngBounds): Boolean
          // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
          overlaps: function(bounds) {
            bounds = toLatLngBounds(bounds);
            var sw = this._southWest, ne2 = this._northEast, sw2 = bounds.getSouthWest(), ne22 = bounds.getNorthEast(), latOverlaps = ne22.lat > sw.lat && sw2.lat < ne2.lat, lngOverlaps = ne22.lng > sw.lng && sw2.lng < ne2.lng;
            return latOverlaps && lngOverlaps;
          },
          // @method toBBoxString(): String
          // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
          toBBoxString: function() {
            return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
          },
          // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
          // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
          equals: function(bounds, maxMargin) {
            if (!bounds) {
              return false;
            }
            bounds = toLatLngBounds(bounds);
            return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
          },
          // @method isValid(): Boolean
          // Returns `true` if the bounds are properly initialized.
          isValid: function() {
            return !!(this._southWest && this._northEast);
          }
        };
        function toLatLngBounds(a2, b) {
          if (a2 instanceof LatLngBounds) {
            return a2;
          }
          return new LatLngBounds(a2, b);
        }
        function LatLng(lat, lng, alt) {
          if (isNaN(lat) || isNaN(lng)) {
            throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
          }
          this.lat = +lat;
          this.lng = +lng;
          if (alt !== void 0) {
            this.alt = +alt;
          }
        }
        LatLng.prototype = {
          // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
          // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
          equals: function(obj, maxMargin) {
            if (!obj) {
              return false;
            }
            obj = toLatLng(obj);
            var margin = Math.max(
              Math.abs(this.lat - obj.lat),
              Math.abs(this.lng - obj.lng)
            );
            return margin <= (maxMargin === void 0 ? 1e-9 : maxMargin);
          },
          // @method toString(): String
          // Returns a string representation of the point (for debugging purposes).
          toString: function(precision) {
            return "LatLng(" + formatNum(this.lat, precision) + ", " + formatNum(this.lng, precision) + ")";
          },
          // @method distanceTo(otherLatLng: LatLng): Number
          // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
          distanceTo: function(other) {
            return Earth.distance(this, toLatLng(other));
          },
          // @method wrap(): LatLng
          // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
          wrap: function() {
            return Earth.wrapLatLng(this);
          },
          // @method toBounds(sizeInMeters: Number): LatLngBounds
          // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
          toBounds: function(sizeInMeters) {
            var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
            return toLatLngBounds(
              [this.lat - latAccuracy, this.lng - lngAccuracy],
              [this.lat + latAccuracy, this.lng + lngAccuracy]
            );
          },
          clone: function() {
            return new LatLng(this.lat, this.lng, this.alt);
          }
        };
        function toLatLng(a2, b, c2) {
          if (a2 instanceof LatLng) {
            return a2;
          }
          if (isArray2(a2) && typeof a2[0] !== "object") {
            if (a2.length === 3) {
              return new LatLng(a2[0], a2[1], a2[2]);
            }
            if (a2.length === 2) {
              return new LatLng(a2[0], a2[1]);
            }
            return null;
          }
          if (a2 === void 0 || a2 === null) {
            return a2;
          }
          if (typeof a2 === "object" && "lat" in a2) {
            return new LatLng(a2.lat, "lng" in a2 ? a2.lng : a2.lon, a2.alt);
          }
          if (b === void 0) {
            return null;
          }
          return new LatLng(a2, b, c2);
        }
        var CRS = {
          // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
          // Projects geographical coordinates into pixel coordinates for a given zoom.
          latLngToPoint: function(latlng, zoom2) {
            var projectedPoint = this.projection.project(latlng), scale2 = this.scale(zoom2);
            return this.transformation._transform(projectedPoint, scale2);
          },
          // @method pointToLatLng(point: Point, zoom: Number): LatLng
          // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
          // zoom into geographical coordinates.
          pointToLatLng: function(point2, zoom2) {
            var scale2 = this.scale(zoom2), untransformedPoint = this.transformation.untransform(point2, scale2);
            return this.projection.unproject(untransformedPoint);
          },
          // @method project(latlng: LatLng): Point
          // Projects geographical coordinates into coordinates in units accepted for
          // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
          project: function(latlng) {
            return this.projection.project(latlng);
          },
          // @method unproject(point: Point): LatLng
          // Given a projected coordinate returns the corresponding LatLng.
          // The inverse of `project`.
          unproject: function(point2) {
            return this.projection.unproject(point2);
          },
          // @method scale(zoom: Number): Number
          // Returns the scale used when transforming projected coordinates into
          // pixel coordinates for a particular zoom. For example, it returns
          // `256 * 2^zoom` for Mercator-based CRS.
          scale: function(zoom2) {
            return 256 * Math.pow(2, zoom2);
          },
          // @method zoom(scale: Number): Number
          // Inverse of `scale()`, returns the zoom level corresponding to a scale
          // factor of `scale`.
          zoom: function(scale2) {
            return Math.log(scale2 / 256) / Math.LN2;
          },
          // @method getProjectedBounds(zoom: Number): Bounds
          // Returns the projection's bounds scaled and transformed for the provided `zoom`.
          getProjectedBounds: function(zoom2) {
            if (this.infinite) {
              return null;
            }
            var b = this.projection.bounds, s2 = this.scale(zoom2), min2 = this.transformation.transform(b.min, s2), max2 = this.transformation.transform(b.max, s2);
            return new Bounds(min2, max2);
          },
          // @method distance(latlng1: LatLng, latlng2: LatLng): Number
          // Returns the distance between two geographical coordinates.
          // @property code: String
          // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
          //
          // @property wrapLng: Number[]
          // An array of two numbers defining whether the longitude (horizontal) coordinate
          // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
          // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
          //
          // @property wrapLat: Number[]
          // Like `wrapLng`, but for the latitude (vertical) axis.
          // wrapLng: [min, max],
          // wrapLat: [min, max],
          // @property infinite: Boolean
          // If true, the coordinate space will be unbounded (infinite in both axes)
          infinite: false,
          // @method wrapLatLng(latlng: LatLng): LatLng
          // Returns a `LatLng` where lat and lng has been wrapped according to the
          // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
          wrapLatLng: function(latlng) {
            var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat, alt = latlng.alt;
            return new LatLng(lat, lng, alt);
          },
          // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
          // Returns a `LatLngBounds` with the same size as the given one, ensuring
          // that its center is within the CRS's bounds.
          // Only accepts actual `L.LatLngBounds` instances, not arrays.
          wrapLatLngBounds: function(bounds) {
            var center = bounds.getCenter(), newCenter = this.wrapLatLng(center), latShift = center.lat - newCenter.lat, lngShift = center.lng - newCenter.lng;
            if (latShift === 0 && lngShift === 0) {
              return bounds;
            }
            var sw = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift), newNe = new LatLng(ne2.lat - latShift, ne2.lng - lngShift);
            return new LatLngBounds(newSw, newNe);
          }
        };
        var Earth = extend2({}, CRS, {
          wrapLng: [-180, 180],
          // Mean Earth Radius, as recommended for use by
          // the International Union of Geodesy and Geophysics,
          // see https://rosettacode.org/wiki/Haversine_formula
          R: 6371e3,
          // distance between two geographical points using spherical law of cosines approximation
          distance: function(latlng1, latlng2) {
            var rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2), a2 = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c2 = 2 * Math.atan2(Math.sqrt(a2), Math.sqrt(1 - a2));
            return this.R * c2;
          }
        });
        var earthRadius = 6378137;
        var SphericalMercator = {
          R: earthRadius,
          MAX_LATITUDE: 85.0511287798,
          project: function(latlng) {
            var d = Math.PI / 180, max2 = this.MAX_LATITUDE, lat = Math.max(Math.min(max2, latlng.lat), -max2), sin2 = Math.sin(lat * d);
            return new Point(
              this.R * latlng.lng * d,
              this.R * Math.log((1 + sin2) / (1 - sin2)) / 2
            );
          },
          unproject: function(point2) {
            var d = 180 / Math.PI;
            return new LatLng(
              (2 * Math.atan(Math.exp(point2.y / this.R)) - Math.PI / 2) * d,
              point2.x * d / this.R
            );
          },
          bounds: function() {
            var d = earthRadius * Math.PI;
            return new Bounds([-d, -d], [d, d]);
          }()
        };
        function Transformation(a2, b, c2, d) {
          if (isArray2(a2)) {
            this._a = a2[0];
            this._b = a2[1];
            this._c = a2[2];
            this._d = a2[3];
            return;
          }
          this._a = a2;
          this._b = b;
          this._c = c2;
          this._d = d;
        }
        Transformation.prototype = {
          // @method transform(point: Point, scale?: Number): Point
          // Returns a transformed point, optionally multiplied by the given scale.
          // Only accepts actual `L.Point` instances, not arrays.
          transform: function(point2, scale2) {
            return this._transform(point2.clone(), scale2);
          },
          // destructive transform (faster)
          _transform: function(point2, scale2) {
            scale2 = scale2 || 1;
            point2.x = scale2 * (this._a * point2.x + this._b);
            point2.y = scale2 * (this._c * point2.y + this._d);
            return point2;
          },
          // @method untransform(point: Point, scale?: Number): Point
          // Returns the reverse transformation of the given point, optionally divided
          // by the given scale. Only accepts actual `L.Point` instances, not arrays.
          untransform: function(point2, scale2) {
            scale2 = scale2 || 1;
            return new Point(
              (point2.x / scale2 - this._b) / this._a,
              (point2.y / scale2 - this._d) / this._c
            );
          }
        };
        function toTransformation(a2, b, c2, d) {
          return new Transformation(a2, b, c2, d);
        }
        var EPSG3857 = extend2({}, Earth, {
          code: "EPSG:3857",
          projection: SphericalMercator,
          transformation: function() {
            var scale2 = 0.5 / (Math.PI * SphericalMercator.R);
            return toTransformation(scale2, 0.5, -scale2, 0.5);
          }()
        });
        var EPSG900913 = extend2({}, EPSG3857, {
          code: "EPSG:900913"
        });
        function svgCreate(name) {
          return document.createElementNS("http://www.w3.org/2000/svg", name);
        }
        function pointsToPath(rings, closed) {
          var str = "", i, j, len, len2, points, p2;
          for (i = 0, len = rings.length; i < len; i++) {
            points = rings[i];
            for (j = 0, len2 = points.length; j < len2; j++) {
              p2 = points[j];
              str += (j ? "L" : "M") + p2.x + " " + p2.y;
            }
            str += closed ? Browser.svg ? "z" : "x" : "";
          }
          return str || "M0 0";
        }
        var style = document.documentElement.style;
        var ie2 = "ActiveXObject" in window;
        var ielt9 = ie2 && !document.addEventListener;
        var edge = "msLaunchUri" in navigator && !("documentMode" in document);
        var webkit = userAgentContains("webkit");
        var android = userAgentContains("android");
        var android23 = userAgentContains("android 2") || userAgentContains("android 3");
        var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10);
        var androidStock = android && userAgentContains("Google") && webkitVer < 537 && !("AudioNode" in window);
        var opera = !!window.opera;
        var chrome = !edge && userAgentContains("chrome");
        var gecko = userAgentContains("gecko") && !webkit && !opera && !ie2;
        var safari = !chrome && userAgentContains("safari");
        var phantom = userAgentContains("phantom");
        var opera12 = "OTransition" in style;
        var win = navigator.platform.indexOf("Win") === 0;
        var ie3d = ie2 && "transition" in style;
        var webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !android23;
        var gecko3d = "MozPerspective" in style;
        var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;
        var mobile = typeof orientation !== "undefined" || userAgentContains("mobile");
        var mobileWebkit = mobile && webkit;
        var mobileWebkit3d = mobile && webkit3d;
        var msPointer = !window.PointerEvent && window.MSPointerEvent;
        var pointer = !!(window.PointerEvent || msPointer);
        var touchNative = "ontouchstart" in window || !!window.TouchEvent;
        var touch = !window.L_NO_TOUCH && (touchNative || pointer);
        var mobileOpera = mobile && opera;
        var mobileGecko = mobile && gecko;
        var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;
        var passiveEvents = function() {
          var supportsPassiveOption = false;
          try {
            var opts = Object.defineProperty({}, "passive", {
              get: function() {
                supportsPassiveOption = true;
              }
            });
            window.addEventListener("testPassiveEventSupport", falseFn, opts);
            window.removeEventListener("testPassiveEventSupport", falseFn, opts);
          } catch (e) {
          }
          return supportsPassiveOption;
        }();
        var canvas$1 = function() {
          return !!document.createElement("canvas").getContext;
        }();
        var svg$1 = !!(document.createElementNS && svgCreate("svg").createSVGRect);
        var inlineSvg = !!svg$1 && function() {
          var div = document.createElement("div");
          div.innerHTML = "<svg/>";
          return (div.firstChild && div.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
        }();
        var vml = !svg$1 && function() {
          try {
            var div = document.createElement("div");
            div.innerHTML = '<v:shape adj="1"/>';
            var shape = div.firstChild;
            shape.style.behavior = "url(#default#VML)";
            return shape && typeof shape.adj === "object";
          } catch (e) {
            return false;
          }
        }();
        var mac = navigator.platform.indexOf("Mac") === 0;
        var linux = navigator.platform.indexOf("Linux") === 0;
        function userAgentContains(str) {
          return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
        }
        var Browser = {
          ie: ie2,
          ielt9,
          edge,
          webkit,
          android,
          android23,
          androidStock,
          opera,
          chrome,
          gecko,
          safari,
          phantom,
          opera12,
          win,
          ie3d,
          webkit3d,
          gecko3d,
          any3d,
          mobile,
          mobileWebkit,
          mobileWebkit3d,
          msPointer,
          pointer,
          touch,
          touchNative,
          mobileOpera,
          mobileGecko,
          retina,
          passiveEvents,
          canvas: canvas$1,
          svg: svg$1,
          vml,
          inlineSvg,
          mac,
          linux
        };
        var POINTER_DOWN = Browser.msPointer ? "MSPointerDown" : "pointerdown";
        var POINTER_MOVE = Browser.msPointer ? "MSPointerMove" : "pointermove";
        var POINTER_UP = Browser.msPointer ? "MSPointerUp" : "pointerup";
        var POINTER_CANCEL = Browser.msPointer ? "MSPointerCancel" : "pointercancel";
        var pEvent = {
          touchstart: POINTER_DOWN,
          touchmove: POINTER_MOVE,
          touchend: POINTER_UP,
          touchcancel: POINTER_CANCEL
        };
        var handle = {
          touchstart: _onPointerStart,
          touchmove: _handlePointer,
          touchend: _handlePointer,
          touchcancel: _handlePointer
        };
        var _pointers = {};
        var _pointerDocListener = false;
        function addPointerListener(obj, type, handler) {
          if (type === "touchstart") {
            _addPointerDocListener();
          }
          if (!handle[type]) {
            console.warn("wrong event specified:", type);
            return falseFn;
          }
          handler = handle[type].bind(this, handler);
          obj.addEventListener(pEvent[type], handler, false);
          return handler;
        }
        function removePointerListener(obj, type, handler) {
          if (!pEvent[type]) {
            console.warn("wrong event specified:", type);
            return;
          }
          obj.removeEventListener(pEvent[type], handler, false);
        }
        function _globalPointerDown(e) {
          _pointers[e.pointerId] = e;
        }
        function _globalPointerMove(e) {
          if (_pointers[e.pointerId]) {
            _pointers[e.pointerId] = e;
          }
        }
        function _globalPointerUp(e) {
          delete _pointers[e.pointerId];
        }
        function _addPointerDocListener() {
          if (!_pointerDocListener) {
            document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
            document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
            document.addEventListener(POINTER_UP, _globalPointerUp, true);
            document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
            _pointerDocListener = true;
          }
        }
        function _handlePointer(handler, e) {
          if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || "mouse")) {
            return;
          }
          e.touches = [];
          for (var i in _pointers) {
            e.touches.push(_pointers[i]);
          }
          e.changedTouches = [e];
          handler(e);
        }
        function _onPointerStart(handler, e) {
          if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {
            preventDefault(e);
          }
          _handlePointer(handler, e);
        }
        function makeDblclick(event) {
          var newEvent = {}, prop, i;
          for (i in event) {
            prop = event[i];
            newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;
          }
          event = newEvent;
          newEvent.type = "dblclick";
          newEvent.detail = 2;
          newEvent.isTrusted = false;
          newEvent._simulated = true;
          return newEvent;
        }
        var delay = 200;
        function addDoubleTapListener(obj, handler) {
          obj.addEventListener("dblclick", handler);
          var last2 = 0, detail;
          function simDblclick(e) {
            if (e.detail !== 1) {
              detail = e.detail;
              return;
            }
            if (e.pointerType === "mouse" || e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents) {
              return;
            }
            var path = getPropagationPath(e);
            if (path.some(function(el2) {
              return el2 instanceof HTMLLabelElement && el2.attributes.for;
            }) && !path.some(function(el2) {
              return el2 instanceof HTMLInputElement || el2 instanceof HTMLSelectElement;
            })) {
              return;
            }
            var now = Date.now();
            if (now - last2 <= delay) {
              detail++;
              if (detail === 2) {
                handler(makeDblclick(e));
              }
            } else {
              detail = 1;
            }
            last2 = now;
          }
          obj.addEventListener("click", simDblclick);
          return {
            dblclick: handler,
            simDblclick
          };
        }
        function removeDoubleTapListener(obj, handlers) {
          obj.removeEventListener("dblclick", handlers.dblclick);
          obj.removeEventListener("click", handlers.simDblclick);
        }
        var TRANSFORM = testProp(
          ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]
        );
        var TRANSITION = testProp(
          ["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]
        );
        var TRANSITION_END = TRANSITION === "webkitTransition" || TRANSITION === "OTransition" ? TRANSITION + "End" : "transitionend";
        function get2(id2) {
          return typeof id2 === "string" ? document.getElementById(id2) : id2;
        }
        function getStyle(el2, style2) {
          var value = el2.style[style2] || el2.currentStyle && el2.currentStyle[style2];
          if ((!value || value === "auto") && document.defaultView) {
            var css = document.defaultView.getComputedStyle(el2, null);
            value = css ? css[style2] : null;
          }
          return value === "auto" ? null : value;
        }
        function create$1(tagName, className, container) {
          var el2 = document.createElement(tagName);
          el2.className = className || "";
          if (container) {
            container.appendChild(el2);
          }
          return el2;
        }
        function remove(el2) {
          var parent = el2.parentNode;
          if (parent) {
            parent.removeChild(el2);
          }
        }
        function empty(el2) {
          while (el2.firstChild) {
            el2.removeChild(el2.firstChild);
          }
        }
        function toFront(el2) {
          var parent = el2.parentNode;
          if (parent && parent.lastChild !== el2) {
            parent.appendChild(el2);
          }
        }
        function toBack(el2) {
          var parent = el2.parentNode;
          if (parent && parent.firstChild !== el2) {
            parent.insertBefore(el2, parent.firstChild);
          }
        }
        function hasClass(el2, name) {
          if (el2.classList !== void 0) {
            return el2.classList.contains(name);
          }
          var className = getClass(el2);
          return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
        }
        function addClass(el2, name) {
          if (el2.classList !== void 0) {
            var classes = splitWords(name);
            for (var i = 0, len = classes.length; i < len; i++) {
              el2.classList.add(classes[i]);
            }
          } else if (!hasClass(el2, name)) {
            var className = getClass(el2);
            setClass(el2, (className ? className + " " : "") + name);
          }
        }
        function removeClass(el2, name) {
          if (el2.classList !== void 0) {
            el2.classList.remove(name);
          } else {
            setClass(el2, trim((" " + getClass(el2) + " ").replace(" " + name + " ", " ")));
          }
        }
        function setClass(el2, name) {
          if (el2.className.baseVal === void 0) {
            el2.className = name;
          } else {
            el2.className.baseVal = name;
          }
        }
        function getClass(el2) {
          if (el2.correspondingElement) {
            el2 = el2.correspondingElement;
          }
          return el2.className.baseVal === void 0 ? el2.className : el2.className.baseVal;
        }
        function setOpacity(el2, value) {
          if ("opacity" in el2.style) {
            el2.style.opacity = value;
          } else if ("filter" in el2.style) {
            _setOpacityIE(el2, value);
          }
        }
        function _setOpacityIE(el2, value) {
          var filter = false, filterName = "DXImageTransform.Microsoft.Alpha";
          try {
            filter = el2.filters.item(filterName);
          } catch (e) {
            if (value === 1) {
              return;
            }
          }
          value = Math.round(value * 100);
          if (filter) {
            filter.Enabled = value !== 100;
            filter.Opacity = value;
          } else {
            el2.style.filter += " progid:" + filterName + "(opacity=" + value + ")";
          }
        }
        function testProp(props) {
          var style2 = document.documentElement.style;
          for (var i = 0; i < props.length; i++) {
            if (props[i] in style2) {
              return props[i];
            }
          }
          return false;
        }
        function setTransform(el2, offset, scale2) {
          var pos = offset || new Point(0, 0);
          el2.style[TRANSFORM] = (Browser.ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale2 ? " scale(" + scale2 + ")" : "");
        }
        function setPosition(el2, point2) {
          el2._leaflet_pos = point2;
          if (Browser.any3d) {
            setTransform(el2, point2);
          } else {
            el2.style.left = point2.x + "px";
            el2.style.top = point2.y + "px";
          }
        }
        function getPosition(el2) {
          return el2._leaflet_pos || new Point(0, 0);
        }
        var disableTextSelection;
        var enableTextSelection;
        var _userSelect;
        if ("onselectstart" in document) {
          disableTextSelection = function() {
            on(window, "selectstart", preventDefault);
          };
          enableTextSelection = function() {
            off(window, "selectstart", preventDefault);
          };
        } else {
          var userSelectProperty = testProp(
            ["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]
          );
          disableTextSelection = function() {
            if (userSelectProperty) {
              var style2 = document.documentElement.style;
              _userSelect = style2[userSelectProperty];
              style2[userSelectProperty] = "none";
            }
          };
          enableTextSelection = function() {
            if (userSelectProperty) {
              document.documentElement.style[userSelectProperty] = _userSelect;
              _userSelect = void 0;
            }
          };
        }
        function disableImageDrag() {
          on(window, "dragstart", preventDefault);
        }
        function enableImageDrag() {
          off(window, "dragstart", preventDefault);
        }
        var _outlineElement, _outlineStyle;
        function preventOutline(element) {
          while (element.tabIndex === -1) {
            element = element.parentNode;
          }
          if (!element.style) {
            return;
          }
          restoreOutline();
          _outlineElement = element;
          _outlineStyle = element.style.outlineStyle;
          element.style.outlineStyle = "none";
          on(window, "keydown", restoreOutline);
        }
        function restoreOutline() {
          if (!_outlineElement) {
            return;
          }
          _outlineElement.style.outlineStyle = _outlineStyle;
          _outlineElement = void 0;
          _outlineStyle = void 0;
          off(window, "keydown", restoreOutline);
        }
        function getSizedParentNode(element) {
          do {
            element = element.parentNode;
          } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
          return element;
        }
        function getScale(element) {
          var rect = element.getBoundingClientRect();
          return {
            x: rect.width / element.offsetWidth || 1,
            y: rect.height / element.offsetHeight || 1,
            boundingClientRect: rect
          };
        }
        var DomUtil = {
          __proto__: null,
          TRANSFORM,
          TRANSITION,
          TRANSITION_END,
          get: get2,
          getStyle,
          create: create$1,
          remove,
          empty,
          toFront,
          toBack,
          hasClass,
          addClass,
          removeClass,
          setClass,
          getClass,
          setOpacity,
          testProp,
          setTransform,
          setPosition,
          getPosition,
          get disableTextSelection() {
            return disableTextSelection;
          },
          get enableTextSelection() {
            return enableTextSelection;
          },
          disableImageDrag,
          enableImageDrag,
          preventOutline,
          restoreOutline,
          getSizedParentNode,
          getScale
        };
        function on(obj, types, fn, context) {
          if (types && typeof types === "object") {
            for (var type in types) {
              addOne(obj, type, types[type], fn);
            }
          } else {
            types = splitWords(types);
            for (var i = 0, len = types.length; i < len; i++) {
              addOne(obj, types[i], fn, context);
            }
          }
          return this;
        }
        var eventsKey = "_leaflet_events";
        function off(obj, types, fn, context) {
          if (arguments.length === 1) {
            batchRemove(obj);
            delete obj[eventsKey];
          } else if (types && typeof types === "object") {
            for (var type in types) {
              removeOne(obj, type, types[type], fn);
            }
          } else {
            types = splitWords(types);
            if (arguments.length === 2) {
              batchRemove(obj, function(type2) {
                return indexOf(types, type2) !== -1;
              });
            } else {
              for (var i = 0, len = types.length; i < len; i++) {
                removeOne(obj, types[i], fn, context);
              }
            }
          }
          return this;
        }
        function batchRemove(obj, filterFn) {
          for (var id2 in obj[eventsKey]) {
            var type = id2.split(/\d/)[0];
            if (!filterFn || filterFn(type)) {
              removeOne(obj, type, null, null, id2);
            }
          }
        }
        var mouseSubst = {
          mouseenter: "mouseover",
          mouseleave: "mouseout",
          wheel: !("onwheel" in window) && "mousewheel"
        };
        function addOne(obj, type, fn, context) {
          var id2 = type + stamp(fn) + (context ? "_" + stamp(context) : "");
          if (obj[eventsKey] && obj[eventsKey][id2]) {
            return this;
          }
          var handler = function(e) {
            return fn.call(context || obj, e || window.event);
          };
          var originalHandler = handler;
          if (!Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0) {
            handler = addPointerListener(obj, type, handler);
          } else if (Browser.touch && type === "dblclick") {
            handler = addDoubleTapListener(obj, handler);
          } else if ("addEventListener" in obj) {
            if (type === "touchstart" || type === "touchmove" || type === "wheel" || type === "mousewheel") {
              obj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? { passive: false } : false);
            } else if (type === "mouseenter" || type === "mouseleave") {
              handler = function(e) {
                e = e || window.event;
                if (isExternalTarget(obj, e)) {
                  originalHandler(e);
                }
              };
              obj.addEventListener(mouseSubst[type], handler, false);
            } else {
              obj.addEventListener(type, originalHandler, false);
            }
          } else {
            obj.attachEvent("on" + type, handler);
          }
          obj[eventsKey] = obj[eventsKey] || {};
          obj[eventsKey][id2] = handler;
        }
        function removeOne(obj, type, fn, context, id2) {
          id2 = id2 || type + stamp(fn) + (context ? "_" + stamp(context) : "");
          var handler = obj[eventsKey] && obj[eventsKey][id2];
          if (!handler) {
            return this;
          }
          if (!Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0) {
            removePointerListener(obj, type, handler);
          } else if (Browser.touch && type === "dblclick") {
            removeDoubleTapListener(obj, handler);
          } else if ("removeEventListener" in obj) {
            obj.removeEventListener(mouseSubst[type] || type, handler, false);
          } else {
            obj.detachEvent("on" + type, handler);
          }
          obj[eventsKey][id2] = null;
        }
        function stopPropagation(e) {
          if (e.stopPropagation) {
            e.stopPropagation();
          } else if (e.originalEvent) {
            e.originalEvent._stopped = true;
          } else {
            e.cancelBubble = true;
          }
          return this;
        }
        function disableScrollPropagation(el2) {
          addOne(el2, "wheel", stopPropagation);
          return this;
        }
        function disableClickPropagation(el2) {
          on(el2, "mousedown touchstart dblclick contextmenu", stopPropagation);
          el2["_leaflet_disable_click"] = true;
          return this;
        }
        function preventDefault(e) {
          if (e.preventDefault) {
            e.preventDefault();
          } else {
            e.returnValue = false;
          }
          return this;
        }
        function stop(e) {
          preventDefault(e);
          stopPropagation(e);
          return this;
        }
        function getPropagationPath(ev) {
          if (ev.composedPath) {
            return ev.composedPath();
          }
          var path = [];
          var el2 = ev.target;
          while (el2) {
            path.push(el2);
            el2 = el2.parentNode;
          }
          return path;
        }
        function getMousePosition(e, container) {
          if (!container) {
            return new Point(e.clientX, e.clientY);
          }
          var scale2 = getScale(container), offset = scale2.boundingClientRect;
          return new Point(
            // offset.left/top values are in page scale (like clientX/Y),
            // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
            (e.clientX - offset.left) / scale2.x - container.clientLeft,
            (e.clientY - offset.top) / scale2.y - container.clientTop
          );
        }
        var wheelPxFactor = Browser.linux && Browser.chrome ? window.devicePixelRatio : Browser.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
        function getWheelDelta(e) {
          return Browser.edge ? e.wheelDeltaY / 2 : (
            // Don't trust window-geometry-based delta
            e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : (
              // Pixels
              e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : (
                // Lines
                e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : (
                  // Pages
                  e.deltaX || e.deltaZ ? 0 : (
                    // Skip horizontal/depth wheel events
                    e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : (
                      // Legacy IE pixels
                      e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : (
                        // Legacy Moz lines
                        e.detail ? e.detail / -32765 * 60 : (
                          // Legacy Moz pages
                          0
                        )
                      )
                    )
                  )
                )
              )
            )
          );
        }
        function isExternalTarget(el2, e) {
          var related = e.relatedTarget;
          if (!related) {
            return true;
          }
          try {
            while (related && related !== el2) {
              related = related.parentNode;
            }
          } catch (err) {
            return false;
          }
          return related !== el2;
        }
        var DomEvent = {
          __proto__: null,
          on,
          off,
          stopPropagation,
          disableScrollPropagation,
          disableClickPropagation,
          preventDefault,
          stop,
          getPropagationPath,
          getMousePosition,
          getWheelDelta,
          isExternalTarget,
          addListener: on,
          removeListener: off
        };
        var PosAnimation = Evented.extend({
          // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
          // Run an animation of a given element to a new position, optionally setting
          // duration in seconds (`0.25` by default) and easing linearity factor (3rd
          // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),
          // `0.5` by default).
          run: function(el2, newPos, duration, easeLinearity) {
            this.stop();
            this._el = el2;
            this._inProgress = true;
            this._duration = duration || 0.25;
            this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
            this._startPos = getPosition(el2);
            this._offset = newPos.subtract(this._startPos);
            this._startTime = +/* @__PURE__ */ new Date();
            this.fire("start");
            this._animate();
          },
          // @method stop()
          // Stops the animation (if currently running).
          stop: function() {
            if (!this._inProgress) {
              return;
            }
            this._step(true);
            this._complete();
          },
          _animate: function() {
            this._animId = requestAnimFrame(this._animate, this);
            this._step();
          },
          _step: function(round2) {
            var elapsed = +/* @__PURE__ */ new Date() - this._startTime, duration = this._duration * 1e3;
            if (elapsed < duration) {
              this._runFrame(this._easeOut(elapsed / duration), round2);
            } else {
              this._runFrame(1);
              this._complete();
            }
          },
          _runFrame: function(progress, round2) {
            var pos = this._startPos.add(this._offset.multiplyBy(progress));
            if (round2) {
              pos._round();
            }
            setPosition(this._el, pos);
            this.fire("step");
          },
          _complete: function() {
            cancelAnimFrame(this._animId);
            this._inProgress = false;
            this.fire("end");
          },
          _easeOut: function(t2) {
            return 1 - Math.pow(1 - t2, this._easeOutPower);
          }
        });
        var Map2 = Evented.extend({
          options: {
            // @section Map State Options
            // @option crs: CRS = L.CRS.EPSG3857
            // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
            // sure what it means.
            crs: EPSG3857,
            // @option center: LatLng = undefined
            // Initial geographic center of the map
            center: void 0,
            // @option zoom: Number = undefined
            // Initial map zoom level
            zoom: void 0,
            // @option minZoom: Number = *
            // Minimum zoom level of the map.
            // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
            // the lowest of their `minZoom` options will be used instead.
            minZoom: void 0,
            // @option maxZoom: Number = *
            // Maximum zoom level of the map.
            // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
            // the highest of their `maxZoom` options will be used instead.
            maxZoom: void 0,
            // @option layers: Layer[] = []
            // Array of layers that will be added to the map initially
            layers: [],
            // @option maxBounds: LatLngBounds = null
            // When this option is set, the map restricts the view to the given
            // geographical bounds, bouncing the user back if the user tries to pan
            // outside the view. To set the restriction dynamically, use
            // [`setMaxBounds`](#map-setmaxbounds) method.
            maxBounds: void 0,
            // @option renderer: Renderer = *
            // The default method for drawing vector layers on the map. `L.SVG`
            // or `L.Canvas` by default depending on browser support.
            renderer: void 0,
            // @section Animation Options
            // @option zoomAnimation: Boolean = true
            // Whether the map zoom animation is enabled. By default it's enabled
            // in all browsers that support CSS3 Transitions except Android.
            zoomAnimation: true,
            // @option zoomAnimationThreshold: Number = 4
            // Won't animate zoom if the zoom difference exceeds this value.
            zoomAnimationThreshold: 4,
            // @option fadeAnimation: Boolean = true
            // Whether the tile fade animation is enabled. By default it's enabled
            // in all browsers that support CSS3 Transitions except Android.
            fadeAnimation: true,
            // @option markerZoomAnimation: Boolean = true
            // Whether markers animate their zoom with the zoom animation, if disabled
            // they will disappear for the length of the animation. By default it's
            // enabled in all browsers that support CSS3 Transitions except Android.
            markerZoomAnimation: true,
            // @option transform3DLimit: Number = 2^23
            // Defines the maximum size of a CSS translation transform. The default
            // value should not be changed unless a web browser positions layers in
            // the wrong place after doing a large `panBy`.
            transform3DLimit: 8388608,
            // Precision limit of a 32-bit float
            // @section Interaction Options
            // @option zoomSnap: Number = 1
            // Forces the map's zoom level to always be a multiple of this, particularly
            // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
            // By default, the zoom level snaps to the nearest integer; lower values
            // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
            // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
            zoomSnap: 1,
            // @option zoomDelta: Number = 1
            // Controls how much the map's zoom level will change after a
            // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
            // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
            // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
            zoomDelta: 1,
            // @option trackResize: Boolean = true
            // Whether the map automatically handles browser window resize to update itself.
            trackResize: true
          },
          initialize: function(id2, options) {
            options = setOptions(this, options);
            this._handlers = [];
            this._layers = {};
            this._zoomBoundLayers = {};
            this._sizeChanged = true;
            this._initContainer(id2);
            this._initLayout();
            this._onResize = bind(this._onResize, this);
            this._initEvents();
            if (options.maxBounds) {
              this.setMaxBounds(options.maxBounds);
            }
            if (options.zoom !== void 0) {
              this._zoom = this._limitZoom(options.zoom);
            }
            if (options.center && options.zoom !== void 0) {
              this.setView(toLatLng(options.center), options.zoom, { reset: true });
            }
            this.callInitHooks();
            this._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;
            if (this._zoomAnimated) {
              this._createAnimProxy();
              on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
            }
            this._addLayers(this.options.layers);
          },
          // @section Methods for modifying map state
          // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
          // Sets the view of the map (geographical center and zoom) with the given
          // animation options.
          setView: function(center, zoom2, options) {
            zoom2 = zoom2 === void 0 ? this._zoom : this._limitZoom(zoom2);
            center = this._limitCenter(toLatLng(center), zoom2, this.options.maxBounds);
            options = options || {};
            this._stop();
            if (this._loaded && !options.reset && options !== true) {
              if (options.animate !== void 0) {
                options.zoom = extend2({ animate: options.animate }, options.zoom);
                options.pan = extend2({ animate: options.animate, duration: options.duration }, options.pan);
              }
              var moved = this._zoom !== zoom2 ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom2, options.zoom) : this._tryAnimatedPan(center, options.pan);
              if (moved) {
                clearTimeout(this._sizeTimer);
                return this;
              }
            }
            this._resetView(center, zoom2, options.pan && options.pan.noMoveStart);
            return this;
          },
          // @method setZoom(zoom: Number, options?: Zoom/pan options): this
          // Sets the zoom of the map.
          setZoom: function(zoom2, options) {
            if (!this._loaded) {
              this._zoom = zoom2;
              return this;
            }
            return this.setView(this.getCenter(), zoom2, { zoom: options });
          },
          // @method zoomIn(delta?: Number, options?: Zoom options): this
          // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
          zoomIn: function(delta, options) {
            delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
            return this.setZoom(this._zoom + delta, options);
          },
          // @method zoomOut(delta?: Number, options?: Zoom options): this
          // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
          zoomOut: function(delta, options) {
            delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
            return this.setZoom(this._zoom - delta, options);
          },
          // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
          // Zooms the map while keeping a specified geographical point on the map
          // stationary (e.g. used internally for scroll zoom and double-click zoom).
          // @alternative
          // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
          // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
          setZoomAround: function(latlng, zoom2, options) {
            var scale2 = this.getZoomScale(zoom2), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale2), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
            return this.setView(newCenter, zoom2, { zoom: options });
          },
          _getBoundsCenterZoom: function(bounds, options) {
            options = options || {};
            bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
            var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), zoom2 = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
            zoom2 = typeof options.maxZoom === "number" ? Math.min(options.maxZoom, zoom2) : zoom2;
            if (zoom2 === Infinity) {
              return {
                center: bounds.getCenter(),
                zoom: zoom2
              };
            }
            var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds.getSouthWest(), zoom2), nePoint = this.project(bounds.getNorthEast(), zoom2), center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom2);
            return {
              center,
              zoom: zoom2
            };
          },
          // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
          // Sets a map view that contains the given geographical bounds with the
          // maximum zoom level possible.
          fitBounds: function(bounds, options) {
            bounds = toLatLngBounds(bounds);
            if (!bounds.isValid()) {
              throw new Error("Bounds are not valid.");
            }
            var target = this._getBoundsCenterZoom(bounds, options);
            return this.setView(target.center, target.zoom, options);
          },
          // @method fitWorld(options?: fitBounds options): this
          // Sets a map view that mostly contains the whole world with the maximum
          // zoom level possible.
          fitWorld: function(options) {
            return this.fitBounds([[-90, -180], [90, 180]], options);
          },
          // @method panTo(latlng: LatLng, options?: Pan options): this
          // Pans the map to a given center.
          panTo: function(center, options) {
            return this.setView(center, this._zoom, { pan: options });
          },
          // @method panBy(offset: Point, options?: Pan options): this
          // Pans the map by a given number of pixels (animated).
          panBy: function(offset, options) {
            offset = toPoint(offset).round();
            options = options || {};
            if (!offset.x && !offset.y) {
              return this.fire("moveend");
            }
            if (options.animate !== true && !this.getSize().contains(offset)) {
              this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
              return this;
            }
            if (!this._panAnim) {
              this._panAnim = new PosAnimation();
              this._panAnim.on({
                "step": this._onPanTransitionStep,
                "end": this._onPanTransitionEnd
              }, this);
            }
            if (!options.noMoveStart) {
              this.fire("movestart");
            }
            if (options.animate !== false) {
              addClass(this._mapPane, "leaflet-pan-anim");
              var newPos = this._getMapPanePos().subtract(offset).round();
              this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
            } else {
              this._rawPanBy(offset);
              this.fire("move").fire("moveend");
            }
            return this;
          },
          // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
          // Sets the view of the map (geographical center and zoom) performing a smooth
          // pan-zoom animation.
          flyTo: function(targetCenter, targetZoom, options) {
            options = options || {};
            if (options.animate === false || !Browser.any3d) {
              return this.setView(targetCenter, targetZoom, options);
            }
            this._stop();
            var from2 = this.project(this.getCenter()), to2 = this.project(targetCenter), size = this.getSize(), startZoom = this._zoom;
            targetCenter = toLatLng(targetCenter);
            targetZoom = targetZoom === void 0 ? startZoom : targetZoom;
            var w0 = Math.max(size.x, size.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to2.distanceTo(from2) || 1, rho = 1.42, rho2 = rho * rho;
            function r2(i) {
              var s1 = i ? -1 : 1, s2 = i ? w1 : w0, t12 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1, b1 = 2 * s2 * rho2 * u1, b = t12 / b1, sq = Math.sqrt(b * b + 1) - b;
              var log2 = sq < 1e-9 ? -18 : Math.log(sq);
              return log2;
            }
            function sinh(n2) {
              return (Math.exp(n2) - Math.exp(-n2)) / 2;
            }
            function cosh(n2) {
              return (Math.exp(n2) + Math.exp(-n2)) / 2;
            }
            function tanh(n2) {
              return sinh(n2) / cosh(n2);
            }
            var r0 = r2(0);
            function w2(s2) {
              return w0 * (cosh(r0) / cosh(r0 + rho * s2));
            }
            function u2(s2) {
              return w0 * (cosh(r0) * tanh(r0 + rho * s2) - sinh(r0)) / rho2;
            }
            function easeOut(t2) {
              return 1 - Math.pow(1 - t2, 1.5);
            }
            var start = Date.now(), S2 = (r2(1) - r0) / rho, duration = options.duration ? 1e3 * options.duration : 1e3 * S2 * 0.8;
            function frame() {
              var t2 = (Date.now() - start) / duration, s2 = easeOut(t2) * S2;
              if (t2 <= 1) {
                this._flyToFrame = requestAnimFrame(frame, this);
                this._move(
                  this.unproject(from2.add(to2.subtract(from2).multiplyBy(u2(s2) / u1)), startZoom),
                  this.getScaleZoom(w0 / w2(s2), startZoom),
                  { flyTo: true }
                );
              } else {
                this._move(targetCenter, targetZoom)._moveEnd(true);
              }
            }
            this._moveStart(true, options.noMoveStart);
            frame.call(this);
            return this;
          },
          // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
          // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
          // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
          flyToBounds: function(bounds, options) {
            var target = this._getBoundsCenterZoom(bounds, options);
            return this.flyTo(target.center, target.zoom, options);
          },
          // @method setMaxBounds(bounds: LatLngBounds): this
          // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
          setMaxBounds: function(bounds) {
            bounds = toLatLngBounds(bounds);
            if (this.listens("moveend", this._panInsideMaxBounds)) {
              this.off("moveend", this._panInsideMaxBounds);
            }
            if (!bounds.isValid()) {
              this.options.maxBounds = null;
              return this;
            }
            this.options.maxBounds = bounds;
            if (this._loaded) {
              this._panInsideMaxBounds();
            }
            return this.on("moveend", this._panInsideMaxBounds);
          },
          // @method setMinZoom(zoom: Number): this
          // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
          setMinZoom: function(zoom2) {
            var oldZoom = this.options.minZoom;
            this.options.minZoom = zoom2;
            if (this._loaded && oldZoom !== zoom2) {
              this.fire("zoomlevelschange");
              if (this.getZoom() < this.options.minZoom) {
                return this.setZoom(zoom2);
              }
            }
            return this;
          },
          // @method setMaxZoom(zoom: Number): this
          // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
          setMaxZoom: function(zoom2) {
            var oldZoom = this.options.maxZoom;
            this.options.maxZoom = zoom2;
            if (this._loaded && oldZoom !== zoom2) {
              this.fire("zoomlevelschange");
              if (this.getZoom() > this.options.maxZoom) {
                return this.setZoom(zoom2);
              }
            }
            return this;
          },
          // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
          // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
          panInsideBounds: function(bounds, options) {
            this._enforcingBounds = true;
            var center = this.getCenter(), newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));
            if (!center.equals(newCenter)) {
              this.panTo(newCenter, options);
            }
            this._enforcingBounds = false;
            return this;
          },
          // @method panInside(latlng: LatLng, options?: padding options): this
          // Pans the map the minimum amount to make the `latlng` visible. Use
          // padding options to fit the display to more restricted bounds.
          // If `latlng` is already within the (optionally padded) display bounds,
          // the map will not be panned.
          panInside: function(latlng, options) {
            options = options || {};
            var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), pixelCenter = this.project(this.getCenter()), pixelPoint = this.project(latlng), pixelBounds = this.getPixelBounds(), paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]), paddedSize = paddedBounds.getSize();
            if (!paddedBounds.contains(pixelPoint)) {
              this._enforcingBounds = true;
              var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());
              var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);
              pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;
              pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;
              this.panTo(this.unproject(pixelCenter), options);
              this._enforcingBounds = false;
            }
            return this;
          },
          // @method invalidateSize(options: Zoom/pan options): this
          // Checks if the map container size changed and updates the map if so 
          // call it after you've changed the map size dynamically, also animating
          // pan by default. If `options.pan` is `false`, panning will not occur.
          // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
          // that it doesn't happen often even if the method is called many
          // times in a row.
          // @alternative
          // @method invalidateSize(animate: Boolean): this
          // Checks if the map container size changed and updates the map if so 
          // call it after you've changed the map size dynamically, also animating
          // pan by default.
          invalidateSize: function(options) {
            if (!this._loaded) {
              return this;
            }
            options = extend2({
              animate: false,
              pan: true
            }, options === true ? { animate: true } : options);
            var oldSize = this.getSize();
            this._sizeChanged = true;
            this._lastCenter = null;
            var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);
            if (!offset.x && !offset.y) {
              return this;
            }
            if (options.animate && options.pan) {
              this.panBy(offset);
            } else {
              if (options.pan) {
                this._rawPanBy(offset);
              }
              this.fire("move");
              if (options.debounceMoveend) {
                clearTimeout(this._sizeTimer);
                this._sizeTimer = setTimeout(bind(this.fire, this, "moveend"), 200);
              } else {
                this.fire("moveend");
              }
            }
            return this.fire("resize", {
              oldSize,
              newSize
            });
          },
          // @section Methods for modifying map state
          // @method stop(): this
          // Stops the currently running `panTo` or `flyTo` animation, if any.
          stop: function() {
            this.setZoom(this._limitZoom(this._zoom));
            if (!this.options.zoomSnap) {
              this.fire("viewreset");
            }
            return this._stop();
          },
          // @section Geolocation methods
          // @method locate(options?: Locate options): this
          // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
          // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
          // and optionally sets the map view to the user's location with respect to
          // detection accuracy (or to the world view if geolocation failed).
          // Note that, if your page doesn't use HTTPS, this method will fail in
          // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
          // See `Locate options` for more details.
          locate: function(options) {
            options = this._locateOptions = extend2({
              timeout: 1e4,
              watch: false
              // setView: false
              // maxZoom: <Number>
              // maximumAge: 0
              // enableHighAccuracy: false
            }, options);
            if (!("geolocation" in navigator)) {
              this._handleGeolocationError({
                code: 0,
                message: "Geolocation not supported."
              });
              return this;
            }
            var onResponse = bind(this._handleGeolocationResponse, this), onError = bind(this._handleGeolocationError, this);
            if (options.watch) {
              this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
            } else {
              navigator.geolocation.getCurrentPosition(onResponse, onError, options);
            }
            return this;
          },
          // @method stopLocate(): this
          // Stops watching location previously initiated by `map.locate({watch: true})`
          // and aborts resetting the map view if map.locate was called with
          // `{setView: true}`.
          stopLocate: function() {
            if (navigator.geolocation && navigator.geolocation.clearWatch) {
              navigator.geolocation.clearWatch(this._locationWatchId);
            }
            if (this._locateOptions) {
              this._locateOptions.setView = false;
            }
            return this;
          },
          _handleGeolocationError: function(error) {
            if (!this._container._leaflet_id) {
              return;
            }
            var c2 = error.code, message = error.message || (c2 === 1 ? "permission denied" : c2 === 2 ? "position unavailable" : "timeout");
            if (this._locateOptions.setView && !this._loaded) {
              this.fitWorld();
            }
            this.fire("locationerror", {
              code: c2,
              message: "Geolocation error: " + message + "."
            });
          },
          _handleGeolocationResponse: function(pos) {
            if (!this._container._leaflet_id) {
              return;
            }
            var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new LatLng(lat, lng), bounds = latlng.toBounds(pos.coords.accuracy * 2), options = this._locateOptions;
            if (options.setView) {
              var zoom2 = this.getBoundsZoom(bounds);
              this.setView(latlng, options.maxZoom ? Math.min(zoom2, options.maxZoom) : zoom2);
            }
            var data = {
              latlng,
              bounds,
              timestamp: pos.timestamp
            };
            for (var i in pos.coords) {
              if (typeof pos.coords[i] === "number") {
                data[i] = pos.coords[i];
              }
            }
            this.fire("locationfound", data);
          },
          // TODO Appropriate docs section?
          // @section Other Methods
          // @method addHandler(name: String, HandlerClass: Function): this
          // Adds a new `Handler` to the map, given its name and constructor function.
          addHandler: function(name, HandlerClass) {
            if (!HandlerClass) {
              return this;
            }
            var handler = this[name] = new HandlerClass(this);
            this._handlers.push(handler);
            if (this.options[name]) {
              handler.enable();
            }
            return this;
          },
          // @method remove(): this
          // Destroys the map and clears all related event listeners.
          remove: function() {
            this._initEvents(true);
            if (this.options.maxBounds) {
              this.off("moveend", this._panInsideMaxBounds);
            }
            if (this._containerId !== this._container._leaflet_id) {
              throw new Error("Map container is being reused by another instance");
            }
            try {
              delete this._container._leaflet_id;
              delete this._containerId;
            } catch (e) {
              this._container._leaflet_id = void 0;
              this._containerId = void 0;
            }
            if (this._locationWatchId !== void 0) {
              this.stopLocate();
            }
            this._stop();
            remove(this._mapPane);
            if (this._clearControlPos) {
              this._clearControlPos();
            }
            if (this._resizeRequest) {
              cancelAnimFrame(this._resizeRequest);
              this._resizeRequest = null;
            }
            this._clearHandlers();
            if (this._loaded) {
              this.fire("unload");
            }
            var i;
            for (i in this._layers) {
              this._layers[i].remove();
            }
            for (i in this._panes) {
              remove(this._panes[i]);
            }
            this._layers = [];
            this._panes = [];
            delete this._mapPane;
            delete this._renderer;
            return this;
          },
          // @section Other Methods
          // @method createPane(name: String, container?: HTMLElement): HTMLElement
          // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
          // then returns it. The pane is created as a child of `container`, or
          // as a child of the main map pane if not set.
          createPane: function(name, container) {
            var className = "leaflet-pane" + (name ? " leaflet-" + name.replace("Pane", "") + "-pane" : ""), pane = create$1("div", className, container || this._mapPane);
            if (name) {
              this._panes[name] = pane;
            }
            return pane;
          },
          // @section Methods for Getting Map State
          // @method getCenter(): LatLng
          // Returns the geographical center of the map view
          getCenter: function() {
            this._checkIfLoaded();
            if (this._lastCenter && !this._moved()) {
              return this._lastCenter.clone();
            }
            return this.layerPointToLatLng(this._getCenterLayerPoint());
          },
          // @method getZoom(): Number
          // Returns the current zoom level of the map view
          getZoom: function() {
            return this._zoom;
          },
          // @method getBounds(): LatLngBounds
          // Returns the geographical bounds visible in the current map view
          getBounds: function() {
            var bounds = this.getPixelBounds(), sw = this.unproject(bounds.getBottomLeft()), ne2 = this.unproject(bounds.getTopRight());
            return new LatLngBounds(sw, ne2);
          },
          // @method getMinZoom(): Number
          // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
          getMinZoom: function() {
            return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
          },
          // @method getMaxZoom(): Number
          // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
          getMaxZoom: function() {
            return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? Infinity : this._layersMaxZoom : this.options.maxZoom;
          },
          // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
          // Returns the maximum zoom level on which the given bounds fit to the map
          // view in its entirety. If `inside` (optional) is set to `true`, the method
          // instead returns the minimum zoom level on which the map view fits into
          // the given bounds in its entirety.
          getBoundsZoom: function(bounds, inside, padding) {
            bounds = toLatLngBounds(bounds);
            padding = toPoint(padding || [0, 0]);
            var zoom2 = this.getZoom() || 0, min2 = this.getMinZoom(), max2 = this.getMaxZoom(), nw = bounds.getNorthWest(), se2 = bounds.getSouthEast(), size = this.getSize().subtract(padding), boundsSize = toBounds(this.project(se2, zoom2), this.project(nw, zoom2)).getSize(), snap = Browser.any3d ? this.options.zoomSnap : 1, scalex = size.x / boundsSize.x, scaley = size.y / boundsSize.y, scale2 = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
            zoom2 = this.getScaleZoom(scale2, zoom2);
            if (snap) {
              zoom2 = Math.round(zoom2 / (snap / 100)) * (snap / 100);
              zoom2 = inside ? Math.ceil(zoom2 / snap) * snap : Math.floor(zoom2 / snap) * snap;
            }
            return Math.max(min2, Math.min(max2, zoom2));
          },
          // @method getSize(): Point
          // Returns the current size of the map container (in pixels).
          getSize: function() {
            if (!this._size || this._sizeChanged) {
              this._size = new Point(
                this._container.clientWidth || 0,
                this._container.clientHeight || 0
              );
              this._sizeChanged = false;
            }
            return this._size.clone();
          },
          // @method getPixelBounds(): Bounds
          // Returns the bounds of the current map view in projected pixel
          // coordinates (sometimes useful in layer and overlay implementations).
          getPixelBounds: function(center, zoom2) {
            var topLeftPoint = this._getTopLeftPoint(center, zoom2);
            return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
          },
          // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
          // the map pane? "left point of the map layer" can be confusing, specially
          // since there can be negative offsets.
          // @method getPixelOrigin(): Point
          // Returns the projected pixel coordinates of the top left point of
          // the map layer (useful in custom layer and overlay implementations).
          getPixelOrigin: function() {
            this._checkIfLoaded();
            return this._pixelOrigin;
          },
          // @method getPixelWorldBounds(zoom?: Number): Bounds
          // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
          // If `zoom` is omitted, the map's current zoom level is used.
          getPixelWorldBounds: function(zoom2) {
            return this.options.crs.getProjectedBounds(zoom2 === void 0 ? this.getZoom() : zoom2);
          },
          // @section Other Methods
          // @method getPane(pane: String|HTMLElement): HTMLElement
          // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
          getPane: function(pane) {
            return typeof pane === "string" ? this._panes[pane] : pane;
          },
          // @method getPanes(): Object
          // Returns a plain object containing the names of all [panes](#map-pane) as keys and
          // the panes as values.
          getPanes: function() {
            return this._panes;
          },
          // @method getContainer: HTMLElement
          // Returns the HTML element that contains the map.
          getContainer: function() {
            return this._container;
          },
          // @section Conversion Methods
          // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
          // Returns the scale factor to be applied to a map transition from zoom level
          // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
          getZoomScale: function(toZoom, fromZoom) {
            var crs = this.options.crs;
            fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
            return crs.scale(toZoom) / crs.scale(fromZoom);
          },
          // @method getScaleZoom(scale: Number, fromZoom: Number): Number
          // Returns the zoom level that the map would end up at, if it is at `fromZoom`
          // level and everything is scaled by a factor of `scale`. Inverse of
          // [`getZoomScale`](#map-getZoomScale).
          getScaleZoom: function(scale2, fromZoom) {
            var crs = this.options.crs;
            fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
            var zoom2 = crs.zoom(scale2 * crs.scale(fromZoom));
            return isNaN(zoom2) ? Infinity : zoom2;
          },
          // @method project(latlng: LatLng, zoom: Number): Point
          // Projects a geographical coordinate `LatLng` according to the projection
          // of the map's CRS, then scales it according to `zoom` and the CRS's
          // `Transformation`. The result is pixel coordinate relative to
          // the CRS origin.
          project: function(latlng, zoom2) {
            zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
            return this.options.crs.latLngToPoint(toLatLng(latlng), zoom2);
          },
          // @method unproject(point: Point, zoom: Number): LatLng
          // Inverse of [`project`](#map-project).
          unproject: function(point2, zoom2) {
            zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
            return this.options.crs.pointToLatLng(toPoint(point2), zoom2);
          },
          // @method layerPointToLatLng(point: Point): LatLng
          // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
          // returns the corresponding geographical coordinate (for the current zoom level).
          layerPointToLatLng: function(point2) {
            var projectedPoint = toPoint(point2).add(this.getPixelOrigin());
            return this.unproject(projectedPoint);
          },
          // @method latLngToLayerPoint(latlng: LatLng): Point
          // Given a geographical coordinate, returns the corresponding pixel coordinate
          // relative to the [origin pixel](#map-getpixelorigin).
          latLngToLayerPoint: function(latlng) {
            var projectedPoint = this.project(toLatLng(latlng))._round();
            return projectedPoint._subtract(this.getPixelOrigin());
          },
          // @method wrapLatLng(latlng: LatLng): LatLng
          // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
          // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
          // CRS's bounds.
          // By default this means longitude is wrapped around the dateline so its
          // value is between -180 and +180 degrees.
          wrapLatLng: function(latlng) {
            return this.options.crs.wrapLatLng(toLatLng(latlng));
          },
          // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
          // Returns a `LatLngBounds` with the same size as the given one, ensuring that
          // its center is within the CRS's bounds.
          // By default this means the center longitude is wrapped around the dateline so its
          // value is between -180 and +180 degrees, and the majority of the bounds
          // overlaps the CRS's bounds.
          wrapLatLngBounds: function(latlng) {
            return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
          },
          // @method distance(latlng1: LatLng, latlng2: LatLng): Number
          // Returns the distance between two geographical coordinates according to
          // the map's CRS. By default this measures distance in meters.
          distance: function(latlng1, latlng2) {
            return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
          },
          // @method containerPointToLayerPoint(point: Point): Point
          // Given a pixel coordinate relative to the map container, returns the corresponding
          // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
          containerPointToLayerPoint: function(point2) {
            return toPoint(point2).subtract(this._getMapPanePos());
          },
          // @method layerPointToContainerPoint(point: Point): Point
          // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
          // returns the corresponding pixel coordinate relative to the map container.
          layerPointToContainerPoint: function(point2) {
            return toPoint(point2).add(this._getMapPanePos());
          },
          // @method containerPointToLatLng(point: Point): LatLng
          // Given a pixel coordinate relative to the map container, returns
          // the corresponding geographical coordinate (for the current zoom level).
          containerPointToLatLng: function(point2) {
            var layerPoint = this.containerPointToLayerPoint(toPoint(point2));
            return this.layerPointToLatLng(layerPoint);
          },
          // @method latLngToContainerPoint(latlng: LatLng): Point
          // Given a geographical coordinate, returns the corresponding pixel coordinate
          // relative to the map container.
          latLngToContainerPoint: function(latlng) {
            return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
          },
          // @method mouseEventToContainerPoint(ev: MouseEvent): Point
          // Given a MouseEvent object, returns the pixel coordinate relative to the
          // map container where the event took place.
          mouseEventToContainerPoint: function(e) {
            return getMousePosition(e, this._container);
          },
          // @method mouseEventToLayerPoint(ev: MouseEvent): Point
          // Given a MouseEvent object, returns the pixel coordinate relative to
          // the [origin pixel](#map-getpixelorigin) where the event took place.
          mouseEventToLayerPoint: function(e) {
            return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
          },
          // @method mouseEventToLatLng(ev: MouseEvent): LatLng
          // Given a MouseEvent object, returns geographical coordinate where the
          // event took place.
          mouseEventToLatLng: function(e) {
            return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
          },
          // map initialization methods
          _initContainer: function(id2) {
            var container = this._container = get2(id2);
            if (!container) {
              throw new Error("Map container not found.");
            } else if (container._leaflet_id) {
              throw new Error("Map container is already initialized.");
            }
            on(container, "scroll", this._onScroll, this);
            this._containerId = stamp(container);
          },
          _initLayout: function() {
            var container = this._container;
            this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;
            addClass(container, "leaflet-container" + (Browser.touch ? " leaflet-touch" : "") + (Browser.retina ? " leaflet-retina" : "") + (Browser.ielt9 ? " leaflet-oldie" : "") + (Browser.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
            var position = getStyle(container, "position");
            if (position !== "absolute" && position !== "relative" && position !== "fixed" && position !== "sticky") {
              container.style.position = "relative";
            }
            this._initPanes();
            if (this._initControlPos) {
              this._initControlPos();
            }
          },
          _initPanes: function() {
            var panes = this._panes = {};
            this._paneRenderers = {};
            this._mapPane = this.createPane("mapPane", this._container);
            setPosition(this._mapPane, new Point(0, 0));
            this.createPane("tilePane");
            this.createPane("overlayPane");
            this.createPane("shadowPane");
            this.createPane("markerPane");
            this.createPane("tooltipPane");
            this.createPane("popupPane");
            if (!this.options.markerZoomAnimation) {
              addClass(panes.markerPane, "leaflet-zoom-hide");
              addClass(panes.shadowPane, "leaflet-zoom-hide");
            }
          },
          // private methods that modify map state
          // @section Map state change events
          _resetView: function(center, zoom2, noMoveStart) {
            setPosition(this._mapPane, new Point(0, 0));
            var loading = !this._loaded;
            this._loaded = true;
            zoom2 = this._limitZoom(zoom2);
            this.fire("viewprereset");
            var zoomChanged = this._zoom !== zoom2;
            this._moveStart(zoomChanged, noMoveStart)._move(center, zoom2)._moveEnd(zoomChanged);
            this.fire("viewreset");
            if (loading) {
              this.fire("load");
            }
          },
          _moveStart: function(zoomChanged, noMoveStart) {
            if (zoomChanged) {
              this.fire("zoomstart");
            }
            if (!noMoveStart) {
              this.fire("movestart");
            }
            return this;
          },
          _move: function(center, zoom2, data, supressEvent) {
            if (zoom2 === void 0) {
              zoom2 = this._zoom;
            }
            var zoomChanged = this._zoom !== zoom2;
            this._zoom = zoom2;
            this._lastCenter = center;
            this._pixelOrigin = this._getNewPixelOrigin(center);
            if (!supressEvent) {
              if (zoomChanged || data && data.pinch) {
                this.fire("zoom", data);
              }
              this.fire("move", data);
            } else if (data && data.pinch) {
              this.fire("zoom", data);
            }
            return this;
          },
          _moveEnd: function(zoomChanged) {
            if (zoomChanged) {
              this.fire("zoomend");
            }
            return this.fire("moveend");
          },
          _stop: function() {
            cancelAnimFrame(this._flyToFrame);
            if (this._panAnim) {
              this._panAnim.stop();
            }
            return this;
          },
          _rawPanBy: function(offset) {
            setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
          },
          _getZoomSpan: function() {
            return this.getMaxZoom() - this.getMinZoom();
          },
          _panInsideMaxBounds: function() {
            if (!this._enforcingBounds) {
              this.panInsideBounds(this.options.maxBounds);
            }
          },
          _checkIfLoaded: function() {
            if (!this._loaded) {
              throw new Error("Set map center and zoom first.");
            }
          },
          // DOM event handling
          // @section Interaction events
          _initEvents: function(remove2) {
            this._targets = {};
            this._targets[stamp(this._container)] = this;
            var onOff = remove2 ? off : on;
            onOff(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this);
            if (this.options.trackResize) {
              onOff(window, "resize", this._onResize, this);
            }
            if (Browser.any3d && this.options.transform3DLimit) {
              (remove2 ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
            }
          },
          _onResize: function() {
            cancelAnimFrame(this._resizeRequest);
            this._resizeRequest = requestAnimFrame(
              function() {
                this.invalidateSize({ debounceMoveend: true });
              },
              this
            );
          },
          _onScroll: function() {
            this._container.scrollTop = 0;
            this._container.scrollLeft = 0;
          },
          _onMoveEnd: function() {
            var pos = this._getMapPanePos();
            if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
              this._resetView(this.getCenter(), this.getZoom());
            }
          },
          _findEventTargets: function(e, type) {
            var targets = [], target, isHover = type === "mouseout" || type === "mouseover", src = e.target || e.srcElement, dragging = false;
            while (src) {
              target = this._targets[stamp(src)];
              if (target && (type === "click" || type === "preclick") && this._draggableMoved(target)) {
                dragging = true;
                break;
              }
              if (target && target.listens(type, true)) {
                if (isHover && !isExternalTarget(src, e)) {
                  break;
                }
                targets.push(target);
                if (isHover) {
                  break;
                }
              }
              if (src === this._container) {
                break;
              }
              src = src.parentNode;
            }
            if (!targets.length && !dragging && !isHover && this.listens(type, true)) {
              targets = [this];
            }
            return targets;
          },
          _isClickDisabled: function(el2) {
            while (el2 && el2 !== this._container) {
              if (el2["_leaflet_disable_click"]) {
                return true;
              }
              el2 = el2.parentNode;
            }
          },
          _handleDOMEvent: function(e) {
            var el2 = e.target || e.srcElement;
            if (!this._loaded || el2["_leaflet_disable_events"] || e.type === "click" && this._isClickDisabled(el2)) {
              return;
            }
            var type = e.type;
            if (type === "mousedown") {
              preventOutline(el2);
            }
            this._fireDOMEvent(e, type);
          },
          _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
          _fireDOMEvent: function(e, type, canvasTargets) {
            if (e.type === "click") {
              var synth = extend2({}, e);
              synth.type = "preclick";
              this._fireDOMEvent(synth, synth.type, canvasTargets);
            }
            var targets = this._findEventTargets(e, type);
            if (canvasTargets) {
              var filtered = [];
              for (var i = 0; i < canvasTargets.length; i++) {
                if (canvasTargets[i].listens(type, true)) {
                  filtered.push(canvasTargets[i]);
                }
              }
              targets = filtered.concat(targets);
            }
            if (!targets.length) {
              return;
            }
            if (type === "contextmenu") {
              preventDefault(e);
            }
            var target = targets[0];
            var data = {
              originalEvent: e
            };
            if (e.type !== "keypress" && e.type !== "keydown" && e.type !== "keyup") {
              var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
              data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
              data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
              data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
            }
            for (i = 0; i < targets.length; i++) {
              targets[i].fire(type, data, true);
              if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {
                return;
              }
            }
          },
          _draggableMoved: function(obj) {
            obj = obj.dragging && obj.dragging.enabled() ? obj : this;
            return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
          },
          _clearHandlers: function() {
            for (var i = 0, len = this._handlers.length; i < len; i++) {
              this._handlers[i].disable();
            }
          },
          // @section Other Methods
          // @method whenReady(fn: Function, context?: Object): this
          // Runs the given function `fn` when the map gets initialized with
          // a view (center and zoom) and at least one layer, or immediately
          // if it's already initialized, optionally passing a function context.
          whenReady: function(callback, context) {
            if (this._loaded) {
              callback.call(context || this, { target: this });
            } else {
              this.on("load", callback, context);
            }
            return this;
          },
          // private methods for getting map state
          _getMapPanePos: function() {
            return getPosition(this._mapPane) || new Point(0, 0);
          },
          _moved: function() {
            var pos = this._getMapPanePos();
            return pos && !pos.equals([0, 0]);
          },
          _getTopLeftPoint: function(center, zoom2) {
            var pixelOrigin = center && zoom2 !== void 0 ? this._getNewPixelOrigin(center, zoom2) : this.getPixelOrigin();
            return pixelOrigin.subtract(this._getMapPanePos());
          },
          _getNewPixelOrigin: function(center, zoom2) {
            var viewHalf = this.getSize()._divideBy(2);
            return this.project(center, zoom2)._subtract(viewHalf)._add(this._getMapPanePos())._round();
          },
          _latLngToNewLayerPoint: function(latlng, zoom2, center) {
            var topLeft = this._getNewPixelOrigin(center, zoom2);
            return this.project(latlng, zoom2)._subtract(topLeft);
          },
          _latLngBoundsToNewLayerBounds: function(latLngBounds, zoom2, center) {
            var topLeft = this._getNewPixelOrigin(center, zoom2);
            return toBounds([
              this.project(latLngBounds.getSouthWest(), zoom2)._subtract(topLeft),
              this.project(latLngBounds.getNorthWest(), zoom2)._subtract(topLeft),
              this.project(latLngBounds.getSouthEast(), zoom2)._subtract(topLeft),
              this.project(latLngBounds.getNorthEast(), zoom2)._subtract(topLeft)
            ]);
          },
          // layer point of the current center
          _getCenterLayerPoint: function() {
            return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
          },
          // offset of the specified place to the current center in pixels
          _getCenterOffset: function(latlng) {
            return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
          },
          // adjust center for view to get inside bounds
          _limitCenter: function(center, zoom2, bounds) {
            if (!bounds) {
              return center;
            }
            var centerPoint = this.project(center, zoom2), viewHalf = this.getSize().divideBy(2), viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds, zoom2);
            if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {
              return center;
            }
            return this.unproject(centerPoint.add(offset), zoom2);
          },
          // adjust offset for view to get inside bounds
          _limitOffset: function(offset, bounds) {
            if (!bounds) {
              return offset;
            }
            var viewBounds = this.getPixelBounds(), newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
            return offset.add(this._getBoundsOffset(newBounds, bounds));
          },
          // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
          _getBoundsOffset: function(pxBounds, maxBounds, zoom2) {
            var projectedMaxBounds = toBounds(
              this.project(maxBounds.getNorthEast(), zoom2),
              this.project(maxBounds.getSouthWest(), zoom2)
            ), minOffset = projectedMaxBounds.min.subtract(pxBounds.min), maxOffset = projectedMaxBounds.max.subtract(pxBounds.max), dx = this._rebound(minOffset.x, -maxOffset.x), dy = this._rebound(minOffset.y, -maxOffset.y);
            return new Point(dx, dy);
          },
          _rebound: function(left, right) {
            return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
          },
          _limitZoom: function(zoom2) {
            var min2 = this.getMinZoom(), max2 = this.getMaxZoom(), snap = Browser.any3d ? this.options.zoomSnap : 1;
            if (snap) {
              zoom2 = Math.round(zoom2 / snap) * snap;
            }
            return Math.max(min2, Math.min(max2, zoom2));
          },
          _onPanTransitionStep: function() {
            this.fire("move");
          },
          _onPanTransitionEnd: function() {
            removeClass(this._mapPane, "leaflet-pan-anim");
            this.fire("moveend");
          },
          _tryAnimatedPan: function(center, options) {
            var offset = this._getCenterOffset(center)._trunc();
            if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
              return false;
            }
            this.panBy(offset, options);
            return true;
          },
          _createAnimProxy: function() {
            var proxy = this._proxy = create$1("div", "leaflet-proxy leaflet-zoom-animated");
            this._panes.mapPane.appendChild(proxy);
            this.on("zoomanim", function(e) {
              var prop = TRANSFORM, transform = this._proxy.style[prop];
              setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));
              if (transform === this._proxy.style[prop] && this._animatingZoom) {
                this._onZoomTransitionEnd();
              }
            }, this);
            this.on("load moveend", this._animMoveEnd, this);
            this._on("unload", this._destroyAnimProxy, this);
          },
          _destroyAnimProxy: function() {
            remove(this._proxy);
            this.off("load moveend", this._animMoveEnd, this);
            delete this._proxy;
          },
          _animMoveEnd: function() {
            var c2 = this.getCenter(), z2 = this.getZoom();
            setTransform(this._proxy, this.project(c2, z2), this.getZoomScale(z2, 1));
          },
          _catchTransitionEnd: function(e) {
            if (this._animatingZoom && e.propertyName.indexOf("transform") >= 0) {
              this._onZoomTransitionEnd();
            }
          },
          _nothingToAnimate: function() {
            return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
          },
          _tryAnimatedZoom: function(center, zoom2, options) {
            if (this._animatingZoom) {
              return true;
            }
            options = options || {};
            if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom2 - this._zoom) > this.options.zoomAnimationThreshold) {
              return false;
            }
            var scale2 = this.getZoomScale(zoom2), offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale2);
            if (options.animate !== true && !this.getSize().contains(offset)) {
              return false;
            }
            requestAnimFrame(function() {
              this._moveStart(true, options.noMoveStart || false)._animateZoom(center, zoom2, true);
            }, this);
            return true;
          },
          _animateZoom: function(center, zoom2, startAnim, noUpdate) {
            if (!this._mapPane) {
              return;
            }
            if (startAnim) {
              this._animatingZoom = true;
              this._animateToCenter = center;
              this._animateToZoom = zoom2;
              addClass(this._mapPane, "leaflet-zoom-anim");
            }
            this.fire("zoomanim", {
              center,
              zoom: zoom2,
              noUpdate
            });
            if (!this._tempFireZoomEvent) {
              this._tempFireZoomEvent = this._zoom !== this._animateToZoom;
            }
            this._move(this._animateToCenter, this._animateToZoom, void 0, true);
            setTimeout(bind(this._onZoomTransitionEnd, this), 250);
          },
          _onZoomTransitionEnd: function() {
            if (!this._animatingZoom) {
              return;
            }
            if (this._mapPane) {
              removeClass(this._mapPane, "leaflet-zoom-anim");
            }
            this._animatingZoom = false;
            this._move(this._animateToCenter, this._animateToZoom, void 0, true);
            if (this._tempFireZoomEvent) {
              this.fire("zoom");
            }
            delete this._tempFireZoomEvent;
            this.fire("move");
            this._moveEnd(true);
          }
        });
        function createMap(id2, options) {
          return new Map2(id2, options);
        }
        var Control = Class.extend({
          // @section
          // @aka Control Options
          options: {
            // @option position: String = 'topright'
            // The position of the control (one of the map corners). Possible values are `'topleft'`,
            // `'topright'`, `'bottomleft'` or `'bottomright'`
            position: "topright"
          },
          initialize: function(options) {
            setOptions(this, options);
          },
          /* @section
           * Classes extending L.Control will inherit the following methods:
           *
           * @method getPosition: string
           * Returns the position of the control.
           */
          getPosition: function() {
            return this.options.position;
          },
          // @method setPosition(position: string): this
          // Sets the position of the control.
          setPosition: function(position) {
            var map2 = this._map;
            if (map2) {
              map2.removeControl(this);
            }
            this.options.position = position;
            if (map2) {
              map2.addControl(this);
            }
            return this;
          },
          // @method getContainer: HTMLElement
          // Returns the HTMLElement that contains the control.
          getContainer: function() {
            return this._container;
          },
          // @method addTo(map: Map): this
          // Adds the control to the given map.
          addTo: function(map2) {
            this.remove();
            this._map = map2;
            var container = this._container = this.onAdd(map2), pos = this.getPosition(), corner = map2._controlCorners[pos];
            addClass(container, "leaflet-control");
            if (pos.indexOf("bottom") !== -1) {
              corner.insertBefore(container, corner.firstChild);
            } else {
              corner.appendChild(container);
            }
            this._map.on("unload", this.remove, this);
            return this;
          },
          // @method remove: this
          // Removes the control from the map it is currently active on.
          remove: function() {
            if (!this._map) {
              return this;
            }
            remove(this._container);
            if (this.onRemove) {
              this.onRemove(this._map);
            }
            this._map.off("unload", this.remove, this);
            this._map = null;
            return this;
          },
          _refocusOnMap: function(e) {
            if (this._map && e && e.screenX > 0 && e.screenY > 0) {
              this._map.getContainer().focus();
            }
          }
        });
        var control = function(options) {
          return new Control(options);
        };
        Map2.include({
          // @method addControl(control: Control): this
          // Adds the given control to the map
          addControl: function(control2) {
            control2.addTo(this);
            return this;
          },
          // @method removeControl(control: Control): this
          // Removes the given control from the map
          removeControl: function(control2) {
            control2.remove();
            return this;
          },
          _initControlPos: function() {
            var corners = this._controlCorners = {}, l2 = "leaflet-", container = this._controlContainer = create$1("div", l2 + "control-container", this._container);
            function createCorner(vSide, hSide) {
              var className = l2 + vSide + " " + l2 + hSide;
              corners[vSide + hSide] = create$1("div", className, container);
            }
            createCorner("top", "left");
            createCorner("top", "right");
            createCorner("bottom", "left");
            createCorner("bottom", "right");
          },
          _clearControlPos: function() {
            for (var i in this._controlCorners) {
              remove(this._controlCorners[i]);
            }
            remove(this._controlContainer);
            delete this._controlCorners;
            delete this._controlContainer;
          }
        });
        var Layers2 = Control.extend({
          // @section
          // @aka Control.Layers options
          options: {
            // @option collapsed: Boolean = true
            // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
            collapsed: true,
            position: "topright",
            // @option autoZIndex: Boolean = true
            // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
            autoZIndex: true,
            // @option hideSingleBase: Boolean = false
            // If `true`, the base layers in the control will be hidden when there is only one.
            hideSingleBase: false,
            // @option sortLayers: Boolean = false
            // Whether to sort the layers. When `false`, layers will keep the order
            // in which they were added to the control.
            sortLayers: false,
            // @option sortFunction: Function = *
            // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
            // that will be used for sorting the layers, when `sortLayers` is `true`.
            // The function receives both the `L.Layer` instances and their names, as in
            // `sortFunction(layerA, layerB, nameA, nameB)`.
            // By default, it sorts layers alphabetically by their name.
            sortFunction: function(layerA, layerB, nameA, nameB) {
              return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
            }
          },
          initialize: function(baseLayers, overlays, options) {
            setOptions(this, options);
            this._layerControlInputs = [];
            this._layers = [];
            this._lastZIndex = 0;
            this._handlingClick = false;
            this._preventClick = false;
            for (var i in baseLayers) {
              this._addLayer(baseLayers[i], i);
            }
            for (i in overlays) {
              this._addLayer(overlays[i], i, true);
            }
          },
          onAdd: function(map2) {
            this._initLayout();
            this._update();
            this._map = map2;
            map2.on("zoomend", this._checkDisabledLayers, this);
            for (var i = 0; i < this._layers.length; i++) {
              this._layers[i].layer.on("add remove", this._onLayerChange, this);
            }
            return this._container;
          },
          addTo: function(map2) {
            Control.prototype.addTo.call(this, map2);
            return this._expandIfNotCollapsed();
          },
          onRemove: function() {
            this._map.off("zoomend", this._checkDisabledLayers, this);
            for (var i = 0; i < this._layers.length; i++) {
              this._layers[i].layer.off("add remove", this._onLayerChange, this);
            }
          },
          // @method addBaseLayer(layer: Layer, name: String): this
          // Adds a base layer (radio button entry) with the given name to the control.
          addBaseLayer: function(layer, name) {
            this._addLayer(layer, name);
            return this._map ? this._update() : this;
          },
          // @method addOverlay(layer: Layer, name: String): this
          // Adds an overlay (checkbox entry) with the given name to the control.
          addOverlay: function(layer, name) {
            this._addLayer(layer, name, true);
            return this._map ? this._update() : this;
          },
          // @method removeLayer(layer: Layer): this
          // Remove the given layer from the control.
          removeLayer: function(layer) {
            layer.off("add remove", this._onLayerChange, this);
            var obj = this._getLayer(stamp(layer));
            if (obj) {
              this._layers.splice(this._layers.indexOf(obj), 1);
            }
            return this._map ? this._update() : this;
          },
          // @method expand(): this
          // Expand the control container if collapsed.
          expand: function() {
            addClass(this._container, "leaflet-control-layers-expanded");
            this._section.style.height = null;
            var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
            if (acceptableHeight < this._section.clientHeight) {
              addClass(this._section, "leaflet-control-layers-scrollbar");
              this._section.style.height = acceptableHeight + "px";
            } else {
              removeClass(this._section, "leaflet-control-layers-scrollbar");
            }
            this._checkDisabledLayers();
            return this;
          },
          // @method collapse(): this
          // Collapse the control container if expanded.
          collapse: function() {
            removeClass(this._container, "leaflet-control-layers-expanded");
            return this;
          },
          _initLayout: function() {
            var className = "leaflet-control-layers", container = this._container = create$1("div", className), collapsed = this.options.collapsed;
            container.setAttribute("aria-haspopup", true);
            disableClickPropagation(container);
            disableScrollPropagation(container);
            var section = this._section = create$1("section", className + "-list");
            if (collapsed) {
              this._map.on("click", this.collapse, this);
              on(container, {
                mouseenter: this._expandSafely,
                mouseleave: this.collapse
              }, this);
            }
            var link = this._layersLink = create$1("a", className + "-toggle", container);
            link.href = "#";
            link.title = "Layers";
            link.setAttribute("role", "button");
            on(link, {
              keydown: function(e) {
                if (e.keyCode === 13) {
                  this._expandSafely();
                }
              },
              // Certain screen readers intercept the key event and instead send a click event
              click: function(e) {
                preventDefault(e);
                this._expandSafely();
              }
            }, this);
            if (!collapsed) {
              this.expand();
            }
            this._baseLayersList = create$1("div", className + "-base", section);
            this._separator = create$1("div", className + "-separator", section);
            this._overlaysList = create$1("div", className + "-overlays", section);
            container.appendChild(section);
          },
          _getLayer: function(id2) {
            for (var i = 0; i < this._layers.length; i++) {
              if (this._layers[i] && stamp(this._layers[i].layer) === id2) {
                return this._layers[i];
              }
            }
          },
          _addLayer: function(layer, name, overlay) {
            if (this._map) {
              layer.on("add remove", this._onLayerChange, this);
            }
            this._layers.push({
              layer,
              name,
              overlay
            });
            if (this.options.sortLayers) {
              this._layers.sort(bind(function(a2, b) {
                return this.options.sortFunction(a2.layer, b.layer, a2.name, b.name);
              }, this));
            }
            if (this.options.autoZIndex && layer.setZIndex) {
              this._lastZIndex++;
              layer.setZIndex(this._lastZIndex);
            }
            this._expandIfNotCollapsed();
          },
          _update: function() {
            if (!this._container) {
              return this;
            }
            empty(this._baseLayersList);
            empty(this._overlaysList);
            this._layerControlInputs = [];
            var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;
            for (i = 0; i < this._layers.length; i++) {
              obj = this._layers[i];
              this._addItem(obj);
              overlaysPresent = overlaysPresent || obj.overlay;
              baseLayersPresent = baseLayersPresent || !obj.overlay;
              baseLayersCount += !obj.overlay ? 1 : 0;
            }
            if (this.options.hideSingleBase) {
              baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
              this._baseLayersList.style.display = baseLayersPresent ? "" : "none";
            }
            this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none";
            return this;
          },
          _onLayerChange: function(e) {
            if (!this._handlingClick) {
              this._update();
            }
            var obj = this._getLayer(stamp(e.target));
            var type = obj.overlay ? e.type === "add" ? "overlayadd" : "overlayremove" : e.type === "add" ? "baselayerchange" : null;
            if (type) {
              this._map.fire(type, obj);
            }
          },
          // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)
          _createRadioElement: function(name, checked) {
            var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : "") + "/>";
            var radioFragment = document.createElement("div");
            radioFragment.innerHTML = radioHtml;
            return radioFragment.firstChild;
          },
          _addItem: function(obj) {
            var label = document.createElement("label"), checked = this._map.hasLayer(obj.layer), input;
            if (obj.overlay) {
              input = document.createElement("input");
              input.type = "checkbox";
              input.className = "leaflet-control-layers-selector";
              input.defaultChecked = checked;
            } else {
              input = this._createRadioElement("leaflet-base-layers_" + stamp(this), checked);
            }
            this._layerControlInputs.push(input);
            input.layerId = stamp(obj.layer);
            on(input, "click", this._onInputClick, this);
            var name = document.createElement("span");
            name.innerHTML = " " + obj.name;
            var holder = document.createElement("span");
            label.appendChild(holder);
            holder.appendChild(input);
            holder.appendChild(name);
            var container = obj.overlay ? this._overlaysList : this._baseLayersList;
            container.appendChild(label);
            this._checkDisabledLayers();
            return label;
          },
          _onInputClick: function() {
            if (this._preventClick) {
              return;
            }
            var inputs = this._layerControlInputs, input, layer;
            var addedLayers = [], removedLayers = [];
            this._handlingClick = true;
            for (var i = inputs.length - 1; i >= 0; i--) {
              input = inputs[i];
              layer = this._getLayer(input.layerId).layer;
              if (input.checked) {
                addedLayers.push(layer);
              } else if (!input.checked) {
                removedLayers.push(layer);
              }
            }
            for (i = 0; i < removedLayers.length; i++) {
              if (this._map.hasLayer(removedLayers[i])) {
                this._map.removeLayer(removedLayers[i]);
              }
            }
            for (i = 0; i < addedLayers.length; i++) {
              if (!this._map.hasLayer(addedLayers[i])) {
                this._map.addLayer(addedLayers[i]);
              }
            }
            this._handlingClick = false;
            this._refocusOnMap();
          },
          _checkDisabledLayers: function() {
            var inputs = this._layerControlInputs, input, layer, zoom2 = this._map.getZoom();
            for (var i = inputs.length - 1; i >= 0; i--) {
              input = inputs[i];
              layer = this._getLayer(input.layerId).layer;
              input.disabled = layer.options.minZoom !== void 0 && zoom2 < layer.options.minZoom || layer.options.maxZoom !== void 0 && zoom2 > layer.options.maxZoom;
            }
          },
          _expandIfNotCollapsed: function() {
            if (this._map && !this.options.collapsed) {
              this.expand();
            }
            return this;
          },
          _expandSafely: function() {
            var section = this._section;
            this._preventClick = true;
            on(section, "click", preventDefault);
            this.expand();
            var that = this;
            setTimeout(function() {
              off(section, "click", preventDefault);
              that._preventClick = false;
            });
          }
        });
        var layers = function(baseLayers, overlays, options) {
          return new Layers2(baseLayers, overlays, options);
        };
        var Zoom = Control.extend({
          // @section
          // @aka Control.Zoom options
          options: {
            position: "topleft",
            // @option zoomInText: String = '<span aria-hidden="true">+</span>'
            // The text set on the 'zoom in' button.
            zoomInText: '<span aria-hidden="true">+</span>',
            // @option zoomInTitle: String = 'Zoom in'
            // The title set on the 'zoom in' button.
            zoomInTitle: "Zoom in",
            // @option zoomOutText: String = '<span aria-hidden="true">&#x2212;</span>'
            // The text set on the 'zoom out' button.
            zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
            // @option zoomOutTitle: String = 'Zoom out'
            // The title set on the 'zoom out' button.
            zoomOutTitle: "Zoom out"
          },
          onAdd: function(map2) {
            var zoomName = "leaflet-control-zoom", container = create$1("div", zoomName + " leaflet-bar"), options = this.options;
            this._zoomInButton = this._createButton(
              options.zoomInText,
              options.zoomInTitle,
              zoomName + "-in",
              container,
              this._zoomIn
            );
            this._zoomOutButton = this._createButton(
              options.zoomOutText,
              options.zoomOutTitle,
              zoomName + "-out",
              container,
              this._zoomOut
            );
            this._updateDisabled();
            map2.on("zoomend zoomlevelschange", this._updateDisabled, this);
            return container;
          },
          onRemove: function(map2) {
            map2.off("zoomend zoomlevelschange", this._updateDisabled, this);
          },
          disable: function() {
            this._disabled = true;
            this._updateDisabled();
            return this;
          },
          enable: function() {
            this._disabled = false;
            this._updateDisabled();
            return this;
          },
          _zoomIn: function(e) {
            if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
              this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
            }
          },
          _zoomOut: function(e) {
            if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
              this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
            }
          },
          _createButton: function(html, title, className, container, fn) {
            var link = create$1("a", className, container);
            link.innerHTML = html;
            link.href = "#";
            link.title = title;
            link.setAttribute("role", "button");
            link.setAttribute("aria-label", title);
            disableClickPropagation(link);
            on(link, "click", stop);
            on(link, "click", fn, this);
            on(link, "click", this._refocusOnMap, this);
            return link;
          },
          _updateDisabled: function() {
            var map2 = this._map, className = "leaflet-disabled";
            removeClass(this._zoomInButton, className);
            removeClass(this._zoomOutButton, className);
            this._zoomInButton.setAttribute("aria-disabled", "false");
            this._zoomOutButton.setAttribute("aria-disabled", "false");
            if (this._disabled || map2._zoom === map2.getMinZoom()) {
              addClass(this._zoomOutButton, className);
              this._zoomOutButton.setAttribute("aria-disabled", "true");
            }
            if (this._disabled || map2._zoom === map2.getMaxZoom()) {
              addClass(this._zoomInButton, className);
              this._zoomInButton.setAttribute("aria-disabled", "true");
            }
          }
        });
        Map2.mergeOptions({
          zoomControl: true
        });
        Map2.addInitHook(function() {
          if (this.options.zoomControl) {
            this.zoomControl = new Zoom();
            this.addControl(this.zoomControl);
          }
        });
        var zoom = function(options) {
          return new Zoom(options);
        };
        var Scale = Control.extend({
          // @section
          // @aka Control.Scale options
          options: {
            position: "bottomleft",
            // @option maxWidth: Number = 100
            // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
            maxWidth: 100,
            // @option metric: Boolean = True
            // Whether to show the metric scale line (m/km).
            metric: true,
            // @option imperial: Boolean = True
            // Whether to show the imperial scale line (mi/ft).
            imperial: true
            // @option updateWhenIdle: Boolean = false
            // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
          },
          onAdd: function(map2) {
            var className = "leaflet-control-scale", container = create$1("div", className), options = this.options;
            this._addScales(options, className + "-line", container);
            map2.on(options.updateWhenIdle ? "moveend" : "move", this._update, this);
            map2.whenReady(this._update, this);
            return container;
          },
          onRemove: function(map2) {
            map2.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
          },
          _addScales: function(options, className, container) {
            if (options.metric) {
              this._mScale = create$1("div", className, container);
            }
            if (options.imperial) {
              this._iScale = create$1("div", className, container);
            }
          },
          _update: function() {
            var map2 = this._map, y2 = map2.getSize().y / 2;
            var maxMeters = map2.distance(
              map2.containerPointToLatLng([0, y2]),
              map2.containerPointToLatLng([this.options.maxWidth, y2])
            );
            this._updateScales(maxMeters);
          },
          _updateScales: function(maxMeters) {
            if (this.options.metric && maxMeters) {
              this._updateMetric(maxMeters);
            }
            if (this.options.imperial && maxMeters) {
              this._updateImperial(maxMeters);
            }
          },
          _updateMetric: function(maxMeters) {
            var meters = this._getRoundNum(maxMeters), label = meters < 1e3 ? meters + " m" : meters / 1e3 + " km";
            this._updateScale(this._mScale, label, meters / maxMeters);
          },
          _updateImperial: function(maxMeters) {
            var maxFeet = maxMeters * 3.2808399, maxMiles, miles, feet;
            if (maxFeet > 5280) {
              maxMiles = maxFeet / 5280;
              miles = this._getRoundNum(maxMiles);
              this._updateScale(this._iScale, miles + " mi", miles / maxMiles);
            } else {
              feet = this._getRoundNum(maxFeet);
              this._updateScale(this._iScale, feet + " ft", feet / maxFeet);
            }
          },
          _updateScale: function(scale2, text, ratio) {
            scale2.style.width = Math.round(this.options.maxWidth * ratio) + "px";
            scale2.innerHTML = text;
          },
          _getRoundNum: function(num) {
            var pow102 = Math.pow(10, (Math.floor(num) + "").length - 1), d = num / pow102;
            d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
            return pow102 * d;
          }
        });
        var scale = function(options) {
          return new Scale(options);
        };
        var ukrainianFlag = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>';
        var Attribution = Control.extend({
          // @section
          // @aka Control.Attribution options
          options: {
            position: "bottomright",
            // @option prefix: String|false = 'Leaflet'
            // The HTML text shown before the attributions. Pass `false` to disable.
            prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Browser.inlineSvg ? ukrainianFlag + " " : "") + "Leaflet</a>"
          },
          initialize: function(options) {
            setOptions(this, options);
            this._attributions = {};
          },
          onAdd: function(map2) {
            map2.attributionControl = this;
            this._container = create$1("div", "leaflet-control-attribution");
            disableClickPropagation(this._container);
            for (var i in map2._layers) {
              if (map2._layers[i].getAttribution) {
                this.addAttribution(map2._layers[i].getAttribution());
              }
            }
            this._update();
            map2.on("layeradd", this._addAttribution, this);
            return this._container;
          },
          onRemove: function(map2) {
            map2.off("layeradd", this._addAttribution, this);
          },
          _addAttribution: function(ev) {
            if (ev.layer.getAttribution) {
              this.addAttribution(ev.layer.getAttribution());
              ev.layer.once("remove", function() {
                this.removeAttribution(ev.layer.getAttribution());
              }, this);
            }
          },
          // @method setPrefix(prefix: String|false): this
          // The HTML text shown before the attributions. Pass `false` to disable.
          setPrefix: function(prefix2) {
            this.options.prefix = prefix2;
            this._update();
            return this;
          },
          // @method addAttribution(text: String): this
          // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).
          addAttribution: function(text) {
            if (!text) {
              return this;
            }
            if (!this._attributions[text]) {
              this._attributions[text] = 0;
            }
            this._attributions[text]++;
            this._update();
            return this;
          },
          // @method removeAttribution(text: String): this
          // Removes an attribution text.
          removeAttribution: function(text) {
            if (!text) {
              return this;
            }
            if (this._attributions[text]) {
              this._attributions[text]--;
              this._update();
            }
            return this;
          },
          _update: function() {
            if (!this._map) {
              return;
            }
            var attribs = [];
            for (var i in this._attributions) {
              if (this._attributions[i]) {
                attribs.push(i);
              }
            }
            var prefixAndAttribs = [];
            if (this.options.prefix) {
              prefixAndAttribs.push(this.options.prefix);
            }
            if (attribs.length) {
              prefixAndAttribs.push(attribs.join(", "));
            }
            this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden="true">|</span> ');
          }
        });
        Map2.mergeOptions({
          attributionControl: true
        });
        Map2.addInitHook(function() {
          if (this.options.attributionControl) {
            new Attribution().addTo(this);
          }
        });
        var attribution = function(options) {
          return new Attribution(options);
        };
        Control.Layers = Layers2;
        Control.Zoom = Zoom;
        Control.Scale = Scale;
        Control.Attribution = Attribution;
        control.layers = layers;
        control.zoom = zoom;
        control.scale = scale;
        control.attribution = attribution;
        var Handler = Class.extend({
          initialize: function(map2) {
            this._map = map2;
          },
          // @method enable(): this
          // Enables the handler
          enable: function() {
            if (this._enabled) {
              return this;
            }
            this._enabled = true;
            this.addHooks();
            return this;
          },
          // @method disable(): this
          // Disables the handler
          disable: function() {
            if (!this._enabled) {
              return this;
            }
            this._enabled = false;
            this.removeHooks();
            return this;
          },
          // @method enabled(): Boolean
          // Returns `true` if the handler is enabled
          enabled: function() {
            return !!this._enabled;
          }
          // @section Extension methods
          // Classes inheriting from `Handler` must implement the two following methods:
          // @method addHooks()
          // Called when the handler is enabled, should add event hooks.
          // @method removeHooks()
          // Called when the handler is disabled, should remove the event hooks added previously.
        });
        Handler.addTo = function(map2, name) {
          map2.addHandler(name, this);
          return this;
        };
        var Mixin = { Events };
        var START = Browser.touch ? "touchstart mousedown" : "mousedown";
        var Draggable = Evented.extend({
          options: {
            // @section
            // @aka Draggable options
            // @option clickTolerance: Number = 3
            // The max number of pixels a user can shift the mouse pointer during a click
            // for it to be considered a valid click (as opposed to a mouse drag).
            clickTolerance: 3
          },
          // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
          // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
          initialize: function(element, dragStartTarget, preventOutline2, options) {
            setOptions(this, options);
            this._element = element;
            this._dragStartTarget = dragStartTarget || element;
            this._preventOutline = preventOutline2;
          },
          // @method enable()
          // Enables the dragging ability
          enable: function() {
            if (this._enabled) {
              return;
            }
            on(this._dragStartTarget, START, this._onDown, this);
            this._enabled = true;
          },
          // @method disable()
          // Disables the dragging ability
          disable: function() {
            if (!this._enabled) {
              return;
            }
            if (Draggable._dragging === this) {
              this.finishDrag(true);
            }
            off(this._dragStartTarget, START, this._onDown, this);
            this._enabled = false;
            this._moved = false;
          },
          _onDown: function(e) {
            if (!this._enabled) {
              return;
            }
            this._moved = false;
            if (hasClass(this._element, "leaflet-zoom-anim")) {
              return;
            }
            if (e.touches && e.touches.length !== 1) {
              if (Draggable._dragging === this) {
                this.finishDrag();
              }
              return;
            }
            if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {
              return;
            }
            Draggable._dragging = this;
            if (this._preventOutline) {
              preventOutline(this._element);
            }
            disableImageDrag();
            disableTextSelection();
            if (this._moving) {
              return;
            }
            this.fire("down");
            var first = e.touches ? e.touches[0] : e, sizedParent = getSizedParentNode(this._element);
            this._startPoint = new Point(first.clientX, first.clientY);
            this._startPos = getPosition(this._element);
            this._parentScale = getScale(sizedParent);
            var mouseevent = e.type === "mousedown";
            on(document, mouseevent ? "mousemove" : "touchmove", this._onMove, this);
            on(document, mouseevent ? "mouseup" : "touchend touchcancel", this._onUp, this);
          },
          _onMove: function(e) {
            if (!this._enabled) {
              return;
            }
            if (e.touches && e.touches.length > 1) {
              this._moved = true;
              return;
            }
            var first = e.touches && e.touches.length === 1 ? e.touches[0] : e, offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);
            if (!offset.x && !offset.y) {
              return;
            }
            if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
              return;
            }
            offset.x /= this._parentScale.x;
            offset.y /= this._parentScale.y;
            preventDefault(e);
            if (!this._moved) {
              this.fire("dragstart");
              this._moved = true;
              addClass(document.body, "leaflet-dragging");
              this._lastTarget = e.target || e.srcElement;
              if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
                this._lastTarget = this._lastTarget.correspondingUseElement;
              }
              addClass(this._lastTarget, "leaflet-drag-target");
            }
            this._newPos = this._startPos.add(offset);
            this._moving = true;
            this._lastEvent = e;
            this._updatePosition();
          },
          _updatePosition: function() {
            var e = { originalEvent: this._lastEvent };
            this.fire("predrag", e);
            setPosition(this._element, this._newPos);
            this.fire("drag", e);
          },
          _onUp: function() {
            if (!this._enabled) {
              return;
            }
            this.finishDrag();
          },
          finishDrag: function(noInertia) {
            removeClass(document.body, "leaflet-dragging");
            if (this._lastTarget) {
              removeClass(this._lastTarget, "leaflet-drag-target");
              this._lastTarget = null;
            }
            off(document, "mousemove touchmove", this._onMove, this);
            off(document, "mouseup touchend touchcancel", this._onUp, this);
            enableImageDrag();
            enableTextSelection();
            var fireDragend = this._moved && this._moving;
            this._moving = false;
            Draggable._dragging = false;
            if (fireDragend) {
              this.fire("dragend", {
                noInertia,
                distance: this._newPos.distanceTo(this._startPos)
              });
            }
          }
        });
        function clipPolygon(points, bounds, round2) {
          var clippedPoints, edges = [1, 4, 2, 8], i, j, k2, a2, b, len, edge2, p2;
          for (i = 0, len = points.length; i < len; i++) {
            points[i]._code = _getBitCode(points[i], bounds);
          }
          for (k2 = 0; k2 < 4; k2++) {
            edge2 = edges[k2];
            clippedPoints = [];
            for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
              a2 = points[i];
              b = points[j];
              if (!(a2._code & edge2)) {
                if (b._code & edge2) {
                  p2 = _getEdgeIntersection(b, a2, edge2, bounds, round2);
                  p2._code = _getBitCode(p2, bounds);
                  clippedPoints.push(p2);
                }
                clippedPoints.push(a2);
              } else if (!(b._code & edge2)) {
                p2 = _getEdgeIntersection(b, a2, edge2, bounds, round2);
                p2._code = _getBitCode(p2, bounds);
                clippedPoints.push(p2);
              }
            }
            points = clippedPoints;
          }
          return points;
        }
        function polygonCenter(latlngs, crs) {
          var i, j, p1, p2, f2, area, x2, y2, center;
          if (!latlngs || latlngs.length === 0) {
            throw new Error("latlngs not passed");
          }
          if (!isFlat(latlngs)) {
            console.warn("latlngs are not flat! Only the first ring will be used");
            latlngs = latlngs[0];
          }
          var centroidLatLng = toLatLng([0, 0]);
          var bounds = toLatLngBounds(latlngs);
          var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
          if (areaBounds < 1700) {
            centroidLatLng = centroid(latlngs);
          }
          var len = latlngs.length;
          var points = [];
          for (i = 0; i < len; i++) {
            var latlng = toLatLng(latlngs[i]);
            points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
          }
          area = x2 = y2 = 0;
          for (i = 0, j = len - 1; i < len; j = i++) {
            p1 = points[i];
            p2 = points[j];
            f2 = p1.y * p2.x - p2.y * p1.x;
            x2 += (p1.x + p2.x) * f2;
            y2 += (p1.y + p2.y) * f2;
            area += f2 * 3;
          }
          if (area === 0) {
            center = points[0];
          } else {
            center = [x2 / area, y2 / area];
          }
          var latlngCenter = crs.unproject(toPoint(center));
          return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
        }
        function centroid(coords) {
          var latSum = 0;
          var lngSum = 0;
          var len = 0;
          for (var i = 0; i < coords.length; i++) {
            var latlng = toLatLng(coords[i]);
            latSum += latlng.lat;
            lngSum += latlng.lng;
            len++;
          }
          return toLatLng([latSum / len, lngSum / len]);
        }
        var PolyUtil = {
          __proto__: null,
          clipPolygon,
          polygonCenter,
          centroid
        };
        function simplify(points, tolerance) {
          if (!tolerance || !points.length) {
            return points.slice();
          }
          var sqTolerance = tolerance * tolerance;
          points = _reducePoints(points, sqTolerance);
          points = _simplifyDP(points, sqTolerance);
          return points;
        }
        function pointToSegmentDistance(p2, p1, p22) {
          return Math.sqrt(_sqClosestPointOnSegment(p2, p1, p22, true));
        }
        function closestPointOnSegment(p2, p1, p22) {
          return _sqClosestPointOnSegment(p2, p1, p22);
        }
        function _simplifyDP(points, sqTolerance) {
          var len = points.length, ArrayConstructor = typeof Uint8Array !== "undefined" ? Uint8Array : Array, markers = new ArrayConstructor(len);
          markers[0] = markers[len - 1] = 1;
          _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);
          var i, newPoints = [];
          for (i = 0; i < len; i++) {
            if (markers[i]) {
              newPoints.push(points[i]);
            }
          }
          return newPoints;
        }
        function _simplifyDPStep(points, markers, sqTolerance, first, last2) {
          var maxSqDist = 0, index2, i, sqDist;
          for (i = first + 1; i <= last2 - 1; i++) {
            sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last2], true);
            if (sqDist > maxSqDist) {
              index2 = i;
              maxSqDist = sqDist;
            }
          }
          if (maxSqDist > sqTolerance) {
            markers[index2] = 1;
            _simplifyDPStep(points, markers, sqTolerance, first, index2);
            _simplifyDPStep(points, markers, sqTolerance, index2, last2);
          }
        }
        function _reducePoints(points, sqTolerance) {
          var reducedPoints = [points[0]];
          for (var i = 1, prev = 0, len = points.length; i < len; i++) {
            if (_sqDist(points[i], points[prev]) > sqTolerance) {
              reducedPoints.push(points[i]);
              prev = i;
            }
          }
          if (prev < len - 1) {
            reducedPoints.push(points[len - 1]);
          }
          return reducedPoints;
        }
        var _lastCode;
        function clipSegment(a2, b, bounds, useLastCode, round2) {
          var codeA = useLastCode ? _lastCode : _getBitCode(a2, bounds), codeB = _getBitCode(b, bounds), codeOut, p2, newCode;
          _lastCode = codeB;
          while (true) {
            if (!(codeA | codeB)) {
              return [a2, b];
            }
            if (codeA & codeB) {
              return false;
            }
            codeOut = codeA || codeB;
            p2 = _getEdgeIntersection(a2, b, codeOut, bounds, round2);
            newCode = _getBitCode(p2, bounds);
            if (codeOut === codeA) {
              a2 = p2;
              codeA = newCode;
            } else {
              b = p2;
              codeB = newCode;
            }
          }
        }
        function _getEdgeIntersection(a2, b, code, bounds, round2) {
          var dx = b.x - a2.x, dy = b.y - a2.y, min2 = bounds.min, max2 = bounds.max, x2, y2;
          if (code & 8) {
            x2 = a2.x + dx * (max2.y - a2.y) / dy;
            y2 = max2.y;
          } else if (code & 4) {
            x2 = a2.x + dx * (min2.y - a2.y) / dy;
            y2 = min2.y;
          } else if (code & 2) {
            x2 = max2.x;
            y2 = a2.y + dy * (max2.x - a2.x) / dx;
          } else if (code & 1) {
            x2 = min2.x;
            y2 = a2.y + dy * (min2.x - a2.x) / dx;
          }
          return new Point(x2, y2, round2);
        }
        function _getBitCode(p2, bounds) {
          var code = 0;
          if (p2.x < bounds.min.x) {
            code |= 1;
          } else if (p2.x > bounds.max.x) {
            code |= 2;
          }
          if (p2.y < bounds.min.y) {
            code |= 4;
          } else if (p2.y > bounds.max.y) {
            code |= 8;
          }
          return code;
        }
        function _sqDist(p1, p2) {
          var dx = p2.x - p1.x, dy = p2.y - p1.y;
          return dx * dx + dy * dy;
        }
        function _sqClosestPointOnSegment(p2, p1, p22, sqDist) {
          var x2 = p1.x, y2 = p1.y, dx = p22.x - x2, dy = p22.y - y2, dot = dx * dx + dy * dy, t2;
          if (dot > 0) {
            t2 = ((p2.x - x2) * dx + (p2.y - y2) * dy) / dot;
            if (t2 > 1) {
              x2 = p22.x;
              y2 = p22.y;
            } else if (t2 > 0) {
              x2 += dx * t2;
              y2 += dy * t2;
            }
          }
          dx = p2.x - x2;
          dy = p2.y - y2;
          return sqDist ? dx * dx + dy * dy : new Point(x2, y2);
        }
        function isFlat(latlngs) {
          return !isArray2(latlngs[0]) || typeof latlngs[0][0] !== "object" && typeof latlngs[0][0] !== "undefined";
        }
        function _flat(latlngs) {
          console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead.");
          return isFlat(latlngs);
        }
        function polylineCenter(latlngs, crs) {
          var i, halfDist, segDist, dist, p1, p2, ratio, center;
          if (!latlngs || latlngs.length === 0) {
            throw new Error("latlngs not passed");
          }
          if (!isFlat(latlngs)) {
            console.warn("latlngs are not flat! Only the first ring will be used");
            latlngs = latlngs[0];
          }
          var centroidLatLng = toLatLng([0, 0]);
          var bounds = toLatLngBounds(latlngs);
          var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
          if (areaBounds < 1700) {
            centroidLatLng = centroid(latlngs);
          }
          var len = latlngs.length;
          var points = [];
          for (i = 0; i < len; i++) {
            var latlng = toLatLng(latlngs[i]);
            points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
          }
          for (i = 0, halfDist = 0; i < len - 1; i++) {
            halfDist += points[i].distanceTo(points[i + 1]) / 2;
          }
          if (halfDist === 0) {
            center = points[0];
          } else {
            for (i = 0, dist = 0; i < len - 1; i++) {
              p1 = points[i];
              p2 = points[i + 1];
              segDist = p1.distanceTo(p2);
              dist += segDist;
              if (dist > halfDist) {
                ratio = (dist - halfDist) / segDist;
                center = [
                  p2.x - ratio * (p2.x - p1.x),
                  p2.y - ratio * (p2.y - p1.y)
                ];
                break;
              }
            }
          }
          var latlngCenter = crs.unproject(toPoint(center));
          return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
        }
        var LineUtil = {
          __proto__: null,
          simplify,
          pointToSegmentDistance,
          closestPointOnSegment,
          clipSegment,
          _getEdgeIntersection,
          _getBitCode,
          _sqClosestPointOnSegment,
          isFlat,
          _flat,
          polylineCenter
        };
        var LonLat = {
          project: function(latlng) {
            return new Point(latlng.lng, latlng.lat);
          },
          unproject: function(point2) {
            return new LatLng(point2.y, point2.x);
          },
          bounds: new Bounds([-180, -90], [180, 90])
        };
        var Mercator = {
          R: 6378137,
          R_MINOR: 6356752314245179e-9,
          bounds: new Bounds([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
          project: function(latlng) {
            var d = Math.PI / 180, r2 = this.R, y2 = latlng.lat * d, tmp = this.R_MINOR / r2, e = Math.sqrt(1 - tmp * tmp), con = e * Math.sin(y2);
            var ts = Math.tan(Math.PI / 4 - y2 / 2) / Math.pow((1 - con) / (1 + con), e / 2);
            y2 = -r2 * Math.log(Math.max(ts, 1e-10));
            return new Point(latlng.lng * d * r2, y2);
          },
          unproject: function(point2) {
            var d = 180 / Math.PI, r2 = this.R, tmp = this.R_MINOR / r2, e = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point2.y / r2), phi = Math.PI / 2 - 2 * Math.atan(ts);
            for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
              con = e * Math.sin(phi);
              con = Math.pow((1 - con) / (1 + con), e / 2);
              dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
              phi += dphi;
            }
            return new LatLng(phi * d, point2.x * d / r2);
          }
        };
        var index = {
          __proto__: null,
          LonLat,
          Mercator,
          SphericalMercator
        };
        var EPSG3395 = extend2({}, Earth, {
          code: "EPSG:3395",
          projection: Mercator,
          transformation: function() {
            var scale2 = 0.5 / (Math.PI * Mercator.R);
            return toTransformation(scale2, 0.5, -scale2, 0.5);
          }()
        });
        var EPSG4326 = extend2({}, Earth, {
          code: "EPSG:4326",
          projection: LonLat,
          transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
        });
        var Simple = extend2({}, CRS, {
          projection: LonLat,
          transformation: toTransformation(1, 0, -1, 0),
          scale: function(zoom2) {
            return Math.pow(2, zoom2);
          },
          zoom: function(scale2) {
            return Math.log(scale2) / Math.LN2;
          },
          distance: function(latlng1, latlng2) {
            var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;
            return Math.sqrt(dx * dx + dy * dy);
          },
          infinite: true
        });
        CRS.Earth = Earth;
        CRS.EPSG3395 = EPSG3395;
        CRS.EPSG3857 = EPSG3857;
        CRS.EPSG900913 = EPSG900913;
        CRS.EPSG4326 = EPSG4326;
        CRS.Simple = Simple;
        var Layer2 = Evented.extend({
          // Classes extending `L.Layer` will inherit the following options:
          options: {
            // @option pane: String = 'overlayPane'
            // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
            pane: "overlayPane",
            // @option attribution: String = null
            // String to be shown in the attribution control, e.g. " OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
            attribution: null,
            bubblingMouseEvents: true
          },
          /* @section
           * Classes extending `L.Layer` will inherit the following methods:
           *
           * @method addTo(map: Map|LayerGroup): this
           * Adds the layer to the given map or layer group.
           */
          addTo: function(map2) {
            map2.addLayer(this);
            return this;
          },
          // @method remove: this
          // Removes the layer from the map it is currently active on.
          remove: function() {
            return this.removeFrom(this._map || this._mapToAdd);
          },
          // @method removeFrom(map: Map): this
          // Removes the layer from the given map
          //
          // @alternative
          // @method removeFrom(group: LayerGroup): this
          // Removes the layer from the given `LayerGroup`
          removeFrom: function(obj) {
            if (obj) {
              obj.removeLayer(this);
            }
            return this;
          },
          // @method getPane(name? : String): HTMLElement
          // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
          getPane: function(name) {
            return this._map.getPane(name ? this.options[name] || name : this.options.pane);
          },
          addInteractiveTarget: function(targetEl) {
            this._map._targets[stamp(targetEl)] = this;
            return this;
          },
          removeInteractiveTarget: function(targetEl) {
            delete this._map._targets[stamp(targetEl)];
            return this;
          },
          // @method getAttribution: String
          // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
          getAttribution: function() {
            return this.options.attribution;
          },
          _layerAdd: function(e) {
            var map2 = e.target;
            if (!map2.hasLayer(this)) {
              return;
            }
            this._map = map2;
            this._zoomAnimated = map2._zoomAnimated;
            if (this.getEvents) {
              var events = this.getEvents();
              map2.on(events, this);
              this.once("remove", function() {
                map2.off(events, this);
              }, this);
            }
            this.onAdd(map2);
            this.fire("add");
            map2.fire("layeradd", { layer: this });
          }
        });
        Map2.include({
          // @method addLayer(layer: Layer): this
          // Adds the given layer to the map
          addLayer: function(layer) {
            if (!layer._layerAdd) {
              throw new Error("The provided object is not a Layer.");
            }
            var id2 = stamp(layer);
            if (this._layers[id2]) {
              return this;
            }
            this._layers[id2] = layer;
            layer._mapToAdd = this;
            if (layer.beforeAdd) {
              layer.beforeAdd(this);
            }
            this.whenReady(layer._layerAdd, layer);
            return this;
          },
          // @method removeLayer(layer: Layer): this
          // Removes the given layer from the map.
          removeLayer: function(layer) {
            var id2 = stamp(layer);
            if (!this._layers[id2]) {
              return this;
            }
            if (this._loaded) {
              layer.onRemove(this);
            }
            delete this._layers[id2];
            if (this._loaded) {
              this.fire("layerremove", { layer });
              layer.fire("remove");
            }
            layer._map = layer._mapToAdd = null;
            return this;
          },
          // @method hasLayer(layer: Layer): Boolean
          // Returns `true` if the given layer is currently added to the map
          hasLayer: function(layer) {
            return stamp(layer) in this._layers;
          },
          /* @method eachLayer(fn: Function, context?: Object): this
           * Iterates over the layers of the map, optionally specifying context of the iterator function.
           * ```
           * map.eachLayer(function(layer){
           *     layer.bindPopup('Hello');
           * });
           * ```
           */
          eachLayer: function(method, context) {
            for (var i in this._layers) {
              method.call(context, this._layers[i]);
            }
            return this;
          },
          _addLayers: function(layers2) {
            layers2 = layers2 ? isArray2(layers2) ? layers2 : [layers2] : [];
            for (var i = 0, len = layers2.length; i < len; i++) {
              this.addLayer(layers2[i]);
            }
          },
          _addZoomLimit: function(layer) {
            if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
              this._zoomBoundLayers[stamp(layer)] = layer;
              this._updateZoomLevels();
            }
          },
          _removeZoomLimit: function(layer) {
            var id2 = stamp(layer);
            if (this._zoomBoundLayers[id2]) {
              delete this._zoomBoundLayers[id2];
              this._updateZoomLevels();
            }
          },
          _updateZoomLevels: function() {
            var minZoom = Infinity, maxZoom = -Infinity, oldZoomSpan = this._getZoomSpan();
            for (var i in this._zoomBoundLayers) {
              var options = this._zoomBoundLayers[i].options;
              minZoom = options.minZoom === void 0 ? minZoom : Math.min(minZoom, options.minZoom);
              maxZoom = options.maxZoom === void 0 ? maxZoom : Math.max(maxZoom, options.maxZoom);
            }
            this._layersMaxZoom = maxZoom === -Infinity ? void 0 : maxZoom;
            this._layersMinZoom = minZoom === Infinity ? void 0 : minZoom;
            if (oldZoomSpan !== this._getZoomSpan()) {
              this.fire("zoomlevelschange");
            }
            if (this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
              this.setZoom(this._layersMaxZoom);
            }
            if (this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
              this.setZoom(this._layersMinZoom);
            }
          }
        });
        var LayerGroup = Layer2.extend({
          initialize: function(layers2, options) {
            setOptions(this, options);
            this._layers = {};
            var i, len;
            if (layers2) {
              for (i = 0, len = layers2.length; i < len; i++) {
                this.addLayer(layers2[i]);
              }
            }
          },
          // @method addLayer(layer: Layer): this
          // Adds the given layer to the group.
          addLayer: function(layer) {
            var id2 = this.getLayerId(layer);
            this._layers[id2] = layer;
            if (this._map) {
              this._map.addLayer(layer);
            }
            return this;
          },
          // @method removeLayer(layer: Layer): this
          // Removes the given layer from the group.
          // @alternative
          // @method removeLayer(id: Number): this
          // Removes the layer with the given internal ID from the group.
          removeLayer: function(layer) {
            var id2 = layer in this._layers ? layer : this.getLayerId(layer);
            if (this._map && this._layers[id2]) {
              this._map.removeLayer(this._layers[id2]);
            }
            delete this._layers[id2];
            return this;
          },
          // @method hasLayer(layer: Layer): Boolean
          // Returns `true` if the given layer is currently added to the group.
          // @alternative
          // @method hasLayer(id: Number): Boolean
          // Returns `true` if the given internal ID is currently added to the group.
          hasLayer: function(layer) {
            var layerId = typeof layer === "number" ? layer : this.getLayerId(layer);
            return layerId in this._layers;
          },
          // @method clearLayers(): this
          // Removes all the layers from the group.
          clearLayers: function() {
            return this.eachLayer(this.removeLayer, this);
          },
          // @method invoke(methodName: String, ): this
          // Calls `methodName` on every layer contained in this group, passing any
          // additional parameters. Has no effect if the layers contained do not
          // implement `methodName`.
          invoke: function(methodName) {
            var args = Array.prototype.slice.call(arguments, 1), i, layer;
            for (i in this._layers) {
              layer = this._layers[i];
              if (layer[methodName]) {
                layer[methodName].apply(layer, args);
              }
            }
            return this;
          },
          onAdd: function(map2) {
            this.eachLayer(map2.addLayer, map2);
          },
          onRemove: function(map2) {
            this.eachLayer(map2.removeLayer, map2);
          },
          // @method eachLayer(fn: Function, context?: Object): this
          // Iterates over the layers of the group, optionally specifying context of the iterator function.
          // ```js
          // group.eachLayer(function (layer) {
          // 	layer.bindPopup('Hello');
          // });
          // ```
          eachLayer: function(method, context) {
            for (var i in this._layers) {
              method.call(context, this._layers[i]);
            }
            return this;
          },
          // @method getLayer(id: Number): Layer
          // Returns the layer with the given internal ID.
          getLayer: function(id2) {
            return this._layers[id2];
          },
          // @method getLayers(): Layer[]
          // Returns an array of all the layers added to the group.
          getLayers: function() {
            var layers2 = [];
            this.eachLayer(layers2.push, layers2);
            return layers2;
          },
          // @method setZIndex(zIndex: Number): this
          // Calls `setZIndex` on every layer contained in this group, passing the z-index.
          setZIndex: function(zIndex) {
            return this.invoke("setZIndex", zIndex);
          },
          // @method getLayerId(layer: Layer): Number
          // Returns the internal ID for a layer
          getLayerId: function(layer) {
            return stamp(layer);
          }
        });
        var layerGroup = function(layers2, options) {
          return new LayerGroup(layers2, options);
        };
        var FeatureGroup = LayerGroup.extend({
          addLayer: function(layer) {
            if (this.hasLayer(layer)) {
              return this;
            }
            layer.addEventParent(this);
            LayerGroup.prototype.addLayer.call(this, layer);
            return this.fire("layeradd", { layer });
          },
          removeLayer: function(layer) {
            if (!this.hasLayer(layer)) {
              return this;
            }
            if (layer in this._layers) {
              layer = this._layers[layer];
            }
            layer.removeEventParent(this);
            LayerGroup.prototype.removeLayer.call(this, layer);
            return this.fire("layerremove", { layer });
          },
          // @method setStyle(style: Path options): this
          // Sets the given path options to each layer of the group that has a `setStyle` method.
          setStyle: function(style2) {
            return this.invoke("setStyle", style2);
          },
          // @method bringToFront(): this
          // Brings the layer group to the top of all other layers
          bringToFront: function() {
            return this.invoke("bringToFront");
          },
          // @method bringToBack(): this
          // Brings the layer group to the back of all other layers
          bringToBack: function() {
            return this.invoke("bringToBack");
          },
          // @method getBounds(): LatLngBounds
          // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
          getBounds: function() {
            var bounds = new LatLngBounds();
            for (var id2 in this._layers) {
              var layer = this._layers[id2];
              bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
            }
            return bounds;
          }
        });
        var featureGroup = function(layers2, options) {
          return new FeatureGroup(layers2, options);
        };
        var Icon2 = Class.extend({
          /* @section
           * @aka Icon options
           *
           * @option iconUrl: String = null
           * **(required)** The URL to the icon image (absolute or relative to your script path).
           *
           * @option iconRetinaUrl: String = null
           * The URL to a retina sized version of the icon image (absolute or relative to your
           * script path). Used for Retina screen devices.
           *
           * @option iconSize: Point = null
           * Size of the icon image in pixels.
           *
           * @option iconAnchor: Point = null
           * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
           * will be aligned so that this point is at the marker's geographical location. Centered
           * by default if size is specified, also can be set in CSS with negative margins.
           *
           * @option popupAnchor: Point = [0, 0]
           * The coordinates of the point from which popups will "open", relative to the icon anchor.
           *
           * @option tooltipAnchor: Point = [0, 0]
           * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
           *
           * @option shadowUrl: String = null
           * The URL to the icon shadow image. If not specified, no shadow image will be created.
           *
           * @option shadowRetinaUrl: String = null
           *
           * @option shadowSize: Point = null
           * Size of the shadow image in pixels.
           *
           * @option shadowAnchor: Point = null
           * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
           * as iconAnchor if not specified).
           *
           * @option className: String = ''
           * A custom class name to assign to both icon and shadow images. Empty by default.
           */
          options: {
            popupAnchor: [0, 0],
            tooltipAnchor: [0, 0],
            // @option crossOrigin: Boolean|String = false
            // Whether the crossOrigin attribute will be added to the tiles.
            // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
            // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
            crossOrigin: false
          },
          initialize: function(options) {
            setOptions(this, options);
          },
          // @method createIcon(oldIcon?: HTMLElement): HTMLElement
          // Called internally when the icon has to be shown, returns a `<img>` HTML element
          // styled according to the options.
          createIcon: function(oldIcon) {
            return this._createIcon("icon", oldIcon);
          },
          // @method createShadow(oldIcon?: HTMLElement): HTMLElement
          // As `createIcon`, but for the shadow beneath it.
          createShadow: function(oldIcon) {
            return this._createIcon("shadow", oldIcon);
          },
          _createIcon: function(name, oldIcon) {
            var src = this._getIconUrl(name);
            if (!src) {
              if (name === "icon") {
                throw new Error("iconUrl not set in Icon options (see the docs).");
              }
              return null;
            }
            var img = this._createImg(src, oldIcon && oldIcon.tagName === "IMG" ? oldIcon : null);
            this._setIconStyles(img, name);
            if (this.options.crossOrigin || this.options.crossOrigin === "") {
              img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
            }
            return img;
          },
          _setIconStyles: function(img, name) {
            var options = this.options;
            var sizeOption = options[name + "Size"];
            if (typeof sizeOption === "number") {
              sizeOption = [sizeOption, sizeOption];
            }
            var size = toPoint(sizeOption), anchor = toPoint(name === "shadow" && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));
            img.className = "leaflet-marker-" + name + " " + (options.className || "");
            if (anchor) {
              img.style.marginLeft = -anchor.x + "px";
              img.style.marginTop = -anchor.y + "px";
            }
            if (size) {
              img.style.width = size.x + "px";
              img.style.height = size.y + "px";
            }
          },
          _createImg: function(src, el2) {
            el2 = el2 || document.createElement("img");
            el2.src = src;
            return el2;
          },
          _getIconUrl: function(name) {
            return Browser.retina && this.options[name + "RetinaUrl"] || this.options[name + "Url"];
          }
        });
        function icon2(options) {
          return new Icon2(options);
        }
        var IconDefault = Icon2.extend({
          options: {
            iconUrl: "marker-icon.png",
            iconRetinaUrl: "marker-icon-2x.png",
            shadowUrl: "marker-shadow.png",
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            tooltipAnchor: [16, -28],
            shadowSize: [41, 41]
          },
          _getIconUrl: function(name) {
            if (typeof IconDefault.imagePath !== "string") {
              IconDefault.imagePath = this._detectIconPath();
            }
            return (this.options.imagePath || IconDefault.imagePath) + Icon2.prototype._getIconUrl.call(this, name);
          },
          _stripUrl: function(path) {
            var strip = function(str, re2, idx) {
              var match = re2.exec(str);
              return match && match[idx];
            };
            path = strip(path, /^url\((['"])?(.+)\1\)$/, 2);
            return path && strip(path, /^(.*)marker-icon\.png$/, 1);
          },
          _detectIconPath: function() {
            var el2 = create$1("div", "leaflet-default-icon-path", document.body);
            var path = getStyle(el2, "background-image") || getStyle(el2, "backgroundImage");
            document.body.removeChild(el2);
            path = this._stripUrl(path);
            if (path) {
              return path;
            }
            var link = document.querySelector('link[href$="leaflet.css"]');
            if (!link) {
              return "";
            }
            return link.href.substring(0, link.href.length - "leaflet.css".length - 1);
          }
        });
        var MarkerDrag = Handler.extend({
          initialize: function(marker2) {
            this._marker = marker2;
          },
          addHooks: function() {
            var icon3 = this._marker._icon;
            if (!this._draggable) {
              this._draggable = new Draggable(icon3, icon3, true);
            }
            this._draggable.on({
              dragstart: this._onDragStart,
              predrag: this._onPreDrag,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this).enable();
            addClass(icon3, "leaflet-marker-draggable");
          },
          removeHooks: function() {
            this._draggable.off({
              dragstart: this._onDragStart,
              predrag: this._onPreDrag,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this).disable();
            if (this._marker._icon) {
              removeClass(this._marker._icon, "leaflet-marker-draggable");
            }
          },
          moved: function() {
            return this._draggable && this._draggable._moved;
          },
          _adjustPan: function(e) {
            var marker2 = this._marker, map2 = marker2._map, speed = this._marker.options.autoPanSpeed, padding = this._marker.options.autoPanPadding, iconPos = getPosition(marker2._icon), bounds = map2.getPixelBounds(), origin = map2.getPixelOrigin();
            var panBounds = toBounds(
              bounds.min._subtract(origin).add(padding),
              bounds.max._subtract(origin).subtract(padding)
            );
            if (!panBounds.contains(iconPos)) {
              var movement = toPoint(
                (Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),
                (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)
              ).multiplyBy(speed);
              map2.panBy(movement, { animate: false });
              this._draggable._newPos._add(movement);
              this._draggable._startPos._add(movement);
              setPosition(marker2._icon, this._draggable._newPos);
              this._onDrag(e);
              this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
            }
          },
          _onDragStart: function() {
            this._oldLatLng = this._marker.getLatLng();
            this._marker.closePopup && this._marker.closePopup();
            this._marker.fire("movestart").fire("dragstart");
          },
          _onPreDrag: function(e) {
            if (this._marker.options.autoPan) {
              cancelAnimFrame(this._panRequest);
              this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
            }
          },
          _onDrag: function(e) {
            var marker2 = this._marker, shadow = marker2._shadow, iconPos = getPosition(marker2._icon), latlng = marker2._map.layerPointToLatLng(iconPos);
            if (shadow) {
              setPosition(shadow, iconPos);
            }
            marker2._latlng = latlng;
            e.latlng = latlng;
            e.oldLatLng = this._oldLatLng;
            marker2.fire("move", e).fire("drag", e);
          },
          _onDragEnd: function(e) {
            cancelAnimFrame(this._panRequest);
            delete this._oldLatLng;
            this._marker.fire("moveend").fire("dragend", e);
          }
        });
        var Marker = Layer2.extend({
          // @section
          // @aka Marker options
          options: {
            // @option icon: Icon = *
            // Icon instance to use for rendering the marker.
            // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
            // If not specified, a common instance of `L.Icon.Default` is used.
            icon: new IconDefault(),
            // Option inherited from "Interactive layer" abstract class
            interactive: true,
            // @option keyboard: Boolean = true
            // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
            keyboard: true,
            // @option title: String = ''
            // Text for the browser tooltip that appear on marker hover (no tooltip by default).
            // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
            title: "",
            // @option alt: String = 'Marker'
            // Text for the `alt` attribute of the icon image.
            // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
            alt: "Marker",
            // @option zIndexOffset: Number = 0
            // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
            zIndexOffset: 0,
            // @option opacity: Number = 1.0
            // The opacity of the marker.
            opacity: 1,
            // @option riseOnHover: Boolean = false
            // If `true`, the marker will get on top of others when you hover the mouse over it.
            riseOnHover: false,
            // @option riseOffset: Number = 250
            // The z-index offset used for the `riseOnHover` feature.
            riseOffset: 250,
            // @option pane: String = 'markerPane'
            // `Map pane` where the markers icon will be added.
            pane: "markerPane",
            // @option shadowPane: String = 'shadowPane'
            // `Map pane` where the markers shadow will be added.
            shadowPane: "shadowPane",
            // @option bubblingMouseEvents: Boolean = false
            // When `true`, a mouse event on this marker will trigger the same event on the map
            // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
            bubblingMouseEvents: false,
            // @option autoPanOnFocus: Boolean = true
            // When `true`, the map will pan whenever the marker is focused (via
            // e.g. pressing `tab` on the keyboard) to ensure the marker is
            // visible within the map's bounds
            autoPanOnFocus: true,
            // @section Draggable marker options
            // @option draggable: Boolean = false
            // Whether the marker is draggable with mouse/touch or not.
            draggable: false,
            // @option autoPan: Boolean = false
            // Whether to pan the map when dragging this marker near its edge or not.
            autoPan: false,
            // @option autoPanPadding: Point = Point(50, 50)
            // Distance (in pixels to the left/right and to the top/bottom) of the
            // map edge to start panning the map.
            autoPanPadding: [50, 50],
            // @option autoPanSpeed: Number = 10
            // Number of pixels the map should pan by.
            autoPanSpeed: 10
          },
          /* @section
           *
           * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
           */
          initialize: function(latlng, options) {
            setOptions(this, options);
            this._latlng = toLatLng(latlng);
          },
          onAdd: function(map2) {
            this._zoomAnimated = this._zoomAnimated && map2.options.markerZoomAnimation;
            if (this._zoomAnimated) {
              map2.on("zoomanim", this._animateZoom, this);
            }
            this._initIcon();
            this.update();
          },
          onRemove: function(map2) {
            if (this.dragging && this.dragging.enabled()) {
              this.options.draggable = true;
              this.dragging.removeHooks();
            }
            delete this.dragging;
            if (this._zoomAnimated) {
              map2.off("zoomanim", this._animateZoom, this);
            }
            this._removeIcon();
            this._removeShadow();
          },
          getEvents: function() {
            return {
              zoom: this.update,
              viewreset: this.update
            };
          },
          // @method getLatLng: LatLng
          // Returns the current geographical position of the marker.
          getLatLng: function() {
            return this._latlng;
          },
          // @method setLatLng(latlng: LatLng): this
          // Changes the marker position to the given point.
          setLatLng: function(latlng) {
            var oldLatLng = this._latlng;
            this._latlng = toLatLng(latlng);
            this.update();
            return this.fire("move", { oldLatLng, latlng: this._latlng });
          },
          // @method setZIndexOffset(offset: Number): this
          // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
          setZIndexOffset: function(offset) {
            this.options.zIndexOffset = offset;
            return this.update();
          },
          // @method getIcon: Icon
          // Returns the current icon used by the marker
          getIcon: function() {
            return this.options.icon;
          },
          // @method setIcon(icon: Icon): this
          // Changes the marker icon.
          setIcon: function(icon3) {
            this.options.icon = icon3;
            if (this._map) {
              this._initIcon();
              this.update();
            }
            if (this._popup) {
              this.bindPopup(this._popup, this._popup.options);
            }
            return this;
          },
          getElement: function() {
            return this._icon;
          },
          update: function() {
            if (this._icon && this._map) {
              var pos = this._map.latLngToLayerPoint(this._latlng).round();
              this._setPos(pos);
            }
            return this;
          },
          _initIcon: function() {
            var options = this.options, classToAdd = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
            var icon3 = options.icon.createIcon(this._icon), addIcon = false;
            if (icon3 !== this._icon) {
              if (this._icon) {
                this._removeIcon();
              }
              addIcon = true;
              if (options.title) {
                icon3.title = options.title;
              }
              if (icon3.tagName === "IMG") {
                icon3.alt = options.alt || "";
              }
            }
            addClass(icon3, classToAdd);
            if (options.keyboard) {
              icon3.tabIndex = "0";
              icon3.setAttribute("role", "button");
            }
            this._icon = icon3;
            if (options.riseOnHover) {
              this.on({
                mouseover: this._bringToFront,
                mouseout: this._resetZIndex
              });
            }
            if (this.options.autoPanOnFocus) {
              on(icon3, "focus", this._panOnFocus, this);
            }
            var newShadow = options.icon.createShadow(this._shadow), addShadow = false;
            if (newShadow !== this._shadow) {
              this._removeShadow();
              addShadow = true;
            }
            if (newShadow) {
              addClass(newShadow, classToAdd);
              newShadow.alt = "";
            }
            this._shadow = newShadow;
            if (options.opacity < 1) {
              this._updateOpacity();
            }
            if (addIcon) {
              this.getPane().appendChild(this._icon);
            }
            this._initInteraction();
            if (newShadow && addShadow) {
              this.getPane(options.shadowPane).appendChild(this._shadow);
            }
          },
          _removeIcon: function() {
            if (this.options.riseOnHover) {
              this.off({
                mouseover: this._bringToFront,
                mouseout: this._resetZIndex
              });
            }
            if (this.options.autoPanOnFocus) {
              off(this._icon, "focus", this._panOnFocus, this);
            }
            remove(this._icon);
            this.removeInteractiveTarget(this._icon);
            this._icon = null;
          },
          _removeShadow: function() {
            if (this._shadow) {
              remove(this._shadow);
            }
            this._shadow = null;
          },
          _setPos: function(pos) {
            if (this._icon) {
              setPosition(this._icon, pos);
            }
            if (this._shadow) {
              setPosition(this._shadow, pos);
            }
            this._zIndex = pos.y + this.options.zIndexOffset;
            this._resetZIndex();
          },
          _updateZIndex: function(offset) {
            if (this._icon) {
              this._icon.style.zIndex = this._zIndex + offset;
            }
          },
          _animateZoom: function(opt) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
            this._setPos(pos);
          },
          _initInteraction: function() {
            if (!this.options.interactive) {
              return;
            }
            addClass(this._icon, "leaflet-interactive");
            this.addInteractiveTarget(this._icon);
            if (MarkerDrag) {
              var draggable = this.options.draggable;
              if (this.dragging) {
                draggable = this.dragging.enabled();
                this.dragging.disable();
              }
              this.dragging = new MarkerDrag(this);
              if (draggable) {
                this.dragging.enable();
              }
            }
          },
          // @method setOpacity(opacity: Number): this
          // Changes the opacity of the marker.
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._map) {
              this._updateOpacity();
            }
            return this;
          },
          _updateOpacity: function() {
            var opacity = this.options.opacity;
            if (this._icon) {
              setOpacity(this._icon, opacity);
            }
            if (this._shadow) {
              setOpacity(this._shadow, opacity);
            }
          },
          _bringToFront: function() {
            this._updateZIndex(this.options.riseOffset);
          },
          _resetZIndex: function() {
            this._updateZIndex(0);
          },
          _panOnFocus: function() {
            var map2 = this._map;
            if (!map2) {
              return;
            }
            var iconOpts = this.options.icon.options;
            var size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);
            var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);
            map2.panInside(this._latlng, {
              paddingTopLeft: anchor,
              paddingBottomRight: size.subtract(anchor)
            });
          },
          _getPopupAnchor: function() {
            return this.options.icon.options.popupAnchor;
          },
          _getTooltipAnchor: function() {
            return this.options.icon.options.tooltipAnchor;
          }
        });
        function marker(latlng, options) {
          return new Marker(latlng, options);
        }
        var Path2 = Layer2.extend({
          // @section
          // @aka Path options
          options: {
            // @option stroke: Boolean = true
            // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
            stroke: true,
            // @option color: String = '#3388ff'
            // Stroke color
            color: "#3388ff",
            // @option weight: Number = 3
            // Stroke width in pixels
            weight: 3,
            // @option opacity: Number = 1.0
            // Stroke opacity
            opacity: 1,
            // @option lineCap: String= 'round'
            // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
            lineCap: "round",
            // @option lineJoin: String = 'round'
            // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
            lineJoin: "round",
            // @option dashArray: String = null
            // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
            dashArray: null,
            // @option dashOffset: String = null
            // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
            dashOffset: null,
            // @option fill: Boolean = depends
            // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
            fill: false,
            // @option fillColor: String = *
            // Fill color. Defaults to the value of the [`color`](#path-color) option
            fillColor: null,
            // @option fillOpacity: Number = 0.2
            // Fill opacity.
            fillOpacity: 0.2,
            // @option fillRule: String = 'evenodd'
            // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
            fillRule: "evenodd",
            // className: '',
            // Option inherited from "Interactive layer" abstract class
            interactive: true,
            // @option bubblingMouseEvents: Boolean = true
            // When `true`, a mouse event on this path will trigger the same event on the map
            // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
            bubblingMouseEvents: true
          },
          beforeAdd: function(map2) {
            this._renderer = map2.getRenderer(this);
          },
          onAdd: function() {
            this._renderer._initPath(this);
            this._reset();
            this._renderer._addPath(this);
          },
          onRemove: function() {
            this._renderer._removePath(this);
          },
          // @method redraw(): this
          // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
          redraw: function() {
            if (this._map) {
              this._renderer._updatePath(this);
            }
            return this;
          },
          // @method setStyle(style: Path options): this
          // Changes the appearance of a Path based on the options in the `Path options` object.
          setStyle: function(style2) {
            setOptions(this, style2);
            if (this._renderer) {
              this._renderer._updateStyle(this);
              if (this.options.stroke && style2 && Object.prototype.hasOwnProperty.call(style2, "weight")) {
                this._updateBounds();
              }
            }
            return this;
          },
          // @method bringToFront(): this
          // Brings the layer to the top of all path layers.
          bringToFront: function() {
            if (this._renderer) {
              this._renderer._bringToFront(this);
            }
            return this;
          },
          // @method bringToBack(): this
          // Brings the layer to the bottom of all path layers.
          bringToBack: function() {
            if (this._renderer) {
              this._renderer._bringToBack(this);
            }
            return this;
          },
          getElement: function() {
            return this._path;
          },
          _reset: function() {
            this._project();
            this._update();
          },
          _clickTolerance: function() {
            return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
          }
        });
        var CircleMarker2 = Path2.extend({
          // @section
          // @aka CircleMarker options
          options: {
            fill: true,
            // @option radius: Number = 10
            // Radius of the circle marker, in pixels
            radius: 10
          },
          initialize: function(latlng, options) {
            setOptions(this, options);
            this._latlng = toLatLng(latlng);
            this._radius = this.options.radius;
          },
          // @method setLatLng(latLng: LatLng): this
          // Sets the position of a circle marker to a new location.
          setLatLng: function(latlng) {
            var oldLatLng = this._latlng;
            this._latlng = toLatLng(latlng);
            this.redraw();
            return this.fire("move", { oldLatLng, latlng: this._latlng });
          },
          // @method getLatLng(): LatLng
          // Returns the current geographical position of the circle marker
          getLatLng: function() {
            return this._latlng;
          },
          // @method setRadius(radius: Number): this
          // Sets the radius of a circle marker. Units are in pixels.
          setRadius: function(radius) {
            this.options.radius = this._radius = radius;
            return this.redraw();
          },
          // @method getRadius(): Number
          // Returns the current radius of the circle
          getRadius: function() {
            return this._radius;
          },
          setStyle: function(options) {
            var radius = options && options.radius || this._radius;
            Path2.prototype.setStyle.call(this, options);
            this.setRadius(radius);
            return this;
          },
          _project: function() {
            this._point = this._map.latLngToLayerPoint(this._latlng);
            this._updateBounds();
          },
          _updateBounds: function() {
            var r2 = this._radius, r22 = this._radiusY || r2, w2 = this._clickTolerance(), p2 = [r2 + w2, r22 + w2];
            this._pxBounds = new Bounds(this._point.subtract(p2), this._point.add(p2));
          },
          _update: function() {
            if (this._map) {
              this._updatePath();
            }
          },
          _updatePath: function() {
            this._renderer._updateCircle(this);
          },
          _empty: function() {
            return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
          },
          // Needed by the `Canvas` renderer for interactivity
          _containsPoint: function(p2) {
            return p2.distanceTo(this._point) <= this._radius + this._clickTolerance();
          }
        });
        function circleMarker(latlng, options) {
          return new CircleMarker2(latlng, options);
        }
        var Circle2 = CircleMarker2.extend({
          initialize: function(latlng, options, legacyOptions) {
            if (typeof options === "number") {
              options = extend2({}, legacyOptions, { radius: options });
            }
            setOptions(this, options);
            this._latlng = toLatLng(latlng);
            if (isNaN(this.options.radius)) {
              throw new Error("Circle radius cannot be NaN");
            }
            this._mRadius = this.options.radius;
          },
          // @method setRadius(radius: Number): this
          // Sets the radius of a circle. Units are in meters.
          setRadius: function(radius) {
            this._mRadius = radius;
            return this.redraw();
          },
          // @method getRadius(): Number
          // Returns the current radius of a circle. Units are in meters.
          getRadius: function() {
            return this._mRadius;
          },
          // @method getBounds(): LatLngBounds
          // Returns the `LatLngBounds` of the path.
          getBounds: function() {
            var half = [this._radius, this._radiusY || this._radius];
            return new LatLngBounds(
              this._map.layerPointToLatLng(this._point.subtract(half)),
              this._map.layerPointToLatLng(this._point.add(half))
            );
          },
          setStyle: Path2.prototype.setStyle,
          _project: function() {
            var lng = this._latlng.lng, lat = this._latlng.lat, map2 = this._map, crs = map2.options.crs;
            if (crs.distance === Earth.distance) {
              var d = Math.PI / 180, latR = this._mRadius / Earth.R / d, top = map2.project([lat + latR, lng]), bottom = map2.project([lat - latR, lng]), p2 = top.add(bottom).divideBy(2), lat2 = map2.unproject(p2).lat, lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;
              if (isNaN(lngR) || lngR === 0) {
                lngR = latR / Math.cos(Math.PI / 180 * lat);
              }
              this._point = p2.subtract(map2.getPixelOrigin());
              this._radius = isNaN(lngR) ? 0 : p2.x - map2.project([lat2, lng - lngR]).x;
              this._radiusY = p2.y - top.y;
            } else {
              var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));
              this._point = map2.latLngToLayerPoint(this._latlng);
              this._radius = this._point.x - map2.latLngToLayerPoint(latlng2).x;
            }
            this._updateBounds();
          }
        });
        function circle(latlng, options, legacyOptions) {
          return new Circle2(latlng, options, legacyOptions);
        }
        var Polyline = Path2.extend({
          // @section
          // @aka Polyline options
          options: {
            // @option smoothFactor: Number = 1.0
            // How much to simplify the polyline on each zoom level. More means
            // better performance and smoother look, and less means more accurate representation.
            smoothFactor: 1,
            // @option noClip: Boolean = false
            // Disable polyline clipping.
            noClip: false
          },
          initialize: function(latlngs, options) {
            setOptions(this, options);
            this._setLatLngs(latlngs);
          },
          // @method getLatLngs(): LatLng[]
          // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
          getLatLngs: function() {
            return this._latlngs;
          },
          // @method setLatLngs(latlngs: LatLng[]): this
          // Replaces all the points in the polyline with the given array of geographical points.
          setLatLngs: function(latlngs) {
            this._setLatLngs(latlngs);
            return this.redraw();
          },
          // @method isEmpty(): Boolean
          // Returns `true` if the Polyline has no LatLngs.
          isEmpty: function() {
            return !this._latlngs.length;
          },
          // @method closestLayerPoint(p: Point): Point
          // Returns the point closest to `p` on the Polyline.
          closestLayerPoint: function(p2) {
            var minDistance = Infinity, minPoint = null, closest = _sqClosestPointOnSegment, p1, p22;
            for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
              var points = this._parts[j];
              for (var i = 1, len = points.length; i < len; i++) {
                p1 = points[i - 1];
                p22 = points[i];
                var sqDist = closest(p2, p1, p22, true);
                if (sqDist < minDistance) {
                  minDistance = sqDist;
                  minPoint = closest(p2, p1, p22);
                }
              }
            }
            if (minPoint) {
              minPoint.distance = Math.sqrt(minDistance);
            }
            return minPoint;
          },
          // @method getCenter(): LatLng
          // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
          getCenter: function() {
            if (!this._map) {
              throw new Error("Must add layer to map before using getCenter()");
            }
            return polylineCenter(this._defaultShape(), this._map.options.crs);
          },
          // @method getBounds(): LatLngBounds
          // Returns the `LatLngBounds` of the path.
          getBounds: function() {
            return this._bounds;
          },
          // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
          // Adds a given point to the polyline. By default, adds to the first ring of
          // the polyline in case of a multi-polyline, but can be overridden by passing
          // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
          addLatLng: function(latlng, latlngs) {
            latlngs = latlngs || this._defaultShape();
            latlng = toLatLng(latlng);
            latlngs.push(latlng);
            this._bounds.extend(latlng);
            return this.redraw();
          },
          _setLatLngs: function(latlngs) {
            this._bounds = new LatLngBounds();
            this._latlngs = this._convertLatLngs(latlngs);
          },
          _defaultShape: function() {
            return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
          },
          // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
          _convertLatLngs: function(latlngs) {
            var result = [], flat = isFlat(latlngs);
            for (var i = 0, len = latlngs.length; i < len; i++) {
              if (flat) {
                result[i] = toLatLng(latlngs[i]);
                this._bounds.extend(result[i]);
              } else {
                result[i] = this._convertLatLngs(latlngs[i]);
              }
            }
            return result;
          },
          _project: function() {
            var pxBounds = new Bounds();
            this._rings = [];
            this._projectLatlngs(this._latlngs, this._rings, pxBounds);
            if (this._bounds.isValid() && pxBounds.isValid()) {
              this._rawPxBounds = pxBounds;
              this._updateBounds();
            }
          },
          _updateBounds: function() {
            var w2 = this._clickTolerance(), p2 = new Point(w2, w2);
            if (!this._rawPxBounds) {
              return;
            }
            this._pxBounds = new Bounds([
              this._rawPxBounds.min.subtract(p2),
              this._rawPxBounds.max.add(p2)
            ]);
          },
          // recursively turns latlngs into a set of rings with projected coordinates
          _projectLatlngs: function(latlngs, result, projectedBounds) {
            var flat = latlngs[0] instanceof LatLng, len = latlngs.length, i, ring;
            if (flat) {
              ring = [];
              for (i = 0; i < len; i++) {
                ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
                projectedBounds.extend(ring[i]);
              }
              result.push(ring);
            } else {
              for (i = 0; i < len; i++) {
                this._projectLatlngs(latlngs[i], result, projectedBounds);
              }
            }
          },
          // clip polyline by renderer bounds so that we have less to render for performance
          _clipPoints: function() {
            var bounds = this._renderer._bounds;
            this._parts = [];
            if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
              return;
            }
            if (this.options.noClip) {
              this._parts = this._rings;
              return;
            }
            var parts = this._parts, i, j, k2, len, len2, segment, points;
            for (i = 0, k2 = 0, len = this._rings.length; i < len; i++) {
              points = this._rings[i];
              for (j = 0, len2 = points.length; j < len2 - 1; j++) {
                segment = clipSegment(points[j], points[j + 1], bounds, j, true);
                if (!segment) {
                  continue;
                }
                parts[k2] = parts[k2] || [];
                parts[k2].push(segment[0]);
                if (segment[1] !== points[j + 1] || j === len2 - 2) {
                  parts[k2].push(segment[1]);
                  k2++;
                }
              }
            }
          },
          // simplify each clipped part of the polyline for performance
          _simplifyPoints: function() {
            var parts = this._parts, tolerance = this.options.smoothFactor;
            for (var i = 0, len = parts.length; i < len; i++) {
              parts[i] = simplify(parts[i], tolerance);
            }
          },
          _update: function() {
            if (!this._map) {
              return;
            }
            this._clipPoints();
            this._simplifyPoints();
            this._updatePath();
          },
          _updatePath: function() {
            this._renderer._updatePoly(this);
          },
          // Needed by the `Canvas` renderer for interactivity
          _containsPoint: function(p2, closed) {
            var i, j, k2, len, len2, part, w2 = this._clickTolerance();
            if (!this._pxBounds || !this._pxBounds.contains(p2)) {
              return false;
            }
            for (i = 0, len = this._parts.length; i < len; i++) {
              part = this._parts[i];
              for (j = 0, len2 = part.length, k2 = len2 - 1; j < len2; k2 = j++) {
                if (!closed && j === 0) {
                  continue;
                }
                if (pointToSegmentDistance(p2, part[k2], part[j]) <= w2) {
                  return true;
                }
              }
            }
            return false;
          }
        });
        function polyline(latlngs, options) {
          return new Polyline(latlngs, options);
        }
        Polyline._flat = _flat;
        var Polygon = Polyline.extend({
          options: {
            fill: true
          },
          isEmpty: function() {
            return !this._latlngs.length || !this._latlngs[0].length;
          },
          // @method getCenter(): LatLng
          // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.
          getCenter: function() {
            if (!this._map) {
              throw new Error("Must add layer to map before using getCenter()");
            }
            return polygonCenter(this._defaultShape(), this._map.options.crs);
          },
          _convertLatLngs: function(latlngs) {
            var result = Polyline.prototype._convertLatLngs.call(this, latlngs), len = result.length;
            if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
              result.pop();
            }
            return result;
          },
          _setLatLngs: function(latlngs) {
            Polyline.prototype._setLatLngs.call(this, latlngs);
            if (isFlat(this._latlngs)) {
              this._latlngs = [this._latlngs];
            }
          },
          _defaultShape: function() {
            return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
          },
          _clipPoints: function() {
            var bounds = this._renderer._bounds, w2 = this.options.weight, p2 = new Point(w2, w2);
            bounds = new Bounds(bounds.min.subtract(p2), bounds.max.add(p2));
            this._parts = [];
            if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
              return;
            }
            if (this.options.noClip) {
              this._parts = this._rings;
              return;
            }
            for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
              clipped = clipPolygon(this._rings[i], bounds, true);
              if (clipped.length) {
                this._parts.push(clipped);
              }
            }
          },
          _updatePath: function() {
            this._renderer._updatePoly(this, true);
          },
          // Needed by the `Canvas` renderer for interactivity
          _containsPoint: function(p2) {
            var inside = false, part, p1, p22, i, j, k2, len, len2;
            if (!this._pxBounds || !this._pxBounds.contains(p2)) {
              return false;
            }
            for (i = 0, len = this._parts.length; i < len; i++) {
              part = this._parts[i];
              for (j = 0, len2 = part.length, k2 = len2 - 1; j < len2; k2 = j++) {
                p1 = part[j];
                p22 = part[k2];
                if (p1.y > p2.y !== p22.y > p2.y && p2.x < (p22.x - p1.x) * (p2.y - p1.y) / (p22.y - p1.y) + p1.x) {
                  inside = !inside;
                }
              }
            }
            return inside || Polyline.prototype._containsPoint.call(this, p2, true);
          }
        });
        function polygon(latlngs, options) {
          return new Polygon(latlngs, options);
        }
        var GeoJSON = FeatureGroup.extend({
          /* @section
           * @aka GeoJSON options
           *
           * @option pointToLayer: Function = *
           * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
           * called when data is added, passing the GeoJSON point feature and its `LatLng`.
           * The default is to spawn a default `Marker`:
           * ```js
           * function(geoJsonPoint, latlng) {
           * 	return L.marker(latlng);
           * }
           * ```
           *
           * @option style: Function = *
           * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
           * called internally when data is added.
           * The default value is to not override any defaults:
           * ```js
           * function (geoJsonFeature) {
           * 	return {}
           * }
           * ```
           *
           * @option onEachFeature: Function = *
           * A `Function` that will be called once for each created `Feature`, after it has
           * been created and styled. Useful for attaching events and popups to features.
           * The default is to do nothing with the newly created layers:
           * ```js
           * function (feature, layer) {}
           * ```
           *
           * @option filter: Function = *
           * A `Function` that will be used to decide whether to include a feature or not.
           * The default is to include all features:
           * ```js
           * function (geoJsonFeature) {
           * 	return true;
           * }
           * ```
           * Note: dynamically changing the `filter` option will have effect only on newly
           * added data. It will _not_ re-evaluate already included features.
           *
           * @option coordsToLatLng: Function = *
           * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
           * The default is the `coordsToLatLng` static method.
           *
           * @option markersInheritOptions: Boolean = false
           * Whether default Markers for "Point" type Features inherit from group options.
           */
          initialize: function(geojson, options) {
            setOptions(this, options);
            this._layers = {};
            if (geojson) {
              this.addData(geojson);
            }
          },
          // @method addData( <GeoJSON> data ): this
          // Adds a GeoJSON object to the layer.
          addData: function(geojson) {
            var features = isArray2(geojson) ? geojson : geojson.features, i, len, feature;
            if (features) {
              for (i = 0, len = features.length; i < len; i++) {
                feature = features[i];
                if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
                  this.addData(feature);
                }
              }
              return this;
            }
            var options = this.options;
            if (options.filter && !options.filter(geojson)) {
              return this;
            }
            var layer = geometryToLayer(geojson, options);
            if (!layer) {
              return this;
            }
            layer.feature = asFeature(geojson);
            layer.defaultOptions = layer.options;
            this.resetStyle(layer);
            if (options.onEachFeature) {
              options.onEachFeature(geojson, layer);
            }
            return this.addLayer(layer);
          },
          // @method resetStyle( <Path> layer? ): this
          // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
          // If `layer` is omitted, the style of all features in the current layer is reset.
          resetStyle: function(layer) {
            if (layer === void 0) {
              return this.eachLayer(this.resetStyle, this);
            }
            layer.options = extend2({}, layer.defaultOptions);
            this._setLayerStyle(layer, this.options.style);
            return this;
          },
          // @method setStyle( <Function> style ): this
          // Changes styles of GeoJSON vector layers with the given style function.
          setStyle: function(style2) {
            return this.eachLayer(function(layer) {
              this._setLayerStyle(layer, style2);
            }, this);
          },
          _setLayerStyle: function(layer, style2) {
            if (layer.setStyle) {
              if (typeof style2 === "function") {
                style2 = style2(layer.feature);
              }
              layer.setStyle(style2);
            }
          }
        });
        function geometryToLayer(geojson, options) {
          var geometry = geojson.type === "Feature" ? geojson.geometry : geojson, coords = geometry ? geometry.coordinates : null, layers2 = [], pointToLayer = options && options.pointToLayer, _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng, latlng, latlngs, i, len;
          if (!coords && !geometry) {
            return null;
          }
          switch (geometry.type) {
            case "Point":
              latlng = _coordsToLatLng(coords);
              return _pointToLayer(pointToLayer, geojson, latlng, options);
            case "MultiPoint":
              for (i = 0, len = coords.length; i < len; i++) {
                latlng = _coordsToLatLng(coords[i]);
                layers2.push(_pointToLayer(pointToLayer, geojson, latlng, options));
              }
              return new FeatureGroup(layers2);
            case "LineString":
            case "MultiLineString":
              latlngs = coordsToLatLngs(coords, geometry.type === "LineString" ? 0 : 1, _coordsToLatLng);
              return new Polyline(latlngs, options);
            case "Polygon":
            case "MultiPolygon":
              latlngs = coordsToLatLngs(coords, geometry.type === "Polygon" ? 1 : 2, _coordsToLatLng);
              return new Polygon(latlngs, options);
            case "GeometryCollection":
              for (i = 0, len = geometry.geometries.length; i < len; i++) {
                var geoLayer = geometryToLayer({
                  geometry: geometry.geometries[i],
                  type: "Feature",
                  properties: geojson.properties
                }, options);
                if (geoLayer) {
                  layers2.push(geoLayer);
                }
              }
              return new FeatureGroup(layers2);
            case "FeatureCollection":
              for (i = 0, len = geometry.features.length; i < len; i++) {
                var featureLayer = geometryToLayer(geometry.features[i], options);
                if (featureLayer) {
                  layers2.push(featureLayer);
                }
              }
              return new FeatureGroup(layers2);
            default:
              throw new Error("Invalid GeoJSON object.");
          }
        }
        function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
          return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);
        }
        function coordsToLatLng(coords) {
          return new LatLng(coords[1], coords[0], coords[2]);
        }
        function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
          var latlngs = [];
          for (var i = 0, len = coords.length, latlng; i < len; i++) {
            latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);
            latlngs.push(latlng);
          }
          return latlngs;
        }
        function latLngToCoords(latlng, precision) {
          latlng = toLatLng(latlng);
          return latlng.alt !== void 0 ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
        }
        function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
          var coords = [];
          for (var i = 0, len = latlngs.length; i < len; i++) {
            coords.push(levelsDeep ? latLngsToCoords(latlngs[i], isFlat(latlngs[i]) ? 0 : levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));
          }
          if (!levelsDeep && closed && coords.length > 0) {
            coords.push(coords[0].slice());
          }
          return coords;
        }
        function getFeature(layer, newGeometry) {
          return layer.feature ? extend2({}, layer.feature, { geometry: newGeometry }) : asFeature(newGeometry);
        }
        function asFeature(geojson) {
          if (geojson.type === "Feature" || geojson.type === "FeatureCollection") {
            return geojson;
          }
          return {
            type: "Feature",
            properties: {},
            geometry: geojson
          };
        }
        var PointToGeoJSON = {
          toGeoJSON: function(precision) {
            return getFeature(this, {
              type: "Point",
              coordinates: latLngToCoords(this.getLatLng(), precision)
            });
          }
        };
        Marker.include(PointToGeoJSON);
        Circle2.include(PointToGeoJSON);
        CircleMarker2.include(PointToGeoJSON);
        Polyline.include({
          toGeoJSON: function(precision) {
            var multi = !isFlat(this._latlngs);
            var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);
            return getFeature(this, {
              type: (multi ? "Multi" : "") + "LineString",
              coordinates: coords
            });
          }
        });
        Polygon.include({
          toGeoJSON: function(precision) {
            var holes = !isFlat(this._latlngs), multi = holes && !isFlat(this._latlngs[0]);
            var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);
            if (!holes) {
              coords = [coords];
            }
            return getFeature(this, {
              type: (multi ? "Multi" : "") + "Polygon",
              coordinates: coords
            });
          }
        });
        LayerGroup.include({
          toMultiPoint: function(precision) {
            var coords = [];
            this.eachLayer(function(layer) {
              coords.push(layer.toGeoJSON(precision).geometry.coordinates);
            });
            return getFeature(this, {
              type: "MultiPoint",
              coordinates: coords
            });
          },
          // @method toGeoJSON(precision?: Number|false): Object
          // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
          // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
          toGeoJSON: function(precision) {
            var type = this.feature && this.feature.geometry && this.feature.geometry.type;
            if (type === "MultiPoint") {
              return this.toMultiPoint(precision);
            }
            var isGeometryCollection = type === "GeometryCollection", jsons = [];
            this.eachLayer(function(layer) {
              if (layer.toGeoJSON) {
                var json = layer.toGeoJSON(precision);
                if (isGeometryCollection) {
                  jsons.push(json.geometry);
                } else {
                  var feature = asFeature(json);
                  if (feature.type === "FeatureCollection") {
                    jsons.push.apply(jsons, feature.features);
                  } else {
                    jsons.push(feature);
                  }
                }
              }
            });
            if (isGeometryCollection) {
              return getFeature(this, {
                geometries: jsons,
                type: "GeometryCollection"
              });
            }
            return {
              type: "FeatureCollection",
              features: jsons
            };
          }
        });
        function geoJSON(geojson, options) {
          return new GeoJSON(geojson, options);
        }
        var geoJson = geoJSON;
        var ImageOverlay = Layer2.extend({
          // @section
          // @aka ImageOverlay options
          options: {
            // @option opacity: Number = 1.0
            // The opacity of the image overlay.
            opacity: 1,
            // @option alt: String = ''
            // Text for the `alt` attribute of the image (useful for accessibility).
            alt: "",
            // @option interactive: Boolean = false
            // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
            interactive: false,
            // @option crossOrigin: Boolean|String = false
            // Whether the crossOrigin attribute will be added to the image.
            // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
            // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
            crossOrigin: false,
            // @option errorOverlayUrl: String = ''
            // URL to the overlay image to show in place of the overlay that failed to load.
            errorOverlayUrl: "",
            // @option zIndex: Number = 1
            // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
            zIndex: 1,
            // @option className: String = ''
            // A custom class name to assign to the image. Empty by default.
            className: ""
          },
          initialize: function(url, bounds, options) {
            this._url = url;
            this._bounds = toLatLngBounds(bounds);
            setOptions(this, options);
          },
          onAdd: function() {
            if (!this._image) {
              this._initImage();
              if (this.options.opacity < 1) {
                this._updateOpacity();
              }
            }
            if (this.options.interactive) {
              addClass(this._image, "leaflet-interactive");
              this.addInteractiveTarget(this._image);
            }
            this.getPane().appendChild(this._image);
            this._reset();
          },
          onRemove: function() {
            remove(this._image);
            if (this.options.interactive) {
              this.removeInteractiveTarget(this._image);
            }
          },
          // @method setOpacity(opacity: Number): this
          // Sets the opacity of the overlay.
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._image) {
              this._updateOpacity();
            }
            return this;
          },
          setStyle: function(styleOpts) {
            if (styleOpts.opacity) {
              this.setOpacity(styleOpts.opacity);
            }
            return this;
          },
          // @method bringToFront(): this
          // Brings the layer to the top of all overlays.
          bringToFront: function() {
            if (this._map) {
              toFront(this._image);
            }
            return this;
          },
          // @method bringToBack(): this
          // Brings the layer to the bottom of all overlays.
          bringToBack: function() {
            if (this._map) {
              toBack(this._image);
            }
            return this;
          },
          // @method setUrl(url: String): this
          // Changes the URL of the image.
          setUrl: function(url) {
            this._url = url;
            if (this._image) {
              this._image.src = url;
            }
            return this;
          },
          // @method setBounds(bounds: LatLngBounds): this
          // Update the bounds that this ImageOverlay covers
          setBounds: function(bounds) {
            this._bounds = toLatLngBounds(bounds);
            if (this._map) {
              this._reset();
            }
            return this;
          },
          getEvents: function() {
            var events = {
              zoom: this._reset,
              viewreset: this._reset
            };
            if (this._zoomAnimated) {
              events.zoomanim = this._animateZoom;
            }
            return events;
          },
          // @method setZIndex(value: Number): this
          // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
          setZIndex: function(value) {
            this.options.zIndex = value;
            this._updateZIndex();
            return this;
          },
          // @method getBounds(): LatLngBounds
          // Get the bounds that this ImageOverlay covers
          getBounds: function() {
            return this._bounds;
          },
          // @method getElement(): HTMLElement
          // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
          // used by this overlay.
          getElement: function() {
            return this._image;
          },
          _initImage: function() {
            var wasElementSupplied = this._url.tagName === "IMG";
            var img = this._image = wasElementSupplied ? this._url : create$1("img");
            addClass(img, "leaflet-image-layer");
            if (this._zoomAnimated) {
              addClass(img, "leaflet-zoom-animated");
            }
            if (this.options.className) {
              addClass(img, this.options.className);
            }
            img.onselectstart = falseFn;
            img.onmousemove = falseFn;
            img.onload = bind(this.fire, this, "load");
            img.onerror = bind(this._overlayOnError, this, "error");
            if (this.options.crossOrigin || this.options.crossOrigin === "") {
              img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
            }
            if (this.options.zIndex) {
              this._updateZIndex();
            }
            if (wasElementSupplied) {
              this._url = img.src;
              return;
            }
            img.src = this._url;
            img.alt = this.options.alt;
          },
          _animateZoom: function(e) {
            var scale2 = this._map.getZoomScale(e.zoom), offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;
            setTransform(this._image, offset, scale2);
          },
          _reset: function() {
            var image = this._image, bounds = new Bounds(
              this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
              this._map.latLngToLayerPoint(this._bounds.getSouthEast())
            ), size = bounds.getSize();
            setPosition(image, bounds.min);
            image.style.width = size.x + "px";
            image.style.height = size.y + "px";
          },
          _updateOpacity: function() {
            setOpacity(this._image, this.options.opacity);
          },
          _updateZIndex: function() {
            if (this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
              this._image.style.zIndex = this.options.zIndex;
            }
          },
          _overlayOnError: function() {
            this.fire("error");
            var errorUrl = this.options.errorOverlayUrl;
            if (errorUrl && this._url !== errorUrl) {
              this._url = errorUrl;
              this._image.src = errorUrl;
            }
          },
          // @method getCenter(): LatLng
          // Returns the center of the ImageOverlay.
          getCenter: function() {
            return this._bounds.getCenter();
          }
        });
        var imageOverlay = function(url, bounds, options) {
          return new ImageOverlay(url, bounds, options);
        };
        var VideoOverlay = ImageOverlay.extend({
          // @section
          // @aka VideoOverlay options
          options: {
            // @option autoplay: Boolean = true
            // Whether the video starts playing automatically when loaded.
            // On some browsers autoplay will only work with `muted: true`
            autoplay: true,
            // @option loop: Boolean = true
            // Whether the video will loop back to the beginning when played.
            loop: true,
            // @option keepAspectRatio: Boolean = true
            // Whether the video will save aspect ratio after the projection.
            // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
            keepAspectRatio: true,
            // @option muted: Boolean = false
            // Whether the video starts on mute when loaded.
            muted: false,
            // @option playsInline: Boolean = true
            // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.
            playsInline: true
          },
          _initImage: function() {
            var wasElementSupplied = this._url.tagName === "VIDEO";
            var vid = this._image = wasElementSupplied ? this._url : create$1("video");
            addClass(vid, "leaflet-image-layer");
            if (this._zoomAnimated) {
              addClass(vid, "leaflet-zoom-animated");
            }
            if (this.options.className) {
              addClass(vid, this.options.className);
            }
            vid.onselectstart = falseFn;
            vid.onmousemove = falseFn;
            vid.onloadeddata = bind(this.fire, this, "load");
            if (wasElementSupplied) {
              var sourceElements = vid.getElementsByTagName("source");
              var sources = [];
              for (var j = 0; j < sourceElements.length; j++) {
                sources.push(sourceElements[j].src);
              }
              this._url = sourceElements.length > 0 ? sources : [vid.src];
              return;
            }
            if (!isArray2(this._url)) {
              this._url = [this._url];
            }
            if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, "objectFit")) {
              vid.style["objectFit"] = "fill";
            }
            vid.autoplay = !!this.options.autoplay;
            vid.loop = !!this.options.loop;
            vid.muted = !!this.options.muted;
            vid.playsInline = !!this.options.playsInline;
            for (var i = 0; i < this._url.length; i++) {
              var source = create$1("source");
              source.src = this._url[i];
              vid.appendChild(source);
            }
          }
          // @method getElement(): HTMLVideoElement
          // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
          // used by this overlay.
        });
        function videoOverlay(video, bounds, options) {
          return new VideoOverlay(video, bounds, options);
        }
        var SVGOverlay = ImageOverlay.extend({
          _initImage: function() {
            var el2 = this._image = this._url;
            addClass(el2, "leaflet-image-layer");
            if (this._zoomAnimated) {
              addClass(el2, "leaflet-zoom-animated");
            }
            if (this.options.className) {
              addClass(el2, this.options.className);
            }
            el2.onselectstart = falseFn;
            el2.onmousemove = falseFn;
          }
          // @method getElement(): SVGElement
          // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
          // used by this overlay.
        });
        function svgOverlay(el2, bounds, options) {
          return new SVGOverlay(el2, bounds, options);
        }
        var DivOverlay = Layer2.extend({
          // @section
          // @aka DivOverlay options
          options: {
            // @option interactive: Boolean = false
            // If true, the popup/tooltip will listen to the mouse events.
            interactive: false,
            // @option offset: Point = Point(0, 0)
            // The offset of the overlay position.
            offset: [0, 0],
            // @option className: String = ''
            // A custom CSS class name to assign to the overlay.
            className: "",
            // @option pane: String = undefined
            // `Map pane` where the overlay will be added.
            pane: void 0,
            // @option content: String|HTMLElement|Function = ''
            // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be
            // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.
            content: ""
          },
          initialize: function(options, source) {
            if (options && (options instanceof LatLng || isArray2(options))) {
              this._latlng = toLatLng(options);
              setOptions(this, source);
            } else {
              setOptions(this, options);
              this._source = source;
            }
            if (this.options.content) {
              this._content = this.options.content;
            }
          },
          // @method openOn(map: Map): this
          // Adds the overlay to the map.
          // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
          openOn: function(map2) {
            map2 = arguments.length ? map2 : this._source._map;
            if (!map2.hasLayer(this)) {
              map2.addLayer(this);
            }
            return this;
          },
          // @method close(): this
          // Closes the overlay.
          // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
          // and `layer.closePopup()`/`.closeTooltip()`.
          close: function() {
            if (this._map) {
              this._map.removeLayer(this);
            }
            return this;
          },
          // @method toggle(layer?: Layer): this
          // Opens or closes the overlay bound to layer depending on its current state.
          // Argument may be omitted only for overlay bound to layer.
          // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
          toggle: function(layer) {
            if (this._map) {
              this.close();
            } else {
              if (arguments.length) {
                this._source = layer;
              } else {
                layer = this._source;
              }
              this._prepareOpen();
              this.openOn(layer._map);
            }
            return this;
          },
          onAdd: function(map2) {
            this._zoomAnimated = map2._zoomAnimated;
            if (!this._container) {
              this._initLayout();
            }
            if (map2._fadeAnimated) {
              setOpacity(this._container, 0);
            }
            clearTimeout(this._removeTimeout);
            this.getPane().appendChild(this._container);
            this.update();
            if (map2._fadeAnimated) {
              setOpacity(this._container, 1);
            }
            this.bringToFront();
            if (this.options.interactive) {
              addClass(this._container, "leaflet-interactive");
              this.addInteractiveTarget(this._container);
            }
          },
          onRemove: function(map2) {
            if (map2._fadeAnimated) {
              setOpacity(this._container, 0);
              this._removeTimeout = setTimeout(bind(remove, void 0, this._container), 200);
            } else {
              remove(this._container);
            }
            if (this.options.interactive) {
              removeClass(this._container, "leaflet-interactive");
              this.removeInteractiveTarget(this._container);
            }
          },
          // @namespace DivOverlay
          // @method getLatLng: LatLng
          // Returns the geographical point of the overlay.
          getLatLng: function() {
            return this._latlng;
          },
          // @method setLatLng(latlng: LatLng): this
          // Sets the geographical point where the overlay will open.
          setLatLng: function(latlng) {
            this._latlng = toLatLng(latlng);
            if (this._map) {
              this._updatePosition();
              this._adjustPan();
            }
            return this;
          },
          // @method getContent: String|HTMLElement
          // Returns the content of the overlay.
          getContent: function() {
            return this._content;
          },
          // @method setContent(htmlContent: String|HTMLElement|Function): this
          // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
          // The function should return a `String` or `HTMLElement` to be used in the overlay.
          setContent: function(content) {
            this._content = content;
            this.update();
            return this;
          },
          // @method getElement: String|HTMLElement
          // Returns the HTML container of the overlay.
          getElement: function() {
            return this._container;
          },
          // @method update: null
          // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
          update: function() {
            if (!this._map) {
              return;
            }
            this._container.style.visibility = "hidden";
            this._updateContent();
            this._updateLayout();
            this._updatePosition();
            this._container.style.visibility = "";
            this._adjustPan();
          },
          getEvents: function() {
            var events = {
              zoom: this._updatePosition,
              viewreset: this._updatePosition
            };
            if (this._zoomAnimated) {
              events.zoomanim = this._animateZoom;
            }
            return events;
          },
          // @method isOpen: Boolean
          // Returns `true` when the overlay is visible on the map.
          isOpen: function() {
            return !!this._map && this._map.hasLayer(this);
          },
          // @method bringToFront: this
          // Brings this overlay in front of other overlays (in the same map pane).
          bringToFront: function() {
            if (this._map) {
              toFront(this._container);
            }
            return this;
          },
          // @method bringToBack: this
          // Brings this overlay to the back of other overlays (in the same map pane).
          bringToBack: function() {
            if (this._map) {
              toBack(this._container);
            }
            return this;
          },
          // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)
          _prepareOpen: function(latlng) {
            var source = this._source;
            if (!source._map) {
              return false;
            }
            if (source instanceof FeatureGroup) {
              source = null;
              var layers2 = this._source._layers;
              for (var id2 in layers2) {
                if (layers2[id2]._map) {
                  source = layers2[id2];
                  break;
                }
              }
              if (!source) {
                return false;
              }
              this._source = source;
            }
            if (!latlng) {
              if (source.getCenter) {
                latlng = source.getCenter();
              } else if (source.getLatLng) {
                latlng = source.getLatLng();
              } else if (source.getBounds) {
                latlng = source.getBounds().getCenter();
              } else {
                throw new Error("Unable to get source layer LatLng.");
              }
            }
            this.setLatLng(latlng);
            if (this._map) {
              this.update();
            }
            return true;
          },
          _updateContent: function() {
            if (!this._content) {
              return;
            }
            var node = this._contentNode;
            var content = typeof this._content === "function" ? this._content(this._source || this) : this._content;
            if (typeof content === "string") {
              node.innerHTML = content;
            } else {
              while (node.hasChildNodes()) {
                node.removeChild(node.firstChild);
              }
              node.appendChild(content);
            }
            this.fire("contentupdate");
          },
          _updatePosition: function() {
            if (!this._map) {
              return;
            }
            var pos = this._map.latLngToLayerPoint(this._latlng), offset = toPoint(this.options.offset), anchor = this._getAnchor();
            if (this._zoomAnimated) {
              setPosition(this._container, pos.add(anchor));
            } else {
              offset = offset.add(pos).add(anchor);
            }
            var bottom = this._containerBottom = -offset.y, left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;
            this._container.style.bottom = bottom + "px";
            this._container.style.left = left + "px";
          },
          _getAnchor: function() {
            return [0, 0];
          }
        });
        Map2.include({
          _initOverlay: function(OverlayClass, content, latlng, options) {
            var overlay = content;
            if (!(overlay instanceof OverlayClass)) {
              overlay = new OverlayClass(options).setContent(content);
            }
            if (latlng) {
              overlay.setLatLng(latlng);
            }
            return overlay;
          }
        });
        Layer2.include({
          _initOverlay: function(OverlayClass, old, content, options) {
            var overlay = content;
            if (overlay instanceof OverlayClass) {
              setOptions(overlay, options);
              overlay._source = this;
            } else {
              overlay = old && !options ? old : new OverlayClass(options, this);
              overlay.setContent(content);
            }
            return overlay;
          }
        });
        var Popup2 = DivOverlay.extend({
          // @section
          // @aka Popup options
          options: {
            // @option pane: String = 'popupPane'
            // `Map pane` where the popup will be added.
            pane: "popupPane",
            // @option offset: Point = Point(0, 7)
            // The offset of the popup position.
            offset: [0, 7],
            // @option maxWidth: Number = 300
            // Max width of the popup, in pixels.
            maxWidth: 300,
            // @option minWidth: Number = 50
            // Min width of the popup, in pixels.
            minWidth: 50,
            // @option maxHeight: Number = null
            // If set, creates a scrollable container of the given height
            // inside a popup if its content exceeds it.
            // The scrollable container can be styled using the
            // `leaflet-popup-scrolled` CSS class selector.
            maxHeight: null,
            // @option autoPan: Boolean = true
            // Set it to `false` if you don't want the map to do panning animation
            // to fit the opened popup.
            autoPan: true,
            // @option autoPanPaddingTopLeft: Point = null
            // The margin between the popup and the top left corner of the map
            // view after autopanning was performed.
            autoPanPaddingTopLeft: null,
            // @option autoPanPaddingBottomRight: Point = null
            // The margin between the popup and the bottom right corner of the map
            // view after autopanning was performed.
            autoPanPaddingBottomRight: null,
            // @option autoPanPadding: Point = Point(5, 5)
            // Equivalent of setting both top left and bottom right autopan padding to the same value.
            autoPanPadding: [5, 5],
            // @option keepInView: Boolean = false
            // Set it to `true` if you want to prevent users from panning the popup
            // off of the screen while it is open.
            keepInView: false,
            // @option closeButton: Boolean = true
            // Controls the presence of a close button in the popup.
            closeButton: true,
            // @option autoClose: Boolean = true
            // Set it to `false` if you want to override the default behavior of
            // the popup closing when another popup is opened.
            autoClose: true,
            // @option closeOnEscapeKey: Boolean = true
            // Set it to `false` if you want to override the default behavior of
            // the ESC key for closing of the popup.
            closeOnEscapeKey: true,
            // @option closeOnClick: Boolean = *
            // Set it if you want to override the default behavior of the popup closing when user clicks
            // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.
            // @option className: String = ''
            // A custom CSS class name to assign to the popup.
            className: ""
          },
          // @namespace Popup
          // @method openOn(map: Map): this
          // Alternative to `map.openPopup(popup)`.
          // Adds the popup to the map and closes the previous one.
          openOn: function(map2) {
            map2 = arguments.length ? map2 : this._source._map;
            if (!map2.hasLayer(this) && map2._popup && map2._popup.options.autoClose) {
              map2.removeLayer(map2._popup);
            }
            map2._popup = this;
            return DivOverlay.prototype.openOn.call(this, map2);
          },
          onAdd: function(map2) {
            DivOverlay.prototype.onAdd.call(this, map2);
            map2.fire("popupopen", { popup: this });
            if (this._source) {
              this._source.fire("popupopen", { popup: this }, true);
              if (!(this._source instanceof Path2)) {
                this._source.on("preclick", stopPropagation);
              }
            }
          },
          onRemove: function(map2) {
            DivOverlay.prototype.onRemove.call(this, map2);
            map2.fire("popupclose", { popup: this });
            if (this._source) {
              this._source.fire("popupclose", { popup: this }, true);
              if (!(this._source instanceof Path2)) {
                this._source.off("preclick", stopPropagation);
              }
            }
          },
          getEvents: function() {
            var events = DivOverlay.prototype.getEvents.call(this);
            if (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
              events.preclick = this.close;
            }
            if (this.options.keepInView) {
              events.moveend = this._adjustPan;
            }
            return events;
          },
          _initLayout: function() {
            var prefix2 = "leaflet-popup", container = this._container = create$1(
              "div",
              prefix2 + " " + (this.options.className || "") + " leaflet-zoom-animated"
            );
            var wrapper = this._wrapper = create$1("div", prefix2 + "-content-wrapper", container);
            this._contentNode = create$1("div", prefix2 + "-content", wrapper);
            disableClickPropagation(container);
            disableScrollPropagation(this._contentNode);
            on(container, "contextmenu", stopPropagation);
            this._tipContainer = create$1("div", prefix2 + "-tip-container", container);
            this._tip = create$1("div", prefix2 + "-tip", this._tipContainer);
            if (this.options.closeButton) {
              var closeButton = this._closeButton = create$1("a", prefix2 + "-close-button", container);
              closeButton.setAttribute("role", "button");
              closeButton.setAttribute("aria-label", "Close popup");
              closeButton.href = "#close";
              closeButton.innerHTML = '<span aria-hidden="true">&#215;</span>';
              on(closeButton, "click", function(ev) {
                preventDefault(ev);
                this.close();
              }, this);
            }
          },
          _updateLayout: function() {
            var container = this._contentNode, style2 = container.style;
            style2.width = "";
            style2.whiteSpace = "nowrap";
            var width = container.offsetWidth;
            width = Math.min(width, this.options.maxWidth);
            width = Math.max(width, this.options.minWidth);
            style2.width = width + 1 + "px";
            style2.whiteSpace = "";
            style2.height = "";
            var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = "leaflet-popup-scrolled";
            if (maxHeight && height > maxHeight) {
              style2.height = maxHeight + "px";
              addClass(container, scrolledClass);
            } else {
              removeClass(container, scrolledClass);
            }
            this._containerWidth = this._container.offsetWidth;
          },
          _animateZoom: function(e) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center), anchor = this._getAnchor();
            setPosition(this._container, pos.add(anchor));
          },
          _adjustPan: function() {
            if (!this.options.autoPan) {
              return;
            }
            if (this._map._panAnim) {
              this._map._panAnim.stop();
            }
            if (this._autopanning) {
              this._autopanning = false;
              return;
            }
            var map2 = this._map, marginBottom = parseInt(getStyle(this._container, "marginBottom"), 10) || 0, containerHeight = this._container.offsetHeight + marginBottom, containerWidth = this._containerWidth, layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);
            layerPos._add(getPosition(this._container));
            var containerPos = map2.layerPointToContainerPoint(layerPos), padding = toPoint(this.options.autoPanPadding), paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding), paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding), size = map2.getSize(), dx = 0, dy = 0;
            if (containerPos.x + containerWidth + paddingBR.x > size.x) {
              dx = containerPos.x + containerWidth - size.x + paddingBR.x;
            }
            if (containerPos.x - dx - paddingTL.x < 0) {
              dx = containerPos.x - paddingTL.x;
            }
            if (containerPos.y + containerHeight + paddingBR.y > size.y) {
              dy = containerPos.y + containerHeight - size.y + paddingBR.y;
            }
            if (containerPos.y - dy - paddingTL.y < 0) {
              dy = containerPos.y - paddingTL.y;
            }
            if (dx || dy) {
              if (this.options.keepInView) {
                this._autopanning = true;
              }
              map2.fire("autopanstart").panBy([dx, dy]);
            }
          },
          _getAnchor: function() {
            return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
          }
        });
        var popup = function(options, source) {
          return new Popup2(options, source);
        };
        Map2.mergeOptions({
          closePopupOnClick: true
        });
        Map2.include({
          // @method openPopup(popup: Popup): this
          // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
          // @alternative
          // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
          // Creates a popup with the specified content and options and opens it in the given point on a map.
          openPopup: function(popup2, latlng, options) {
            this._initOverlay(Popup2, popup2, latlng, options).openOn(this);
            return this;
          },
          // @method closePopup(popup?: Popup): this
          // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
          closePopup: function(popup2) {
            popup2 = arguments.length ? popup2 : this._popup;
            if (popup2) {
              popup2.close();
            }
            return this;
          }
        });
        Layer2.include({
          // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
          // Binds a popup to the layer with the passed `content` and sets up the
          // necessary event listeners. If a `Function` is passed it will receive
          // the layer as the first argument and should return a `String` or `HTMLElement`.
          bindPopup: function(content, options) {
            this._popup = this._initOverlay(Popup2, this._popup, content, options);
            if (!this._popupHandlersAdded) {
              this.on({
                click: this._openPopup,
                keypress: this._onKeyPress,
                remove: this.closePopup,
                move: this._movePopup
              });
              this._popupHandlersAdded = true;
            }
            return this;
          },
          // @method unbindPopup(): this
          // Removes the popup previously bound with `bindPopup`.
          unbindPopup: function() {
            if (this._popup) {
              this.off({
                click: this._openPopup,
                keypress: this._onKeyPress,
                remove: this.closePopup,
                move: this._movePopup
              });
              this._popupHandlersAdded = false;
              this._popup = null;
            }
            return this;
          },
          // @method openPopup(latlng?: LatLng): this
          // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
          openPopup: function(latlng) {
            if (this._popup) {
              if (!(this instanceof FeatureGroup)) {
                this._popup._source = this;
              }
              if (this._popup._prepareOpen(latlng || this._latlng)) {
                this._popup.openOn(this._map);
              }
            }
            return this;
          },
          // @method closePopup(): this
          // Closes the popup bound to this layer if it is open.
          closePopup: function() {
            if (this._popup) {
              this._popup.close();
            }
            return this;
          },
          // @method togglePopup(): this
          // Opens or closes the popup bound to this layer depending on its current state.
          togglePopup: function() {
            if (this._popup) {
              this._popup.toggle(this);
            }
            return this;
          },
          // @method isPopupOpen(): boolean
          // Returns `true` if the popup bound to this layer is currently open.
          isPopupOpen: function() {
            return this._popup ? this._popup.isOpen() : false;
          },
          // @method setPopupContent(content: String|HTMLElement|Popup): this
          // Sets the content of the popup bound to this layer.
          setPopupContent: function(content) {
            if (this._popup) {
              this._popup.setContent(content);
            }
            return this;
          },
          // @method getPopup(): Popup
          // Returns the popup bound to this layer.
          getPopup: function() {
            return this._popup;
          },
          _openPopup: function(e) {
            if (!this._popup || !this._map) {
              return;
            }
            stop(e);
            var target = e.layer || e.target;
            if (this._popup._source === target && !(target instanceof Path2)) {
              if (this._map.hasLayer(this._popup)) {
                this.closePopup();
              } else {
                this.openPopup(e.latlng);
              }
              return;
            }
            this._popup._source = target;
            this.openPopup(e.latlng);
          },
          _movePopup: function(e) {
            this._popup.setLatLng(e.latlng);
          },
          _onKeyPress: function(e) {
            if (e.originalEvent.keyCode === 13) {
              this._openPopup(e);
            }
          }
        });
        var Tooltip2 = DivOverlay.extend({
          // @section
          // @aka Tooltip options
          options: {
            // @option pane: String = 'tooltipPane'
            // `Map pane` where the tooltip will be added.
            pane: "tooltipPane",
            // @option offset: Point = Point(0, 0)
            // Optional offset of the tooltip position.
            offset: [0, 0],
            // @option direction: String = 'auto'
            // Direction where to open the tooltip. Possible values are: `right`, `left`,
            // `top`, `bottom`, `center`, `auto`.
            // `auto` will dynamically switch between `right` and `left` according to the tooltip
            // position on the map.
            direction: "auto",
            // @option permanent: Boolean = false
            // Whether to open the tooltip permanently or only on mouseover.
            permanent: false,
            // @option sticky: Boolean = false
            // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
            sticky: false,
            // @option opacity: Number = 0.9
            // Tooltip container opacity.
            opacity: 0.9
          },
          onAdd: function(map2) {
            DivOverlay.prototype.onAdd.call(this, map2);
            this.setOpacity(this.options.opacity);
            map2.fire("tooltipopen", { tooltip: this });
            if (this._source) {
              this.addEventParent(this._source);
              this._source.fire("tooltipopen", { tooltip: this }, true);
            }
          },
          onRemove: function(map2) {
            DivOverlay.prototype.onRemove.call(this, map2);
            map2.fire("tooltipclose", { tooltip: this });
            if (this._source) {
              this.removeEventParent(this._source);
              this._source.fire("tooltipclose", { tooltip: this }, true);
            }
          },
          getEvents: function() {
            var events = DivOverlay.prototype.getEvents.call(this);
            if (!this.options.permanent) {
              events.preclick = this.close;
            }
            return events;
          },
          _initLayout: function() {
            var prefix2 = "leaflet-tooltip", className = prefix2 + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
            this._contentNode = this._container = create$1("div", className);
            this._container.setAttribute("role", "tooltip");
            this._container.setAttribute("id", "leaflet-tooltip-" + stamp(this));
          },
          _updateLayout: function() {
          },
          _adjustPan: function() {
          },
          _setPosition: function(pos) {
            var subX, subY, map2 = this._map, container = this._container, centerPoint = map2.latLngToContainerPoint(map2.getCenter()), tooltipPoint = map2.layerPointToContainerPoint(pos), direction = this.options.direction, tooltipWidth = container.offsetWidth, tooltipHeight = container.offsetHeight, offset = toPoint(this.options.offset), anchor = this._getAnchor();
            if (direction === "top") {
              subX = tooltipWidth / 2;
              subY = tooltipHeight;
            } else if (direction === "bottom") {
              subX = tooltipWidth / 2;
              subY = 0;
            } else if (direction === "center") {
              subX = tooltipWidth / 2;
              subY = tooltipHeight / 2;
            } else if (direction === "right") {
              subX = 0;
              subY = tooltipHeight / 2;
            } else if (direction === "left") {
              subX = tooltipWidth;
              subY = tooltipHeight / 2;
            } else if (tooltipPoint.x < centerPoint.x) {
              direction = "right";
              subX = 0;
              subY = tooltipHeight / 2;
            } else {
              direction = "left";
              subX = tooltipWidth + (offset.x + anchor.x) * 2;
              subY = tooltipHeight / 2;
            }
            pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);
            removeClass(container, "leaflet-tooltip-right");
            removeClass(container, "leaflet-tooltip-left");
            removeClass(container, "leaflet-tooltip-top");
            removeClass(container, "leaflet-tooltip-bottom");
            addClass(container, "leaflet-tooltip-" + direction);
            setPosition(container, pos);
          },
          _updatePosition: function() {
            var pos = this._map.latLngToLayerPoint(this._latlng);
            this._setPosition(pos);
          },
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._container) {
              setOpacity(this._container, opacity);
            }
          },
          _animateZoom: function(e) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
            this._setPosition(pos);
          },
          _getAnchor: function() {
            return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
          }
        });
        var tooltip = function(options, source) {
          return new Tooltip2(options, source);
        };
        Map2.include({
          // @method openTooltip(tooltip: Tooltip): this
          // Opens the specified tooltip.
          // @alternative
          // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
          // Creates a tooltip with the specified content and options and open it.
          openTooltip: function(tooltip2, latlng, options) {
            this._initOverlay(Tooltip2, tooltip2, latlng, options).openOn(this);
            return this;
          },
          // @method closeTooltip(tooltip: Tooltip): this
          // Closes the tooltip given as parameter.
          closeTooltip: function(tooltip2) {
            tooltip2.close();
            return this;
          }
        });
        Layer2.include({
          // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
          // Binds a tooltip to the layer with the passed `content` and sets up the
          // necessary event listeners. If a `Function` is passed it will receive
          // the layer as the first argument and should return a `String` or `HTMLElement`.
          bindTooltip: function(content, options) {
            if (this._tooltip && this.isTooltipOpen()) {
              this.unbindTooltip();
            }
            this._tooltip = this._initOverlay(Tooltip2, this._tooltip, content, options);
            this._initTooltipInteractions();
            if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
              this.openTooltip();
            }
            return this;
          },
          // @method unbindTooltip(): this
          // Removes the tooltip previously bound with `bindTooltip`.
          unbindTooltip: function() {
            if (this._tooltip) {
              this._initTooltipInteractions(true);
              this.closeTooltip();
              this._tooltip = null;
            }
            return this;
          },
          _initTooltipInteractions: function(remove2) {
            if (!remove2 && this._tooltipHandlersAdded) {
              return;
            }
            var onOff = remove2 ? "off" : "on", events = {
              remove: this.closeTooltip,
              move: this._moveTooltip
            };
            if (!this._tooltip.options.permanent) {
              events.mouseover = this._openTooltip;
              events.mouseout = this.closeTooltip;
              events.click = this._openTooltip;
              if (this._map) {
                this._addFocusListeners();
              } else {
                events.add = this._addFocusListeners;
              }
            } else {
              events.add = this._openTooltip;
            }
            if (this._tooltip.options.sticky) {
              events.mousemove = this._moveTooltip;
            }
            this[onOff](events);
            this._tooltipHandlersAdded = !remove2;
          },
          // @method openTooltip(latlng?: LatLng): this
          // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
          openTooltip: function(latlng) {
            if (this._tooltip) {
              if (!(this instanceof FeatureGroup)) {
                this._tooltip._source = this;
              }
              if (this._tooltip._prepareOpen(latlng)) {
                this._tooltip.openOn(this._map);
                if (this.getElement) {
                  this._setAriaDescribedByOnLayer(this);
                } else if (this.eachLayer) {
                  this.eachLayer(this._setAriaDescribedByOnLayer, this);
                }
              }
            }
            return this;
          },
          // @method closeTooltip(): this
          // Closes the tooltip bound to this layer if it is open.
          closeTooltip: function() {
            if (this._tooltip) {
              return this._tooltip.close();
            }
          },
          // @method toggleTooltip(): this
          // Opens or closes the tooltip bound to this layer depending on its current state.
          toggleTooltip: function() {
            if (this._tooltip) {
              this._tooltip.toggle(this);
            }
            return this;
          },
          // @method isTooltipOpen(): boolean
          // Returns `true` if the tooltip bound to this layer is currently open.
          isTooltipOpen: function() {
            return this._tooltip.isOpen();
          },
          // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
          // Sets the content of the tooltip bound to this layer.
          setTooltipContent: function(content) {
            if (this._tooltip) {
              this._tooltip.setContent(content);
            }
            return this;
          },
          // @method getTooltip(): Tooltip
          // Returns the tooltip bound to this layer.
          getTooltip: function() {
            return this._tooltip;
          },
          _addFocusListeners: function() {
            if (this.getElement) {
              this._addFocusListenersOnLayer(this);
            } else if (this.eachLayer) {
              this.eachLayer(this._addFocusListenersOnLayer, this);
            }
          },
          _addFocusListenersOnLayer: function(layer) {
            var el2 = typeof layer.getElement === "function" && layer.getElement();
            if (el2) {
              on(el2, "focus", function() {
                this._tooltip._source = layer;
                this.openTooltip();
              }, this);
              on(el2, "blur", this.closeTooltip, this);
            }
          },
          _setAriaDescribedByOnLayer: function(layer) {
            var el2 = typeof layer.getElement === "function" && layer.getElement();
            if (el2) {
              el2.setAttribute("aria-describedby", this._tooltip._container.id);
            }
          },
          _openTooltip: function(e) {
            if (!this._tooltip || !this._map) {
              return;
            }
            if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
              this._openOnceFlag = true;
              var that = this;
              this._map.once("moveend", function() {
                that._openOnceFlag = false;
                that._openTooltip(e);
              });
              return;
            }
            this._tooltip._source = e.layer || e.target;
            this.openTooltip(this._tooltip.options.sticky ? e.latlng : void 0);
          },
          _moveTooltip: function(e) {
            var latlng = e.latlng, containerPoint, layerPoint;
            if (this._tooltip.options.sticky && e.originalEvent) {
              containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
              layerPoint = this._map.containerPointToLayerPoint(containerPoint);
              latlng = this._map.layerPointToLatLng(layerPoint);
            }
            this._tooltip.setLatLng(latlng);
          }
        });
        var DivIcon = Icon2.extend({
          options: {
            // @section
            // @aka DivIcon options
            iconSize: [12, 12],
            // also can be set through CSS
            // iconAnchor: (Point),
            // popupAnchor: (Point),
            // @option html: String|HTMLElement = ''
            // Custom HTML code to put inside the div element, empty by default. Alternatively,
            // an instance of `HTMLElement`.
            html: false,
            // @option bgPos: Point = [0, 0]
            // Optional relative position of the background, in pixels
            bgPos: null,
            className: "leaflet-div-icon"
          },
          createIcon: function(oldIcon) {
            var div = oldIcon && oldIcon.tagName === "DIV" ? oldIcon : document.createElement("div"), options = this.options;
            if (options.html instanceof Element) {
              empty(div);
              div.appendChild(options.html);
            } else {
              div.innerHTML = options.html !== false ? options.html : "";
            }
            if (options.bgPos) {
              var bgPos = toPoint(options.bgPos);
              div.style.backgroundPosition = -bgPos.x + "px " + -bgPos.y + "px";
            }
            this._setIconStyles(div, "icon");
            return div;
          },
          createShadow: function() {
            return null;
          }
        });
        function divIcon(options) {
          return new DivIcon(options);
        }
        Icon2.Default = IconDefault;
        var GridLayer = Layer2.extend({
          // @section
          // @aka GridLayer options
          options: {
            // @option tileSize: Number|Point = 256
            // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
            tileSize: 256,
            // @option opacity: Number = 1.0
            // Opacity of the tiles. Can be used in the `createTile()` function.
            opacity: 1,
            // @option updateWhenIdle: Boolean = (depends)
            // Load new tiles only when panning ends.
            // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
            // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
            // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
            updateWhenIdle: Browser.mobile,
            // @option updateWhenZooming: Boolean = true
            // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
            updateWhenZooming: true,
            // @option updateInterval: Number = 200
            // Tiles will not update more than once every `updateInterval` milliseconds when panning.
            updateInterval: 200,
            // @option zIndex: Number = 1
            // The explicit zIndex of the tile layer.
            zIndex: 1,
            // @option bounds: LatLngBounds = undefined
            // If set, tiles will only be loaded inside the set `LatLngBounds`.
            bounds: null,
            // @option minZoom: Number = 0
            // The minimum zoom level down to which this layer will be displayed (inclusive).
            minZoom: 0,
            // @option maxZoom: Number = undefined
            // The maximum zoom level up to which this layer will be displayed (inclusive).
            maxZoom: void 0,
            // @option maxNativeZoom: Number = undefined
            // Maximum zoom number the tile source has available. If it is specified,
            // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
            // from `maxNativeZoom` level and auto-scaled.
            maxNativeZoom: void 0,
            // @option minNativeZoom: Number = undefined
            // Minimum zoom number the tile source has available. If it is specified,
            // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
            // from `minNativeZoom` level and auto-scaled.
            minNativeZoom: void 0,
            // @option noWrap: Boolean = false
            // Whether the layer is wrapped around the antimeridian. If `true`, the
            // GridLayer will only be displayed once at low zoom levels. Has no
            // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
            // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
            // tiles outside the CRS limits.
            noWrap: false,
            // @option pane: String = 'tilePane'
            // `Map pane` where the grid layer will be added.
            pane: "tilePane",
            // @option className: String = ''
            // A custom class name to assign to the tile layer. Empty by default.
            className: "",
            // @option keepBuffer: Number = 2
            // When panning the map, keep this many rows and columns of tiles before unloading them.
            keepBuffer: 2
          },
          initialize: function(options) {
            setOptions(this, options);
          },
          onAdd: function() {
            this._initContainer();
            this._levels = {};
            this._tiles = {};
            this._resetView();
          },
          beforeAdd: function(map2) {
            map2._addZoomLimit(this);
          },
          onRemove: function(map2) {
            this._removeAllTiles();
            remove(this._container);
            map2._removeZoomLimit(this);
            this._container = null;
            this._tileZoom = void 0;
          },
          // @method bringToFront: this
          // Brings the tile layer to the top of all tile layers.
          bringToFront: function() {
            if (this._map) {
              toFront(this._container);
              this._setAutoZIndex(Math.max);
            }
            return this;
          },
          // @method bringToBack: this
          // Brings the tile layer to the bottom of all tile layers.
          bringToBack: function() {
            if (this._map) {
              toBack(this._container);
              this._setAutoZIndex(Math.min);
            }
            return this;
          },
          // @method getContainer: HTMLElement
          // Returns the HTML element that contains the tiles for this layer.
          getContainer: function() {
            return this._container;
          },
          // @method setOpacity(opacity: Number): this
          // Changes the [opacity](#gridlayer-opacity) of the grid layer.
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            this._updateOpacity();
            return this;
          },
          // @method setZIndex(zIndex: Number): this
          // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
          setZIndex: function(zIndex) {
            this.options.zIndex = zIndex;
            this._updateZIndex();
            return this;
          },
          // @method isLoading: Boolean
          // Returns `true` if any tile in the grid layer has not finished loading.
          isLoading: function() {
            return this._loading;
          },
          // @method redraw: this
          // Causes the layer to clear all the tiles and request them again.
          redraw: function() {
            if (this._map) {
              this._removeAllTiles();
              var tileZoom = this._clampZoom(this._map.getZoom());
              if (tileZoom !== this._tileZoom) {
                this._tileZoom = tileZoom;
                this._updateLevels();
              }
              this._update();
            }
            return this;
          },
          getEvents: function() {
            var events = {
              viewprereset: this._invalidateAll,
              viewreset: this._resetView,
              zoom: this._resetView,
              moveend: this._onMoveEnd
            };
            if (!this.options.updateWhenIdle) {
              if (!this._onMove) {
                this._onMove = throttle2(this._onMoveEnd, this.options.updateInterval, this);
              }
              events.move = this._onMove;
            }
            if (this._zoomAnimated) {
              events.zoomanim = this._animateZoom;
            }
            return events;
          },
          // @section Extension methods
          // Layers extending `GridLayer` shall reimplement the following method.
          // @method createTile(coords: Object, done?: Function): HTMLElement
          // Called only internally, must be overridden by classes extending `GridLayer`.
          // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
          // is specified, it must be called when the tile has finished loading and drawing.
          createTile: function() {
            return document.createElement("div");
          },
          // @section
          // @method getTileSize: Point
          // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
          getTileSize: function() {
            var s2 = this.options.tileSize;
            return s2 instanceof Point ? s2 : new Point(s2, s2);
          },
          _updateZIndex: function() {
            if (this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
              this._container.style.zIndex = this.options.zIndex;
            }
          },
          _setAutoZIndex: function(compare) {
            var layers2 = this.getPane().children, edgeZIndex = -compare(-Infinity, Infinity);
            for (var i = 0, len = layers2.length, zIndex; i < len; i++) {
              zIndex = layers2[i].style.zIndex;
              if (layers2[i] !== this._container && zIndex) {
                edgeZIndex = compare(edgeZIndex, +zIndex);
              }
            }
            if (isFinite(edgeZIndex)) {
              this.options.zIndex = edgeZIndex + compare(-1, 1);
              this._updateZIndex();
            }
          },
          _updateOpacity: function() {
            if (!this._map) {
              return;
            }
            if (Browser.ielt9) {
              return;
            }
            setOpacity(this._container, this.options.opacity);
            var now = +/* @__PURE__ */ new Date(), nextFrame = false, willPrune = false;
            for (var key in this._tiles) {
              var tile = this._tiles[key];
              if (!tile.current || !tile.loaded) {
                continue;
              }
              var fade = Math.min(1, (now - tile.loaded) / 200);
              setOpacity(tile.el, fade);
              if (fade < 1) {
                nextFrame = true;
              } else {
                if (tile.active) {
                  willPrune = true;
                } else {
                  this._onOpaqueTile(tile);
                }
                tile.active = true;
              }
            }
            if (willPrune && !this._noPrune) {
              this._pruneTiles();
            }
            if (nextFrame) {
              cancelAnimFrame(this._fadeFrame);
              this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
            }
          },
          _onOpaqueTile: falseFn,
          _initContainer: function() {
            if (this._container) {
              return;
            }
            this._container = create$1("div", "leaflet-layer " + (this.options.className || ""));
            this._updateZIndex();
            if (this.options.opacity < 1) {
              this._updateOpacity();
            }
            this.getPane().appendChild(this._container);
          },
          _updateLevels: function() {
            var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom;
            if (zoom2 === void 0) {
              return void 0;
            }
            for (var z2 in this._levels) {
              z2 = Number(z2);
              if (this._levels[z2].el.children.length || z2 === zoom2) {
                this._levels[z2].el.style.zIndex = maxZoom - Math.abs(zoom2 - z2);
                this._onUpdateLevel(z2);
              } else {
                remove(this._levels[z2].el);
                this._removeTilesAtZoom(z2);
                this._onRemoveLevel(z2);
                delete this._levels[z2];
              }
            }
            var level = this._levels[zoom2], map2 = this._map;
            if (!level) {
              level = this._levels[zoom2] = {};
              level.el = create$1("div", "leaflet-tile-container leaflet-zoom-animated", this._container);
              level.el.style.zIndex = maxZoom;
              level.origin = map2.project(map2.unproject(map2.getPixelOrigin()), zoom2).round();
              level.zoom = zoom2;
              this._setZoomTransform(level, map2.getCenter(), map2.getZoom());
              falseFn(level.el.offsetWidth);
              this._onCreateLevel(level);
            }
            this._level = level;
            return level;
          },
          _onUpdateLevel: falseFn,
          _onRemoveLevel: falseFn,
          _onCreateLevel: falseFn,
          _pruneTiles: function() {
            if (!this._map) {
              return;
            }
            var key, tile;
            var zoom2 = this._map.getZoom();
            if (zoom2 > this.options.maxZoom || zoom2 < this.options.minZoom) {
              this._removeAllTiles();
              return;
            }
            for (key in this._tiles) {
              tile = this._tiles[key];
              tile.retain = tile.current;
            }
            for (key in this._tiles) {
              tile = this._tiles[key];
              if (tile.current && !tile.active) {
                var coords = tile.coords;
                if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
                  this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
                }
              }
            }
            for (key in this._tiles) {
              if (!this._tiles[key].retain) {
                this._removeTile(key);
              }
            }
          },
          _removeTilesAtZoom: function(zoom2) {
            for (var key in this._tiles) {
              if (this._tiles[key].coords.z !== zoom2) {
                continue;
              }
              this._removeTile(key);
            }
          },
          _removeAllTiles: function() {
            for (var key in this._tiles) {
              this._removeTile(key);
            }
          },
          _invalidateAll: function() {
            for (var z2 in this._levels) {
              remove(this._levels[z2].el);
              this._onRemoveLevel(Number(z2));
              delete this._levels[z2];
            }
            this._removeAllTiles();
            this._tileZoom = void 0;
          },
          _retainParent: function(x2, y2, z2, minZoom) {
            var x22 = Math.floor(x2 / 2), y22 = Math.floor(y2 / 2), z22 = z2 - 1, coords2 = new Point(+x22, +y22);
            coords2.z = +z22;
            var key = this._tileCoordsToKey(coords2), tile = this._tiles[key];
            if (tile && tile.active) {
              tile.retain = true;
              return true;
            } else if (tile && tile.loaded) {
              tile.retain = true;
            }
            if (z22 > minZoom) {
              return this._retainParent(x22, y22, z22, minZoom);
            }
            return false;
          },
          _retainChildren: function(x2, y2, z2, maxZoom) {
            for (var i = 2 * x2; i < 2 * x2 + 2; i++) {
              for (var j = 2 * y2; j < 2 * y2 + 2; j++) {
                var coords = new Point(i, j);
                coords.z = z2 + 1;
                var key = this._tileCoordsToKey(coords), tile = this._tiles[key];
                if (tile && tile.active) {
                  tile.retain = true;
                  continue;
                } else if (tile && tile.loaded) {
                  tile.retain = true;
                }
                if (z2 + 1 < maxZoom) {
                  this._retainChildren(i, j, z2 + 1, maxZoom);
                }
              }
            }
          },
          _resetView: function(e) {
            var animating = e && (e.pinch || e.flyTo);
            this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
          },
          _animateZoom: function(e) {
            this._setView(e.center, e.zoom, true, e.noUpdate);
          },
          _clampZoom: function(zoom2) {
            var options = this.options;
            if (void 0 !== options.minNativeZoom && zoom2 < options.minNativeZoom) {
              return options.minNativeZoom;
            }
            if (void 0 !== options.maxNativeZoom && options.maxNativeZoom < zoom2) {
              return options.maxNativeZoom;
            }
            return zoom2;
          },
          _setView: function(center, zoom2, noPrune, noUpdate) {
            var tileZoom = Math.round(zoom2);
            if (this.options.maxZoom !== void 0 && tileZoom > this.options.maxZoom || this.options.minZoom !== void 0 && tileZoom < this.options.minZoom) {
              tileZoom = void 0;
            } else {
              tileZoom = this._clampZoom(tileZoom);
            }
            var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
            if (!noUpdate || tileZoomChanged) {
              this._tileZoom = tileZoom;
              if (this._abortLoading) {
                this._abortLoading();
              }
              this._updateLevels();
              this._resetGrid();
              if (tileZoom !== void 0) {
                this._update(center);
              }
              if (!noPrune) {
                this._pruneTiles();
              }
              this._noPrune = !!noPrune;
            }
            this._setZoomTransforms(center, zoom2);
          },
          _setZoomTransforms: function(center, zoom2) {
            for (var i in this._levels) {
              this._setZoomTransform(this._levels[i], center, zoom2);
            }
          },
          _setZoomTransform: function(level, center, zoom2) {
            var scale2 = this._map.getZoomScale(zoom2, level.zoom), translate = level.origin.multiplyBy(scale2).subtract(this._map._getNewPixelOrigin(center, zoom2)).round();
            if (Browser.any3d) {
              setTransform(level.el, translate, scale2);
            } else {
              setPosition(level.el, translate);
            }
          },
          _resetGrid: function() {
            var map2 = this._map, crs = map2.options.crs, tileSize = this._tileSize = this.getTileSize(), tileZoom = this._tileZoom;
            var bounds = this._map.getPixelWorldBounds(this._tileZoom);
            if (bounds) {
              this._globalTileRange = this._pxBoundsToTileRange(bounds);
            }
            this._wrapX = crs.wrapLng && !this.options.noWrap && [
              Math.floor(map2.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
              Math.ceil(map2.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
            ];
            this._wrapY = crs.wrapLat && !this.options.noWrap && [
              Math.floor(map2.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
              Math.ceil(map2.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
            ];
          },
          _onMoveEnd: function() {
            if (!this._map || this._map._animatingZoom) {
              return;
            }
            this._update();
          },
          _getTiledPixelBounds: function(center) {
            var map2 = this._map, mapZoom = map2._animatingZoom ? Math.max(map2._animateToZoom, map2.getZoom()) : map2.getZoom(), scale2 = map2.getZoomScale(mapZoom, this._tileZoom), pixelCenter = map2.project(center, this._tileZoom).floor(), halfSize = map2.getSize().divideBy(scale2 * 2);
            return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
          },
          // Private method to load tiles in the grid's active zoom level according to map bounds
          _update: function(center) {
            var map2 = this._map;
            if (!map2) {
              return;
            }
            var zoom2 = this._clampZoom(map2.getZoom());
            if (center === void 0) {
              center = map2.getCenter();
            }
            if (this._tileZoom === void 0) {
              return;
            }
            var pixelBounds = this._getTiledPixelBounds(center), tileRange = this._pxBoundsToTileRange(pixelBounds), tileCenter = tileRange.getCenter(), queue = [], margin = this.options.keepBuffer, noPruneRange = new Bounds(
              tileRange.getBottomLeft().subtract([margin, -margin]),
              tileRange.getTopRight().add([margin, -margin])
            );
            if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
              throw new Error("Attempted to load an infinite number of tiles");
            }
            for (var key in this._tiles) {
              var c2 = this._tiles[key].coords;
              if (c2.z !== this._tileZoom || !noPruneRange.contains(new Point(c2.x, c2.y))) {
                this._tiles[key].current = false;
              }
            }
            if (Math.abs(zoom2 - this._tileZoom) > 1) {
              this._setView(center, zoom2);
              return;
            }
            for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
              for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
                var coords = new Point(i, j);
                coords.z = this._tileZoom;
                if (!this._isValidTile(coords)) {
                  continue;
                }
                var tile = this._tiles[this._tileCoordsToKey(coords)];
                if (tile) {
                  tile.current = true;
                } else {
                  queue.push(coords);
                }
              }
            }
            queue.sort(function(a2, b) {
              return a2.distanceTo(tileCenter) - b.distanceTo(tileCenter);
            });
            if (queue.length !== 0) {
              if (!this._loading) {
                this._loading = true;
                this.fire("loading");
              }
              var fragment = document.createDocumentFragment();
              for (i = 0; i < queue.length; i++) {
                this._addTile(queue[i], fragment);
              }
              this._level.el.appendChild(fragment);
            }
          },
          _isValidTile: function(coords) {
            var crs = this._map.options.crs;
            if (!crs.infinite) {
              var bounds = this._globalTileRange;
              if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
                return false;
              }
            }
            if (!this.options.bounds) {
              return true;
            }
            var tileBounds = this._tileCoordsToBounds(coords);
            return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
          },
          _keyToBounds: function(key) {
            return this._tileCoordsToBounds(this._keyToTileCoords(key));
          },
          _tileCoordsToNwSe: function(coords) {
            var map2 = this._map, tileSize = this.getTileSize(), nwPoint = coords.scaleBy(tileSize), sePoint = nwPoint.add(tileSize), nw = map2.unproject(nwPoint, coords.z), se2 = map2.unproject(sePoint, coords.z);
            return [nw, se2];
          },
          // converts tile coordinates to its geographical bounds
          _tileCoordsToBounds: function(coords) {
            var bp = this._tileCoordsToNwSe(coords), bounds = new LatLngBounds(bp[0], bp[1]);
            if (!this.options.noWrap) {
              bounds = this._map.wrapLatLngBounds(bounds);
            }
            return bounds;
          },
          // converts tile coordinates to key for the tile cache
          _tileCoordsToKey: function(coords) {
            return coords.x + ":" + coords.y + ":" + coords.z;
          },
          // converts tile cache key to coordinates
          _keyToTileCoords: function(key) {
            var k2 = key.split(":"), coords = new Point(+k2[0], +k2[1]);
            coords.z = +k2[2];
            return coords;
          },
          _removeTile: function(key) {
            var tile = this._tiles[key];
            if (!tile) {
              return;
            }
            remove(tile.el);
            delete this._tiles[key];
            this.fire("tileunload", {
              tile: tile.el,
              coords: this._keyToTileCoords(key)
            });
          },
          _initTile: function(tile) {
            addClass(tile, "leaflet-tile");
            var tileSize = this.getTileSize();
            tile.style.width = tileSize.x + "px";
            tile.style.height = tileSize.y + "px";
            tile.onselectstart = falseFn;
            tile.onmousemove = falseFn;
            if (Browser.ielt9 && this.options.opacity < 1) {
              setOpacity(tile, this.options.opacity);
            }
          },
          _addTile: function(coords, container) {
            var tilePos = this._getTilePos(coords), key = this._tileCoordsToKey(coords);
            var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));
            this._initTile(tile);
            if (this.createTile.length < 2) {
              requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
            }
            setPosition(tile, tilePos);
            this._tiles[key] = {
              el: tile,
              coords,
              current: true
            };
            container.appendChild(tile);
            this.fire("tileloadstart", {
              tile,
              coords
            });
          },
          _tileReady: function(coords, err, tile) {
            if (err) {
              this.fire("tileerror", {
                error: err,
                tile,
                coords
              });
            }
            var key = this._tileCoordsToKey(coords);
            tile = this._tiles[key];
            if (!tile) {
              return;
            }
            tile.loaded = +/* @__PURE__ */ new Date();
            if (this._map._fadeAnimated) {
              setOpacity(tile.el, 0);
              cancelAnimFrame(this._fadeFrame);
              this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
            } else {
              tile.active = true;
              this._pruneTiles();
            }
            if (!err) {
              addClass(tile.el, "leaflet-tile-loaded");
              this.fire("tileload", {
                tile: tile.el,
                coords
              });
            }
            if (this._noTilesToLoad()) {
              this._loading = false;
              this.fire("load");
              if (Browser.ielt9 || !this._map._fadeAnimated) {
                requestAnimFrame(this._pruneTiles, this);
              } else {
                setTimeout(bind(this._pruneTiles, this), 250);
              }
            }
          },
          _getTilePos: function(coords) {
            return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
          },
          _wrapCoords: function(coords) {
            var newCoords = new Point(
              this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
              this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y
            );
            newCoords.z = coords.z;
            return newCoords;
          },
          _pxBoundsToTileRange: function(bounds) {
            var tileSize = this.getTileSize();
            return new Bounds(
              bounds.min.unscaleBy(tileSize).floor(),
              bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1])
            );
          },
          _noTilesToLoad: function() {
            for (var key in this._tiles) {
              if (!this._tiles[key].loaded) {
                return false;
              }
            }
            return true;
          }
        });
        function gridLayer(options) {
          return new GridLayer(options);
        }
        var TileLayer2 = GridLayer.extend({
          // @section
          // @aka TileLayer options
          options: {
            // @option minZoom: Number = 0
            // The minimum zoom level down to which this layer will be displayed (inclusive).
            minZoom: 0,
            // @option maxZoom: Number = 18
            // The maximum zoom level up to which this layer will be displayed (inclusive).
            maxZoom: 18,
            // @option subdomains: String|String[] = 'abc'
            // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
            subdomains: "abc",
            // @option errorTileUrl: String = ''
            // URL to the tile image to show in place of the tile that failed to load.
            errorTileUrl: "",
            // @option zoomOffset: Number = 0
            // The zoom number used in tile URLs will be offset with this value.
            zoomOffset: 0,
            // @option tms: Boolean = false
            // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
            tms: false,
            // @option zoomReverse: Boolean = false
            // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
            zoomReverse: false,
            // @option detectRetina: Boolean = false
            // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
            detectRetina: false,
            // @option crossOrigin: Boolean|String = false
            // Whether the crossOrigin attribute will be added to the tiles.
            // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
            // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
            crossOrigin: false,
            // @option referrerPolicy: Boolean|String = false
            // Whether the referrerPolicy attribute will be added to the tiles.
            // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.
            // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer
            // (e.g. to validate an API token).
            // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.
            referrerPolicy: false
          },
          initialize: function(url, options) {
            this._url = url;
            options = setOptions(this, options);
            if (options.detectRetina && Browser.retina && options.maxZoom > 0) {
              options.tileSize = Math.floor(options.tileSize / 2);
              if (!options.zoomReverse) {
                options.zoomOffset++;
                options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);
              } else {
                options.zoomOffset--;
                options.minZoom = Math.min(options.maxZoom, options.minZoom + 1);
              }
              options.minZoom = Math.max(0, options.minZoom);
            } else if (!options.zoomReverse) {
              options.maxZoom = Math.max(options.minZoom, options.maxZoom);
            } else {
              options.minZoom = Math.min(options.maxZoom, options.minZoom);
            }
            if (typeof options.subdomains === "string") {
              options.subdomains = options.subdomains.split("");
            }
            this.on("tileunload", this._onTileRemove);
          },
          // @method setUrl(url: String, noRedraw?: Boolean): this
          // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
          // If the URL does not change, the layer will not be redrawn unless
          // the noRedraw parameter is set to false.
          setUrl: function(url, noRedraw) {
            if (this._url === url && noRedraw === void 0) {
              noRedraw = true;
            }
            this._url = url;
            if (!noRedraw) {
              this.redraw();
            }
            return this;
          },
          // @method createTile(coords: Object, done?: Function): HTMLElement
          // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
          // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
          // callback is called when the tile has been loaded.
          createTile: function(coords, done) {
            var tile = document.createElement("img");
            on(tile, "load", bind(this._tileOnLoad, this, done, tile));
            on(tile, "error", bind(this._tileOnError, this, done, tile));
            if (this.options.crossOrigin || this.options.crossOrigin === "") {
              tile.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
            }
            if (typeof this.options.referrerPolicy === "string") {
              tile.referrerPolicy = this.options.referrerPolicy;
            }
            tile.alt = "";
            tile.src = this.getTileUrl(coords);
            return tile;
          },
          // @section Extension methods
          // @uninheritable
          // Layers extending `TileLayer` might reimplement the following method.
          // @method getTileUrl(coords: Object): String
          // Called only internally, returns the URL for a tile given its coordinates.
          // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
          getTileUrl: function(coords) {
            var data = {
              r: Browser.retina ? "@2x" : "",
              s: this._getSubdomain(coords),
              x: coords.x,
              y: coords.y,
              z: this._getZoomForUrl()
            };
            if (this._map && !this._map.options.crs.infinite) {
              var invertedY = this._globalTileRange.max.y - coords.y;
              if (this.options.tms) {
                data["y"] = invertedY;
              }
              data["-y"] = invertedY;
            }
            return template(this._url, extend2(data, this.options));
          },
          _tileOnLoad: function(done, tile) {
            if (Browser.ielt9) {
              setTimeout(bind(done, this, null, tile), 0);
            } else {
              done(null, tile);
            }
          },
          _tileOnError: function(done, tile, e) {
            var errorUrl = this.options.errorTileUrl;
            if (errorUrl && tile.getAttribute("src") !== errorUrl) {
              tile.src = errorUrl;
            }
            done(e, tile);
          },
          _onTileRemove: function(e) {
            e.tile.onload = null;
          },
          _getZoomForUrl: function() {
            var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom, zoomReverse = this.options.zoomReverse, zoomOffset = this.options.zoomOffset;
            if (zoomReverse) {
              zoom2 = maxZoom - zoom2;
            }
            return zoom2 + zoomOffset;
          },
          _getSubdomain: function(tilePoint) {
            var index2 = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
            return this.options.subdomains[index2];
          },
          // stops loading all tiles in the background layer
          _abortLoading: function() {
            var i, tile;
            for (i in this._tiles) {
              if (this._tiles[i].coords.z !== this._tileZoom) {
                tile = this._tiles[i].el;
                tile.onload = falseFn;
                tile.onerror = falseFn;
                if (!tile.complete) {
                  tile.src = emptyImageUrl;
                  var coords = this._tiles[i].coords;
                  remove(tile);
                  delete this._tiles[i];
                  this.fire("tileabort", {
                    tile,
                    coords
                  });
                }
              }
            }
          },
          _removeTile: function(key) {
            var tile = this._tiles[key];
            if (!tile) {
              return;
            }
            tile.el.setAttribute("src", emptyImageUrl);
            return GridLayer.prototype._removeTile.call(this, key);
          },
          _tileReady: function(coords, err, tile) {
            if (!this._map || tile && tile.getAttribute("src") === emptyImageUrl) {
              return;
            }
            return GridLayer.prototype._tileReady.call(this, coords, err, tile);
          }
        });
        function tileLayer(url, options) {
          return new TileLayer2(url, options);
        }
        var TileLayerWMS = TileLayer2.extend({
          // @section
          // @aka TileLayer.WMS options
          // If any custom options not documented here are used, they will be sent to the
          // WMS server as extra parameters in each request URL. This can be useful for
          // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
          defaultWmsParams: {
            service: "WMS",
            request: "GetMap",
            // @option layers: String = ''
            // **(required)** Comma-separated list of WMS layers to show.
            layers: "",
            // @option styles: String = ''
            // Comma-separated list of WMS styles.
            styles: "",
            // @option format: String = 'image/jpeg'
            // WMS image format (use `'image/png'` for layers with transparency).
            format: "image/jpeg",
            // @option transparent: Boolean = false
            // If `true`, the WMS service will return images with transparency.
            transparent: false,
            // @option version: String = '1.1.1'
            // Version of the WMS service to use
            version: "1.1.1"
          },
          options: {
            // @option crs: CRS = null
            // Coordinate Reference System to use for the WMS requests, defaults to
            // map CRS. Don't change this if you're not sure what it means.
            crs: null,
            // @option uppercase: Boolean = false
            // If `true`, WMS request parameter keys will be uppercase.
            uppercase: false
          },
          initialize: function(url, options) {
            this._url = url;
            var wmsParams = extend2({}, this.defaultWmsParams);
            for (var i in options) {
              if (!(i in this.options)) {
                wmsParams[i] = options[i];
              }
            }
            options = setOptions(this, options);
            var realRetina = options.detectRetina && Browser.retina ? 2 : 1;
            var tileSize = this.getTileSize();
            wmsParams.width = tileSize.x * realRetina;
            wmsParams.height = tileSize.y * realRetina;
            this.wmsParams = wmsParams;
          },
          onAdd: function(map2) {
            this._crs = this.options.crs || map2.options.crs;
            this._wmsVersion = parseFloat(this.wmsParams.version);
            var projectionKey = this._wmsVersion >= 1.3 ? "crs" : "srs";
            this.wmsParams[projectionKey] = this._crs.code;
            TileLayer2.prototype.onAdd.call(this, map2);
          },
          getTileUrl: function(coords) {
            var tileBounds = this._tileCoordsToNwSe(coords), crs = this._crs, bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])), min2 = bounds.min, max2 = bounds.max, bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min2.y, min2.x, max2.y, max2.x] : [min2.x, min2.y, max2.x, max2.y]).join(","), url = TileLayer2.prototype.getTileUrl.call(this, coords);
            return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + bbox;
          },
          // @method setParams(params: Object, noRedraw?: Boolean): this
          // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
          setParams: function(params, noRedraw) {
            extend2(this.wmsParams, params);
            if (!noRedraw) {
              this.redraw();
            }
            return this;
          }
        });
        function tileLayerWMS(url, options) {
          return new TileLayerWMS(url, options);
        }
        TileLayer2.WMS = TileLayerWMS;
        tileLayer.wms = tileLayerWMS;
        var Renderer = Layer2.extend({
          // @section
          // @aka Renderer options
          options: {
            // @option padding: Number = 0.1
            // How much to extend the clip area around the map view (relative to its size)
            // e.g. 0.1 would be 10% of map view in each direction
            padding: 0.1
          },
          initialize: function(options) {
            setOptions(this, options);
            stamp(this);
            this._layers = this._layers || {};
          },
          onAdd: function() {
            if (!this._container) {
              this._initContainer();
              addClass(this._container, "leaflet-zoom-animated");
            }
            this.getPane().appendChild(this._container);
            this._update();
            this.on("update", this._updatePaths, this);
          },
          onRemove: function() {
            this.off("update", this._updatePaths, this);
            this._destroyContainer();
          },
          getEvents: function() {
            var events = {
              viewreset: this._reset,
              zoom: this._onZoom,
              moveend: this._update,
              zoomend: this._onZoomEnd
            };
            if (this._zoomAnimated) {
              events.zoomanim = this._onAnimZoom;
            }
            return events;
          },
          _onAnimZoom: function(ev) {
            this._updateTransform(ev.center, ev.zoom);
          },
          _onZoom: function() {
            this._updateTransform(this._map.getCenter(), this._map.getZoom());
          },
          _updateTransform: function(center, zoom2) {
            var scale2 = this._map.getZoomScale(zoom2, this._zoom), viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding), currentCenterPoint = this._map.project(this._center, zoom2), topLeftOffset = viewHalf.multiplyBy(-scale2).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center, zoom2));
            if (Browser.any3d) {
              setTransform(this._container, topLeftOffset, scale2);
            } else {
              setPosition(this._container, topLeftOffset);
            }
          },
          _reset: function() {
            this._update();
            this._updateTransform(this._center, this._zoom);
            for (var id2 in this._layers) {
              this._layers[id2]._reset();
            }
          },
          _onZoomEnd: function() {
            for (var id2 in this._layers) {
              this._layers[id2]._project();
            }
          },
          _updatePaths: function() {
            for (var id2 in this._layers) {
              this._layers[id2]._update();
            }
          },
          _update: function() {
            var p2 = this.options.padding, size = this._map.getSize(), min2 = this._map.containerPointToLayerPoint(size.multiplyBy(-p2)).round();
            this._bounds = new Bounds(min2, min2.add(size.multiplyBy(1 + p2 * 2)).round());
            this._center = this._map.getCenter();
            this._zoom = this._map.getZoom();
          }
        });
        var Canvas = Renderer.extend({
          // @section
          // @aka Canvas options
          options: {
            // @option tolerance: Number = 0
            // How much to extend the click tolerance around a path/object on the map.
            tolerance: 0
          },
          getEvents: function() {
            var events = Renderer.prototype.getEvents.call(this);
            events.viewprereset = this._onViewPreReset;
            return events;
          },
          _onViewPreReset: function() {
            this._postponeUpdatePaths = true;
          },
          onAdd: function() {
            Renderer.prototype.onAdd.call(this);
            this._draw();
          },
          _initContainer: function() {
            var container = this._container = document.createElement("canvas");
            on(container, "mousemove", this._onMouseMove, this);
            on(container, "click dblclick mousedown mouseup contextmenu", this._onClick, this);
            on(container, "mouseout", this._handleMouseOut, this);
            container["_leaflet_disable_events"] = true;
            this._ctx = container.getContext("2d");
          },
          _destroyContainer: function() {
            cancelAnimFrame(this._redrawRequest);
            delete this._ctx;
            remove(this._container);
            off(this._container);
            delete this._container;
          },
          _updatePaths: function() {
            if (this._postponeUpdatePaths) {
              return;
            }
            var layer;
            this._redrawBounds = null;
            for (var id2 in this._layers) {
              layer = this._layers[id2];
              layer._update();
            }
            this._redraw();
          },
          _update: function() {
            if (this._map._animatingZoom && this._bounds) {
              return;
            }
            Renderer.prototype._update.call(this);
            var b = this._bounds, container = this._container, size = b.getSize(), m2 = Browser.retina ? 2 : 1;
            setPosition(container, b.min);
            container.width = m2 * size.x;
            container.height = m2 * size.y;
            container.style.width = size.x + "px";
            container.style.height = size.y + "px";
            if (Browser.retina) {
              this._ctx.scale(2, 2);
            }
            this._ctx.translate(-b.min.x, -b.min.y);
            this.fire("update");
          },
          _reset: function() {
            Renderer.prototype._reset.call(this);
            if (this._postponeUpdatePaths) {
              this._postponeUpdatePaths = false;
              this._updatePaths();
            }
          },
          _initPath: function(layer) {
            this._updateDashArray(layer);
            this._layers[stamp(layer)] = layer;
            var order = layer._order = {
              layer,
              prev: this._drawLast,
              next: null
            };
            if (this._drawLast) {
              this._drawLast.next = order;
            }
            this._drawLast = order;
            this._drawFirst = this._drawFirst || this._drawLast;
          },
          _addPath: function(layer) {
            this._requestRedraw(layer);
          },
          _removePath: function(layer) {
            var order = layer._order;
            var next = order.next;
            var prev = order.prev;
            if (next) {
              next.prev = prev;
            } else {
              this._drawLast = prev;
            }
            if (prev) {
              prev.next = next;
            } else {
              this._drawFirst = next;
            }
            delete layer._order;
            delete this._layers[stamp(layer)];
            this._requestRedraw(layer);
          },
          _updatePath: function(layer) {
            this._extendRedrawBounds(layer);
            layer._project();
            layer._update();
            this._requestRedraw(layer);
          },
          _updateStyle: function(layer) {
            this._updateDashArray(layer);
            this._requestRedraw(layer);
          },
          _updateDashArray: function(layer) {
            if (typeof layer.options.dashArray === "string") {
              var parts = layer.options.dashArray.split(/[, ]+/), dashArray = [], dashValue, i;
              for (i = 0; i < parts.length; i++) {
                dashValue = Number(parts[i]);
                if (isNaN(dashValue)) {
                  return;
                }
                dashArray.push(dashValue);
              }
              layer.options._dashArray = dashArray;
            } else {
              layer.options._dashArray = layer.options.dashArray;
            }
          },
          _requestRedraw: function(layer) {
            if (!this._map) {
              return;
            }
            this._extendRedrawBounds(layer);
            this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
          },
          _extendRedrawBounds: function(layer) {
            if (layer._pxBounds) {
              var padding = (layer.options.weight || 0) + 1;
              this._redrawBounds = this._redrawBounds || new Bounds();
              this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
              this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
            }
          },
          _redraw: function() {
            this._redrawRequest = null;
            if (this._redrawBounds) {
              this._redrawBounds.min._floor();
              this._redrawBounds.max._ceil();
            }
            this._clear();
            this._draw();
            this._redrawBounds = null;
          },
          _clear: function() {
            var bounds = this._redrawBounds;
            if (bounds) {
              var size = bounds.getSize();
              this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
            } else {
              this._ctx.save();
              this._ctx.setTransform(1, 0, 0, 1, 0, 0);
              this._ctx.clearRect(0, 0, this._container.width, this._container.height);
              this._ctx.restore();
            }
          },
          _draw: function() {
            var layer, bounds = this._redrawBounds;
            this._ctx.save();
            if (bounds) {
              var size = bounds.getSize();
              this._ctx.beginPath();
              this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
              this._ctx.clip();
            }
            this._drawing = true;
            for (var order = this._drawFirst; order; order = order.next) {
              layer = order.layer;
              if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {
                layer._updatePath();
              }
            }
            this._drawing = false;
            this._ctx.restore();
          },
          _updatePoly: function(layer, closed) {
            if (!this._drawing) {
              return;
            }
            var i, j, len2, p2, parts = layer._parts, len = parts.length, ctx = this._ctx;
            if (!len) {
              return;
            }
            ctx.beginPath();
            for (i = 0; i < len; i++) {
              for (j = 0, len2 = parts[i].length; j < len2; j++) {
                p2 = parts[i][j];
                ctx[j ? "lineTo" : "moveTo"](p2.x, p2.y);
              }
              if (closed) {
                ctx.closePath();
              }
            }
            this._fillStroke(ctx, layer);
          },
          _updateCircle: function(layer) {
            if (!this._drawing || layer._empty()) {
              return;
            }
            var p2 = layer._point, ctx = this._ctx, r2 = Math.max(Math.round(layer._radius), 1), s2 = (Math.max(Math.round(layer._radiusY), 1) || r2) / r2;
            if (s2 !== 1) {
              ctx.save();
              ctx.scale(1, s2);
            }
            ctx.beginPath();
            ctx.arc(p2.x, p2.y / s2, r2, 0, Math.PI * 2, false);
            if (s2 !== 1) {
              ctx.restore();
            }
            this._fillStroke(ctx, layer);
          },
          _fillStroke: function(ctx, layer) {
            var options = layer.options;
            if (options.fill) {
              ctx.globalAlpha = options.fillOpacity;
              ctx.fillStyle = options.fillColor || options.color;
              ctx.fill(options.fillRule || "evenodd");
            }
            if (options.stroke && options.weight !== 0) {
              if (ctx.setLineDash) {
                ctx.setLineDash(layer.options && layer.options._dashArray || []);
              }
              ctx.globalAlpha = options.opacity;
              ctx.lineWidth = options.weight;
              ctx.strokeStyle = options.color;
              ctx.lineCap = options.lineCap;
              ctx.lineJoin = options.lineJoin;
              ctx.stroke();
            }
          },
          // Canvas obviously doesn't have mouse events for individual drawn objects,
          // so we emulate that by calculating what's under the mouse on mousemove/click manually
          _onClick: function(e) {
            var point2 = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;
            for (var order = this._drawFirst; order; order = order.next) {
              layer = order.layer;
              if (layer.options.interactive && layer._containsPoint(point2)) {
                if (!(e.type === "click" || e.type === "preclick") || !this._map._draggableMoved(layer)) {
                  clickedLayer = layer;
                }
              }
            }
            this._fireEvent(clickedLayer ? [clickedLayer] : false, e);
          },
          _onMouseMove: function(e) {
            if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
              return;
            }
            var point2 = this._map.mouseEventToLayerPoint(e);
            this._handleMouseHover(e, point2);
          },
          _handleMouseOut: function(e) {
            var layer = this._hoveredLayer;
            if (layer) {
              removeClass(this._container, "leaflet-interactive");
              this._fireEvent([layer], e, "mouseout");
              this._hoveredLayer = null;
              this._mouseHoverThrottled = false;
            }
          },
          _handleMouseHover: function(e, point2) {
            if (this._mouseHoverThrottled) {
              return;
            }
            var layer, candidateHoveredLayer;
            for (var order = this._drawFirst; order; order = order.next) {
              layer = order.layer;
              if (layer.options.interactive && layer._containsPoint(point2)) {
                candidateHoveredLayer = layer;
              }
            }
            if (candidateHoveredLayer !== this._hoveredLayer) {
              this._handleMouseOut(e);
              if (candidateHoveredLayer) {
                addClass(this._container, "leaflet-interactive");
                this._fireEvent([candidateHoveredLayer], e, "mouseover");
                this._hoveredLayer = candidateHoveredLayer;
              }
            }
            this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e);
            this._mouseHoverThrottled = true;
            setTimeout(bind(function() {
              this._mouseHoverThrottled = false;
            }, this), 32);
          },
          _fireEvent: function(layers2, e, type) {
            this._map._fireDOMEvent(e, type || e.type, layers2);
          },
          _bringToFront: function(layer) {
            var order = layer._order;
            if (!order) {
              return;
            }
            var next = order.next;
            var prev = order.prev;
            if (next) {
              next.prev = prev;
            } else {
              return;
            }
            if (prev) {
              prev.next = next;
            } else if (next) {
              this._drawFirst = next;
            }
            order.prev = this._drawLast;
            this._drawLast.next = order;
            order.next = null;
            this._drawLast = order;
            this._requestRedraw(layer);
          },
          _bringToBack: function(layer) {
            var order = layer._order;
            if (!order) {
              return;
            }
            var next = order.next;
            var prev = order.prev;
            if (prev) {
              prev.next = next;
            } else {
              return;
            }
            if (next) {
              next.prev = prev;
            } else if (prev) {
              this._drawLast = prev;
            }
            order.prev = null;
            order.next = this._drawFirst;
            this._drawFirst.prev = order;
            this._drawFirst = order;
            this._requestRedraw(layer);
          }
        });
        function canvas(options) {
          return Browser.canvas ? new Canvas(options) : null;
        }
        var vmlCreate = function() {
          try {
            document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml");
            return function(name) {
              return document.createElement("<lvml:" + name + ' class="lvml">');
            };
          } catch (e) {
          }
          return function(name) {
            return document.createElement("<" + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
          };
        }();
        var vmlMixin = {
          _initContainer: function() {
            this._container = create$1("div", "leaflet-vml-container");
          },
          _update: function() {
            if (this._map._animatingZoom) {
              return;
            }
            Renderer.prototype._update.call(this);
            this.fire("update");
          },
          _initPath: function(layer) {
            var container = layer._container = vmlCreate("shape");
            addClass(container, "leaflet-vml-shape " + (this.options.className || ""));
            container.coordsize = "1 1";
            layer._path = vmlCreate("path");
            container.appendChild(layer._path);
            this._updateStyle(layer);
            this._layers[stamp(layer)] = layer;
          },
          _addPath: function(layer) {
            var container = layer._container;
            this._container.appendChild(container);
            if (layer.options.interactive) {
              layer.addInteractiveTarget(container);
            }
          },
          _removePath: function(layer) {
            var container = layer._container;
            remove(container);
            layer.removeInteractiveTarget(container);
            delete this._layers[stamp(layer)];
          },
          _updateStyle: function(layer) {
            var stroke = layer._stroke, fill = layer._fill, options = layer.options, container = layer._container;
            container.stroked = !!options.stroke;
            container.filled = !!options.fill;
            if (options.stroke) {
              if (!stroke) {
                stroke = layer._stroke = vmlCreate("stroke");
              }
              container.appendChild(stroke);
              stroke.weight = options.weight + "px";
              stroke.color = options.color;
              stroke.opacity = options.opacity;
              if (options.dashArray) {
                stroke.dashStyle = isArray2(options.dashArray) ? options.dashArray.join(" ") : options.dashArray.replace(/( *, *)/g, " ");
              } else {
                stroke.dashStyle = "";
              }
              stroke.endcap = options.lineCap.replace("butt", "flat");
              stroke.joinstyle = options.lineJoin;
            } else if (stroke) {
              container.removeChild(stroke);
              layer._stroke = null;
            }
            if (options.fill) {
              if (!fill) {
                fill = layer._fill = vmlCreate("fill");
              }
              container.appendChild(fill);
              fill.color = options.fillColor || options.color;
              fill.opacity = options.fillOpacity;
            } else if (fill) {
              container.removeChild(fill);
              layer._fill = null;
            }
          },
          _updateCircle: function(layer) {
            var p2 = layer._point.round(), r2 = Math.round(layer._radius), r22 = Math.round(layer._radiusY || r2);
            this._setPath(layer, layer._empty() ? "M0 0" : "AL " + p2.x + "," + p2.y + " " + r2 + "," + r22 + " 0," + 65535 * 360);
          },
          _setPath: function(layer, path) {
            layer._path.v = path;
          },
          _bringToFront: function(layer) {
            toFront(layer._container);
          },
          _bringToBack: function(layer) {
            toBack(layer._container);
          }
        };
        var create = Browser.vml ? vmlCreate : svgCreate;
        var SVG = Renderer.extend({
          _initContainer: function() {
            this._container = create("svg");
            this._container.setAttribute("pointer-events", "none");
            this._rootGroup = create("g");
            this._container.appendChild(this._rootGroup);
          },
          _destroyContainer: function() {
            remove(this._container);
            off(this._container);
            delete this._container;
            delete this._rootGroup;
            delete this._svgSize;
          },
          _update: function() {
            if (this._map._animatingZoom && this._bounds) {
              return;
            }
            Renderer.prototype._update.call(this);
            var b = this._bounds, size = b.getSize(), container = this._container;
            if (!this._svgSize || !this._svgSize.equals(size)) {
              this._svgSize = size;
              container.setAttribute("width", size.x);
              container.setAttribute("height", size.y);
            }
            setPosition(container, b.min);
            container.setAttribute("viewBox", [b.min.x, b.min.y, size.x, size.y].join(" "));
            this.fire("update");
          },
          // methods below are called by vector layers implementations
          _initPath: function(layer) {
            var path = layer._path = create("path");
            if (layer.options.className) {
              addClass(path, layer.options.className);
            }
            if (layer.options.interactive) {
              addClass(path, "leaflet-interactive");
            }
            this._updateStyle(layer);
            this._layers[stamp(layer)] = layer;
          },
          _addPath: function(layer) {
            if (!this._rootGroup) {
              this._initContainer();
            }
            this._rootGroup.appendChild(layer._path);
            layer.addInteractiveTarget(layer._path);
          },
          _removePath: function(layer) {
            remove(layer._path);
            layer.removeInteractiveTarget(layer._path);
            delete this._layers[stamp(layer)];
          },
          _updatePath: function(layer) {
            layer._project();
            layer._update();
          },
          _updateStyle: function(layer) {
            var path = layer._path, options = layer.options;
            if (!path) {
              return;
            }
            if (options.stroke) {
              path.setAttribute("stroke", options.color);
              path.setAttribute("stroke-opacity", options.opacity);
              path.setAttribute("stroke-width", options.weight);
              path.setAttribute("stroke-linecap", options.lineCap);
              path.setAttribute("stroke-linejoin", options.lineJoin);
              if (options.dashArray) {
                path.setAttribute("stroke-dasharray", options.dashArray);
              } else {
                path.removeAttribute("stroke-dasharray");
              }
              if (options.dashOffset) {
                path.setAttribute("stroke-dashoffset", options.dashOffset);
              } else {
                path.removeAttribute("stroke-dashoffset");
              }
            } else {
              path.setAttribute("stroke", "none");
            }
            if (options.fill) {
              path.setAttribute("fill", options.fillColor || options.color);
              path.setAttribute("fill-opacity", options.fillOpacity);
              path.setAttribute("fill-rule", options.fillRule || "evenodd");
            } else {
              path.setAttribute("fill", "none");
            }
          },
          _updatePoly: function(layer, closed) {
            this._setPath(layer, pointsToPath(layer._parts, closed));
          },
          _updateCircle: function(layer) {
            var p2 = layer._point, r2 = Math.max(Math.round(layer._radius), 1), r22 = Math.max(Math.round(layer._radiusY), 1) || r2, arc = "a" + r2 + "," + r22 + " 0 1,0 ";
            var d = layer._empty() ? "M0 0" : "M" + (p2.x - r2) + "," + p2.y + arc + r2 * 2 + ",0 " + arc + -r2 * 2 + ",0 ";
            this._setPath(layer, d);
          },
          _setPath: function(layer, path) {
            layer._path.setAttribute("d", path);
          },
          // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
          _bringToFront: function(layer) {
            toFront(layer._path);
          },
          _bringToBack: function(layer) {
            toBack(layer._path);
          }
        });
        if (Browser.vml) {
          SVG.include(vmlMixin);
        }
        function svg(options) {
          return Browser.svg || Browser.vml ? new SVG(options) : null;
        }
        Map2.include({
          // @namespace Map; @method getRenderer(layer: Path): Renderer
          // Returns the instance of `Renderer` that should be used to render the given
          // `Path`. It will ensure that the `renderer` options of the map and paths
          // are respected, and that the renderers do exist on the map.
          getRenderer: function(layer) {
            var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;
            if (!renderer) {
              renderer = this._renderer = this._createRenderer();
            }
            if (!this.hasLayer(renderer)) {
              this.addLayer(renderer);
            }
            return renderer;
          },
          _getPaneRenderer: function(name) {
            if (name === "overlayPane" || name === void 0) {
              return false;
            }
            var renderer = this._paneRenderers[name];
            if (renderer === void 0) {
              renderer = this._createRenderer({ pane: name });
              this._paneRenderers[name] = renderer;
            }
            return renderer;
          },
          _createRenderer: function(options) {
            return this.options.preferCanvas && canvas(options) || svg(options);
          }
        });
        var Rectangle2 = Polygon.extend({
          initialize: function(latLngBounds, options) {
            Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
          },
          // @method setBounds(latLngBounds: LatLngBounds): this
          // Redraws the rectangle with the passed bounds.
          setBounds: function(latLngBounds) {
            return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
          },
          _boundsToLatLngs: function(latLngBounds) {
            latLngBounds = toLatLngBounds(latLngBounds);
            return [
              latLngBounds.getSouthWest(),
              latLngBounds.getNorthWest(),
              latLngBounds.getNorthEast(),
              latLngBounds.getSouthEast()
            ];
          }
        });
        function rectangle(latLngBounds, options) {
          return new Rectangle2(latLngBounds, options);
        }
        SVG.create = create;
        SVG.pointsToPath = pointsToPath;
        GeoJSON.geometryToLayer = geometryToLayer;
        GeoJSON.coordsToLatLng = coordsToLatLng;
        GeoJSON.coordsToLatLngs = coordsToLatLngs;
        GeoJSON.latLngToCoords = latLngToCoords;
        GeoJSON.latLngsToCoords = latLngsToCoords;
        GeoJSON.getFeature = getFeature;
        GeoJSON.asFeature = asFeature;
        Map2.mergeOptions({
          // @option boxZoom: Boolean = true
          // Whether the map can be zoomed to a rectangular area specified by
          // dragging the mouse while pressing the shift key.
          boxZoom: true
        });
        var BoxZoom = Handler.extend({
          initialize: function(map2) {
            this._map = map2;
            this._container = map2._container;
            this._pane = map2._panes.overlayPane;
            this._resetStateTimeout = 0;
            map2.on("unload", this._destroy, this);
          },
          addHooks: function() {
            on(this._container, "mousedown", this._onMouseDown, this);
          },
          removeHooks: function() {
            off(this._container, "mousedown", this._onMouseDown, this);
          },
          moved: function() {
            return this._moved;
          },
          _destroy: function() {
            remove(this._pane);
            delete this._pane;
          },
          _resetState: function() {
            this._resetStateTimeout = 0;
            this._moved = false;
          },
          _clearDeferredResetState: function() {
            if (this._resetStateTimeout !== 0) {
              clearTimeout(this._resetStateTimeout);
              this._resetStateTimeout = 0;
            }
          },
          _onMouseDown: function(e) {
            if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
              return false;
            }
            this._clearDeferredResetState();
            this._resetState();
            disableTextSelection();
            disableImageDrag();
            this._startPoint = this._map.mouseEventToContainerPoint(e);
            on(document, {
              contextmenu: stop,
              mousemove: this._onMouseMove,
              mouseup: this._onMouseUp,
              keydown: this._onKeyDown
            }, this);
          },
          _onMouseMove: function(e) {
            if (!this._moved) {
              this._moved = true;
              this._box = create$1("div", "leaflet-zoom-box", this._container);
              addClass(this._container, "leaflet-crosshair");
              this._map.fire("boxzoomstart");
            }
            this._point = this._map.mouseEventToContainerPoint(e);
            var bounds = new Bounds(this._point, this._startPoint), size = bounds.getSize();
            setPosition(this._box, bounds.min);
            this._box.style.width = size.x + "px";
            this._box.style.height = size.y + "px";
          },
          _finish: function() {
            if (this._moved) {
              remove(this._box);
              removeClass(this._container, "leaflet-crosshair");
            }
            enableTextSelection();
            enableImageDrag();
            off(document, {
              contextmenu: stop,
              mousemove: this._onMouseMove,
              mouseup: this._onMouseUp,
              keydown: this._onKeyDown
            }, this);
          },
          _onMouseUp: function(e) {
            if (e.which !== 1 && e.button !== 1) {
              return;
            }
            this._finish();
            if (!this._moved) {
              return;
            }
            this._clearDeferredResetState();
            this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);
            var bounds = new LatLngBounds(
              this._map.containerPointToLatLng(this._startPoint),
              this._map.containerPointToLatLng(this._point)
            );
            this._map.fitBounds(bounds).fire("boxzoomend", { boxZoomBounds: bounds });
          },
          _onKeyDown: function(e) {
            if (e.keyCode === 27) {
              this._finish();
              this._clearDeferredResetState();
              this._resetState();
            }
          }
        });
        Map2.addInitHook("addHandler", "boxZoom", BoxZoom);
        Map2.mergeOptions({
          // @option doubleClickZoom: Boolean|String = true
          // Whether the map can be zoomed in by double clicking on it and
          // zoomed out by double clicking while holding shift. If passed
          // `'center'`, double-click zoom will zoom to the center of the
          //  view regardless of where the mouse was.
          doubleClickZoom: true
        });
        var DoubleClickZoom = Handler.extend({
          addHooks: function() {
            this._map.on("dblclick", this._onDoubleClick, this);
          },
          removeHooks: function() {
            this._map.off("dblclick", this._onDoubleClick, this);
          },
          _onDoubleClick: function(e) {
            var map2 = this._map, oldZoom = map2.getZoom(), delta = map2.options.zoomDelta, zoom2 = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;
            if (map2.options.doubleClickZoom === "center") {
              map2.setZoom(zoom2);
            } else {
              map2.setZoomAround(e.containerPoint, zoom2);
            }
          }
        });
        Map2.addInitHook("addHandler", "doubleClickZoom", DoubleClickZoom);
        Map2.mergeOptions({
          // @option dragging: Boolean = true
          // Whether the map is draggable with mouse/touch or not.
          dragging: true,
          // @section Panning Inertia Options
          // @option inertia: Boolean = *
          // If enabled, panning of the map will have an inertia effect where
          // the map builds momentum while dragging and continues moving in
          // the same direction for some time. Feels especially nice on touch
          // devices. Enabled by default.
          inertia: true,
          // @option inertiaDeceleration: Number = 3000
          // The rate with which the inertial movement slows down, in pixels/second.
          inertiaDeceleration: 3400,
          // px/s^2
          // @option inertiaMaxSpeed: Number = Infinity
          // Max speed of the inertial movement, in pixels/second.
          inertiaMaxSpeed: Infinity,
          // px/s
          // @option easeLinearity: Number = 0.2
          easeLinearity: 0.2,
          // TODO refactor, move to CRS
          // @option worldCopyJump: Boolean = false
          // With this option enabled, the map tracks when you pan to another "copy"
          // of the world and seamlessly jumps to the original one so that all overlays
          // like markers and vector layers are still visible.
          worldCopyJump: false,
          // @option maxBoundsViscosity: Number = 0.0
          // If `maxBounds` is set, this option will control how solid the bounds
          // are when dragging the map around. The default value of `0.0` allows the
          // user to drag outside the bounds at normal speed, higher values will
          // slow down map dragging outside bounds, and `1.0` makes the bounds fully
          // solid, preventing the user from dragging outside the bounds.
          maxBoundsViscosity: 0
        });
        var Drag = Handler.extend({
          addHooks: function() {
            if (!this._draggable) {
              var map2 = this._map;
              this._draggable = new Draggable(map2._mapPane, map2._container);
              this._draggable.on({
                dragstart: this._onDragStart,
                drag: this._onDrag,
                dragend: this._onDragEnd
              }, this);
              this._draggable.on("predrag", this._onPreDragLimit, this);
              if (map2.options.worldCopyJump) {
                this._draggable.on("predrag", this._onPreDragWrap, this);
                map2.on("zoomend", this._onZoomEnd, this);
                map2.whenReady(this._onZoomEnd, this);
              }
            }
            addClass(this._map._container, "leaflet-grab leaflet-touch-drag");
            this._draggable.enable();
            this._positions = [];
            this._times = [];
          },
          removeHooks: function() {
            removeClass(this._map._container, "leaflet-grab");
            removeClass(this._map._container, "leaflet-touch-drag");
            this._draggable.disable();
          },
          moved: function() {
            return this._draggable && this._draggable._moved;
          },
          moving: function() {
            return this._draggable && this._draggable._moving;
          },
          _onDragStart: function() {
            var map2 = this._map;
            map2._stop();
            if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
              var bounds = toLatLngBounds(this._map.options.maxBounds);
              this._offsetLimit = toBounds(
                this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
                this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize())
              );
              this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
            } else {
              this._offsetLimit = null;
            }
            map2.fire("movestart").fire("dragstart");
            if (map2.options.inertia) {
              this._positions = [];
              this._times = [];
            }
          },
          _onDrag: function(e) {
            if (this._map.options.inertia) {
              var time2 = this._lastTime = +/* @__PURE__ */ new Date(), pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;
              this._positions.push(pos);
              this._times.push(time2);
              this._prunePositions(time2);
            }
            this._map.fire("move", e).fire("drag", e);
          },
          _prunePositions: function(time2) {
            while (this._positions.length > 1 && time2 - this._times[0] > 50) {
              this._positions.shift();
              this._times.shift();
            }
          },
          _onZoomEnd: function() {
            var pxCenter = this._map.getSize().divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);
            this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
            this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
          },
          _viscousLimit: function(value, threshold2) {
            return value - (value - threshold2) * this._viscosity;
          },
          _onPreDragLimit: function() {
            if (!this._viscosity || !this._offsetLimit) {
              return;
            }
            var offset = this._draggable._newPos.subtract(this._draggable._startPos);
            var limit = this._offsetLimit;
            if (offset.x < limit.min.x) {
              offset.x = this._viscousLimit(offset.x, limit.min.x);
            }
            if (offset.y < limit.min.y) {
              offset.y = this._viscousLimit(offset.y, limit.min.y);
            }
            if (offset.x > limit.max.x) {
              offset.x = this._viscousLimit(offset.x, limit.max.x);
            }
            if (offset.y > limit.max.y) {
              offset.y = this._viscousLimit(offset.y, limit.max.y);
            }
            this._draggable._newPos = this._draggable._startPos.add(offset);
          },
          _onPreDragWrap: function() {
            var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x2 = this._draggable._newPos.x, newX1 = (x2 - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x2 + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
            this._draggable._absPos = this._draggable._newPos.clone();
            this._draggable._newPos.x = newX;
          },
          _onDragEnd: function(e) {
            var map2 = this._map, options = map2.options, noInertia = !options.inertia || e.noInertia || this._times.length < 2;
            map2.fire("dragend", e);
            if (noInertia) {
              map2.fire("moveend");
            } else {
              this._prunePositions(+/* @__PURE__ */ new Date());
              var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime - this._times[0]) / 1e3, ease = options.easeLinearity, speedVector = direction.multiplyBy(ease / duration), speed = speedVector.distanceTo([0, 0]), limitedSpeed = Math.min(options.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease), offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
              if (!offset.x && !offset.y) {
                map2.fire("moveend");
              } else {
                offset = map2._limitOffset(offset, map2.options.maxBounds);
                requestAnimFrame(function() {
                  map2.panBy(offset, {
                    duration: decelerationDuration,
                    easeLinearity: ease,
                    noMoveStart: true,
                    animate: true
                  });
                });
              }
            }
          }
        });
        Map2.addInitHook("addHandler", "dragging", Drag);
        Map2.mergeOptions({
          // @option keyboard: Boolean = true
          // Makes the map focusable and allows users to navigate the map with keyboard
          // arrows and `+`/`-` keys.
          keyboard: true,
          // @option keyboardPanDelta: Number = 80
          // Amount of pixels to pan when pressing an arrow key.
          keyboardPanDelta: 80
        });
        var Keyboard = Handler.extend({
          keyCodes: {
            left: [37],
            right: [39],
            down: [40],
            up: [38],
            zoomIn: [187, 107, 61, 171],
            zoomOut: [189, 109, 54, 173]
          },
          initialize: function(map2) {
            this._map = map2;
            this._setPanDelta(map2.options.keyboardPanDelta);
            this._setZoomDelta(map2.options.zoomDelta);
          },
          addHooks: function() {
            var container = this._map._container;
            if (container.tabIndex <= 0) {
              container.tabIndex = "0";
            }
            on(container, {
              focus: this._onFocus,
              blur: this._onBlur,
              mousedown: this._onMouseDown
            }, this);
            this._map.on({
              focus: this._addHooks,
              blur: this._removeHooks
            }, this);
          },
          removeHooks: function() {
            this._removeHooks();
            off(this._map._container, {
              focus: this._onFocus,
              blur: this._onBlur,
              mousedown: this._onMouseDown
            }, this);
            this._map.off({
              focus: this._addHooks,
              blur: this._removeHooks
            }, this);
          },
          _onMouseDown: function() {
            if (this._focused) {
              return;
            }
            var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;
            this._map._container.focus();
            window.scrollTo(left, top);
          },
          _onFocus: function() {
            this._focused = true;
            this._map.fire("focus");
          },
          _onBlur: function() {
            this._focused = false;
            this._map.fire("blur");
          },
          _setPanDelta: function(panDelta) {
            var keys = this._panKeys = {}, codes = this.keyCodes, i, len;
            for (i = 0, len = codes.left.length; i < len; i++) {
              keys[codes.left[i]] = [-1 * panDelta, 0];
            }
            for (i = 0, len = codes.right.length; i < len; i++) {
              keys[codes.right[i]] = [panDelta, 0];
            }
            for (i = 0, len = codes.down.length; i < len; i++) {
              keys[codes.down[i]] = [0, panDelta];
            }
            for (i = 0, len = codes.up.length; i < len; i++) {
              keys[codes.up[i]] = [0, -1 * panDelta];
            }
          },
          _setZoomDelta: function(zoomDelta) {
            var keys = this._zoomKeys = {}, codes = this.keyCodes, i, len;
            for (i = 0, len = codes.zoomIn.length; i < len; i++) {
              keys[codes.zoomIn[i]] = zoomDelta;
            }
            for (i = 0, len = codes.zoomOut.length; i < len; i++) {
              keys[codes.zoomOut[i]] = -zoomDelta;
            }
          },
          _addHooks: function() {
            on(document, "keydown", this._onKeyDown, this);
          },
          _removeHooks: function() {
            off(document, "keydown", this._onKeyDown, this);
          },
          _onKeyDown: function(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) {
              return;
            }
            var key = e.keyCode, map2 = this._map, offset;
            if (key in this._panKeys) {
              if (!map2._panAnim || !map2._panAnim._inProgress) {
                offset = this._panKeys[key];
                if (e.shiftKey) {
                  offset = toPoint(offset).multiplyBy(3);
                }
                if (map2.options.maxBounds) {
                  offset = map2._limitOffset(toPoint(offset), map2.options.maxBounds);
                }
                if (map2.options.worldCopyJump) {
                  var newLatLng = map2.wrapLatLng(map2.unproject(map2.project(map2.getCenter()).add(offset)));
                  map2.panTo(newLatLng);
                } else {
                  map2.panBy(offset);
                }
              }
            } else if (key in this._zoomKeys) {
              map2.setZoom(map2.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);
            } else if (key === 27 && map2._popup && map2._popup.options.closeOnEscapeKey) {
              map2.closePopup();
            } else {
              return;
            }
            stop(e);
          }
        });
        Map2.addInitHook("addHandler", "keyboard", Keyboard);
        Map2.mergeOptions({
          // @section Mouse wheel options
          // @option scrollWheelZoom: Boolean|String = true
          // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
          // it will zoom to the center of the view regardless of where the mouse was.
          scrollWheelZoom: true,
          // @option wheelDebounceTime: Number = 40
          // Limits the rate at which a wheel can fire (in milliseconds). By default
          // user can't zoom via wheel more often than once per 40 ms.
          wheelDebounceTime: 40,
          // @option wheelPxPerZoomLevel: Number = 60
          // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
          // mean a change of one full zoom level. Smaller values will make wheel-zooming
          // faster (and vice versa).
          wheelPxPerZoomLevel: 60
        });
        var ScrollWheelZoom = Handler.extend({
          addHooks: function() {
            on(this._map._container, "wheel", this._onWheelScroll, this);
            this._delta = 0;
          },
          removeHooks: function() {
            off(this._map._container, "wheel", this._onWheelScroll, this);
          },
          _onWheelScroll: function(e) {
            var delta = getWheelDelta(e);
            var debounce2 = this._map.options.wheelDebounceTime;
            this._delta += delta;
            this._lastMousePos = this._map.mouseEventToContainerPoint(e);
            if (!this._startTime) {
              this._startTime = +/* @__PURE__ */ new Date();
            }
            var left = Math.max(debounce2 - (+/* @__PURE__ */ new Date() - this._startTime), 0);
            clearTimeout(this._timer);
            this._timer = setTimeout(bind(this._performZoom, this), left);
            stop(e);
          },
          _performZoom: function() {
            var map2 = this._map, zoom2 = map2.getZoom(), snap = this._map.options.zoomSnap || 0;
            map2._stop();
            var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2, d4 = snap ? Math.ceil(d3 / snap) * snap : d3, delta = map2._limitZoom(zoom2 + (this._delta > 0 ? d4 : -d4)) - zoom2;
            this._delta = 0;
            this._startTime = null;
            if (!delta) {
              return;
            }
            if (map2.options.scrollWheelZoom === "center") {
              map2.setZoom(zoom2 + delta);
            } else {
              map2.setZoomAround(this._lastMousePos, zoom2 + delta);
            }
          }
        });
        Map2.addInitHook("addHandler", "scrollWheelZoom", ScrollWheelZoom);
        var tapHoldDelay = 600;
        Map2.mergeOptions({
          // @section Touch interaction options
          // @option tapHold: Boolean
          // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.
          tapHold: Browser.touchNative && Browser.safari && Browser.mobile,
          // @option tapTolerance: Number = 15
          // The max number of pixels a user can shift his finger during touch
          // for it to be considered a valid tap.
          tapTolerance: 15
        });
        var TapHold = Handler.extend({
          addHooks: function() {
            on(this._map._container, "touchstart", this._onDown, this);
          },
          removeHooks: function() {
            off(this._map._container, "touchstart", this._onDown, this);
          },
          _onDown: function(e) {
            clearTimeout(this._holdTimeout);
            if (e.touches.length !== 1) {
              return;
            }
            var first = e.touches[0];
            this._startPos = this._newPos = new Point(first.clientX, first.clientY);
            this._holdTimeout = setTimeout(bind(function() {
              this._cancel();
              if (!this._isTapValid()) {
                return;
              }
              on(document, "touchend", preventDefault);
              on(document, "touchend touchcancel", this._cancelClickPrevent);
              this._simulateEvent("contextmenu", first);
            }, this), tapHoldDelay);
            on(document, "touchend touchcancel contextmenu", this._cancel, this);
            on(document, "touchmove", this._onMove, this);
          },
          _cancelClickPrevent: function cancelClickPrevent() {
            off(document, "touchend", preventDefault);
            off(document, "touchend touchcancel", cancelClickPrevent);
          },
          _cancel: function() {
            clearTimeout(this._holdTimeout);
            off(document, "touchend touchcancel contextmenu", this._cancel, this);
            off(document, "touchmove", this._onMove, this);
          },
          _onMove: function(e) {
            var first = e.touches[0];
            this._newPos = new Point(first.clientX, first.clientY);
          },
          _isTapValid: function() {
            return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
          },
          _simulateEvent: function(type, e) {
            var simulatedEvent = new MouseEvent(type, {
              bubbles: true,
              cancelable: true,
              view: window,
              // detail: 1,
              screenX: e.screenX,
              screenY: e.screenY,
              clientX: e.clientX,
              clientY: e.clientY
              // button: 2,
              // buttons: 2
            });
            simulatedEvent._simulated = true;
            e.target.dispatchEvent(simulatedEvent);
          }
        });
        Map2.addInitHook("addHandler", "tapHold", TapHold);
        Map2.mergeOptions({
          // @section Touch interaction options
          // @option touchZoom: Boolean|String = *
          // Whether the map can be zoomed by touch-dragging with two fingers. If
          // passed `'center'`, it will zoom to the center of the view regardless of
          // where the touch events (fingers) were. Enabled for touch-capable web
          // browsers.
          touchZoom: Browser.touch,
          // @option bounceAtZoomLimits: Boolean = true
          // Set it to false if you don't want the map to zoom beyond min/max zoom
          // and then bounce back when pinch-zooming.
          bounceAtZoomLimits: true
        });
        var TouchZoom = Handler.extend({
          addHooks: function() {
            addClass(this._map._container, "leaflet-touch-zoom");
            on(this._map._container, "touchstart", this._onTouchStart, this);
          },
          removeHooks: function() {
            removeClass(this._map._container, "leaflet-touch-zoom");
            off(this._map._container, "touchstart", this._onTouchStart, this);
          },
          _onTouchStart: function(e) {
            var map2 = this._map;
            if (!e.touches || e.touches.length !== 2 || map2._animatingZoom || this._zooming) {
              return;
            }
            var p1 = map2.mouseEventToContainerPoint(e.touches[0]), p2 = map2.mouseEventToContainerPoint(e.touches[1]);
            this._centerPoint = map2.getSize()._divideBy(2);
            this._startLatLng = map2.containerPointToLatLng(this._centerPoint);
            if (map2.options.touchZoom !== "center") {
              this._pinchStartLatLng = map2.containerPointToLatLng(p1.add(p2)._divideBy(2));
            }
            this._startDist = p1.distanceTo(p2);
            this._startZoom = map2.getZoom();
            this._moved = false;
            this._zooming = true;
            map2._stop();
            on(document, "touchmove", this._onTouchMove, this);
            on(document, "touchend touchcancel", this._onTouchEnd, this);
            preventDefault(e);
          },
          _onTouchMove: function(e) {
            if (!e.touches || e.touches.length !== 2 || !this._zooming) {
              return;
            }
            var map2 = this._map, p1 = map2.mouseEventToContainerPoint(e.touches[0]), p2 = map2.mouseEventToContainerPoint(e.touches[1]), scale2 = p1.distanceTo(p2) / this._startDist;
            this._zoom = map2.getScaleZoom(scale2, this._startZoom);
            if (!map2.options.bounceAtZoomLimits && (this._zoom < map2.getMinZoom() && scale2 < 1 || this._zoom > map2.getMaxZoom() && scale2 > 1)) {
              this._zoom = map2._limitZoom(this._zoom);
            }
            if (map2.options.touchZoom === "center") {
              this._center = this._startLatLng;
              if (scale2 === 1) {
                return;
              }
            } else {
              var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
              if (scale2 === 1 && delta.x === 0 && delta.y === 0) {
                return;
              }
              this._center = map2.unproject(map2.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
            }
            if (!this._moved) {
              map2._moveStart(true, false);
              this._moved = true;
            }
            cancelAnimFrame(this._animRequest);
            var moveFn = bind(map2._move, map2, this._center, this._zoom, { pinch: true, round: false }, void 0);
            this._animRequest = requestAnimFrame(moveFn, this, true);
            preventDefault(e);
          },
          _onTouchEnd: function() {
            if (!this._moved || !this._zooming) {
              this._zooming = false;
              return;
            }
            this._zooming = false;
            cancelAnimFrame(this._animRequest);
            off(document, "touchmove", this._onTouchMove, this);
            off(document, "touchend touchcancel", this._onTouchEnd, this);
            if (this._map.options.zoomAnimation) {
              this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
            } else {
              this._map._resetView(this._center, this._map._limitZoom(this._zoom));
            }
          }
        });
        Map2.addInitHook("addHandler", "touchZoom", TouchZoom);
        Map2.BoxZoom = BoxZoom;
        Map2.DoubleClickZoom = DoubleClickZoom;
        Map2.Drag = Drag;
        Map2.Keyboard = Keyboard;
        Map2.ScrollWheelZoom = ScrollWheelZoom;
        Map2.TapHold = TapHold;
        Map2.TouchZoom = TouchZoom;
        exports$12.Bounds = Bounds;
        exports$12.Browser = Browser;
        exports$12.CRS = CRS;
        exports$12.Canvas = Canvas;
        exports$12.Circle = Circle2;
        exports$12.CircleMarker = CircleMarker2;
        exports$12.Class = Class;
        exports$12.Control = Control;
        exports$12.DivIcon = DivIcon;
        exports$12.DivOverlay = DivOverlay;
        exports$12.DomEvent = DomEvent;
        exports$12.DomUtil = DomUtil;
        exports$12.Draggable = Draggable;
        exports$12.Evented = Evented;
        exports$12.FeatureGroup = FeatureGroup;
        exports$12.GeoJSON = GeoJSON;
        exports$12.GridLayer = GridLayer;
        exports$12.Handler = Handler;
        exports$12.Icon = Icon2;
        exports$12.ImageOverlay = ImageOverlay;
        exports$12.LatLng = LatLng;
        exports$12.LatLngBounds = LatLngBounds;
        exports$12.Layer = Layer2;
        exports$12.LayerGroup = LayerGroup;
        exports$12.LineUtil = LineUtil;
        exports$12.Map = Map2;
        exports$12.Marker = Marker;
        exports$12.Mixin = Mixin;
        exports$12.Path = Path2;
        exports$12.Point = Point;
        exports$12.PolyUtil = PolyUtil;
        exports$12.Polygon = Polygon;
        exports$12.Polyline = Polyline;
        exports$12.Popup = Popup2;
        exports$12.PosAnimation = PosAnimation;
        exports$12.Projection = index;
        exports$12.Rectangle = Rectangle2;
        exports$12.Renderer = Renderer;
        exports$12.SVG = SVG;
        exports$12.SVGOverlay = SVGOverlay;
        exports$12.TileLayer = TileLayer2;
        exports$12.Tooltip = Tooltip2;
        exports$12.Transformation = Transformation;
        exports$12.Util = Util;
        exports$12.VideoOverlay = VideoOverlay;
        exports$12.bind = bind;
        exports$12.bounds = toBounds;
        exports$12.canvas = canvas;
        exports$12.circle = circle;
        exports$12.circleMarker = circleMarker;
        exports$12.control = control;
        exports$12.divIcon = divIcon;
        exports$12.extend = extend2;
        exports$12.featureGroup = featureGroup;
        exports$12.geoJSON = geoJSON;
        exports$12.geoJson = geoJson;
        exports$12.gridLayer = gridLayer;
        exports$12.icon = icon2;
        exports$12.imageOverlay = imageOverlay;
        exports$12.latLng = toLatLng;
        exports$12.latLngBounds = toLatLngBounds;
        exports$12.layerGroup = layerGroup;
        exports$12.map = createMap;
        exports$12.marker = marker;
        exports$12.point = toPoint;
        exports$12.polygon = polygon;
        exports$12.polyline = polyline;
        exports$12.popup = popup;
        exports$12.rectangle = rectangle;
        exports$12.setOptions = setOptions;
        exports$12.stamp = stamp;
        exports$12.svg = svg;
        exports$12.svgOverlay = svgOverlay;
        exports$12.tileLayer = tileLayer;
        exports$12.tooltip = tooltip;
        exports$12.transformation = toTransformation;
        exports$12.version = version;
        exports$12.videoOverlay = videoOverlay;
        var oldL = window.L;
        exports$12.noConflict = function() {
          window.L = oldL;
          return this;
        };
        window.L = exports$12;
      });
    })(leafletSrc, leafletSrc.exports);
    var leafletSrcExports = leafletSrc.exports;
    const L$1 = /* @__PURE__ */ getDefaultExportFromCjs(leafletSrcExports);
    function createElementObject(instance, context, container) {
      return Object.freeze({
        instance,
        context,
        container
      });
    }
    function createElementHook(createElement, updateElement) {
      if (updateElement == null) {
        return function useImmutableLeafletElement(props, context) {
          const elementRef = reactExports.useRef();
          if (!elementRef.current) elementRef.current = createElement(props, context);
          return elementRef;
        };
      }
      return function useMutableLeafletElement(props, context) {
        const elementRef = reactExports.useRef();
        if (!elementRef.current) elementRef.current = createElement(props, context);
        const propsRef = reactExports.useRef(props);
        const { instance } = elementRef.current;
        reactExports.useEffect(function updateElementProps() {
          if (propsRef.current !== props) {
            updateElement(instance, props, propsRef.current);
            propsRef.current = props;
          }
        }, [
          instance,
          props,
          context
        ]);
        return elementRef;
      };
    }
    function useLayerLifecycle(element, context) {
      reactExports.useEffect(function addLayer() {
        var _a;
        const container = (_a = context.layerContainer) != null ? _a : context.map;
        container.addLayer(element.instance);
        return function removeLayer() {
          var _a2;
          (_a2 = context.layerContainer) == null ? void 0 : _a2.removeLayer(element.instance);
          context.map.removeLayer(element.instance);
        };
      }, [
        context,
        element
      ]);
    }
    function createLayerHook(useElement) {
      return function useLayer(props) {
        const context = useLeafletContext();
        const elementRef = useElement(withPane(props, context), context);
        useAttribution(context.map, props.attribution);
        useEventHandlers(elementRef.current, props.eventHandlers);
        useLayerLifecycle(elementRef.current, context);
        return elementRef;
      };
    }
    function usePathOptions(element, props) {
      const optionsRef = reactExports.useRef();
      reactExports.useEffect(function updatePathOptions() {
        var _a;
        if (props.pathOptions !== optionsRef.current) {
          const options = (_a = props.pathOptions) != null ? _a : {};
          element.instance.setStyle(options);
          optionsRef.current = options;
        }
      }, [
        element,
        props
      ]);
    }
    function createPathHook(useElement) {
      return function usePath(props) {
        const context = useLeafletContext();
        const elementRef = useElement(withPane(props, context), context);
        useEventHandlers(elementRef.current, props.eventHandlers);
        useLayerLifecycle(elementRef.current, context);
        usePathOptions(elementRef.current, props);
        return elementRef;
      };
    }
    function createOverlayComponent(createElement, useLifecycle) {
      const useElement = createElementHook(createElement);
      const useOverlay = createDivOverlayHook(useElement, useLifecycle);
      return createDivOverlayComponent(useOverlay);
    }
    function createPathComponent(createElement, updateElement) {
      const useElement = createElementHook(createElement, updateElement);
      const usePath = createPathHook(useElement);
      return createContainerComponent(usePath);
    }
    function createTileLayerComponent(createElement, updateElement) {
      const useElement = createElementHook(createElement, updateElement);
      const useLayer = createLayerHook(useElement);
      return createLeafComponent(useLayer);
    }
    function updateGridLayer(layer, props, prevProps) {
      const { opacity, zIndex } = props;
      if (opacity != null && opacity !== prevProps.opacity) {
        layer.setOpacity(opacity);
      }
      if (zIndex != null && zIndex !== prevProps.zIndex) {
        layer.setZIndex(zIndex);
      }
    }
    const CircleMarker = createPathComponent(function createCircleMarker(_a, ctx) {
      var _b = _a, { center, children: _c } = _b, options = __objRest(_b, ["center", "children"]);
      const marker = new leafletSrcExports.CircleMarker(center, options);
      return createElementObject(marker, extendContext(ctx, {
        overlayContainer: marker
      }));
    }, updateCircle);
    const useLayersControlElement = createElementHook(function createLayersControl(_c2, ctx) {
      var _d = _c2, { children: _c } = _d, options = __objRest(_d, ["children"]);
      const control = new leafletSrcExports.Control.Layers(void 0, void 0, options);
      return createElementObject(control, extendContext(ctx, {
        layersControl: control
      }));
    }, function updateLayersControl(control, props, prevProps) {
      if (props.collapsed !== prevProps.collapsed) {
        if (props.collapsed === true) {
          control.collapse();
        } else {
          control.expand();
        }
      }
    });
    const useLayersControl = createControlHook(useLayersControlElement);
    const LayersControl = createContainerComponent(useLayersControl);
    function createControlledLayer(addLayerToControl) {
      return function ControlledLayer(props) {
        const parentContext = useLeafletContext();
        const propsRef = reactExports.useRef(props);
        const [layer, setLayer] = reactExports.useState(null);
        const { layersControl, map: map2 } = parentContext;
        const addLayer = reactExports.useCallback((layerToAdd) => {
          if (layersControl != null) {
            if (propsRef.current.checked) {
              map2.addLayer(layerToAdd);
            }
            addLayerToControl(layersControl, layerToAdd, propsRef.current.name);
            setLayer(layerToAdd);
          }
        }, [
          layersControl,
          map2
        ]);
        const removeLayer = reactExports.useCallback((layerToRemove) => {
          layersControl == null ? void 0 : layersControl.removeLayer(layerToRemove);
          setLayer(null);
        }, [
          layersControl
        ]);
        const context = reactExports.useMemo(() => {
          return extendContext(parentContext, {
            layerContainer: {
              addLayer,
              removeLayer
            }
          });
        }, [
          parentContext,
          addLayer,
          removeLayer
        ]);
        reactExports.useEffect(() => {
          if (layer !== null && propsRef.current !== props) {
            if (props.checked === true && (propsRef.current.checked == null || propsRef.current.checked === false)) {
              map2.addLayer(layer);
            } else if (propsRef.current.checked === true && (props.checked == null || props.checked === false)) {
              map2.removeLayer(layer);
            }
            propsRef.current = props;
          }
        });
        return props.children ? /* @__PURE__ */ React$3.createElement(LeafletProvider, {
          value: context
        }, props.children) : null;
      };
    }
    LayersControl.BaseLayer = createControlledLayer(function addBaseLayer(layersControl, layer, name) {
      layersControl.addBaseLayer(layer, name);
    });
    LayersControl.Overlay = createControlledLayer(function addOverlay(layersControl, layer, name) {
      layersControl.addOverlay(layer, name);
    });
    function _extends$v() {
      _extends$v = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$v.apply(this, arguments);
    }
    function MapContainerComponent(_e, forwardedRef) {
      var _f = _e, { bounds, boundsOptions, center, children, className, id: id2, placeholder, style, whenReady, zoom } = _f, options = __objRest(_f, ["bounds", "boundsOptions", "center", "children", "className", "id", "placeholder", "style", "whenReady", "zoom"]);
      const [props] = reactExports.useState({
        className,
        id: id2,
        style
      });
      const [context, setContext] = reactExports.useState(null);
      reactExports.useImperativeHandle(forwardedRef, () => {
        var _a;
        return (_a = context == null ? void 0 : context.map) != null ? _a : null;
      }, [
        context
      ]);
      const mapRef = reactExports.useCallback((node) => {
        if (node !== null && context === null) {
          const map2 = new leafletSrcExports.Map(node, options);
          if (center != null && zoom != null) {
            map2.setView(center, zoom);
          } else if (bounds != null) {
            map2.fitBounds(bounds, boundsOptions);
          }
          if (whenReady != null) {
            map2.whenReady(whenReady);
          }
          setContext(createLeafletContext(map2));
        }
      }, []);
      reactExports.useEffect(() => {
        return () => {
          context == null ? void 0 : context.map.remove();
        };
      }, [
        context
      ]);
      const contents = context ? /* @__PURE__ */ React$3.createElement(LeafletProvider, {
        value: context
      }, children) : placeholder != null ? placeholder : null;
      return /* @__PURE__ */ React$3.createElement("div", _extends$v({}, props, {
        ref: mapRef
      }), contents);
    }
    const MapContainer = /* @__PURE__ */ reactExports.forwardRef(MapContainerComponent);
    const Popup = createOverlayComponent(function createPopup(props, context) {
      const popup = new leafletSrcExports.Popup(props, context.overlayContainer);
      return createElementObject(popup, context);
    }, function usePopupLifecycle(element, context, { position }, setOpen) {
      reactExports.useEffect(function addPopup() {
        const { instance } = element;
        function onPopupOpen(event) {
          if (event.popup === instance) {
            instance.update();
            setOpen(true);
          }
        }
        function onPopupClose(event) {
          if (event.popup === instance) {
            setOpen(false);
          }
        }
        context.map.on({
          popupopen: onPopupOpen,
          popupclose: onPopupClose
        });
        if (context.overlayContainer == null) {
          if (position != null) {
            instance.setLatLng(position);
          }
          instance.openOn(context.map);
        } else {
          context.overlayContainer.bindPopup(instance);
        }
        return function removePopup() {
          var _a;
          context.map.off({
            popupopen: onPopupOpen,
            popupclose: onPopupClose
          });
          (_a = context.overlayContainer) == null ? void 0 : _a.unbindPopup();
          context.map.removeLayer(instance);
        };
      }, [
        element,
        context,
        setOpen,
        position
      ]);
    });
    const TileLayer = createTileLayerComponent(function createTileLayer(_g, context) {
      var _h = _g, { url } = _h, options = __objRest(_h, ["url"]);
      const layer = new leafletSrcExports.TileLayer(url, withPane(options, context));
      return createElementObject(layer, context);
    }, function updateTileLayer(layer, props, prevProps) {
      updateGridLayer(layer, props, prevProps);
      const { url } = props;
      if (url != null && url !== prevProps.url) {
        layer.setUrl(url);
      }
    });
    const icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAApCAYAAADAk4LOAAAFgUlEQVR4Aa1XA5BjWRTN2oW17d3YaZtr2962HUzbDNpjszW24mRt28p47v7zq/bXZtrp/lWnXr337j3nPCe85NcypgSFdugCpW5YoDAMRaIMqRi6aKq5E3YqDQO3qAwjVWrD8Ncq/RBpykd8oZUb/kaJutow8r1aP9II0WmLKLIsJyv1w/kqw9Ch2MYdB++12Onxee/QMwvf4/Dk/Lfp/i4nxTXtOoQ4pW5Aj7wpici1A9erdAN2OH64x8OSP9j3Ft3b7aWkTg/Fm91siTra0f9on5sQr9INejH6CUUUpavjFNq1B+Oadhxmnfa8RfEmN8VNAsQhPqF55xHkMzz3jSmChWU6f7/XZKNH+9+hBLOHYozuKQPxyMPUKkrX/K0uWnfFaJGS1QPRtZsOPtr3NsW0uyh6NNCOkU3Yz+bXbT3I8G3xE5EXLXtCXbbqwCO9zPQYPRTZ5vIDXD7U+w7rFDEoUUf7ibHIR4y6bLVPXrz8JVZEql13trxwue/uDivd3fkWRbS6/IA2bID4uk0UpF1N8qLlbBlXs4Ee7HLTfV1j54APvODnSfOWBqtKVvjgLKzF5YdEk5ewRkGlK0i33Eofffc7HT56jD7/6U+qH3Cx7SBLNntH5YIPvODnyfIXZYRVDPqgHtLs5ABHD3YzLuespb7t79FY34DjMwrVrcTuwlT55YMPvOBnRrJ4VXTdNnYug5ucHLBjEpt30701A3Ts+HEa73u6dT3FNWwflY86eMHPk+Yu+i6pzUpRrW7SNDg5JHR4KapmM5Wv2E8Tfcb1HoqqHMHU+uWDD7zg54mz5/2BSnizi9T1Dg4QQXLToGNCkb6tb1NU+QAlGr1++eADrzhn/u8Q2YZhQVlZ5+CAOtqfbhmaUCS1ezNFVm2imDbPmPng5wmz+gwh+oHDce0eUtQ6OGDIyR0uUhUsoO3vfDmmgOezH0mZN59x7MBi++WDL1g/eEiU3avlidO671bkLfwbw5XV2P8Pzo0ydy4t2/0eu33xYSOMOD8hTf4CrBtGMSoXfPLchX+J0ruSePw3LZeK0juPJbYzrhkH0io7B3k164hiGvawhOKMLkrQLyVpZg8rHFW7E2uHOL888IBPlNZ1FPzstSJM694fWr6RwpvcJK60+0HCILTBzZLFNdtAzJaohze60T8qBzyh5ZuOg5e7uwQppofEmf2++DYvmySqGBuKaicF1blQjhuHdvCIMvp8whTTfZzI7RldpwtSzL+F1+wkdZ2TBOW2gIF88PBTzD/gpeREAMEbxnJcaJHNHrpzji0gQCS6hdkEeYt9DF/2qPcEC8RM28Hwmr3sdNyht00byAut2k3gufWNtgtOEOFGUwcXWNDbdNbpgBGxEvKkOQsxivJx33iow0Vw5S6SVTrpVq11ysA2Rp7gTfPfktc6zhtXBBC+adRLshf6sG2RfHPZ5EAc4sVZ83yCN00Fk/4kggu40ZTvIEm5g24qtU4KjBrx/BTTH8ifVASAG7gKrnWxJDcU7x8X6Ecczhm3o6YicvsLXWfh3Ch1W0k8x0nXF+0fFxgt4phz8QvypiwCCFKMqXCnqXExjq10beH+UUA7+nG6mdG/Pu0f3LgFcGrl2s0kNNjpmoJ9o4B29CMO8dMT4Q5ox8uitF6fqsrJOr8qnwNbRzv6hSnG5wP+64C7h9lp30hKNtKdWjtdkbuPA19nJ7Tz3zR/ibgARbhb4AlhavcBebmTHcFl2fvYEnW0ox9xMxKBS8btJ+KiEbq9zA4RthQXDhPa0T9TEe69gWupwc6uBUphquXgf+/FrIjweHQS4/pduMe5ERUMHUd9xv8ZR98CxkS4F2n3EUrUZ10EYNw7BWm9x1GiPssi3GgiGRDKWRYZfXlON+dfNbM+GgIwYdwAAAAASUVORK5CYII=";
    const iconShadow = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAApCAQAAAACach9AAACMUlEQVR4Ae3ShY7jQBAE0Aoz/f9/HTMzhg1zrdKUrJbdx+Kd2nD8VNudfsL/Th///dyQN2TH6f3y/BGpC379rV+S+qqetBOxImNQXL8JCAr2V4iMQXHGNJxeCfZXhSRBcQMfvkOWUdtfzlLgAENmZDcmo2TVmt8OSM2eXxBp3DjHSMFutqS7SbmemzBiR+xpKCNUIRkdkkYxhAkyGoBvyQFEJEefwSmmvBfJuJ6aKqKWnAkvGZOaZXTUgFqYULWNSHUckZuR1HIIimUExutRxwzOLROIG4vKmCKQt364mIlhSyzAf1m9lHZHJZrlAOMMztRRiKimp/rpdJDc9Awry5xTZCte7FHtuS8wJgeYGrex28xNTd086Dik7vUMscQOa8y4DoGtCCSkAKlNwpgNtphjrC6MIHUkR6YWxxs6Sc5xqn222mmCRFzIt8lEdKx+ikCtg91qS2WpwVfBelJCiQJwvzixfI9cxZQWgiSJelKnwBElKYtDOb2MFbhmUigbReQBV0Cg4+qMXSxXSyGUn4UbF8l+7qdSGnTC0XLCmahIgUHLhLOhpVCtw4CzYXvLQWQbJNmxoCsOKAxSgBJno75avolkRw8iIAFcsdc02e9iyCd8tHwmeSSoKTowIgvscSGZUOA7PuCN5b2BX9mQM7S0wYhMNU74zgsPBj3HU7wguAfnxxjFQGBE6pwN+GjME9zHY7zGp8wVxMShYX9NXvEWD3HbwJf4giO4CFIQxXScH1/TM+04kkBiAAAAAElFTkSuQmCC";
    let DefaultIcon = L$1.icon({
      iconUrl: icon,
      shadowUrl: iconShadow,
      iconSize: [25, 41],
      iconAnchor: [12, 41]
    });
    L$1.Marker.prototype.options.icon = DefaultIcon;
    const RiskMap = () => {
      const [locations, setLocations] = reactExports.useState([]);
      reactExports.useEffect(() => {
        const fetchLocations = () => __async(exports, null, function* () {
          try {
            const response = yield api.get("/godowns");
            if (response.success) {
              const mappedData = response.data.map((g) => ({
                id: g.id,
                lat: g.lat,
                lng: g.lng,
                name: g.name,
                risk: g.riskScore > 75 ? "High" : g.riskScore > 40 ? "Medium" : "Low",
                stock: Math.floor(g.capacity * 0.8),
                // Simulated visual stock
                humidity: g.riskScore > 75 ? 18 : 12
                // Simulated correlation
              }));
              setLocations(mappedData);
            }
          } catch (err) {
            console.error(err);
          }
        });
        fetchLocations();
      }, []);
      const getColor = (risk) => {
        if (risk === "High") return "#ef4444";
        if (risk === "Medium") return "#f97316";
        return "#10b981";
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-[500px] w-full bg-slate-100 rounded-xl overflow-hidden shadow-inner border border-slate-200 relative z-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MapContainer, { center: [10.7905, 78.7047], zoom: 7, scrollWheelZoom: true, className: "h-full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(LayersControl, { position: "topright", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(LayersControl.BaseLayer, { checked: true, name: "Street Map", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          TileLayer,
          {
            attribution: " OpenStreetMap contributors",
            url: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(LayersControl.BaseLayer, { name: "Satellite (Precision)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          TileLayer,
          {
            attribution: "Tiles  Esri  Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community",
            url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}"
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(LayersControl.Overlay, { checked: true, name: "Risk Locations", children: /* @__PURE__ */ jsxRuntimeExports.jsx(React$3.Fragment, { children: locations.map((loc) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          CircleMarker,
          {
            center: [loc.lat, loc.lng],
            pathOptions: { color: getColor(loc.risk), fillColor: getColor(loc.risk), fillOpacity: 0.7 },
            radius: 12,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Popup, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-1 min-w-[200px]", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { className: "text-sm font-bold block mb-1", children: loc.name }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `text-xs px-2 py-0.5 rounded text-white ${loc.risk === "High" ? "bg-red-500" : "bg-green-500"}`, children: [
                  loc.risk,
                  " Risk"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "a",
                  {
                    href: `https://www.google.com/maps?layer=c&cbll=${loc.lat},${loc.lng}`,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    className: "text-blue-600 text-xs font-bold underline",
                    children: "Street View 360"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-gray-600 space-y-1", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  "Stock: ",
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("b", { children: [
                    loc.stock,
                    " MT"
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  "Humidity: ",
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("b", { children: [
                    loc.humidity,
                    "%"
                  ] })
                ] })
              ] })
            ] }) })
          },
          loc.id
        )) }) })
      ] }) }) });
    };
    function r(e) {
      var t2, f2, n2 = "";
      if ("string" == typeof e || "number" == typeof e) n2 += e;
      else if ("object" == typeof e) if (Array.isArray(e)) {
        var o = e.length;
        for (t2 = 0; t2 < o; t2++) e[t2] && (f2 = r(e[t2])) && (n2 && (n2 += " "), n2 += f2);
      } else for (f2 in e) e[f2] && (n2 && (n2 += " "), n2 += f2);
      return n2;
    }
    function clsx() {
      for (var e, t2, f2 = 0, n2 = "", o = arguments.length; f2 < o; f2++) (e = arguments[f2]) && (t2 = r(e)) && (n2 && (n2 += " "), n2 += t2);
      return n2;
    }
    var EventKeys = ["dangerouslySetInnerHTML", "onCopy", "onCopyCapture", "onCut", "onCutCapture", "onPaste", "onPasteCapture", "onCompositionEnd", "onCompositionEndCapture", "onCompositionStart", "onCompositionStartCapture", "onCompositionUpdate", "onCompositionUpdateCapture", "onFocus", "onFocusCapture", "onBlur", "onBlurCapture", "onChange", "onChangeCapture", "onBeforeInput", "onBeforeInputCapture", "onInput", "onInputCapture", "onReset", "onResetCapture", "onSubmit", "onSubmitCapture", "onInvalid", "onInvalidCapture", "onLoad", "onLoadCapture", "onError", "onErrorCapture", "onKeyDown", "onKeyDownCapture", "onKeyPress", "onKeyPressCapture", "onKeyUp", "onKeyUpCapture", "onAbort", "onAbortCapture", "onCanPlay", "onCanPlayCapture", "onCanPlayThrough", "onCanPlayThroughCapture", "onDurationChange", "onDurationChangeCapture", "onEmptied", "onEmptiedCapture", "onEncrypted", "onEncryptedCapture", "onEnded", "onEndedCapture", "onLoadedData", "onLoadedDataCapture", "onLoadedMetadata", "onLoadedMetadataCapture", "onLoadStart", "onLoadStartCapture", "onPause", "onPauseCapture", "onPlay", "onPlayCapture", "onPlaying", "onPlayingCapture", "onProgress", "onProgressCapture", "onRateChange", "onRateChangeCapture", "onSeeked", "onSeekedCapture", "onSeeking", "onSeekingCapture", "onStalled", "onStalledCapture", "onSuspend", "onSuspendCapture", "onTimeUpdate", "onTimeUpdateCapture", "onVolumeChange", "onVolumeChangeCapture", "onWaiting", "onWaitingCapture", "onAuxClick", "onAuxClickCapture", "onClick", "onClickCapture", "onContextMenu", "onContextMenuCapture", "onDoubleClick", "onDoubleClickCapture", "onDrag", "onDragCapture", "onDragEnd", "onDragEndCapture", "onDragEnter", "onDragEnterCapture", "onDragExit", "onDragExitCapture", "onDragLeave", "onDragLeaveCapture", "onDragOver", "onDragOverCapture", "onDragStart", "onDragStartCapture", "onDrop", "onDropCapture", "onMouseDown", "onMouseDownCapture", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseMoveCapture", "onMouseOut", "onMouseOutCapture", "onMouseOver", "onMouseOverCapture", "onMouseUp", "onMouseUpCapture", "onSelect", "onSelectCapture", "onTouchCancel", "onTouchCancelCapture", "onTouchEnd", "onTouchEndCapture", "onTouchMove", "onTouchMoveCapture", "onTouchStart", "onTouchStartCapture", "onPointerDown", "onPointerDownCapture", "onPointerMove", "onPointerMoveCapture", "onPointerUp", "onPointerUpCapture", "onPointerCancel", "onPointerCancelCapture", "onPointerEnter", "onPointerEnterCapture", "onPointerLeave", "onPointerLeaveCapture", "onPointerOver", "onPointerOverCapture", "onPointerOut", "onPointerOutCapture", "onGotPointerCapture", "onGotPointerCaptureCapture", "onLostPointerCapture", "onLostPointerCaptureCapture", "onScroll", "onScrollCapture", "onWheel", "onWheelCapture", "onAnimationStart", "onAnimationStartCapture", "onAnimationEnd", "onAnimationEndCapture", "onAnimationIteration", "onAnimationIterationCapture", "onTransitionEnd", "onTransitionEndCapture"];
    function isEventKey(key) {
      if (typeof key !== "string") {
        return false;
      }
      var allowedEventKeys = EventKeys;
      return allowedEventKeys.includes(key);
    }
    var SVGElementPropKeys = [
      "aria-activedescendant",
      "aria-atomic",
      "aria-autocomplete",
      "aria-busy",
      "aria-checked",
      "aria-colcount",
      "aria-colindex",
      "aria-colspan",
      "aria-controls",
      "aria-current",
      "aria-describedby",
      "aria-details",
      "aria-disabled",
      "aria-errormessage",
      "aria-expanded",
      "aria-flowto",
      "aria-haspopup",
      "aria-hidden",
      "aria-invalid",
      "aria-keyshortcuts",
      "aria-label",
      "aria-labelledby",
      "aria-level",
      "aria-live",
      "aria-modal",
      "aria-multiline",
      "aria-multiselectable",
      "aria-orientation",
      "aria-owns",
      "aria-placeholder",
      "aria-posinset",
      "aria-pressed",
      "aria-readonly",
      "aria-relevant",
      "aria-required",
      "aria-roledescription",
      "aria-rowcount",
      "aria-rowindex",
      "aria-rowspan",
      "aria-selected",
      "aria-setsize",
      "aria-sort",
      "aria-valuemax",
      "aria-valuemin",
      "aria-valuenow",
      "aria-valuetext",
      "className",
      "color",
      "height",
      "id",
      "lang",
      "max",
      "media",
      "method",
      "min",
      "name",
      "style",
      /*
       * removed 'type' SVGElementPropKey because we do not currently use any SVG elements
       * that can use it, and it conflicts with the recharts prop 'type'
       * https://github.com/recharts/recharts/pull/3327
       * https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/type
       */
      // 'type',
      "target",
      "width",
      "role",
      "tabIndex",
      "accentHeight",
      "accumulate",
      "additive",
      "alignmentBaseline",
      "allowReorder",
      "alphabetic",
      "amplitude",
      "arabicForm",
      "ascent",
      "attributeName",
      "attributeType",
      "autoReverse",
      "azimuth",
      "baseFrequency",
      "baselineShift",
      "baseProfile",
      "bbox",
      "begin",
      "bias",
      "by",
      "calcMode",
      "capHeight",
      "clip",
      "clipPath",
      "clipPathUnits",
      "clipRule",
      "colorInterpolation",
      "colorInterpolationFilters",
      "colorProfile",
      "colorRendering",
      "contentScriptType",
      "contentStyleType",
      "cursor",
      "cx",
      "cy",
      "d",
      "decelerate",
      "descent",
      "diffuseConstant",
      "direction",
      "display",
      "divisor",
      "dominantBaseline",
      "dur",
      "dx",
      "dy",
      "edgeMode",
      "elevation",
      "enableBackground",
      "end",
      "exponent",
      "externalResourcesRequired",
      "fill",
      "fillOpacity",
      "fillRule",
      "filter",
      "filterRes",
      "filterUnits",
      "floodColor",
      "floodOpacity",
      "focusable",
      "fontFamily",
      "fontSize",
      "fontSizeAdjust",
      "fontStretch",
      "fontStyle",
      "fontVariant",
      "fontWeight",
      "format",
      "from",
      "fx",
      "fy",
      "g1",
      "g2",
      "glyphName",
      "glyphOrientationHorizontal",
      "glyphOrientationVertical",
      "glyphRef",
      "gradientTransform",
      "gradientUnits",
      "hanging",
      "horizAdvX",
      "horizOriginX",
      "href",
      "ideographic",
      "imageRendering",
      "in2",
      "in",
      "intercept",
      "k1",
      "k2",
      "k3",
      "k4",
      "k",
      "kernelMatrix",
      "kernelUnitLength",
      "kerning",
      "keyPoints",
      "keySplines",
      "keyTimes",
      "lengthAdjust",
      "letterSpacing",
      "lightingColor",
      "limitingConeAngle",
      "local",
      "markerEnd",
      "markerHeight",
      "markerMid",
      "markerStart",
      "markerUnits",
      "markerWidth",
      "mask",
      "maskContentUnits",
      "maskUnits",
      "mathematical",
      "mode",
      "numOctaves",
      "offset",
      "opacity",
      "operator",
      "order",
      "orient",
      "orientation",
      "origin",
      "overflow",
      "overlinePosition",
      "overlineThickness",
      "paintOrder",
      "panose1",
      "pathLength",
      "patternContentUnits",
      "patternTransform",
      "patternUnits",
      "pointerEvents",
      "pointsAtX",
      "pointsAtY",
      "pointsAtZ",
      "preserveAlpha",
      "preserveAspectRatio",
      "primitiveUnits",
      "r",
      "radius",
      "refX",
      "refY",
      "renderingIntent",
      "repeatCount",
      "repeatDur",
      "requiredExtensions",
      "requiredFeatures",
      "restart",
      "result",
      "rotate",
      "rx",
      "ry",
      "seed",
      "shapeRendering",
      "slope",
      "spacing",
      "specularConstant",
      "specularExponent",
      "speed",
      "spreadMethod",
      "startOffset",
      "stdDeviation",
      "stemh",
      "stemv",
      "stitchTiles",
      "stopColor",
      "stopOpacity",
      "strikethroughPosition",
      "strikethroughThickness",
      "string",
      "stroke",
      "strokeDasharray",
      "strokeDashoffset",
      "strokeLinecap",
      "strokeLinejoin",
      "strokeMiterlimit",
      "strokeOpacity",
      "strokeWidth",
      "surfaceScale",
      "systemLanguage",
      "tableValues",
      "targetX",
      "targetY",
      "textAnchor",
      "textDecoration",
      "textLength",
      "textRendering",
      "to",
      "transform",
      "u1",
      "u2",
      "underlinePosition",
      "underlineThickness",
      "unicode",
      "unicodeBidi",
      "unicodeRange",
      "unitsPerEm",
      "vAlphabetic",
      "values",
      "vectorEffect",
      "version",
      "vertAdvY",
      "vertOriginX",
      "vertOriginY",
      "vHanging",
      "vIdeographic",
      "viewTarget",
      "visibility",
      "vMathematical",
      "widths",
      "wordSpacing",
      "writingMode",
      "x1",
      "x2",
      "x",
      "xChannelSelector",
      "xHeight",
      "xlinkActuate",
      "xlinkArcrole",
      "xlinkHref",
      "xlinkRole",
      "xlinkShow",
      "xlinkTitle",
      "xlinkType",
      "xmlBase",
      "xmlLang",
      "xmlns",
      "xmlnsXlink",
      "xmlSpace",
      "y1",
      "y2",
      "y",
      "yChannelSelector",
      "z",
      "zoomAndPan",
      "ref",
      "key",
      "angle"
    ];
    var SVGElementPropKeySet = new Set(SVGElementPropKeys);
    function isSvgElementPropKey(key) {
      if (typeof key !== "string") {
        return false;
      }
      return SVGElementPropKeySet.has(key);
    }
    function isDataAttribute(key) {
      return typeof key === "string" && key.startsWith("data-");
    }
    function svgPropertiesNoEvents(obj) {
      if (typeof obj !== "object" || obj === null) {
        return {};
      }
      var result = {};
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          if (isSvgElementPropKey(key) || isDataAttribute(key)) {
            result[key] = obj[key];
          }
        }
      }
      return result;
    }
    function svgPropertiesNoEventsFromUnknown(input) {
      if (input == null) {
        return null;
      }
      if (/* @__PURE__ */ reactExports.isValidElement(input) && typeof input.props === "object" && input.props !== null) {
        var p2 = input.props;
        return svgPropertiesNoEvents(p2);
      }
      if (typeof input === "object" && !Array.isArray(input)) {
        return svgPropertiesNoEvents(input);
      }
      return null;
    }
    function svgPropertiesAndEvents(obj) {
      var result = {};
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          if (isSvgElementPropKey(key) || isDataAttribute(key) || isEventKey(key)) {
            result[key] = obj[key];
          }
        }
      }
      return result;
    }
    function svgPropertiesAndEventsFromUnknown(input) {
      if (input == null) {
        return null;
      }
      if (/* @__PURE__ */ reactExports.isValidElement(input)) {
        return svgPropertiesAndEvents(input.props);
      }
      if (typeof input === "object" && !Array.isArray(input)) {
        return svgPropertiesAndEvents(input);
      }
      return null;
    }
    var _excluded$p = ["children", "width", "height", "viewBox", "className", "style", "title", "desc"];
    function _extends$u() {
      return _extends$u = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$u.apply(null, arguments);
    }
    function _objectWithoutProperties$p(e, t2) {
      if (null == e) return {};
      var o, r2, i = _objectWithoutPropertiesLoose$p(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e);
        for (r2 = 0; r2 < n2.length; r2++) o = n2[r2], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose$p(r2, e) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    var Surface = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var {
        children,
        width,
        height,
        viewBox,
        className,
        style,
        title,
        desc
      } = props, others = _objectWithoutProperties$p(props, _excluded$p);
      var svgView = viewBox || {
        width,
        height,
        x: 0,
        y: 0
      };
      var layerClass = clsx("recharts-surface", className);
      return /* @__PURE__ */ reactExports.createElement("svg", _extends$u({}, svgPropertiesAndEvents(others), {
        className: layerClass,
        width,
        height,
        style,
        viewBox: "".concat(svgView.x, " ").concat(svgView.y, " ").concat(svgView.width, " ").concat(svgView.height),
        ref
      }), /* @__PURE__ */ reactExports.createElement("title", null, title), /* @__PURE__ */ reactExports.createElement("desc", null, desc), children);
    });
    var _excluded$o = ["children", "className"];
    function _extends$t() {
      return _extends$t = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$t.apply(null, arguments);
    }
    function _objectWithoutProperties$o(e, t2) {
      if (null == e) return {};
      var o, r2, i = _objectWithoutPropertiesLoose$o(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e);
        for (r2 = 0; r2 < n2.length; r2++) o = n2[r2], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose$o(r2, e) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    var Layer = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var {
        children,
        className
      } = props, others = _objectWithoutProperties$o(props, _excluded$o);
      var layerClass = clsx("recharts-layer", className);
      return /* @__PURE__ */ reactExports.createElement("g", _extends$t({
        className: layerClass
      }, svgPropertiesAndEvents(others), {
        ref
      }), children);
    });
    var LegendPortalContext = /* @__PURE__ */ reactExports.createContext(null);
    var useLegendPortal = () => reactExports.useContext(LegendPortalContext);
    function constant$1(x2) {
      return function constant2() {
        return x2;
      };
    }
    const cos = Math.cos;
    const sin = Math.sin;
    const sqrt$1 = Math.sqrt;
    const pi$1 = Math.PI;
    const tau$1 = 2 * pi$1;
    const pi = Math.PI, tau = 2 * pi, epsilon = 1e-6, tauEpsilon = tau - epsilon;
    function append(strings) {
      this._ += strings[0];
      for (let i = 1, n2 = strings.length; i < n2; ++i) {
        this._ += arguments[i] + strings[i];
      }
    }
    function appendRound(digits) {
      let d = Math.floor(digits);
      if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
      if (d > 15) return append;
      const k2 = __pow(10, d);
      return function(strings) {
        this._ += strings[0];
        for (let i = 1, n2 = strings.length; i < n2; ++i) {
          this._ += Math.round(arguments[i] * k2) / k2 + strings[i];
        }
      };
    }
    class Path {
      constructor(digits) {
        this._x0 = this._y0 = // start of current subpath
        this._x1 = this._y1 = null;
        this._ = "";
        this._append = digits == null ? append : appendRound(digits);
      }
      moveTo(x2, y2) {
        this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
      }
      closePath() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._append`Z`;
        }
      }
      lineTo(x2, y2) {
        this._append`L${this._x1 = +x2},${this._y1 = +y2}`;
      }
      quadraticCurveTo(x1, y1, x2, y2) {
        this._append`Q${+x1},${+y1},${this._x1 = +x2},${this._y1 = +y2}`;
      }
      bezierCurveTo(x1, y1, x2, y2, x3, y3) {
        this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x3},${this._y1 = +y3}`;
      }
      arcTo(x1, y1, x2, y2, r2) {
        x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r2 = +r2;
        if (r2 < 0) throw new Error(`negative radius: ${r2}`);
        let x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
        if (this._x1 === null) {
          this._append`M${this._x1 = x1},${this._y1 = y1}`;
        } else if (!(l01_2 > epsilon)) ;
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r2) {
          this._append`L${this._x1 = x1},${this._y1 = y1}`;
        } else {
          let x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l2 = r2 * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l2 / l01, t21 = l2 / l21;
          if (Math.abs(t01 - 1) > epsilon) {
            this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
          }
          this._append`A${r2},${r2},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
        }
      }
      arc(x2, y2, r2, a0, a1, ccw) {
        x2 = +x2, y2 = +y2, r2 = +r2, ccw = !!ccw;
        if (r2 < 0) throw new Error(`negative radius: ${r2}`);
        let dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da2 = ccw ? a0 - a1 : a1 - a0;
        if (this._x1 === null) {
          this._append`M${x0},${y0}`;
        } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
          this._append`L${x0},${y0}`;
        }
        if (!r2) return;
        if (da2 < 0) da2 = da2 % tau + tau;
        if (da2 > tauEpsilon) {
          this._append`A${r2},${r2},0,1,${cw},${x2 - dx},${y2 - dy}A${r2},${r2},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
        } else if (da2 > epsilon) {
          this._append`A${r2},${r2},0,${+(da2 >= pi)},${cw},${this._x1 = x2 + r2 * Math.cos(a1)},${this._y1 = y2 + r2 * Math.sin(a1)}`;
        }
      }
      rect(x2, y2, w2, h) {
        this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${w2 = +w2}v${+h}h${-w2}Z`;
      }
      toString() {
        return this._;
      }
    }
    function withPath(shape) {
      let digits = 3;
      shape.digits = function(_) {
        if (!arguments.length) return digits;
        if (_ == null) {
          digits = null;
        } else {
          const d = Math.floor(_);
          if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
          digits = d;
        }
        return shape;
      };
      return () => new Path(digits);
    }
    function array(x2) {
      return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
    }
    function Linear(context) {
      this._context = context;
    }
    Linear.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
            break;
          case 1:
            this._point = 2;
          default:
            this._context.lineTo(x2, y2);
            break;
        }
      }
    };
    function curveLinear(context) {
      return new Linear(context);
    }
    function x(p2) {
      return p2[0];
    }
    function y(p2) {
      return p2[1];
    }
    function shapeLine(x$12, y$12) {
      var defined2 = constant$1(true), context = null, curve = curveLinear, output = null, path = withPath(line);
      x$12 = typeof x$12 === "function" ? x$12 : x$12 === void 0 ? x : constant$1(x$12);
      y$12 = typeof y$12 === "function" ? y$12 : y$12 === void 0 ? y : constant$1(y$12);
      function line(data) {
        var i, n2 = (data = array(data)).length, d, defined0 = false, buffer;
        if (context == null) output = curve(buffer = path());
        for (i = 0; i <= n2; ++i) {
          if (!(i < n2 && defined2(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) output.lineStart();
            else output.lineEnd();
          }
          if (defined0) output.point(+x$12(d, i, data), +y$12(d, i, data));
        }
        if (buffer) return output = null, buffer + "" || null;
      }
      line.x = function(_) {
        return arguments.length ? (x$12 = typeof _ === "function" ? _ : constant$1(+_), line) : x$12;
      };
      line.y = function(_) {
        return arguments.length ? (y$12 = typeof _ === "function" ? _ : constant$1(+_), line) : y$12;
      };
      line.defined = function(_) {
        return arguments.length ? (defined2 = typeof _ === "function" ? _ : constant$1(!!_), line) : defined2;
      };
      line.curve = function(_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
      };
      line.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
      };
      return line;
    }
    function shapeArea(x0, y0, y1) {
      var x1 = null, defined2 = constant$1(true), context = null, curve = curveLinear, output = null, path = withPath(area);
      x0 = typeof x0 === "function" ? x0 : x0 === void 0 ? x : constant$1(+x0);
      y0 = typeof y0 === "function" ? y0 : y0 === void 0 ? constant$1(0) : constant$1(+y0);
      y1 = typeof y1 === "function" ? y1 : y1 === void 0 ? y : constant$1(+y1);
      function area(data) {
        var i, j, k2, n2 = (data = array(data)).length, d, defined0 = false, buffer, x0z = new Array(n2), y0z = new Array(n2);
        if (context == null) output = curve(buffer = path());
        for (i = 0; i <= n2; ++i) {
          if (!(i < n2 && defined2(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) {
              j = i;
              output.areaStart();
              output.lineStart();
            } else {
              output.lineEnd();
              output.lineStart();
              for (k2 = i - 1; k2 >= j; --k2) {
                output.point(x0z[k2], y0z[k2]);
              }
              output.lineEnd();
              output.areaEnd();
            }
          }
          if (defined0) {
            x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
            output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
          }
        }
        if (buffer) return output = null, buffer + "" || null;
      }
      function arealine() {
        return shapeLine().defined(defined2).curve(curve).context(context);
      }
      area.x = function(_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$1(+_), x1 = null, area) : x0;
      };
      area.x0 = function(_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$1(+_), area) : x0;
      };
      area.x1 = function(_) {
        return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), area) : x1;
      };
      area.y = function(_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$1(+_), y1 = null, area) : y0;
      };
      area.y0 = function(_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$1(+_), area) : y0;
      };
      area.y1 = function(_) {
        return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), area) : y1;
      };
      area.lineX0 = area.lineY0 = function() {
        return arealine().x(x0).y(y0);
      };
      area.lineY1 = function() {
        return arealine().x(x0).y(y1);
      };
      area.lineX1 = function() {
        return arealine().x(x1).y(y0);
      };
      area.defined = function(_) {
        return arguments.length ? (defined2 = typeof _ === "function" ? _ : constant$1(!!_), area) : defined2;
      };
      area.curve = function(_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
      };
      area.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
      };
      return area;
    }
    class Bump {
      constructor(context, x2) {
        this._context = context;
        this._x = x2;
      }
      areaStart() {
        this._line = 0;
      }
      areaEnd() {
        this._line = NaN;
      }
      lineStart() {
        this._point = 0;
      }
      lineEnd() {
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        this._line = 1 - this._line;
      }
      point(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0: {
            this._point = 1;
            if (this._line) this._context.lineTo(x2, y2);
            else this._context.moveTo(x2, y2);
            break;
          }
          case 1:
            this._point = 2;
          default: {
            if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x2) / 2, this._y0, this._x0, y2, x2, y2);
            else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y2) / 2, x2, this._y0, x2, y2);
            break;
          }
        }
        this._x0 = x2, this._y0 = y2;
      }
    }
    function bumpX(context) {
      return new Bump(context, true);
    }
    function bumpY(context) {
      return new Bump(context, false);
    }
    const symbolCircle = {
      draw(context, size) {
        const r2 = sqrt$1(size / pi$1);
        context.moveTo(r2, 0);
        context.arc(0, 0, r2, 0, tau$1);
      }
    };
    const symbolCross = {
      draw(context, size) {
        const r2 = sqrt$1(size / 5) / 2;
        context.moveTo(-3 * r2, -r2);
        context.lineTo(-r2, -r2);
        context.lineTo(-r2, -3 * r2);
        context.lineTo(r2, -3 * r2);
        context.lineTo(r2, -r2);
        context.lineTo(3 * r2, -r2);
        context.lineTo(3 * r2, r2);
        context.lineTo(r2, r2);
        context.lineTo(r2, 3 * r2);
        context.lineTo(-r2, 3 * r2);
        context.lineTo(-r2, r2);
        context.lineTo(-3 * r2, r2);
        context.closePath();
      }
    };
    const tan30 = sqrt$1(1 / 3);
    const tan30_2 = tan30 * 2;
    const symbolDiamond = {
      draw(context, size) {
        const y2 = sqrt$1(size / tan30_2);
        const x2 = y2 * tan30;
        context.moveTo(0, -y2);
        context.lineTo(x2, 0);
        context.lineTo(0, y2);
        context.lineTo(-x2, 0);
        context.closePath();
      }
    };
    const symbolSquare = {
      draw(context, size) {
        const w2 = sqrt$1(size);
        const x2 = -w2 / 2;
        context.rect(x2, x2, w2, w2);
      }
    };
    const ka = 0.8908130915292852;
    const kr = sin(pi$1 / 10) / sin(7 * pi$1 / 10);
    const kx = sin(tau$1 / 10) * kr;
    const ky = -cos(tau$1 / 10) * kr;
    const symbolStar = {
      draw(context, size) {
        const r2 = sqrt$1(size * ka);
        const x2 = kx * r2;
        const y2 = ky * r2;
        context.moveTo(0, -r2);
        context.lineTo(x2, y2);
        for (let i = 1; i < 5; ++i) {
          const a2 = tau$1 * i / 5;
          const c2 = cos(a2);
          const s2 = sin(a2);
          context.lineTo(s2 * r2, -c2 * r2);
          context.lineTo(c2 * x2 - s2 * y2, s2 * x2 + c2 * y2);
        }
        context.closePath();
      }
    };
    const sqrt3 = sqrt$1(3);
    const symbolTriangle = {
      draw(context, size) {
        const y2 = -sqrt$1(size / (sqrt3 * 3));
        context.moveTo(0, y2 * 2);
        context.lineTo(-sqrt3 * y2, -y2);
        context.lineTo(sqrt3 * y2, -y2);
        context.closePath();
      }
    };
    const c = -0.5;
    const s = sqrt$1(3) / 2;
    const k = 1 / sqrt$1(12);
    const a = (k / 2 + 1) * 3;
    const symbolWye = {
      draw(context, size) {
        const r2 = sqrt$1(size / a);
        const x0 = r2 / 2, y0 = r2 * k;
        const x1 = x0, y1 = r2 * k + r2;
        const x2 = -x1, y2 = y1;
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
        context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
        context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
        context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
        context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
        context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
        context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
        context.closePath();
      }
    };
    function Symbol$1(type, size) {
      let context = null, path = withPath(symbol);
      type = typeof type === "function" ? type : constant$1(type || symbolCircle);
      size = typeof size === "function" ? size : constant$1(size === void 0 ? 64 : +size);
      function symbol() {
        let buffer;
        if (!context) context = buffer = path();
        type.apply(this, arguments).draw(context, +size.apply(this, arguments));
        if (buffer) return context = null, buffer + "" || null;
      }
      symbol.type = function(_) {
        return arguments.length ? (type = typeof _ === "function" ? _ : constant$1(_), symbol) : type;
      };
      symbol.size = function(_) {
        return arguments.length ? (size = typeof _ === "function" ? _ : constant$1(+_), symbol) : size;
      };
      symbol.context = function(_) {
        return arguments.length ? (context = _ == null ? null : _, symbol) : context;
      };
      return symbol;
    }
    function noop$3() {
    }
    function point$2(that, x2, y2) {
      that._context.bezierCurveTo(
        (2 * that._x0 + that._x1) / 3,
        (2 * that._y0 + that._y1) / 3,
        (that._x0 + 2 * that._x1) / 3,
        (that._y0 + 2 * that._y1) / 3,
        (that._x0 + 4 * that._x1 + x2) / 6,
        (that._y0 + 4 * that._y1 + y2) / 6
      );
    }
    function Basis(context) {
      this._context = context;
    }
    Basis.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 3:
            point$2(this, this._x1, this._y1);
          case 2:
            this._context.lineTo(this._x1, this._y1);
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
          default:
            point$2(this, x2, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = x2;
        this._y0 = this._y1, this._y1 = y2;
      }
    };
    function curveBasis(context) {
      return new Basis(context);
    }
    function BasisClosed(context) {
      this._context = context;
    }
    BasisClosed.prototype = {
      areaStart: noop$3,
      areaEnd: noop$3,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x2, this._y2);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
            this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x2, this._y2);
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            break;
          }
        }
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._x2 = x2, this._y2 = y2;
            break;
          case 1:
            this._point = 2;
            this._x3 = x2, this._y3 = y2;
            break;
          case 2:
            this._point = 3;
            this._x4 = x2, this._y4 = y2;
            this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
            break;
          default:
            point$2(this, x2, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = x2;
        this._y0 = this._y1, this._y1 = y2;
      }
    };
    function curveBasisClosed(context) {
      return new BasisClosed(context);
    }
    function BasisOpen(context) {
      this._context = context;
    }
    BasisOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            var x0 = (this._x0 + 4 * this._x1 + x2) / 6, y0 = (this._y0 + 4 * this._y1 + y2) / 6;
            this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
            break;
          case 3:
            this._point = 4;
          default:
            point$2(this, x2, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = x2;
        this._y0 = this._y1, this._y1 = y2;
      }
    };
    function curveBasisOpen(context) {
      return new BasisOpen(context);
    }
    function LinearClosed(context) {
      this._context = context;
    }
    LinearClosed.prototype = {
      areaStart: noop$3,
      areaEnd: noop$3,
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._point) this._context.closePath();
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        if (this._point) this._context.lineTo(x2, y2);
        else this._point = 1, this._context.moveTo(x2, y2);
      }
    };
    function curveLinearClosed(context) {
      return new LinearClosed(context);
    }
    function sign(x2) {
      return x2 < 0 ? -1 : 1;
    }
    function slope3(that, x2, y2) {
      var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p2 = (s0 * h1 + s1 * h0) / (h0 + h1);
      return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p2)) || 0;
    }
    function slope2(that, t2) {
      var h = that._x1 - that._x0;
      return h ? (3 * (that._y1 - that._y0) / h - t2) / 2 : t2;
    }
    function point$1(that, t02, t12) {
      var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
      that._context.bezierCurveTo(x0 + dx, y0 + dx * t02, x1 - dx, y1 - dx * t12, x1, y1);
    }
    function MonotoneX(context) {
      this._context = context;
    }
    MonotoneX.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x1, this._y1);
            break;
          case 3:
            point$1(this, this._t0, slope2(this, this._t0));
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        var t12 = NaN;
        x2 = +x2, y2 = +y2;
        if (x2 === this._x1 && y2 === this._y1) return;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            point$1(this, slope2(this, t12 = slope3(this, x2, y2)), t12);
            break;
          default:
            point$1(this, this._t0, t12 = slope3(this, x2, y2));
            break;
        }
        this._x0 = this._x1, this._x1 = x2;
        this._y0 = this._y1, this._y1 = y2;
        this._t0 = t12;
      }
    };
    function MonotoneY(context) {
      this._context = new ReflectContext(context);
    }
    (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y2) {
      MonotoneX.prototype.point.call(this, y2, x2);
    };
    function ReflectContext(context) {
      this._context = context;
    }
    ReflectContext.prototype = {
      moveTo: function(x2, y2) {
        this._context.moveTo(y2, x2);
      },
      closePath: function() {
        this._context.closePath();
      },
      lineTo: function(x2, y2) {
        this._context.lineTo(y2, x2);
      },
      bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
        this._context.bezierCurveTo(y1, x1, y2, x2, y3, x3);
      }
    };
    function monotoneX(context) {
      return new MonotoneX(context);
    }
    function monotoneY(context) {
      return new MonotoneY(context);
    }
    function Natural(context) {
      this._context = context;
    }
    Natural.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = [];
        this._y = [];
      },
      lineEnd: function() {
        var x2 = this._x, y2 = this._y, n2 = x2.length;
        if (n2) {
          this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
          if (n2 === 2) {
            this._context.lineTo(x2[1], y2[1]);
          } else {
            var px = controlPoints(x2), py = controlPoints(y2);
            for (var i0 = 0, i1 = 1; i1 < n2; ++i0, ++i1) {
              this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y2[i1]);
            }
          }
        }
        if (this._line || this._line !== 0 && n2 === 1) this._context.closePath();
        this._line = 1 - this._line;
        this._x = this._y = null;
      },
      point: function(x2, y2) {
        this._x.push(+x2);
        this._y.push(+y2);
      }
    };
    function controlPoints(x2) {
      var i, n2 = x2.length - 1, m2, a2 = new Array(n2), b = new Array(n2), r2 = new Array(n2);
      a2[0] = 0, b[0] = 2, r2[0] = x2[0] + 2 * x2[1];
      for (i = 1; i < n2 - 1; ++i) a2[i] = 1, b[i] = 4, r2[i] = 4 * x2[i] + 2 * x2[i + 1];
      a2[n2 - 1] = 2, b[n2 - 1] = 7, r2[n2 - 1] = 8 * x2[n2 - 1] + x2[n2];
      for (i = 1; i < n2; ++i) m2 = a2[i] / b[i - 1], b[i] -= m2, r2[i] -= m2 * r2[i - 1];
      a2[n2 - 1] = r2[n2 - 1] / b[n2 - 1];
      for (i = n2 - 2; i >= 0; --i) a2[i] = (r2[i] - a2[i + 1]) / b[i];
      b[n2 - 1] = (x2[n2] + a2[n2 - 1]) / 2;
      for (i = 0; i < n2 - 1; ++i) b[i] = 2 * x2[i + 1] - a2[i + 1];
      return [a2, b];
    }
    function curveNatural(context) {
      return new Natural(context);
    }
    function Step(context, t2) {
      this._context = context;
      this._t = t2;
    }
    Step.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = this._y = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
            break;
          case 1:
            this._point = 2;
          default: {
            if (this._t <= 0) {
              this._context.lineTo(this._x, y2);
              this._context.lineTo(x2, y2);
            } else {
              var x1 = this._x * (1 - this._t) + x2 * this._t;
              this._context.lineTo(x1, this._y);
              this._context.lineTo(x1, y2);
            }
            break;
          }
        }
        this._x = x2, this._y = y2;
      }
    };
    function curveStep(context) {
      return new Step(context, 0.5);
    }
    function stepBefore(context) {
      return new Step(context, 0);
    }
    function stepAfter(context) {
      return new Step(context, 1);
    }
    function stackOffsetNone(series, order) {
      if (!((n2 = series.length) > 1)) return;
      for (var i = 1, j, s0, s1 = series[order[0]], n2, m2 = s1.length; i < n2; ++i) {
        s0 = s1, s1 = series[order[i]];
        for (j = 0; j < m2; ++j) {
          s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
        }
      }
    }
    function stackOrderNone(series) {
      var n2 = series.length, o = new Array(n2);
      while (--n2 >= 0) o[n2] = n2;
      return o;
    }
    function stackValue(d, key) {
      return d[key];
    }
    function stackSeries(key) {
      const series = [];
      series.key = key;
      return series;
    }
    function shapeStack() {
      var keys = constant$1([]), order = stackOrderNone, offset = stackOffsetNone, value = stackValue;
      function stack(data) {
        var sz = Array.from(keys.apply(this, arguments), stackSeries), i, n2 = sz.length, j = -1, oz;
        for (const d of data) {
          for (i = 0, ++j; i < n2; ++i) {
            (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
          }
        }
        for (i = 0, oz = array(order(sz)); i < n2; ++i) {
          sz[oz[i]].index = i;
        }
        offset(sz, oz);
        return sz;
      }
      stack.keys = function(_) {
        return arguments.length ? (keys = typeof _ === "function" ? _ : constant$1(Array.from(_)), stack) : keys;
      };
      stack.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$1(+_), stack) : value;
      };
      stack.order = function(_) {
        return arguments.length ? (order = _ == null ? stackOrderNone : typeof _ === "function" ? _ : constant$1(Array.from(_)), stack) : order;
      };
      stack.offset = function(_) {
        return arguments.length ? (offset = _ == null ? stackOffsetNone : _, stack) : offset;
      };
      return stack;
    }
    function stackOffsetExpand(series, order) {
      if (!((n2 = series.length) > 0)) return;
      for (var i, n2, j = 0, m2 = series[0].length, y2; j < m2; ++j) {
        for (y2 = i = 0; i < n2; ++i) y2 += series[i][j][1] || 0;
        if (y2) for (i = 0; i < n2; ++i) series[i][j][1] /= y2;
      }
      stackOffsetNone(series, order);
    }
    function stackOffsetSilhouette(series, order) {
      if (!((n2 = series.length) > 0)) return;
      for (var j = 0, s0 = series[order[0]], n2, m2 = s0.length; j < m2; ++j) {
        for (var i = 0, y2 = 0; i < n2; ++i) y2 += series[i][j][1] || 0;
        s0[j][1] += s0[j][0] = -y2 / 2;
      }
      stackOffsetNone(series, order);
    }
    function stackOffsetWiggle(series, order) {
      if (!((n2 = series.length) > 0) || !((m2 = (s0 = series[order[0]]).length) > 0)) return;
      for (var y2 = 0, j = 1, s0, m2, n2; j < m2; ++j) {
        for (var i = 0, s1 = 0, s2 = 0; i < n2; ++i) {
          var si2 = series[order[i]], sij0 = si2[j][1] || 0, sij1 = si2[j - 1][1] || 0, s3 = (sij0 - sij1) / 2;
          for (var k2 = 0; k2 < i; ++k2) {
            var sk2 = series[order[k2]], skj0 = sk2[j][1] || 0, skj1 = sk2[j - 1][1] || 0;
            s3 += skj0 - skj1;
          }
          s1 += sij0, s2 += s3 * sij0;
        }
        s0[j - 1][1] += s0[j - 1][0] = y2;
        if (s1) y2 -= s2 / s1;
      }
      s0[j - 1][1] += s0[j - 1][0] = y2;
      stackOffsetNone(series, order);
    }
    var get$3 = {};
    var isUnsafeProperty = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      function isUnsafeProperty2(key) {
        return key === "__proto__";
      }
      exports$1.isUnsafeProperty = isUnsafeProperty2;
    })(isUnsafeProperty);
    var isDeepKey = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      function isDeepKey2(key) {
        switch (typeof key) {
          case "number":
          case "symbol": {
            return false;
          }
          case "string": {
            return key.includes(".") || key.includes("[") || key.includes("]");
          }
        }
      }
      exports$1.isDeepKey = isDeepKey2;
    })(isDeepKey);
    var toKey = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      function toKey2(value) {
        var _a;
        if (typeof value === "string" || typeof value === "symbol") {
          return value;
        }
        if (Object.is((_a = value == null ? void 0 : value.valueOf) == null ? void 0 : _a.call(value), -0)) {
          return "-0";
        }
        return String(value);
      }
      exports$1.toKey = toKey2;
    })(toKey);
    var toPath = {};
    var toString$1 = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      function toString2(value) {
        if (value == null) {
          return "";
        }
        if (typeof value === "string") {
          return value;
        }
        if (Array.isArray(value)) {
          return value.map(toString2).join(",");
        }
        const result = String(value);
        if (result === "0" && Object.is(Number(value), -0)) {
          return "-0";
        }
        return result;
      }
      exports$1.toString = toString2;
    })(toString$1);
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const toString2 = toString$1;
      const toKey$1 = toKey;
      function toPath2(deepKey) {
        if (Array.isArray(deepKey)) {
          return deepKey.map(toKey$1.toKey);
        }
        if (typeof deepKey === "symbol") {
          return [deepKey];
        }
        deepKey = toString2.toString(deepKey);
        const result = [];
        const length = deepKey.length;
        if (length === 0) {
          return result;
        }
        let index = 0;
        let key = "";
        let quoteChar = "";
        let bracket = false;
        if (deepKey.charCodeAt(0) === 46) {
          result.push("");
          index++;
        }
        while (index < length) {
          const char = deepKey[index];
          if (quoteChar) {
            if (char === "\\" && index + 1 < length) {
              index++;
              key += deepKey[index];
            } else if (char === quoteChar) {
              quoteChar = "";
            } else {
              key += char;
            }
          } else if (bracket) {
            if (char === '"' || char === "'") {
              quoteChar = char;
            } else if (char === "]") {
              bracket = false;
              result.push(key);
              key = "";
            } else {
              key += char;
            }
          } else {
            if (char === "[") {
              bracket = true;
              if (key) {
                result.push(key);
                key = "";
              }
            } else if (char === ".") {
              if (key) {
                result.push(key);
                key = "";
              }
            } else {
              key += char;
            }
          }
          index++;
        }
        if (key) {
          result.push(key);
        }
        return result;
      }
      exports$1.toPath = toPath2;
    })(toPath);
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const isUnsafeProperty$1 = isUnsafeProperty;
      const isDeepKey$1 = isDeepKey;
      const toKey$1 = toKey;
      const toPath$1 = toPath;
      function get2(object2, path, defaultValue) {
        if (object2 == null) {
          return defaultValue;
        }
        switch (typeof path) {
          case "string": {
            if (isUnsafeProperty$1.isUnsafeProperty(path)) {
              return defaultValue;
            }
            const result = object2[path];
            if (result === void 0) {
              if (isDeepKey$1.isDeepKey(path)) {
                return get2(object2, toPath$1.toPath(path), defaultValue);
              } else {
                return defaultValue;
              }
            }
            return result;
          }
          case "number":
          case "symbol": {
            if (typeof path === "number") {
              path = toKey$1.toKey(path);
            }
            const result = object2[path];
            if (result === void 0) {
              return defaultValue;
            }
            return result;
          }
          default: {
            if (Array.isArray(path)) {
              return getWithPath(object2, path, defaultValue);
            }
            if (Object.is(path == null ? void 0 : path.valueOf(), -0)) {
              path = "-0";
            } else {
              path = String(path);
            }
            if (isUnsafeProperty$1.isUnsafeProperty(path)) {
              return defaultValue;
            }
            const result = object2[path];
            if (result === void 0) {
              return defaultValue;
            }
            return result;
          }
        }
      }
      function getWithPath(object2, path, defaultValue) {
        if (path.length === 0) {
          return defaultValue;
        }
        let current2 = object2;
        for (let index = 0; index < path.length; index++) {
          if (current2 == null) {
            return defaultValue;
          }
          if (isUnsafeProperty$1.isUnsafeProperty(path[index])) {
            return defaultValue;
          }
          current2 = current2[path[index]];
        }
        if (current2 === void 0) {
          return defaultValue;
        }
        return current2;
      }
      exports$1.get = get2;
    })(get$3);
    var get$1 = get$3.get;
    const get$2 = /* @__PURE__ */ getDefaultExportFromCjs(get$1);
    var mathSign = (value) => {
      if (value === 0) {
        return 0;
      }
      if (value > 0) {
        return 1;
      }
      return -1;
    };
    var isNan = (value) => {
      return typeof value == "number" && value != +value;
    };
    var isPercent = (value) => typeof value === "string" && value.indexOf("%") === value.length - 1;
    var isNumber = (value) => (typeof value === "number" || value instanceof Number) && !isNan(value);
    var isNumOrStr = (value) => isNumber(value) || typeof value === "string";
    var idCounter = 0;
    var uniqueId = (prefix2) => {
      var id2 = ++idCounter;
      return "".concat(prefix2 || "").concat(id2);
    };
    var getPercentValue = function getPercentValue2(percent, totalValue) {
      var defaultValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var validate = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      if (!isNumber(percent) && typeof percent !== "string") {
        return defaultValue;
      }
      var value;
      if (isPercent(percent)) {
        if (totalValue == null) {
          return defaultValue;
        }
        var index = percent.indexOf("%");
        value = totalValue * parseFloat(percent.slice(0, index)) / 100;
      } else {
        value = +percent;
      }
      if (isNan(value)) {
        value = defaultValue;
      }
      if (validate && totalValue != null && value > totalValue) {
        value = totalValue;
      }
      return value;
    };
    var hasDuplicate = (ary) => {
      if (!Array.isArray(ary)) {
        return false;
      }
      var len = ary.length;
      var cache = {};
      for (var i = 0; i < len; i++) {
        if (!cache[ary[i]]) {
          cache[ary[i]] = true;
        } else {
          return true;
        }
      }
      return false;
    };
    function interpolate$1(start, end, t2) {
      if (isNumber(start) && isNumber(end)) {
        return start + t2 * (end - start);
      }
      return end;
    }
    function findEntryInArray(ary, specifiedKey, specifiedValue) {
      if (!ary || !ary.length) {
        return void 0;
      }
      return ary.find((entry) => entry && (typeof specifiedKey === "function" ? specifiedKey(entry) : get$2(entry, specifiedKey)) === specifiedValue);
    }
    var isNullish = (value) => {
      return value === null || typeof value === "undefined";
    };
    var upperFirst = (value) => {
      if (isNullish(value)) {
        return value;
      }
      return "".concat(value.charAt(0).toUpperCase()).concat(value.slice(1));
    };
    function isNotNil(value) {
      return value != null;
    }
    function noop$2() {
    }
    var _excluded$n = ["type", "size", "sizeType"];
    function _extends$s() {
      return _extends$s = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$s.apply(null, arguments);
    }
    function ownKeys$G(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$G(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$G(Object(t2), true).forEach(function(r3) {
          _defineProperty$I(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$G(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$I(e, r2, t2) {
      return (r2 = _toPropertyKey$I(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$I(t2) {
      var i = _toPrimitive$I(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$I(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function _objectWithoutProperties$n(e, t2) {
      if (null == e) return {};
      var o, r2, i = _objectWithoutPropertiesLoose$n(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e);
        for (r2 = 0; r2 < n2.length; r2++) o = n2[r2], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose$n(r2, e) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    var symbolFactories = {
      symbolCircle,
      symbolCross,
      symbolDiamond,
      symbolSquare,
      symbolStar,
      symbolTriangle,
      symbolWye
    };
    var RADIAN$1 = Math.PI / 180;
    var getSymbolFactory = (type) => {
      var name = "symbol".concat(upperFirst(type));
      return symbolFactories[name] || symbolCircle;
    };
    var calculateAreaSize = (size, sizeType, type) => {
      if (sizeType === "area") {
        return size;
      }
      switch (type) {
        case "cross":
          return 5 * size * size / 9;
        case "diamond":
          return 0.5 * size * size / Math.sqrt(3);
        case "square":
          return size * size;
        case "star": {
          var angle = 18 * RADIAN$1;
          return 1.25 * size * size * (Math.tan(angle) - Math.tan(angle * 2) * __pow(Math.tan(angle), 2));
        }
        case "triangle":
          return Math.sqrt(3) * size * size / 4;
        case "wye":
          return (21 - 10 * Math.sqrt(3)) * size * size / 8;
        default:
          return Math.PI * size * size / 4;
      }
    };
    var registerSymbol = (key, factory) => {
      symbolFactories["symbol".concat(upperFirst(key))] = factory;
    };
    var Symbols = (_ref2) => {
      var {
        type = "circle",
        size = 64,
        sizeType = "area"
      } = _ref2, rest = _objectWithoutProperties$n(_ref2, _excluded$n);
      var props = _objectSpread$G(_objectSpread$G({}, rest), {}, {
        type,
        size,
        sizeType
      });
      var realType = "circle";
      if (typeof type === "string") {
        realType = type;
      }
      var getPath2 = () => {
        var symbolFactory = getSymbolFactory(realType);
        var symbol = Symbol$1().type(symbolFactory).size(calculateAreaSize(size, sizeType, realType));
        var s2 = symbol();
        if (s2 === null) {
          return void 0;
        }
        return s2;
      };
      var {
        className,
        cx,
        cy
      } = props;
      var filteredProps = svgPropertiesAndEvents(props);
      if (isNumber(cx) && isNumber(cy) && isNumber(size)) {
        return /* @__PURE__ */ reactExports.createElement("path", _extends$s({}, filteredProps, {
          className: clsx("recharts-symbols", className),
          transform: "translate(".concat(cx, ", ").concat(cy, ")"),
          d: getPath2()
        }));
      }
      return null;
    };
    Symbols.registerSymbol = registerSymbol;
    var isPolarCoordinate = (c2) => {
      return "radius" in c2 && "startAngle" in c2 && "endAngle" in c2;
    };
    var adaptEventHandlers = (props, newHandler) => {
      if (!props || typeof props === "function" || typeof props === "boolean") {
        return null;
      }
      var inputProps = props;
      if (/* @__PURE__ */ reactExports.isValidElement(props)) {
        inputProps = props.props;
      }
      if (typeof inputProps !== "object" && typeof inputProps !== "function") {
        return null;
      }
      var out = {};
      Object.keys(inputProps).forEach((key) => {
        if (isEventKey(key)) {
          out[key] = (e) => inputProps[key](inputProps, e);
        }
      });
      return out;
    };
    var getEventHandlerOfChild = (originalHandler, data, index) => (e) => {
      originalHandler(data, index, e);
      return null;
    };
    var adaptEventsOfChild = (props, data, index) => {
      if (props === null || typeof props !== "object" && typeof props !== "function") {
        return null;
      }
      var out = null;
      Object.keys(props).forEach((key) => {
        var item = props[key];
        if (isEventKey(key) && typeof item === "function") {
          if (!out) out = {};
          out[key] = getEventHandlerOfChild(item, data, index);
        }
      });
      return out;
    };
    function ownKeys$F(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$F(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$F(Object(t2), true).forEach(function(r3) {
          _defineProperty$H(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$F(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$H(e, r2, t2) {
      return (r2 = _toPropertyKey$H(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$H(t2) {
      var i = _toPrimitive$H(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$H(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function resolveDefaultProps(realProps, defaultProps) {
      var resolvedProps = _objectSpread$F({}, realProps);
      var dp = defaultProps;
      var keys = Object.keys(defaultProps);
      var withDefaults = keys.reduce((acc, key) => {
        if (acc[key] === void 0 && dp[key] !== void 0) {
          acc[key] = dp[key];
        }
        return acc;
      }, resolvedProps);
      return withDefaults;
    }
    function _extends$r() {
      return _extends$r = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$r.apply(null, arguments);
    }
    function ownKeys$E(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$E(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$E(Object(t2), true).forEach(function(r3) {
          _defineProperty$G(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$E(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$G(e, r2, t2) {
      return (r2 = _toPropertyKey$G(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$G(t2) {
      var i = _toPrimitive$G(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$G(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    var SIZE = 32;
    var defaultLegendContentDefaultProps = {
      align: "center",
      iconSize: 14,
      inactiveColor: "#ccc",
      layout: "horizontal",
      verticalAlign: "middle"
    };
    function Icon(_ref2) {
      var {
        data,
        iconType,
        inactiveColor
      } = _ref2;
      var halfSize = SIZE / 2;
      var sixthSize = SIZE / 6;
      var thirdSize = SIZE / 3;
      var color2 = data.inactive ? inactiveColor : data.color;
      var preferredIcon = iconType !== null && iconType !== void 0 ? iconType : data.type;
      if (preferredIcon === "none") {
        return null;
      }
      if (preferredIcon === "plainline") {
        var _data$payload;
        return /* @__PURE__ */ reactExports.createElement("line", {
          strokeWidth: 4,
          fill: "none",
          stroke: color2,
          strokeDasharray: (_data$payload = data.payload) === null || _data$payload === void 0 ? void 0 : _data$payload.strokeDasharray,
          x1: 0,
          y1: halfSize,
          x2: SIZE,
          y2: halfSize,
          className: "recharts-legend-icon"
        });
      }
      if (preferredIcon === "line") {
        return /* @__PURE__ */ reactExports.createElement("path", {
          strokeWidth: 4,
          fill: "none",
          stroke: color2,
          d: "M0,".concat(halfSize, "h").concat(thirdSize, "\n            A").concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(2 * thirdSize, ",").concat(halfSize, "\n            H").concat(SIZE, "M").concat(2 * thirdSize, ",").concat(halfSize, "\n            A").concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(thirdSize, ",").concat(halfSize),
          className: "recharts-legend-icon"
        });
      }
      if (preferredIcon === "rect") {
        return /* @__PURE__ */ reactExports.createElement("path", {
          stroke: "none",
          fill: color2,
          d: "M0,".concat(SIZE / 8, "h").concat(SIZE, "v").concat(SIZE * 3 / 4, "h").concat(-SIZE, "z"),
          className: "recharts-legend-icon"
        });
      }
      if (/* @__PURE__ */ reactExports.isValidElement(data.legendIcon)) {
        var iconProps = _objectSpread$E({}, data);
        delete iconProps.legendIcon;
        return /* @__PURE__ */ reactExports.cloneElement(data.legendIcon, iconProps);
      }
      return /* @__PURE__ */ reactExports.createElement(Symbols, {
        fill: color2,
        cx: halfSize,
        cy: halfSize,
        size: SIZE,
        sizeType: "diameter",
        type: preferredIcon
      });
    }
    function Items(props) {
      var {
        payload,
        iconSize,
        layout,
        formatter,
        inactiveColor,
        iconType
      } = props;
      var viewBox = {
        x: 0,
        y: 0,
        width: SIZE,
        height: SIZE
      };
      var itemStyle = {
        display: layout === "horizontal" ? "inline-block" : "block",
        marginRight: 10
      };
      var svgStyle = {
        display: "inline-block",
        verticalAlign: "middle",
        marginRight: 4
      };
      return payload.map((entry, i) => {
        var finalFormatter = entry.formatter || formatter;
        var className = clsx({
          "recharts-legend-item": true,
          ["legend-item-".concat(i)]: true,
          inactive: entry.inactive
        });
        if (entry.type === "none") {
          return null;
        }
        var color2 = entry.inactive ? inactiveColor : entry.color;
        var finalValue = finalFormatter ? finalFormatter(entry.value, entry, i) : entry.value;
        return /* @__PURE__ */ reactExports.createElement("li", _extends$r({
          className,
          style: itemStyle,
          key: "legend-item-".concat(i)
        }, adaptEventsOfChild(props, entry, i)), /* @__PURE__ */ reactExports.createElement(Surface, {
          width: iconSize,
          height: iconSize,
          viewBox,
          style: svgStyle,
          "aria-label": "".concat(finalValue, " legend icon")
        }, /* @__PURE__ */ reactExports.createElement(Icon, {
          data: entry,
          iconType,
          inactiveColor
        })), /* @__PURE__ */ reactExports.createElement("span", {
          className: "recharts-legend-item-text",
          style: {
            color: color2
          }
        }, finalValue));
      });
    }
    var DefaultLegendContent = (outsideProps) => {
      var props = resolveDefaultProps(outsideProps, defaultLegendContentDefaultProps);
      var {
        payload,
        layout,
        align
      } = props;
      if (!payload || !payload.length) {
        return null;
      }
      var finalStyle = {
        padding: 0,
        margin: 0,
        textAlign: layout === "horizontal" ? align : "left"
      };
      return /* @__PURE__ */ reactExports.createElement("ul", {
        className: "recharts-default-legend",
        style: finalStyle
      }, /* @__PURE__ */ reactExports.createElement(Items, _extends$r({}, props, {
        payload
      })));
    };
    var uniqBy$3 = {};
    var uniqBy$2 = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      function uniqBy2(arr, mapper) {
        const map2 = /* @__PURE__ */ new Map();
        for (let i = 0; i < arr.length; i++) {
          const item = arr[i];
          const key = mapper(item);
          if (!map2.has(key)) {
            map2.set(key, item);
          }
        }
        return Array.from(map2.values());
      }
      exports$1.uniqBy = uniqBy2;
    })(uniqBy$2);
    var identity$4 = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      function identity2(x2) {
        return x2;
      }
      exports$1.identity = identity2;
    })(identity$4);
    var isArrayLikeObject = {};
    var isArrayLike = {};
    var isLength = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      function isLength2(value) {
        return Number.isSafeInteger(value) && value >= 0;
      }
      exports$1.isLength = isLength2;
    })(isLength);
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const isLength$1 = isLength;
      function isArrayLike2(value) {
        return value != null && typeof value !== "function" && isLength$1.isLength(value.length);
      }
      exports$1.isArrayLike = isArrayLike2;
    })(isArrayLike);
    var isObjectLike = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      function isObjectLike2(value) {
        return typeof value === "object" && value !== null;
      }
      exports$1.isObjectLike = isObjectLike2;
    })(isObjectLike);
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const isArrayLike$1 = isArrayLike;
      const isObjectLike$1 = isObjectLike;
      function isArrayLikeObject2(value) {
        return isObjectLike$1.isObjectLike(value) && isArrayLike$1.isArrayLike(value);
      }
      exports$1.isArrayLikeObject = isArrayLikeObject2;
    })(isArrayLikeObject);
    var iteratee = {};
    var property = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const get2 = get$3;
      function property2(path) {
        return function(object2) {
          return get2.get(object2, path);
        };
      }
      exports$1.property = property2;
    })(property);
    var matches = {};
    var isMatch = {};
    var isMatchWith = {};
    var isObject = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      function isObject2(value) {
        return value !== null && (typeof value === "object" || typeof value === "function");
      }
      exports$1.isObject = isObject2;
    })(isObject);
    var isPrimitive = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      function isPrimitive2(value) {
        return value == null || typeof value !== "object" && typeof value !== "function";
      }
      exports$1.isPrimitive = isPrimitive2;
    })(isPrimitive);
    var eq = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      function eq2(value, other) {
        return value === other || Number.isNaN(value) && Number.isNaN(other);
      }
      exports$1.eq = eq2;
    })(eq);
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const isObject$1 = isObject;
      const isPrimitive$1 = isPrimitive;
      const eq$1 = eq;
      function isMatchWith2(target, source, compare) {
        if (typeof compare !== "function") {
          return isMatchWith2(target, source, () => void 0);
        }
        return isMatchWithInternal(target, source, function doesMatch(objValue, srcValue, key, object2, source2, stack) {
          const isEqual = compare(objValue, srcValue, key, object2, source2, stack);
          if (isEqual !== void 0) {
            return Boolean(isEqual);
          }
          return isMatchWithInternal(objValue, srcValue, doesMatch, stack);
        }, /* @__PURE__ */ new Map());
      }
      function isMatchWithInternal(target, source, compare, stack) {
        if (source === target) {
          return true;
        }
        switch (typeof source) {
          case "object": {
            return isObjectMatch(target, source, compare, stack);
          }
          case "function": {
            const sourceKeys = Object.keys(source);
            if (sourceKeys.length > 0) {
              return isMatchWithInternal(target, __spreadValues({}, source), compare, stack);
            }
            return eq$1.eq(target, source);
          }
          default: {
            if (!isObject$1.isObject(target)) {
              return eq$1.eq(target, source);
            }
            if (typeof source === "string") {
              return source === "";
            }
            return true;
          }
        }
      }
      function isObjectMatch(target, source, compare, stack) {
        if (source == null) {
          return true;
        }
        if (Array.isArray(source)) {
          return isArrayMatch(target, source, compare, stack);
        }
        if (source instanceof Map) {
          return isMapMatch(target, source, compare, stack);
        }
        if (source instanceof Set) {
          return isSetMatch(target, source, compare, stack);
        }
        const keys = Object.keys(source);
        if (target == null || isPrimitive$1.isPrimitive(target)) {
          return keys.length === 0;
        }
        if (keys.length === 0) {
          return true;
        }
        if (stack == null ? void 0 : stack.has(source)) {
          return stack.get(source) === target;
        }
        stack == null ? void 0 : stack.set(source, target);
        try {
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            if (!isPrimitive$1.isPrimitive(target) && !(key in target)) {
              return false;
            }
            if (source[key] === void 0 && target[key] !== void 0) {
              return false;
            }
            if (source[key] === null && target[key] !== null) {
              return false;
            }
            const isEqual = compare(target[key], source[key], key, target, source, stack);
            if (!isEqual) {
              return false;
            }
          }
          return true;
        } finally {
          stack == null ? void 0 : stack.delete(source);
        }
      }
      function isMapMatch(target, source, compare, stack) {
        if (source.size === 0) {
          return true;
        }
        if (!(target instanceof Map)) {
          return false;
        }
        for (const [key, sourceValue] of source.entries()) {
          const targetValue = target.get(key);
          const isEqual = compare(targetValue, sourceValue, key, target, source, stack);
          if (isEqual === false) {
            return false;
          }
        }
        return true;
      }
      function isArrayMatch(target, source, compare, stack) {
        if (source.length === 0) {
          return true;
        }
        if (!Array.isArray(target)) {
          return false;
        }
        const countedIndex = /* @__PURE__ */ new Set();
        for (let i = 0; i < source.length; i++) {
          const sourceItem = source[i];
          let found = false;
          for (let j = 0; j < target.length; j++) {
            if (countedIndex.has(j)) {
              continue;
            }
            const targetItem = target[j];
            let matches2 = false;
            const isEqual = compare(targetItem, sourceItem, i, target, source, stack);
            if (isEqual) {
              matches2 = true;
            }
            if (matches2) {
              countedIndex.add(j);
              found = true;
              break;
            }
          }
          if (!found) {
            return false;
          }
        }
        return true;
      }
      function isSetMatch(target, source, compare, stack) {
        if (source.size === 0) {
          return true;
        }
        if (!(target instanceof Set)) {
          return false;
        }
        return isArrayMatch([...target], [...source], compare, stack);
      }
      exports$1.isMatchWith = isMatchWith2;
      exports$1.isSetMatch = isSetMatch;
    })(isMatchWith);
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const isMatchWith$1 = isMatchWith;
      function isMatch2(target, source) {
        return isMatchWith$1.isMatchWith(target, source, () => void 0);
      }
      exports$1.isMatch = isMatch2;
    })(isMatch);
    var cloneDeep$1 = {};
    var cloneDeepWith$1 = {};
    var getSymbols = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      function getSymbols2(object2) {
        return Object.getOwnPropertySymbols(object2).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object2, symbol));
      }
      exports$1.getSymbols = getSymbols2;
    })(getSymbols);
    var getTag = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      function getTag2(value) {
        if (value == null) {
          return value === void 0 ? "[object Undefined]" : "[object Null]";
        }
        return Object.prototype.toString.call(value);
      }
      exports$1.getTag = getTag2;
    })(getTag);
    var tags = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const regexpTag = "[object RegExp]";
      const stringTag = "[object String]";
      const numberTag = "[object Number]";
      const booleanTag = "[object Boolean]";
      const argumentsTag = "[object Arguments]";
      const symbolTag = "[object Symbol]";
      const dateTag = "[object Date]";
      const mapTag = "[object Map]";
      const setTag = "[object Set]";
      const arrayTag = "[object Array]";
      const functionTag = "[object Function]";
      const arrayBufferTag = "[object ArrayBuffer]";
      const objectTag = "[object Object]";
      const errorTag = "[object Error]";
      const dataViewTag = "[object DataView]";
      const uint8ArrayTag = "[object Uint8Array]";
      const uint8ClampedArrayTag = "[object Uint8ClampedArray]";
      const uint16ArrayTag = "[object Uint16Array]";
      const uint32ArrayTag = "[object Uint32Array]";
      const bigUint64ArrayTag = "[object BigUint64Array]";
      const int8ArrayTag = "[object Int8Array]";
      const int16ArrayTag = "[object Int16Array]";
      const int32ArrayTag = "[object Int32Array]";
      const bigInt64ArrayTag = "[object BigInt64Array]";
      const float32ArrayTag = "[object Float32Array]";
      const float64ArrayTag = "[object Float64Array]";
      exports$1.argumentsTag = argumentsTag;
      exports$1.arrayBufferTag = arrayBufferTag;
      exports$1.arrayTag = arrayTag;
      exports$1.bigInt64ArrayTag = bigInt64ArrayTag;
      exports$1.bigUint64ArrayTag = bigUint64ArrayTag;
      exports$1.booleanTag = booleanTag;
      exports$1.dataViewTag = dataViewTag;
      exports$1.dateTag = dateTag;
      exports$1.errorTag = errorTag;
      exports$1.float32ArrayTag = float32ArrayTag;
      exports$1.float64ArrayTag = float64ArrayTag;
      exports$1.functionTag = functionTag;
      exports$1.int16ArrayTag = int16ArrayTag;
      exports$1.int32ArrayTag = int32ArrayTag;
      exports$1.int8ArrayTag = int8ArrayTag;
      exports$1.mapTag = mapTag;
      exports$1.numberTag = numberTag;
      exports$1.objectTag = objectTag;
      exports$1.regexpTag = regexpTag;
      exports$1.setTag = setTag;
      exports$1.stringTag = stringTag;
      exports$1.symbolTag = symbolTag;
      exports$1.uint16ArrayTag = uint16ArrayTag;
      exports$1.uint32ArrayTag = uint32ArrayTag;
      exports$1.uint8ArrayTag = uint8ArrayTag;
      exports$1.uint8ClampedArrayTag = uint8ClampedArrayTag;
    })(tags);
    var isTypedArray = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      function isTypedArray2(x2) {
        return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
      }
      exports$1.isTypedArray = isTypedArray2;
    })(isTypedArray);
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const getSymbols$1 = getSymbols;
      const getTag$1 = getTag;
      const tags$1 = tags;
      const isPrimitive$1 = isPrimitive;
      const isTypedArray$1 = isTypedArray;
      function cloneDeepWith2(obj, cloneValue) {
        return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), cloneValue);
      }
      function cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack = /* @__PURE__ */ new Map(), cloneValue = void 0) {
        const cloned = cloneValue == null ? void 0 : cloneValue(valueToClone, keyToClone, objectToClone, stack);
        if (cloned !== void 0) {
          return cloned;
        }
        if (isPrimitive$1.isPrimitive(valueToClone)) {
          return valueToClone;
        }
        if (stack.has(valueToClone)) {
          return stack.get(valueToClone);
        }
        if (Array.isArray(valueToClone)) {
          const result = new Array(valueToClone.length);
          stack.set(valueToClone, result);
          for (let i = 0; i < valueToClone.length; i++) {
            result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);
          }
          if (Object.hasOwn(valueToClone, "index")) {
            result.index = valueToClone.index;
          }
          if (Object.hasOwn(valueToClone, "input")) {
            result.input = valueToClone.input;
          }
          return result;
        }
        if (valueToClone instanceof Date) {
          return new Date(valueToClone.getTime());
        }
        if (valueToClone instanceof RegExp) {
          const result = new RegExp(valueToClone.source, valueToClone.flags);
          result.lastIndex = valueToClone.lastIndex;
          return result;
        }
        if (valueToClone instanceof Map) {
          const result = /* @__PURE__ */ new Map();
          stack.set(valueToClone, result);
          for (const [key, value] of valueToClone) {
            result.set(key, cloneDeepWithImpl(value, key, objectToClone, stack, cloneValue));
          }
          return result;
        }
        if (valueToClone instanceof Set) {
          const result = /* @__PURE__ */ new Set();
          stack.set(valueToClone, result);
          for (const value of valueToClone) {
            result.add(cloneDeepWithImpl(value, void 0, objectToClone, stack, cloneValue));
          }
          return result;
        }
        if (typeof Buffer !== "undefined" && Buffer.isBuffer(valueToClone)) {
          return valueToClone.subarray();
        }
        if (isTypedArray$1.isTypedArray(valueToClone)) {
          const result = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);
          stack.set(valueToClone, result);
          for (let i = 0; i < valueToClone.length; i++) {
            result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);
          }
          return result;
        }
        if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && valueToClone instanceof SharedArrayBuffer) {
          return valueToClone.slice(0);
        }
        if (valueToClone instanceof DataView) {
          const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);
          stack.set(valueToClone, result);
          copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
          return result;
        }
        if (typeof File !== "undefined" && valueToClone instanceof File) {
          const result = new File([valueToClone], valueToClone.name, {
            type: valueToClone.type
          });
          stack.set(valueToClone, result);
          copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
          return result;
        }
        if (typeof Blob !== "undefined" && valueToClone instanceof Blob) {
          const result = new Blob([valueToClone], { type: valueToClone.type });
          stack.set(valueToClone, result);
          copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
          return result;
        }
        if (valueToClone instanceof Error) {
          const result = new valueToClone.constructor();
          stack.set(valueToClone, result);
          result.message = valueToClone.message;
          result.name = valueToClone.name;
          result.stack = valueToClone.stack;
          result.cause = valueToClone.cause;
          copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
          return result;
        }
        if (valueToClone instanceof Boolean) {
          const result = new Boolean(valueToClone.valueOf());
          stack.set(valueToClone, result);
          copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
          return result;
        }
        if (valueToClone instanceof Number) {
          const result = new Number(valueToClone.valueOf());
          stack.set(valueToClone, result);
          copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
          return result;
        }
        if (valueToClone instanceof String) {
          const result = new String(valueToClone.valueOf());
          stack.set(valueToClone, result);
          copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
          return result;
        }
        if (typeof valueToClone === "object" && isCloneableObject(valueToClone)) {
          const result = Object.create(Object.getPrototypeOf(valueToClone));
          stack.set(valueToClone, result);
          copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
          return result;
        }
        return valueToClone;
      }
      function copyProperties(target, source, objectToClone = target, stack, cloneValue) {
        const keys = [...Object.keys(source), ...getSymbols$1.getSymbols(source)];
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const descriptor = Object.getOwnPropertyDescriptor(target, key);
          if (descriptor == null || descriptor.writable) {
            target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack, cloneValue);
          }
        }
      }
      function isCloneableObject(object2) {
        switch (getTag$1.getTag(object2)) {
          case tags$1.argumentsTag:
          case tags$1.arrayTag:
          case tags$1.arrayBufferTag:
          case tags$1.dataViewTag:
          case tags$1.booleanTag:
          case tags$1.dateTag:
          case tags$1.float32ArrayTag:
          case tags$1.float64ArrayTag:
          case tags$1.int8ArrayTag:
          case tags$1.int16ArrayTag:
          case tags$1.int32ArrayTag:
          case tags$1.mapTag:
          case tags$1.numberTag:
          case tags$1.objectTag:
          case tags$1.regexpTag:
          case tags$1.setTag:
          case tags$1.stringTag:
          case tags$1.symbolTag:
          case tags$1.uint8ArrayTag:
          case tags$1.uint8ClampedArrayTag:
          case tags$1.uint16ArrayTag:
          case tags$1.uint32ArrayTag: {
            return true;
          }
          default: {
            return false;
          }
        }
      }
      exports$1.cloneDeepWith = cloneDeepWith2;
      exports$1.cloneDeepWithImpl = cloneDeepWithImpl;
      exports$1.copyProperties = copyProperties;
    })(cloneDeepWith$1);
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const cloneDeepWith2 = cloneDeepWith$1;
      function cloneDeep2(obj) {
        return cloneDeepWith2.cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), void 0);
      }
      exports$1.cloneDeep = cloneDeep2;
    })(cloneDeep$1);
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const isMatch$1 = isMatch;
      const cloneDeep2 = cloneDeep$1;
      function matches2(source) {
        source = cloneDeep2.cloneDeep(source);
        return (target) => {
          return isMatch$1.isMatch(target, source);
        };
      }
      exports$1.matches = matches2;
    })(matches);
    var matchesProperty = {};
    var cloneDeep = {};
    var cloneDeepWith = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const cloneDeepWith$1$1 = cloneDeepWith$1;
      const tags$1 = tags;
      function cloneDeepWith2(obj, customizer) {
        return cloneDeepWith$1$1.cloneDeepWith(obj, (value, key, object2, stack) => {
          const cloned = customizer == null ? void 0 : customizer(value, key, object2, stack);
          if (cloned !== void 0) {
            return cloned;
          }
          if (typeof obj !== "object") {
            return void 0;
          }
          switch (Object.prototype.toString.call(obj)) {
            case tags$1.numberTag:
            case tags$1.stringTag:
            case tags$1.booleanTag: {
              const result = new obj.constructor(obj == null ? void 0 : obj.valueOf());
              cloneDeepWith$1$1.copyProperties(result, obj);
              return result;
            }
            case tags$1.argumentsTag: {
              const result = {};
              cloneDeepWith$1$1.copyProperties(result, obj);
              result.length = obj.length;
              result[Symbol.iterator] = obj[Symbol.iterator];
              return result;
            }
            default: {
              return void 0;
            }
          }
        });
      }
      exports$1.cloneDeepWith = cloneDeepWith2;
    })(cloneDeepWith);
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const cloneDeepWith$12 = cloneDeepWith;
      function cloneDeep2(obj) {
        return cloneDeepWith$12.cloneDeepWith(obj);
      }
      exports$1.cloneDeep = cloneDeep2;
    })(cloneDeep);
    var has$2 = {};
    var isIndex = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const IS_UNSIGNED_INTEGER = /^(?:0|[1-9]\d*)$/;
      function isIndex2(value, length = Number.MAX_SAFE_INTEGER) {
        switch (typeof value) {
          case "number": {
            return Number.isInteger(value) && value >= 0 && value < length;
          }
          case "symbol": {
            return false;
          }
          case "string": {
            return IS_UNSIGNED_INTEGER.test(value);
          }
        }
      }
      exports$1.isIndex = isIndex2;
    })(isIndex);
    var isArguments = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const getTag$1 = getTag;
      function isArguments2(value) {
        return value !== null && typeof value === "object" && getTag$1.getTag(value) === "[object Arguments]";
      }
      exports$1.isArguments = isArguments2;
    })(isArguments);
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const isDeepKey$1 = isDeepKey;
      const isIndex$1 = isIndex;
      const isArguments$1 = isArguments;
      const toPath$1 = toPath;
      function has2(object2, path) {
        let resolvedPath;
        if (Array.isArray(path)) {
          resolvedPath = path;
        } else if (typeof path === "string" && isDeepKey$1.isDeepKey(path) && (object2 == null ? void 0 : object2[path]) == null) {
          resolvedPath = toPath$1.toPath(path);
        } else {
          resolvedPath = [path];
        }
        if (resolvedPath.length === 0) {
          return false;
        }
        let current2 = object2;
        for (let i = 0; i < resolvedPath.length; i++) {
          const key = resolvedPath[i];
          if (current2 == null || !Object.hasOwn(current2, key)) {
            const isSparseIndex = (Array.isArray(current2) || isArguments$1.isArguments(current2)) && isIndex$1.isIndex(key) && key < current2.length;
            if (!isSparseIndex) {
              return false;
            }
          }
          current2 = current2[key];
        }
        return true;
      }
      exports$1.has = has2;
    })(has$2);
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const isMatch$1 = isMatch;
      const toKey$1 = toKey;
      const cloneDeep$12 = cloneDeep;
      const get2 = get$3;
      const has2 = has$2;
      function matchesProperty2(property2, source) {
        switch (typeof property2) {
          case "object": {
            if (Object.is(property2 == null ? void 0 : property2.valueOf(), -0)) {
              property2 = "-0";
            }
            break;
          }
          case "number": {
            property2 = toKey$1.toKey(property2);
            break;
          }
        }
        source = cloneDeep$12.cloneDeep(source);
        return function(target) {
          const result = get2.get(target, property2);
          if (result === void 0) {
            return has2.has(target, property2);
          }
          if (source === void 0) {
            return result === void 0;
          }
          return isMatch$1.isMatch(result, source);
        };
      }
      exports$1.matchesProperty = matchesProperty2;
    })(matchesProperty);
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const identity2 = identity$4;
      const property$1 = property;
      const matches$1 = matches;
      const matchesProperty$1 = matchesProperty;
      function iteratee2(value) {
        if (value == null) {
          return identity2.identity;
        }
        switch (typeof value) {
          case "function": {
            return value;
          }
          case "object": {
            if (Array.isArray(value) && value.length === 2) {
              return matchesProperty$1.matchesProperty(value[0], value[1]);
            }
            return matches$1.matches(value);
          }
          case "string":
          case "symbol":
          case "number": {
            return property$1.property(value);
          }
        }
      }
      exports$1.iteratee = iteratee2;
    })(iteratee);
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const uniqBy$12 = uniqBy$2;
      const identity2 = identity$4;
      const isArrayLikeObject$1 = isArrayLikeObject;
      const iteratee$1 = iteratee;
      function uniqBy2(array2, iteratee$1$1 = identity2.identity) {
        if (!isArrayLikeObject$1.isArrayLikeObject(array2)) {
          return [];
        }
        return uniqBy$12.uniqBy(Array.from(array2), iteratee$1.iteratee(iteratee$1$1));
      }
      exports$1.uniqBy = uniqBy2;
    })(uniqBy$3);
    var uniqBy = uniqBy$3.uniqBy;
    const uniqBy$1 = /* @__PURE__ */ getDefaultExportFromCjs(uniqBy);
    function getUniqPayload(payload, option, defaultUniqBy2) {
      if (option === true) {
        return uniqBy$1(payload, defaultUniqBy2);
      }
      if (typeof option === "function") {
        return uniqBy$1(payload, option);
      }
      return payload;
    }
    var withSelector = { exports: {} };
    var withSelector_production = {};
    var shim$2 = { exports: {} };
    var useSyncExternalStoreShim_production = {};
    /**
     * @license React
     * use-sync-external-store-shim.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var React$2 = reactExports;
    function is$5(x2, y2) {
      return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
    }
    var objectIs$2 = "function" === typeof Object.is ? Object.is : is$5, useState = React$2.useState, useEffect$2 = React$2.useEffect, useLayoutEffect = React$2.useLayoutEffect, useDebugValue$2 = React$2.useDebugValue;
    function useSyncExternalStore$2(subscribe, getSnapshot) {
      var value = getSnapshot(), _useState = useState({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
      useLayoutEffect(
        function() {
          inst.value = value;
          inst.getSnapshot = getSnapshot;
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        },
        [subscribe, value, getSnapshot]
      );
      useEffect$2(
        function() {
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          return subscribe(function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          });
        },
        [subscribe]
      );
      useDebugValue$2(value);
      return value;
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs$2(inst, nextValue);
      } catch (error) {
        return true;
      }
    }
    function useSyncExternalStore$1$1(subscribe, getSnapshot) {
      return getSnapshot();
    }
    var shim$1 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1$1 : useSyncExternalStore$2;
    useSyncExternalStoreShim_production.useSyncExternalStore = void 0 !== React$2.useSyncExternalStore ? React$2.useSyncExternalStore : shim$1;
    {
      shim$2.exports = useSyncExternalStoreShim_production;
    }
    var shimExports = shim$2.exports;
    /**
     * @license React
     * use-sync-external-store-shim/with-selector.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var React$1 = reactExports, shim = shimExports;
    function is$4(x2, y2) {
      return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
    }
    var objectIs$1 = "function" === typeof Object.is ? Object.is : is$4, useSyncExternalStore$1 = shim.useSyncExternalStore, useRef$1 = React$1.useRef, useEffect$1 = React$1.useEffect, useMemo$1 = React$1.useMemo, useDebugValue$1 = React$1.useDebugValue;
    withSelector_production.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
      var instRef = useRef$1(null);
      if (null === instRef.current) {
        var inst = { hasValue: false, value: null };
        instRef.current = inst;
      } else inst = instRef.current;
      instRef = useMemo$1(
        function() {
          function memoizedSelector(nextSnapshot) {
            if (!hasMemo) {
              hasMemo = true;
              memoizedSnapshot = nextSnapshot;
              nextSnapshot = selector(nextSnapshot);
              if (void 0 !== isEqual && inst.hasValue) {
                var currentSelection = inst.value;
                if (isEqual(currentSelection, nextSnapshot))
                  return memoizedSelection = currentSelection;
              }
              return memoizedSelection = nextSnapshot;
            }
            currentSelection = memoizedSelection;
            if (objectIs$1(memoizedSnapshot, nextSnapshot)) return currentSelection;
            var nextSelection = selector(nextSnapshot);
            if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
              return memoizedSnapshot = nextSnapshot, currentSelection;
            memoizedSnapshot = nextSnapshot;
            return memoizedSelection = nextSelection;
          }
          var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
          return [
            function() {
              return memoizedSelector(getSnapshot());
            },
            null === maybeGetServerSnapshot ? void 0 : function() {
              return memoizedSelector(maybeGetServerSnapshot());
            }
          ];
        },
        [getSnapshot, getServerSnapshot, selector, isEqual]
      );
      var value = useSyncExternalStore$1(subscribe, instRef[0], instRef[1]);
      useEffect$1(
        function() {
          inst.hasValue = true;
          inst.value = value;
        },
        [value]
      );
      useDebugValue$1(value);
      return value;
    };
    {
      withSelector.exports = withSelector_production;
    }
    var withSelectorExports = withSelector.exports;
    var RechartsReduxContext = /* @__PURE__ */ reactExports.createContext(null);
    var noopDispatch = (a2) => a2;
    var useAppDispatch = () => {
      var context = reactExports.useContext(RechartsReduxContext);
      if (context) {
        return context.store.dispatch;
      }
      return noopDispatch;
    };
    var noop$1 = () => {
    };
    var addNestedSubNoop = () => noop$1;
    var refEquality = (a2, b) => a2 === b;
    function useAppSelector(selector) {
      var context = reactExports.useContext(RechartsReduxContext);
      return withSelectorExports.useSyncExternalStoreWithSelector(context ? context.subscription.addNestedSub : addNestedSubNoop, context ? context.store.getState : noop$1, context ? context.store.getState : noop$1, context ? selector : noop$1, refEquality);
    }
    function assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {
      if (typeof func !== "function") {
        throw new TypeError(errorMessage);
      }
    }
    function assertIsObject(object2, errorMessage = `expected an object, instead received ${typeof object2}`) {
      if (typeof object2 !== "object") {
        throw new TypeError(errorMessage);
      }
    }
    function assertIsArrayOfFunctions(array2, errorMessage = `expected all items to be functions, instead received the following types: `) {
      if (!array2.every((item) => typeof item === "function")) {
        const itemTypes = array2.map(
          (item) => typeof item === "function" ? `function ${item.name || "unnamed"}()` : typeof item
        ).join(", ");
        throw new TypeError(`${errorMessage}[${itemTypes}]`);
      }
    }
    var ensureIsArray = (item) => {
      return Array.isArray(item) ? item : [item];
    };
    function getDependencies(createSelectorArgs) {
      const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;
      assertIsArrayOfFunctions(
        dependencies,
        `createSelector expects all input-selectors to be functions, but received the following types: `
      );
      return dependencies;
    }
    function collectInputSelectorResults(dependencies, inputSelectorArgs) {
      const inputSelectorResults = [];
      const { length } = dependencies;
      for (let i = 0; i < length; i++) {
        inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));
      }
      return inputSelectorResults;
    }
    var StrongRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value;
      }
    };
    var Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
    var UNTERMINATED = 0;
    var TERMINATED = 1;
    function createCacheNode() {
      return {
        s: UNTERMINATED,
        v: void 0,
        o: null,
        p: null
      };
    }
    function weakMapMemoize(func, options = {}) {
      let fnNode = createCacheNode();
      const { resultEqualityCheck } = options;
      let lastResult2;
      let resultsCount = 0;
      function memoized() {
        var _a, _b;
        let cacheNode = fnNode;
        const { length } = arguments;
        for (let i = 0, l2 = length; i < l2; i++) {
          const arg = arguments[i];
          if (typeof arg === "function" || typeof arg === "object" && arg !== null) {
            let objectCache = cacheNode.o;
            if (objectCache === null) {
              cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();
            }
            const objectNode = objectCache.get(arg);
            if (objectNode === void 0) {
              cacheNode = createCacheNode();
              objectCache.set(arg, cacheNode);
            } else {
              cacheNode = objectNode;
            }
          } else {
            let primitiveCache = cacheNode.p;
            if (primitiveCache === null) {
              cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();
            }
            const primitiveNode = primitiveCache.get(arg);
            if (primitiveNode === void 0) {
              cacheNode = createCacheNode();
              primitiveCache.set(arg, cacheNode);
            } else {
              cacheNode = primitiveNode;
            }
          }
        }
        const terminatedNode = cacheNode;
        let result;
        if (cacheNode.s === TERMINATED) {
          result = cacheNode.v;
        } else {
          result = func.apply(null, arguments);
          resultsCount++;
          if (resultEqualityCheck) {
            const lastResultValue = (_b = (_a = lastResult2 == null ? void 0 : lastResult2.deref) == null ? void 0 : _a.call(lastResult2)) != null ? _b : lastResult2;
            if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {
              result = lastResultValue;
              resultsCount !== 0 && resultsCount--;
            }
            const needsWeakRef = typeof result === "object" && result !== null || typeof result === "function";
            lastResult2 = needsWeakRef ? new Ref(result) : result;
          }
        }
        terminatedNode.s = TERMINATED;
        terminatedNode.v = result;
        return result;
      }
      memoized.clearCache = () => {
        fnNode = createCacheNode();
        memoized.resetResultsCount();
      };
      memoized.resultsCount = () => resultsCount;
      memoized.resetResultsCount = () => {
        resultsCount = 0;
      };
      return memoized;
    }
    function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
      const createSelectorCreatorOptions = typeof memoizeOrOptions === "function" ? {
        memoize: memoizeOrOptions,
        memoizeOptions: memoizeOptionsFromArgs
      } : memoizeOrOptions;
      const createSelector2 = (...createSelectorArgs) => {
        let recomputations = 0;
        let dependencyRecomputations = 0;
        let lastResult2;
        let directlyPassedOptions = {};
        let resultFunc = createSelectorArgs.pop();
        if (typeof resultFunc === "object") {
          directlyPassedOptions = resultFunc;
          resultFunc = createSelectorArgs.pop();
        }
        assertIsFunction(
          resultFunc,
          `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`
        );
        const combinedOptions = __spreadValues(__spreadValues({}, createSelectorCreatorOptions), directlyPassedOptions);
        const {
          memoize,
          memoizeOptions = [],
          argsMemoize = weakMapMemoize,
          argsMemoizeOptions = []
        } = combinedOptions;
        const finalMemoizeOptions = ensureIsArray(memoizeOptions);
        const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
        const dependencies = getDependencies(createSelectorArgs);
        const memoizedResultFunc = memoize(function recomputationWrapper() {
          recomputations++;
          return resultFunc.apply(
            null,
            arguments
          );
        }, ...finalMemoizeOptions);
        const selector = argsMemoize(function dependenciesChecker() {
          dependencyRecomputations++;
          const inputSelectorResults = collectInputSelectorResults(
            dependencies,
            arguments
          );
          lastResult2 = memoizedResultFunc.apply(null, inputSelectorResults);
          return lastResult2;
        }, ...finalArgsMemoizeOptions);
        return Object.assign(selector, {
          resultFunc,
          memoizedResultFunc,
          dependencies,
          dependencyRecomputations: () => dependencyRecomputations,
          resetDependencyRecomputations: () => {
            dependencyRecomputations = 0;
          },
          lastResult: () => lastResult2,
          recomputations: () => recomputations,
          resetRecomputations: () => {
            recomputations = 0;
          },
          memoize,
          argsMemoize
        });
      };
      Object.assign(createSelector2, {
        withTypes: () => createSelector2
      });
      return createSelector2;
    }
    var createSelector = /* @__PURE__ */ createSelectorCreator(weakMapMemoize);
    var createStructuredSelector = Object.assign(
      (inputSelectorsObject, selectorCreator = createSelector) => {
        assertIsObject(
          inputSelectorsObject,
          `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`
        );
        const inputSelectorKeys = Object.keys(inputSelectorsObject);
        const dependencies = inputSelectorKeys.map(
          (key) => inputSelectorsObject[key]
        );
        const structuredSelector = selectorCreator(
          dependencies,
          (...inputSelectorResults) => {
            return inputSelectorResults.reduce((composition, value, index) => {
              composition[inputSelectorKeys[index]] = value;
              return composition;
            }, {});
          }
        );
        return structuredSelector;
      },
      { withTypes: () => createStructuredSelector }
    );
    var sortBy$2 = {};
    var orderBy = {};
    var compareValues = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      function getPriority(a2) {
        if (typeof a2 === "symbol") {
          return 1;
        }
        if (a2 === null) {
          return 2;
        }
        if (a2 === void 0) {
          return 3;
        }
        if (a2 !== a2) {
          return 4;
        }
        return 0;
      }
      const compareValues2 = (a2, b, order) => {
        if (a2 !== b) {
          const aPriority = getPriority(a2);
          const bPriority = getPriority(b);
          if (aPriority === bPriority && aPriority === 0) {
            if (a2 < b) {
              return order === "desc" ? 1 : -1;
            }
            if (a2 > b) {
              return order === "desc" ? -1 : 1;
            }
          }
          return order === "desc" ? bPriority - aPriority : aPriority - bPriority;
        }
        return 0;
      };
      exports$1.compareValues = compareValues2;
    })(compareValues);
    var isKey = {};
    var isSymbol = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      function isSymbol2(value) {
        return typeof value === "symbol" || value instanceof Symbol;
      }
      exports$1.isSymbol = isSymbol2;
    })(isSymbol);
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const isSymbol$1 = isSymbol;
      const regexIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
      const regexIsPlainProp = /^\w*$/;
      function isKey2(value, object2) {
        if (Array.isArray(value)) {
          return false;
        }
        if (typeof value === "number" || typeof value === "boolean" || value == null || isSymbol$1.isSymbol(value)) {
          return true;
        }
        return typeof value === "string" && (regexIsPlainProp.test(value) || !regexIsDeepProp.test(value)) || object2 != null && Object.hasOwn(object2, value);
      }
      exports$1.isKey = isKey2;
    })(isKey);
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const compareValues$1 = compareValues;
      const isKey$1 = isKey;
      const toPath$1 = toPath;
      function orderBy2(collection, criteria, orders, guard) {
        if (collection == null) {
          return [];
        }
        orders = guard ? void 0 : orders;
        if (!Array.isArray(collection)) {
          collection = Object.values(collection);
        }
        if (!Array.isArray(criteria)) {
          criteria = criteria == null ? [null] : [criteria];
        }
        if (criteria.length === 0) {
          criteria = [null];
        }
        if (!Array.isArray(orders)) {
          orders = orders == null ? [] : [orders];
        }
        orders = orders.map((order) => String(order));
        const getValueByNestedPath = (object2, path) => {
          let target = object2;
          for (let i = 0; i < path.length && target != null; ++i) {
            target = target[path[i]];
          }
          return target;
        };
        const getValueByCriterion = (criterion, object2) => {
          if (object2 == null || criterion == null) {
            return object2;
          }
          if (typeof criterion === "object" && "key" in criterion) {
            if (Object.hasOwn(object2, criterion.key)) {
              return object2[criterion.key];
            }
            return getValueByNestedPath(object2, criterion.path);
          }
          if (typeof criterion === "function") {
            return criterion(object2);
          }
          if (Array.isArray(criterion)) {
            return getValueByNestedPath(object2, criterion);
          }
          if (typeof object2 === "object") {
            return object2[criterion];
          }
          return object2;
        };
        const preparedCriteria = criteria.map((criterion) => {
          if (Array.isArray(criterion) && criterion.length === 1) {
            criterion = criterion[0];
          }
          if (criterion == null || typeof criterion === "function" || Array.isArray(criterion) || isKey$1.isKey(criterion)) {
            return criterion;
          }
          return { key: criterion, path: toPath$1.toPath(criterion) };
        });
        const preparedCollection = collection.map((item) => ({
          original: item,
          criteria: preparedCriteria.map((criterion) => getValueByCriterion(criterion, item))
        }));
        return preparedCollection.slice().sort((a2, b) => {
          for (let i = 0; i < preparedCriteria.length; i++) {
            const comparedResult = compareValues$1.compareValues(a2.criteria[i], b.criteria[i], orders[i]);
            if (comparedResult !== 0) {
              return comparedResult;
            }
          }
          return 0;
        }).map((item) => item.original);
      }
      exports$1.orderBy = orderBy2;
    })(orderBy);
    var flatten = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      function flatten2(arr, depth = 1) {
        const result = [];
        const flooredDepth = Math.floor(depth);
        const recursive = (arr2, currentDepth) => {
          for (let i = 0; i < arr2.length; i++) {
            const item = arr2[i];
            if (Array.isArray(item) && currentDepth < flooredDepth) {
              recursive(item, currentDepth + 1);
            } else {
              result.push(item);
            }
          }
        };
        recursive(arr, 0);
        return result;
      }
      exports$1.flatten = flatten2;
    })(flatten);
    var isIterateeCall = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const isIndex$1 = isIndex;
      const isArrayLike$1 = isArrayLike;
      const isObject$1 = isObject;
      const eq$1 = eq;
      function isIterateeCall2(value, index, object2) {
        if (!isObject$1.isObject(object2)) {
          return false;
        }
        if (typeof index === "number" && isArrayLike$1.isArrayLike(object2) && isIndex$1.isIndex(index) && index < object2.length || typeof index === "string" && index in object2) {
          return eq$1.eq(object2[index], value);
        }
        return false;
      }
      exports$1.isIterateeCall = isIterateeCall2;
    })(isIterateeCall);
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const orderBy$1 = orderBy;
      const flatten$1 = flatten;
      const isIterateeCall$1 = isIterateeCall;
      function sortBy2(collection, ...criteria) {
        const length = criteria.length;
        if (length > 1 && isIterateeCall$1.isIterateeCall(collection, criteria[0], criteria[1])) {
          criteria = [];
        } else if (length > 2 && isIterateeCall$1.isIterateeCall(criteria[0], criteria[1], criteria[2])) {
          criteria = [criteria[0]];
        }
        return orderBy$1.orderBy(collection, flatten$1.flatten(criteria), ["asc"]);
      }
      exports$1.sortBy = sortBy2;
    })(sortBy$2);
    var sortBy = sortBy$2.sortBy;
    const sortBy$1 = /* @__PURE__ */ getDefaultExportFromCjs(sortBy);
    var selectLegendSettings = (state) => state.legend.settings;
    var selectLegendSize = (state) => state.legend.size;
    var selectAllLegendPayload2DArray = (state) => state.legend.payload;
    var selectLegendPayload = createSelector([selectAllLegendPayload2DArray, selectLegendSettings], (payloads, _ref2) => {
      var {
        itemSorter
      } = _ref2;
      var flat = payloads.flat(1);
      return itemSorter ? sortBy$1(flat, itemSorter) : flat;
    });
    function useLegendPayload() {
      return useAppSelector(selectLegendPayload);
    }
    var EPS$1 = 1;
    function useElementOffset() {
      var extraDependencies = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var [lastBoundingBox, setLastBoundingBox] = reactExports.useState({
        height: 0,
        left: 0,
        top: 0,
        width: 0
      });
      var updateBoundingBox = reactExports.useCallback(
        (node) => {
          if (node != null) {
            var rect = node.getBoundingClientRect();
            var box = {
              height: rect.height,
              left: rect.left,
              top: rect.top,
              width: rect.width
            };
            if (Math.abs(box.height - lastBoundingBox.height) > EPS$1 || Math.abs(box.left - lastBoundingBox.left) > EPS$1 || Math.abs(box.top - lastBoundingBox.top) > EPS$1 || Math.abs(box.width - lastBoundingBox.width) > EPS$1) {
              setLastBoundingBox({
                height: box.height,
                left: box.left,
                top: box.top,
                width: box.width
              });
            }
          }
        },
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [lastBoundingBox.width, lastBoundingBox.height, lastBoundingBox.top, lastBoundingBox.left, ...extraDependencies]
      );
      return [lastBoundingBox, updateBoundingBox];
    }
    function formatProdErrorMessage$1(code) {
      return `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
    }
    var $$observable = /* @__PURE__ */ (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
    var symbol_observable_default = $$observable;
    var randomString = () => Math.random().toString(36).substring(7).split("").join(".");
    var ActionTypes = {
      INIT: `@@redux/INIT${/* @__PURE__ */ randomString()}`,
      REPLACE: `@@redux/REPLACE${/* @__PURE__ */ randomString()}`,
      PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`
    };
    var actionTypes_default = ActionTypes;
    function isPlainObject$5(obj) {
      if (typeof obj !== "object" || obj === null)
        return false;
      let proto = obj;
      while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
      }
      return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;
    }
    function createStore(reducer, preloadedState, enhancer) {
      if (typeof reducer !== "function") {
        throw new Error(formatProdErrorMessage$1(2));
      }
      if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
        throw new Error(formatProdErrorMessage$1(0));
      }
      if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
        enhancer = preloadedState;
        preloadedState = void 0;
      }
      if (typeof enhancer !== "undefined") {
        if (typeof enhancer !== "function") {
          throw new Error(formatProdErrorMessage$1(1));
        }
        return enhancer(createStore)(reducer, preloadedState);
      }
      let currentReducer = reducer;
      let currentState = preloadedState;
      let currentListeners = /* @__PURE__ */ new Map();
      let nextListeners = currentListeners;
      let listenerIdCounter = 0;
      let isDispatching = false;
      function ensureCanMutateNextListeners() {
        if (nextListeners === currentListeners) {
          nextListeners = /* @__PURE__ */ new Map();
          currentListeners.forEach((listener2, key) => {
            nextListeners.set(key, listener2);
          });
        }
      }
      function getState() {
        if (isDispatching) {
          throw new Error(formatProdErrorMessage$1(3));
        }
        return currentState;
      }
      function subscribe(listener2) {
        if (typeof listener2 !== "function") {
          throw new Error(formatProdErrorMessage$1(4));
        }
        if (isDispatching) {
          throw new Error(formatProdErrorMessage$1(5));
        }
        let isSubscribed = true;
        ensureCanMutateNextListeners();
        const listenerId = listenerIdCounter++;
        nextListeners.set(listenerId, listener2);
        return function unsubscribe() {
          if (!isSubscribed) {
            return;
          }
          if (isDispatching) {
            throw new Error(formatProdErrorMessage$1(6));
          }
          isSubscribed = false;
          ensureCanMutateNextListeners();
          nextListeners.delete(listenerId);
          currentListeners = null;
        };
      }
      function dispatch(action) {
        if (!isPlainObject$5(action)) {
          throw new Error(formatProdErrorMessage$1(7));
        }
        if (typeof action.type === "undefined") {
          throw new Error(formatProdErrorMessage$1(8));
        }
        if (typeof action.type !== "string") {
          throw new Error(formatProdErrorMessage$1(17));
        }
        if (isDispatching) {
          throw new Error(formatProdErrorMessage$1(9));
        }
        try {
          isDispatching = true;
          currentState = currentReducer(currentState, action);
        } finally {
          isDispatching = false;
        }
        const listeners = currentListeners = nextListeners;
        listeners.forEach((listener2) => {
          listener2();
        });
        return action;
      }
      function replaceReducer(nextReducer) {
        if (typeof nextReducer !== "function") {
          throw new Error(formatProdErrorMessage$1(10));
        }
        currentReducer = nextReducer;
        dispatch({
          type: actionTypes_default.REPLACE
        });
      }
      function observable() {
        const outerSubscribe = subscribe;
        return {
          /**
           * The minimal observable subscription method.
           * @param observer Any object that can be used as an observer.
           * The observer object should have a `next` method.
           * @returns An object with an `unsubscribe` method that can
           * be used to unsubscribe the observable from the store, and prevent further
           * emission of values from the observable.
           */
          subscribe(observer) {
            if (typeof observer !== "object" || observer === null) {
              throw new Error(formatProdErrorMessage$1(11));
            }
            function observeState() {
              const observerAsObserver = observer;
              if (observerAsObserver.next) {
                observerAsObserver.next(getState());
              }
            }
            observeState();
            const unsubscribe = outerSubscribe(observeState);
            return {
              unsubscribe
            };
          },
          [symbol_observable_default]() {
            return this;
          }
        };
      }
      dispatch({
        type: actionTypes_default.INIT
      });
      const store = {
        dispatch,
        subscribe,
        getState,
        replaceReducer,
        [symbol_observable_default]: observable
      };
      return store;
    }
    function assertReducerShape(reducers) {
      Object.keys(reducers).forEach((key) => {
        const reducer = reducers[key];
        const initialState2 = reducer(void 0, {
          type: actionTypes_default.INIT
        });
        if (typeof initialState2 === "undefined") {
          throw new Error(formatProdErrorMessage$1(12));
        }
        if (typeof reducer(void 0, {
          type: actionTypes_default.PROBE_UNKNOWN_ACTION()
        }) === "undefined") {
          throw new Error(formatProdErrorMessage$1(13));
        }
      });
    }
    function combineReducers(reducers) {
      const reducerKeys = Object.keys(reducers);
      const finalReducers = {};
      for (let i = 0; i < reducerKeys.length; i++) {
        const key = reducerKeys[i];
        if (typeof reducers[key] === "function") {
          finalReducers[key] = reducers[key];
        }
      }
      const finalReducerKeys = Object.keys(finalReducers);
      let shapeAssertionError;
      try {
        assertReducerShape(finalReducers);
      } catch (e) {
        shapeAssertionError = e;
      }
      return function combination(state = {}, action) {
        if (shapeAssertionError) {
          throw shapeAssertionError;
        }
        let hasChanged = false;
        const nextState = {};
        for (let i = 0; i < finalReducerKeys.length; i++) {
          const key = finalReducerKeys[i];
          const reducer = finalReducers[key];
          const previousStateForKey = state[key];
          const nextStateForKey = reducer(previousStateForKey, action);
          if (typeof nextStateForKey === "undefined") {
            action && action.type;
            throw new Error(formatProdErrorMessage$1(14));
          }
          nextState[key] = nextStateForKey;
          hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
        }
        hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
        return hasChanged ? nextState : state;
      };
    }
    function compose$1(...funcs) {
      if (funcs.length === 0) {
        return (arg) => arg;
      }
      if (funcs.length === 1) {
        return funcs[0];
      }
      return funcs.reduce((a2, b) => (...args) => a2(b(...args)));
    }
    function applyMiddleware(...middlewares) {
      return (createStore2) => (reducer, preloadedState) => {
        const store = createStore2(reducer, preloadedState);
        let dispatch = () => {
          throw new Error(formatProdErrorMessage$1(15));
        };
        const middlewareAPI = {
          getState: store.getState,
          dispatch: (action, ...args) => dispatch(action, ...args)
        };
        const chain = middlewares.map((middleware) => middleware(middlewareAPI));
        dispatch = compose$1(...chain)(store.dispatch);
        return __spreadProps(__spreadValues({}, store), {
          dispatch
        });
      };
    }
    function isAction(action) {
      return isPlainObject$5(action) && "type" in action && typeof action.type === "string";
    }
    var NOTHING$1 = Symbol.for("immer-nothing");
    var DRAFTABLE$1 = Symbol.for("immer-draftable");
    var DRAFT_STATE$1 = Symbol.for("immer-state");
    function die$1(error, ...args) {
      throw new Error(
        `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
      );
    }
    var O = Object;
    var getPrototypeOf$1 = O.getPrototypeOf;
    var CONSTRUCTOR = "constructor";
    var PROTOTYPE = "prototype";
    var CONFIGURABLE = "configurable";
    var ENUMERABLE = "enumerable";
    var WRITABLE = "writable";
    var VALUE = "value";
    var isDraft$1 = (value) => !!value && !!value[DRAFT_STATE$1];
    function isDraftable$1(value) {
      var _a;
      if (!value)
        return false;
      return isPlainObject$4(value) || isArray(value) || !!value[DRAFTABLE$1] || !!((_a = value[CONSTRUCTOR]) == null ? void 0 : _a[DRAFTABLE$1]) || isMap$1(value) || isSet$1(value);
    }
    var objectCtorString$1 = O[PROTOTYPE][CONSTRUCTOR].toString();
    var cachedCtorStrings$1 = /* @__PURE__ */ new WeakMap();
    function isPlainObject$4(value) {
      if (!value || !isObjectish(value))
        return false;
      const proto = getPrototypeOf$1(value);
      if (proto === null || proto === O[PROTOTYPE])
        return true;
      const Ctor = O.hasOwnProperty.call(proto, CONSTRUCTOR) && proto[CONSTRUCTOR];
      if (Ctor === Object)
        return true;
      if (!isFunction(Ctor))
        return false;
      let ctorString = cachedCtorStrings$1.get(Ctor);
      if (ctorString === void 0) {
        ctorString = Function.toString.call(Ctor);
        cachedCtorStrings$1.set(Ctor, ctorString);
      }
      return ctorString === objectCtorString$1;
    }
    function each$1(obj, iter, strict = true) {
      if (getArchtype$1(obj) === 0) {
        const keys = strict ? Reflect.ownKeys(obj) : O.keys(obj);
        keys.forEach((key) => {
          iter(key, obj[key], obj);
        });
      } else {
        obj.forEach((entry, index) => iter(index, entry, obj));
      }
    }
    function getArchtype$1(thing) {
      const state = thing[DRAFT_STATE$1];
      return state ? state.type_ : isArray(thing) ? 1 : isMap$1(thing) ? 2 : isSet$1(thing) ? 3 : 0;
    }
    var has$1 = (thing, prop, type = getArchtype$1(thing)) => type === 2 ? thing.has(prop) : O[PROTOTYPE].hasOwnProperty.call(thing, prop);
    var get = (thing, prop, type = getArchtype$1(thing)) => (
      // @ts-ignore
      type === 2 ? thing.get(prop) : thing[prop]
    );
    var set$1 = (thing, propOrOldValue, value, type = getArchtype$1(thing)) => {
      if (type === 2)
        thing.set(propOrOldValue, value);
      else if (type === 3) {
        thing.add(value);
      } else
        thing[propOrOldValue] = value;
    };
    function is$3(x2, y2) {
      if (x2 === y2) {
        return x2 !== 0 || 1 / x2 === 1 / y2;
      } else {
        return x2 !== x2 && y2 !== y2;
      }
    }
    var isArray = Array.isArray;
    var isMap$1 = (target) => target instanceof Map;
    var isSet$1 = (target) => target instanceof Set;
    var isObjectish = (target) => typeof target === "object";
    var isFunction = (target) => typeof target === "function";
    var isBoolean$1 = (target) => typeof target === "boolean";
    var latest$1 = (state) => state.copy_ || state.base_;
    var getFinalValue = (state) => state.modified_ ? state.copy_ : state.base_;
    function shallowCopy$1(base, strict) {
      if (isMap$1(base)) {
        return new Map(base);
      }
      if (isSet$1(base)) {
        return new Set(base);
      }
      if (isArray(base))
        return Array[PROTOTYPE].slice.call(base);
      const isPlain = isPlainObject$4(base);
      if (strict === true || strict === "class_only" && !isPlain) {
        const descriptors = O.getOwnPropertyDescriptors(base);
        delete descriptors[DRAFT_STATE$1];
        let keys = Reflect.ownKeys(descriptors);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const desc = descriptors[key];
          if (desc[WRITABLE] === false) {
            desc[WRITABLE] = true;
            desc[CONFIGURABLE] = true;
          }
          if (desc.get || desc.set)
            descriptors[key] = {
              [CONFIGURABLE]: true,
              [WRITABLE]: true,
              // could live with !!desc.set as well here...
              [ENUMERABLE]: desc[ENUMERABLE],
              [VALUE]: base[key]
            };
        }
        return O.create(getPrototypeOf$1(base), descriptors);
      } else {
        const proto = getPrototypeOf$1(base);
        if (proto !== null && isPlain) {
          return __spreadValues({}, base);
        }
        const obj = O.create(proto);
        return O.assign(obj, base);
      }
    }
    function freeze$1(obj, deep = false) {
      if (isFrozen$1(obj) || isDraft$1(obj) || !isDraftable$1(obj))
        return obj;
      if (getArchtype$1(obj) > 1) {
        O.defineProperties(obj, {
          set: dontMutateMethodOverride$1,
          add: dontMutateMethodOverride$1,
          clear: dontMutateMethodOverride$1,
          delete: dontMutateMethodOverride$1
        });
      }
      O.freeze(obj);
      if (deep)
        each$1(
          obj,
          (_key, value) => {
            freeze$1(value, true);
          },
          false
        );
      return obj;
    }
    function dontMutateFrozenCollections$1() {
      die$1(2);
    }
    var dontMutateMethodOverride$1 = {
      [VALUE]: dontMutateFrozenCollections$1
    };
    function isFrozen$1(obj) {
      if (obj === null || !isObjectish(obj))
        return true;
      return O.isFrozen(obj);
    }
    var PluginMapSet = "MapSet";
    var PluginPatches = "Patches";
    var plugins$1 = {};
    function getPlugin$1(pluginKey) {
      const plugin = plugins$1[pluginKey];
      if (!plugin) {
        die$1(0, pluginKey);
      }
      return plugin;
    }
    var isPluginLoaded = (pluginKey) => !!plugins$1[pluginKey];
    var currentScope$1;
    var getCurrentScope$1 = () => currentScope$1;
    var createScope$1 = (parent_, immer_) => ({
      drafts_: [],
      parent_,
      immer_,
      // Whenever the modified draft contains a draft from another scope, we
      // need to prevent auto-freezing so the unowned draft can be finalized.
      canAutoFreeze_: true,
      unfinalizedDrafts_: 0,
      handledSet_: /* @__PURE__ */ new Set(),
      processedForPatches_: /* @__PURE__ */ new Set(),
      mapSetPlugin_: isPluginLoaded(PluginMapSet) ? getPlugin$1(PluginMapSet) : void 0
    });
    function usePatchesInScope$1(scope, patchListener) {
      if (patchListener) {
        scope.patchPlugin_ = getPlugin$1(PluginPatches);
        scope.patches_ = [];
        scope.inversePatches_ = [];
        scope.patchListener_ = patchListener;
      }
    }
    function revokeScope$1(scope) {
      leaveScope$1(scope);
      scope.drafts_.forEach(revokeDraft$1);
      scope.drafts_ = null;
    }
    function leaveScope$1(scope) {
      if (scope === currentScope$1) {
        currentScope$1 = scope.parent_;
      }
    }
    var enterScope$1 = (immer2) => currentScope$1 = createScope$1(currentScope$1, immer2);
    function revokeDraft$1(draft) {
      const state = draft[DRAFT_STATE$1];
      if (state.type_ === 0 || state.type_ === 1)
        state.revoke_();
      else
        state.revoked_ = true;
    }
    function processResult$1(result, scope) {
      scope.unfinalizedDrafts_ = scope.drafts_.length;
      const baseDraft = scope.drafts_[0];
      const isReplaced = result !== void 0 && result !== baseDraft;
      if (isReplaced) {
        if (baseDraft[DRAFT_STATE$1].modified_) {
          revokeScope$1(scope);
          die$1(4);
        }
        if (isDraftable$1(result)) {
          result = finalize$1(scope, result);
        }
        const { patchPlugin_ } = scope;
        if (patchPlugin_) {
          patchPlugin_.generateReplacementPatches_(
            baseDraft[DRAFT_STATE$1].base_,
            result,
            scope
          );
        }
      } else {
        result = finalize$1(scope, baseDraft);
      }
      maybeFreeze$1(scope, result, true);
      revokeScope$1(scope);
      if (scope.patches_) {
        scope.patchListener_(scope.patches_, scope.inversePatches_);
      }
      return result !== NOTHING$1 ? result : void 0;
    }
    function finalize$1(rootScope, value) {
      if (isFrozen$1(value))
        return value;
      const state = value[DRAFT_STATE$1];
      if (!state) {
        const finalValue = handleValue(value, rootScope.handledSet_, rootScope);
        return finalValue;
      }
      if (!isSameScope(state, rootScope)) {
        return value;
      }
      if (!state.modified_) {
        return state.base_;
      }
      if (!state.finalized_) {
        const { callbacks_ } = state;
        if (callbacks_) {
          while (callbacks_.length > 0) {
            const callback = callbacks_.pop();
            callback(rootScope);
          }
        }
        generatePatchesAndFinalize(state, rootScope);
      }
      return state.copy_;
    }
    function maybeFreeze$1(scope, value, deep = false) {
      if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
        freeze$1(value, deep);
      }
    }
    function markStateFinalized(state) {
      state.finalized_ = true;
      state.scope_.unfinalizedDrafts_--;
    }
    var isSameScope = (state, rootScope) => state.scope_ === rootScope;
    var EMPTY_LOCATIONS_RESULT = [];
    function updateDraftInParent(parent, draftValue, finalizedValue, originalKey) {
      var _a;
      const parentCopy = latest$1(parent);
      const parentType = parent.type_;
      if (originalKey !== void 0) {
        const currentValue = get(parentCopy, originalKey, parentType);
        if (currentValue === draftValue) {
          set$1(parentCopy, originalKey, finalizedValue, parentType);
          return;
        }
      }
      if (!parent.draftLocations_) {
        const draftLocations = parent.draftLocations_ = /* @__PURE__ */ new Map();
        each$1(parentCopy, (key, value) => {
          if (isDraft$1(value)) {
            const keys = draftLocations.get(value) || [];
            keys.push(key);
            draftLocations.set(value, keys);
          }
        });
      }
      const locations = (_a = parent.draftLocations_.get(draftValue)) != null ? _a : EMPTY_LOCATIONS_RESULT;
      for (const location of locations) {
        set$1(parentCopy, location, finalizedValue, parentType);
      }
    }
    function registerChildFinalizationCallback(parent, child, key) {
      parent.callbacks_.push(function childCleanup(rootScope) {
        var _a, _b;
        const state = child;
        if (!state || !isSameScope(state, rootScope)) {
          return;
        }
        (_a = rootScope.mapSetPlugin_) == null ? void 0 : _a.fixSetContents(state);
        const finalizedValue = getFinalValue(state);
        updateDraftInParent(parent, (_b = state.draft_) != null ? _b : state, finalizedValue, key);
        generatePatchesAndFinalize(state, rootScope);
      });
    }
    function generatePatchesAndFinalize(state, rootScope) {
      var _a, _b;
      const shouldFinalize = state.modified_ && !state.finalized_ && (state.type_ === 3 || ((_b = (_a = state.assigned_) == null ? void 0 : _a.size) != null ? _b : 0) > 0);
      if (shouldFinalize) {
        const { patchPlugin_ } = rootScope;
        if (patchPlugin_) {
          const basePath = patchPlugin_.getPath(state);
          if (basePath) {
            patchPlugin_.generatePatches_(state, basePath, rootScope);
          }
        }
        markStateFinalized(state);
      }
    }
    function handleCrossReference(target, key, value) {
      const { scope_ } = target;
      if (isDraft$1(value)) {
        const state = value[DRAFT_STATE$1];
        if (isSameScope(state, scope_)) {
          state.callbacks_.push(function crossReferenceCleanup() {
            prepareCopy$1(target);
            const finalizedValue = getFinalValue(state);
            updateDraftInParent(target, value, finalizedValue, key);
          });
        }
      } else if (isDraftable$1(value)) {
        target.callbacks_.push(function nestedDraftCleanup() {
          var _a;
          const targetCopy = latest$1(target);
          if (get(targetCopy, key, target.type_) === value) {
            if (scope_.drafts_.length > 1 && ((_a = target.assigned_.get(key)) != null ? _a : false) === true && target.copy_) {
              handleValue(
                get(target.copy_, key, target.type_),
                scope_.handledSet_,
                scope_
              );
            }
          }
        });
      }
    }
    function handleValue(target, handledSet, rootScope) {
      if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
        return target;
      }
      if (isDraft$1(target) || handledSet.has(target) || !isDraftable$1(target) || isFrozen$1(target)) {
        return target;
      }
      handledSet.add(target);
      each$1(target, (key, value) => {
        if (isDraft$1(value)) {
          const state = value[DRAFT_STATE$1];
          if (isSameScope(state, rootScope)) {
            const updatedValue = getFinalValue(state);
            set$1(target, key, updatedValue, target.type_);
            markStateFinalized(state);
          }
        } else if (isDraftable$1(value)) {
          handleValue(value, handledSet, rootScope);
        }
      });
      return target;
    }
    function createProxyProxy$1(base, parent) {
      const baseIsArray = isArray(base);
      const state = {
        type_: baseIsArray ? 1 : 0,
        // Track which produce call this is associated with.
        scope_: parent ? parent.scope_ : getCurrentScope$1(),
        // True for both shallow and deep changes.
        modified_: false,
        // Used during finalization.
        finalized_: false,
        // Track which properties have been assigned (true) or deleted (false).
        // actually instantiated in `prepareCopy()`
        assigned_: void 0,
        // The parent draft state.
        parent_: parent,
        // The base state.
        base_: base,
        // The base proxy.
        draft_: null,
        // set below
        // The base copy with any updated values.
        copy_: null,
        // Called by the `produce` function.
        revoke_: null,
        isManual_: false,
        // `callbacks` actually gets assigned in `createProxy`
        callbacks_: void 0
      };
      let target = state;
      let traps = objectTraps$1;
      if (baseIsArray) {
        target = [state];
        traps = arrayTraps$1;
      }
      const { revoke, proxy } = Proxy.revocable(target, traps);
      state.draft_ = proxy;
      state.revoke_ = revoke;
      return [proxy, state];
    }
    var objectTraps$1 = {
      get(state, prop) {
        if (prop === DRAFT_STATE$1)
          return state;
        const source = latest$1(state);
        if (!has$1(source, prop, state.type_)) {
          return readPropFromProto$1(state, source, prop);
        }
        const value = source[prop];
        if (state.finalized_ || !isDraftable$1(value)) {
          return value;
        }
        if (value === peek$1(state.base_, prop)) {
          prepareCopy$1(state);
          const childKey = state.type_ === 1 ? +prop : prop;
          const childDraft = createProxy$1(state.scope_, value, state, childKey);
          return state.copy_[childKey] = childDraft;
        }
        return value;
      },
      has(state, prop) {
        return prop in latest$1(state);
      },
      ownKeys(state) {
        return Reflect.ownKeys(latest$1(state));
      },
      set(state, prop, value) {
        const desc = getDescriptorFromProto$1(latest$1(state), prop);
        if (desc == null ? void 0 : desc.set) {
          desc.set.call(state.draft_, value);
          return true;
        }
        if (!state.modified_) {
          const current2 = peek$1(latest$1(state), prop);
          const currentState = current2 == null ? void 0 : current2[DRAFT_STATE$1];
          if (currentState && currentState.base_ === value) {
            state.copy_[prop] = value;
            state.assigned_.set(prop, false);
            return true;
          }
          if (is$3(value, current2) && (value !== void 0 || has$1(state.base_, prop, state.type_)))
            return true;
          prepareCopy$1(state);
          markChanged$1(state);
        }
        if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
        (value !== void 0 || prop in state.copy_) || // special case: NaN
        Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
          return true;
        state.copy_[prop] = value;
        state.assigned_.set(prop, true);
        handleCrossReference(state, prop, value);
        return true;
      },
      deleteProperty(state, prop) {
        prepareCopy$1(state);
        if (peek$1(state.base_, prop) !== void 0 || prop in state.base_) {
          state.assigned_.set(prop, false);
          markChanged$1(state);
        } else {
          state.assigned_.delete(prop);
        }
        if (state.copy_) {
          delete state.copy_[prop];
        }
        return true;
      },
      // Note: We never coerce `desc.value` into an Immer draft, because we can't make
      // the same guarantee in ES5 mode.
      getOwnPropertyDescriptor(state, prop) {
        const owner = latest$1(state);
        const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
        if (!desc)
          return desc;
        return {
          [WRITABLE]: true,
          [CONFIGURABLE]: state.type_ !== 1 || prop !== "length",
          [ENUMERABLE]: desc[ENUMERABLE],
          [VALUE]: owner[prop]
        };
      },
      defineProperty() {
        die$1(11);
      },
      getPrototypeOf(state) {
        return getPrototypeOf$1(state.base_);
      },
      setPrototypeOf() {
        die$1(12);
      }
    };
    var arrayTraps$1 = {};
    each$1(objectTraps$1, (key, fn) => {
      arrayTraps$1[key] = function() {
        const args = arguments;
        args[0] = args[0][0];
        return fn.apply(this, args);
      };
    });
    arrayTraps$1.deleteProperty = function(state, prop) {
      return arrayTraps$1.set.call(this, state, prop, void 0);
    };
    arrayTraps$1.set = function(state, prop, value) {
      return objectTraps$1.set.call(this, state[0], prop, value, state[0]);
    };
    function peek$1(draft, prop) {
      const state = draft[DRAFT_STATE$1];
      const source = state ? latest$1(state) : draft;
      return source[prop];
    }
    function readPropFromProto$1(state, source, prop) {
      var _a;
      const desc = getDescriptorFromProto$1(source, prop);
      return desc ? VALUE in desc ? desc[VALUE] : (
        // This is a very special case, if the prop is a getter defined by the
        // prototype, we should invoke it with the draft as context!
        (_a = desc.get) == null ? void 0 : _a.call(state.draft_)
      ) : void 0;
    }
    function getDescriptorFromProto$1(source, prop) {
      if (!(prop in source))
        return void 0;
      let proto = getPrototypeOf$1(source);
      while (proto) {
        const desc = Object.getOwnPropertyDescriptor(proto, prop);
        if (desc)
          return desc;
        proto = getPrototypeOf$1(proto);
      }
      return void 0;
    }
    function markChanged$1(state) {
      if (!state.modified_) {
        state.modified_ = true;
        if (state.parent_) {
          markChanged$1(state.parent_);
        }
      }
    }
    function prepareCopy$1(state) {
      if (!state.copy_) {
        state.assigned_ = /* @__PURE__ */ new Map();
        state.copy_ = shallowCopy$1(
          state.base_,
          state.scope_.immer_.useStrictShallowCopy_
        );
      }
    }
    var Immer2$1 = class Immer2 {
      constructor(config2) {
        this.autoFreeze_ = true;
        this.useStrictShallowCopy_ = false;
        this.useStrictIteration_ = false;
        this.produce = (base, recipe, patchListener) => {
          if (isFunction(base) && !isFunction(recipe)) {
            const defaultBase = recipe;
            recipe = base;
            const self2 = this;
            return function curriedProduce(base2 = defaultBase, ...args) {
              return self2.produce(base2, (draft) => recipe.call(this, draft, ...args));
            };
          }
          if (!isFunction(recipe))
            die$1(6);
          if (patchListener !== void 0 && !isFunction(patchListener))
            die$1(7);
          let result;
          if (isDraftable$1(base)) {
            const scope = enterScope$1(this);
            const proxy = createProxy$1(scope, base, void 0);
            let hasError = true;
            try {
              result = recipe(proxy);
              hasError = false;
            } finally {
              if (hasError)
                revokeScope$1(scope);
              else
                leaveScope$1(scope);
            }
            usePatchesInScope$1(scope, patchListener);
            return processResult$1(result, scope);
          } else if (!base || !isObjectish(base)) {
            result = recipe(base);
            if (result === void 0)
              result = base;
            if (result === NOTHING$1)
              result = void 0;
            if (this.autoFreeze_)
              freeze$1(result, true);
            if (patchListener) {
              const p2 = [];
              const ip = [];
              getPlugin$1(PluginPatches).generateReplacementPatches_(base, result, {
                patches_: p2,
                inversePatches_: ip
              });
              patchListener(p2, ip);
            }
            return result;
          } else
            die$1(1, base);
        };
        this.produceWithPatches = (base, recipe) => {
          if (isFunction(base)) {
            return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
          }
          let patches, inversePatches;
          const result = this.produce(base, recipe, (p2, ip) => {
            patches = p2;
            inversePatches = ip;
          });
          return [result, patches, inversePatches];
        };
        if (isBoolean$1(config2 == null ? void 0 : config2.autoFreeze))
          this.setAutoFreeze(config2.autoFreeze);
        if (isBoolean$1(config2 == null ? void 0 : config2.useStrictShallowCopy))
          this.setUseStrictShallowCopy(config2.useStrictShallowCopy);
        if (isBoolean$1(config2 == null ? void 0 : config2.useStrictIteration))
          this.setUseStrictIteration(config2.useStrictIteration);
      }
      createDraft(base) {
        if (!isDraftable$1(base))
          die$1(8);
        if (isDraft$1(base))
          base = current$1(base);
        const scope = enterScope$1(this);
        const proxy = createProxy$1(scope, base, void 0);
        proxy[DRAFT_STATE$1].isManual_ = true;
        leaveScope$1(scope);
        return proxy;
      }
      finishDraft(draft, patchListener) {
        const state = draft && draft[DRAFT_STATE$1];
        if (!state || !state.isManual_)
          die$1(9);
        const { scope_: scope } = state;
        usePatchesInScope$1(scope, patchListener);
        return processResult$1(void 0, scope);
      }
      /**
       * Pass true to automatically freeze all copies created by Immer.
       *
       * By default, auto-freezing is enabled.
       */
      setAutoFreeze(value) {
        this.autoFreeze_ = value;
      }
      /**
       * Pass true to enable strict shallow copy.
       *
       * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
       */
      setUseStrictShallowCopy(value) {
        this.useStrictShallowCopy_ = value;
      }
      /**
       * Pass false to use faster iteration that skips non-enumerable properties
       * but still handles symbols for compatibility.
       *
       * By default, strict iteration is enabled (includes all own properties).
       */
      setUseStrictIteration(value) {
        this.useStrictIteration_ = value;
      }
      shouldUseStrictIteration() {
        return this.useStrictIteration_;
      }
      applyPatches(base, patches) {
        let i;
        for (i = patches.length - 1; i >= 0; i--) {
          const patch = patches[i];
          if (patch.path.length === 0 && patch.op === "replace") {
            base = patch.value;
            break;
          }
        }
        if (i > -1) {
          patches = patches.slice(i + 1);
        }
        const applyPatchesImpl = getPlugin$1(PluginPatches).applyPatches_;
        if (isDraft$1(base)) {
          return applyPatchesImpl(base, patches);
        }
        return this.produce(
          base,
          (draft) => applyPatchesImpl(draft, patches)
        );
      }
    };
    function createProxy$1(rootScope, value, parent, key) {
      var _a, _b;
      const [draft, state] = isMap$1(value) ? getPlugin$1(PluginMapSet).proxyMap_(value, parent) : isSet$1(value) ? getPlugin$1(PluginMapSet).proxySet_(value, parent) : createProxyProxy$1(value, parent);
      const scope = (_a = parent == null ? void 0 : parent.scope_) != null ? _a : getCurrentScope$1();
      scope.drafts_.push(draft);
      state.callbacks_ = (_b = parent == null ? void 0 : parent.callbacks_) != null ? _b : [];
      state.key_ = key;
      if (parent && key !== void 0) {
        registerChildFinalizationCallback(parent, state, key);
      } else {
        state.callbacks_.push(function rootDraftCleanup(rootScope2) {
          var _a2;
          (_a2 = rootScope2.mapSetPlugin_) == null ? void 0 : _a2.fixSetContents(state);
          const { patchPlugin_ } = rootScope2;
          if (state.modified_ && patchPlugin_) {
            patchPlugin_.generatePatches_(state, [], rootScope2);
          }
        });
      }
      return draft;
    }
    function current$1(value) {
      if (!isDraft$1(value))
        die$1(10, value);
      return currentImpl$1(value);
    }
    function currentImpl$1(value) {
      if (!isDraftable$1(value) || isFrozen$1(value))
        return value;
      const state = value[DRAFT_STATE$1];
      let copy2;
      let strict = true;
      if (state) {
        if (!state.modified_)
          return state.base_;
        state.finalized_ = true;
        copy2 = shallowCopy$1(value, state.scope_.immer_.useStrictShallowCopy_);
        strict = state.scope_.immer_.shouldUseStrictIteration();
      } else {
        copy2 = shallowCopy$1(value, true);
      }
      each$1(
        copy2,
        (key, childValue) => {
          set$1(copy2, key, currentImpl$1(childValue));
        },
        strict
      );
      if (state) {
        state.finalized_ = false;
      }
      return copy2;
    }
    var immer$1 = new Immer2$1();
    var produce = immer$1.produce;
    function createThunkMiddleware(extraArgument) {
      const middleware = ({ dispatch, getState }) => (next) => (action) => {
        if (typeof action === "function") {
          return action(dispatch, getState, extraArgument);
        }
        return next(action);
      };
      return middleware;
    }
    var thunk = createThunkMiddleware();
    var withExtraArgument = createThunkMiddleware;
    var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
      if (arguments.length === 0) return void 0;
      if (typeof arguments[0] === "object") return compose$1;
      return compose$1.apply(null, arguments);
    };
    function createAction(type, prepareAction) {
      function actionCreator(...args) {
        if (prepareAction) {
          let prepared = prepareAction(...args);
          if (!prepared) {
            throw new Error(formatProdErrorMessage(0));
          }
          return __spreadValues(__spreadValues({
            type,
            payload: prepared.payload
          }, "meta" in prepared && {
            meta: prepared.meta
          }), "error" in prepared && {
            error: prepared.error
          });
        }
        return {
          type,
          payload: args[0]
        };
      }
      actionCreator.toString = () => `${type}`;
      actionCreator.type = type;
      actionCreator.match = (action) => isAction(action) && action.type === type;
      return actionCreator;
    }
    var Tuple = class _Tuple extends Array {
      constructor(...items) {
        super(...items);
        Object.setPrototypeOf(this, _Tuple.prototype);
      }
      static get [Symbol.species]() {
        return _Tuple;
      }
      concat(...arr) {
        return super.concat.apply(this, arr);
      }
      prepend(...arr) {
        if (arr.length === 1 && Array.isArray(arr[0])) {
          return new _Tuple(...arr[0].concat(this));
        }
        return new _Tuple(...arr.concat(this));
      }
    };
    function freezeDraftable(val) {
      return isDraftable$1(val) ? produce(val, () => {
      }) : val;
    }
    function getOrInsertComputed(map2, key, compute) {
      if (map2.has(key)) return map2.get(key);
      return map2.set(key, compute(key)).get(key);
    }
    function isBoolean(x2) {
      return typeof x2 === "boolean";
    }
    var buildGetDefaultMiddleware = () => function getDefaultMiddleware(options) {
      const {
        thunk: thunk$1 = true,
        immutableCheck = true,
        serializableCheck = true,
        actionCreatorCheck = true
      } = options != null ? options : {};
      let middlewareArray = new Tuple();
      if (thunk$1) {
        if (isBoolean(thunk$1)) {
          middlewareArray.push(thunk);
        } else {
          middlewareArray.push(withExtraArgument(thunk$1.extraArgument));
        }
      }
      return middlewareArray;
    };
    var SHOULD_AUTOBATCH = "RTK_autoBatch";
    var prepareAutoBatched = () => (payload) => ({
      payload,
      meta: {
        [SHOULD_AUTOBATCH]: true
      }
    });
    var createQueueWithTimer = (timeout) => {
      return (notify) => {
        setTimeout(notify, timeout);
      };
    };
    var autoBatchEnhancer = (options = {
      type: "raf"
    }) => (next) => (...args) => {
      const store = next(...args);
      let notifying = true;
      let shouldNotifyAtEndOfTick = false;
      let notificationQueued = false;
      const listeners = /* @__PURE__ */ new Set();
      const queueCallback = options.type === "tick" ? queueMicrotask : options.type === "raf" ? (
        // requestAnimationFrame won't exist in SSR environments. Fall back to a vague approximation just to keep from erroring.
        typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10)
      ) : options.type === "callback" ? options.queueNotification : createQueueWithTimer(options.timeout);
      const notifyListeners = () => {
        notificationQueued = false;
        if (shouldNotifyAtEndOfTick) {
          shouldNotifyAtEndOfTick = false;
          listeners.forEach((l2) => l2());
        }
      };
      return Object.assign({}, store, {
        // Override the base `store.subscribe` method to keep original listeners
        // from running if we're delaying notifications
        subscribe(listener2) {
          const wrappedListener = () => notifying && listener2();
          const unsubscribe = store.subscribe(wrappedListener);
          listeners.add(listener2);
          return () => {
            unsubscribe();
            listeners.delete(listener2);
          };
        },
        // Override the base `store.dispatch` method so that we can check actions
        // for the `shouldAutoBatch` flag and determine if batching is active
        dispatch(action) {
          var _a;
          try {
            notifying = !((_a = action == null ? void 0 : action.meta) == null ? void 0 : _a[SHOULD_AUTOBATCH]);
            shouldNotifyAtEndOfTick = !notifying;
            if (shouldNotifyAtEndOfTick) {
              if (!notificationQueued) {
                notificationQueued = true;
                queueCallback(notifyListeners);
              }
            }
            return store.dispatch(action);
          } finally {
            notifying = true;
          }
        }
      });
    };
    var buildGetDefaultEnhancers = (middlewareEnhancer) => function getDefaultEnhancers(options) {
      const {
        autoBatch = true
      } = options != null ? options : {};
      let enhancerArray = new Tuple(middlewareEnhancer);
      if (autoBatch) {
        enhancerArray.push(autoBatchEnhancer(typeof autoBatch === "object" ? autoBatch : void 0));
      }
      return enhancerArray;
    };
    function configureStore(options) {
      const getDefaultMiddleware = buildGetDefaultMiddleware();
      const {
        reducer = void 0,
        middleware,
        devTools = true,
        preloadedState = void 0,
        enhancers = void 0
      } = options || {};
      let rootReducer2;
      if (typeof reducer === "function") {
        rootReducer2 = reducer;
      } else if (isPlainObject$5(reducer)) {
        rootReducer2 = combineReducers(reducer);
      } else {
        throw new Error(formatProdErrorMessage(1));
      }
      let finalMiddleware;
      if (typeof middleware === "function") {
        finalMiddleware = middleware(getDefaultMiddleware);
      } else {
        finalMiddleware = getDefaultMiddleware();
      }
      let finalCompose = compose$1;
      if (devTools) {
        finalCompose = composeWithDevTools(__spreadValues({
          // Enable capture of stack traces for dispatched Redux actions
          trace: false
        }, typeof devTools === "object" && devTools));
      }
      const middlewareEnhancer = applyMiddleware(...finalMiddleware);
      const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);
      let storeEnhancers = typeof enhancers === "function" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();
      const composedEnhancer = finalCompose(...storeEnhancers);
      return createStore(rootReducer2, preloadedState, composedEnhancer);
    }
    function executeReducerBuilderCallback(builderCallback) {
      const actionsMap = {};
      const actionMatchers = [];
      let defaultCaseReducer;
      const builder = {
        addCase(typeOrActionCreator, reducer) {
          const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
          if (!type) {
            throw new Error(formatProdErrorMessage(28));
          }
          if (type in actionsMap) {
            throw new Error(formatProdErrorMessage(29));
          }
          actionsMap[type] = reducer;
          return builder;
        },
        addAsyncThunk(asyncThunk, reducers) {
          if (reducers.pending) actionsMap[asyncThunk.pending.type] = reducers.pending;
          if (reducers.rejected) actionsMap[asyncThunk.rejected.type] = reducers.rejected;
          if (reducers.fulfilled) actionsMap[asyncThunk.fulfilled.type] = reducers.fulfilled;
          if (reducers.settled) actionMatchers.push({
            matcher: asyncThunk.settled,
            reducer: reducers.settled
          });
          return builder;
        },
        addMatcher(matcher, reducer) {
          actionMatchers.push({
            matcher,
            reducer
          });
          return builder;
        },
        addDefaultCase(reducer) {
          defaultCaseReducer = reducer;
          return builder;
        }
      };
      builderCallback(builder);
      return [actionsMap, actionMatchers, defaultCaseReducer];
    }
    function isStateFunction(x2) {
      return typeof x2 === "function";
    }
    function createReducer(initialState2, mapOrBuilderCallback) {
      let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);
      let getInitialState;
      if (isStateFunction(initialState2)) {
        getInitialState = () => freezeDraftable(initialState2());
      } else {
        const frozenInitialState = freezeDraftable(initialState2);
        getInitialState = () => frozenInitialState;
      }
      function reducer(state = getInitialState(), action) {
        let caseReducers = [actionsMap[action.type], ...finalActionMatchers.filter(({
          matcher
        }) => matcher(action)).map(({
          reducer: reducer2
        }) => reducer2)];
        if (caseReducers.filter((cr) => !!cr).length === 0) {
          caseReducers = [finalDefaultCaseReducer];
        }
        return caseReducers.reduce((previousState, caseReducer) => {
          if (caseReducer) {
            if (isDraft$1(previousState)) {
              const draft = previousState;
              const result = caseReducer(draft, action);
              if (result === void 0) {
                return previousState;
              }
              return result;
            } else if (!isDraftable$1(previousState)) {
              const result = caseReducer(previousState, action);
              if (result === void 0) {
                if (previousState === null) {
                  return previousState;
                }
                throw Error("A case reducer on a non-draftable value must not return undefined");
              }
              return result;
            } else {
              return produce(previousState, (draft) => {
                return caseReducer(draft, action);
              });
            }
          }
          return previousState;
        }, state);
      }
      reducer.getInitialState = getInitialState;
      return reducer;
    }
    var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
    var nanoid = (size = 21) => {
      let id2 = "";
      let i = size;
      while (i--) {
        id2 += urlAlphabet[Math.random() * 64 | 0];
      }
      return id2;
    };
    var asyncThunkSymbol = /* @__PURE__ */ Symbol.for("rtk-slice-createasyncthunk");
    function getType(slice, actionKey) {
      return `${slice}/${actionKey}`;
    }
    function buildCreateSlice({
      creators
    } = {}) {
      var _a;
      const cAT = (_a = creators == null ? void 0 : creators.asyncThunk) == null ? void 0 : _a[asyncThunkSymbol];
      return function createSlice2(options) {
        const {
          name,
          reducerPath = name
        } = options;
        if (!name) {
          throw new Error(formatProdErrorMessage(11));
        }
        const reducers = (typeof options.reducers === "function" ? options.reducers(buildReducerCreators()) : options.reducers) || {};
        const reducerNames = Object.keys(reducers);
        const context = {
          sliceCaseReducersByName: {},
          sliceCaseReducersByType: {},
          actionCreators: {},
          sliceMatchers: []
        };
        const contextMethods = {
          addCase(typeOrActionCreator, reducer2) {
            const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
            if (!type) {
              throw new Error(formatProdErrorMessage(12));
            }
            if (type in context.sliceCaseReducersByType) {
              throw new Error(formatProdErrorMessage(13));
            }
            context.sliceCaseReducersByType[type] = reducer2;
            return contextMethods;
          },
          addMatcher(matcher, reducer2) {
            context.sliceMatchers.push({
              matcher,
              reducer: reducer2
            });
            return contextMethods;
          },
          exposeAction(name2, actionCreator) {
            context.actionCreators[name2] = actionCreator;
            return contextMethods;
          },
          exposeCaseReducer(name2, reducer2) {
            context.sliceCaseReducersByName[name2] = reducer2;
            return contextMethods;
          }
        };
        reducerNames.forEach((reducerName) => {
          const reducerDefinition = reducers[reducerName];
          const reducerDetails = {
            reducerName,
            type: getType(name, reducerName),
            createNotation: typeof options.reducers === "function"
          };
          if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {
            handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);
          } else {
            handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);
          }
        });
        function buildReducer() {
          const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers];
          const finalCaseReducers = __spreadValues(__spreadValues({}, extraReducers), context.sliceCaseReducersByType);
          return createReducer(options.initialState, (builder) => {
            for (let key in finalCaseReducers) {
              builder.addCase(key, finalCaseReducers[key]);
            }
            for (let sM of context.sliceMatchers) {
              builder.addMatcher(sM.matcher, sM.reducer);
            }
            for (let m2 of actionMatchers) {
              builder.addMatcher(m2.matcher, m2.reducer);
            }
            if (defaultCaseReducer) {
              builder.addDefaultCase(defaultCaseReducer);
            }
          });
        }
        const selectSelf = (state) => state;
        const injectedSelectorCache = /* @__PURE__ */ new Map();
        const injectedStateCache = /* @__PURE__ */ new WeakMap();
        let _reducer;
        function reducer(state, action) {
          if (!_reducer) _reducer = buildReducer();
          return _reducer(state, action);
        }
        function getInitialState() {
          if (!_reducer) _reducer = buildReducer();
          return _reducer.getInitialState();
        }
        function makeSelectorProps(reducerPath2, injected = false) {
          function selectSlice(state) {
            let sliceState = state[reducerPath2];
            if (typeof sliceState === "undefined") {
              if (injected) {
                sliceState = getOrInsertComputed(injectedStateCache, selectSlice, getInitialState);
              }
            }
            return sliceState;
          }
          function getSelectors(selectState = selectSelf) {
            const selectorCache = getOrInsertComputed(injectedSelectorCache, injected, () => /* @__PURE__ */ new WeakMap());
            return getOrInsertComputed(selectorCache, selectState, () => {
              var _a2;
              const map2 = {};
              for (const [name2, selector] of Object.entries((_a2 = options.selectors) != null ? _a2 : {})) {
                map2[name2] = wrapSelector(selector, selectState, () => getOrInsertComputed(injectedStateCache, selectState, getInitialState), injected);
              }
              return map2;
            });
          }
          return {
            reducerPath: reducerPath2,
            getSelectors,
            get selectors() {
              return getSelectors(selectSlice);
            },
            selectSlice
          };
        }
        const slice = __spreadProps(__spreadValues({
          name,
          reducer,
          actions: context.actionCreators,
          caseReducers: context.sliceCaseReducersByName,
          getInitialState
        }, makeSelectorProps(reducerPath)), {
          injectInto(injectable, _a2 = {}) {
            var _b = _a2, {
              reducerPath: pathOpt
            } = _b, config2 = __objRest(_b, [
              "reducerPath"
            ]);
            const newReducerPath = pathOpt != null ? pathOpt : reducerPath;
            injectable.inject({
              reducerPath: newReducerPath,
              reducer
            }, config2);
            return __spreadValues(__spreadValues({}, slice), makeSelectorProps(newReducerPath, true));
          }
        });
        return slice;
      };
    }
    function wrapSelector(selector, selectState, getInitialState, injected) {
      function wrapper(rootState, ...args) {
        let sliceState = selectState(rootState);
        if (typeof sliceState === "undefined") {
          if (injected) {
            sliceState = getInitialState();
          }
        }
        return selector(sliceState, ...args);
      }
      wrapper.unwrapped = selector;
      return wrapper;
    }
    var createSlice = /* @__PURE__ */ buildCreateSlice();
    function buildReducerCreators() {
      function asyncThunk(payloadCreator, config2) {
        return __spreadValues({
          _reducerDefinitionType: "asyncThunk",
          payloadCreator
        }, config2);
      }
      asyncThunk.withTypes = () => asyncThunk;
      return {
        reducer(caseReducer) {
          return Object.assign({
            // hack so the wrapping function has the same name as the original
            // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original
            [caseReducer.name](...args) {
              return caseReducer(...args);
            }
          }[caseReducer.name], {
            _reducerDefinitionType: "reducer"
            /* reducer */
          });
        },
        preparedReducer(prepare, reducer) {
          return {
            _reducerDefinitionType: "reducerWithPrepare",
            prepare,
            reducer
          };
        },
        asyncThunk
      };
    }
    function handleNormalReducerDefinition({
      type,
      reducerName,
      createNotation
    }, maybeReducerWithPrepare, context) {
      let caseReducer;
      let prepareCallback;
      if ("reducer" in maybeReducerWithPrepare) {
        if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {
          throw new Error(formatProdErrorMessage(17));
        }
        caseReducer = maybeReducerWithPrepare.reducer;
        prepareCallback = maybeReducerWithPrepare.prepare;
      } else {
        caseReducer = maybeReducerWithPrepare;
      }
      context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));
    }
    function isAsyncThunkSliceReducerDefinition(reducerDefinition) {
      return reducerDefinition._reducerDefinitionType === "asyncThunk";
    }
    function isCaseReducerWithPrepareDefinition(reducerDefinition) {
      return reducerDefinition._reducerDefinitionType === "reducerWithPrepare";
    }
    function handleThunkCaseReducerDefinition({
      type,
      reducerName
    }, reducerDefinition, context, cAT) {
      if (!cAT) {
        throw new Error(formatProdErrorMessage(18));
      }
      const {
        payloadCreator,
        fulfilled,
        pending,
        rejected,
        settled,
        options
      } = reducerDefinition;
      const thunk2 = cAT(type, payloadCreator, options);
      context.exposeAction(reducerName, thunk2);
      if (fulfilled) {
        context.addCase(thunk2.fulfilled, fulfilled);
      }
      if (pending) {
        context.addCase(thunk2.pending, pending);
      }
      if (rejected) {
        context.addCase(thunk2.rejected, rejected);
      }
      if (settled) {
        context.addMatcher(thunk2.settled, settled);
      }
      context.exposeCaseReducer(reducerName, {
        fulfilled: fulfilled || noop,
        pending: pending || noop,
        rejected: rejected || noop,
        settled: settled || noop
      });
    }
    function noop() {
    }
    var task = "task";
    var listener = "listener";
    var completed = "completed";
    var cancelled = "cancelled";
    var taskCancelled = `task-${cancelled}`;
    var taskCompleted = `task-${completed}`;
    var listenerCancelled = `${listener}-${cancelled}`;
    var listenerCompleted = `${listener}-${completed}`;
    var TaskAbortError = class {
      constructor(code) {
        __publicField(this, "name", "TaskAbortError");
        __publicField(this, "message");
        this.code = code;
        this.message = `${task} ${cancelled} (reason: ${code})`;
      }
    };
    var assertFunction = (func, expected) => {
      if (typeof func !== "function") {
        throw new TypeError(formatProdErrorMessage(32));
      }
    };
    var noop2 = () => {
    };
    var catchRejection = (promise, onError = noop2) => {
      promise.catch(onError);
      return promise;
    };
    var addAbortSignalListener = (abortSignal, callback) => {
      abortSignal.addEventListener("abort", callback, {
        once: true
      });
      return () => abortSignal.removeEventListener("abort", callback);
    };
    var validateActive = (signal) => {
      if (signal.aborted) {
        throw new TaskAbortError(signal.reason);
      }
    };
    function raceWithSignal(signal, promise) {
      let cleanup = noop2;
      return new Promise((resolve, reject) => {
        const notifyRejection = () => reject(new TaskAbortError(signal.reason));
        if (signal.aborted) {
          notifyRejection();
          return;
        }
        cleanup = addAbortSignalListener(signal, notifyRejection);
        promise.finally(() => cleanup()).then(resolve, reject);
      }).finally(() => {
        cleanup = noop2;
      });
    }
    var runTask = (task2, cleanUp) => __async(exports, null, function* () {
      try {
        yield Promise.resolve();
        const value = yield task2();
        return {
          status: "ok",
          value
        };
      } catch (error) {
        return {
          status: error instanceof TaskAbortError ? "cancelled" : "rejected",
          error
        };
      } finally {
        cleanUp == null ? void 0 : cleanUp();
      }
    });
    var createPause = (signal) => {
      return (promise) => {
        return catchRejection(raceWithSignal(signal, promise).then((output) => {
          validateActive(signal);
          return output;
        }));
      };
    };
    var createDelay = (signal) => {
      const pause = createPause(signal);
      return (timeoutMs) => {
        return pause(new Promise((resolve) => setTimeout(resolve, timeoutMs)));
      };
    };
    var {
      assign
    } = Object;
    var INTERNAL_NIL_TOKEN = {};
    var alm = "listenerMiddleware";
    var createFork = (parentAbortSignal, parentBlockingPromises) => {
      const linkControllers = (controller) => addAbortSignalListener(parentAbortSignal, () => controller.abort(parentAbortSignal.reason));
      return (taskExecutor, opts) => {
        assertFunction(taskExecutor);
        const childAbortController = new AbortController();
        linkControllers(childAbortController);
        const result = runTask(() => __async(exports, null, function* () {
          validateActive(parentAbortSignal);
          validateActive(childAbortController.signal);
          const result2 = yield taskExecutor({
            pause: createPause(childAbortController.signal),
            delay: createDelay(childAbortController.signal),
            signal: childAbortController.signal
          });
          validateActive(childAbortController.signal);
          return result2;
        }), () => childAbortController.abort(taskCompleted));
        if (opts == null ? void 0 : opts.autoJoin) {
          parentBlockingPromises.push(result.catch(noop2));
        }
        return {
          result: createPause(parentAbortSignal)(result),
          cancel() {
            childAbortController.abort(taskCancelled);
          }
        };
      };
    };
    var createTakePattern = (startListening, signal) => {
      const take = (predicate, timeout) => __async(exports, null, function* () {
        validateActive(signal);
        let unsubscribe = () => {
        };
        const tuplePromise = new Promise((resolve, reject) => {
          let stopListening = startListening({
            predicate,
            effect: (action, listenerApi) => {
              listenerApi.unsubscribe();
              resolve([action, listenerApi.getState(), listenerApi.getOriginalState()]);
            }
          });
          unsubscribe = () => {
            stopListening();
            reject();
          };
        });
        const promises = [tuplePromise];
        if (timeout != null) {
          promises.push(new Promise((resolve) => setTimeout(resolve, timeout, null)));
        }
        try {
          const output = yield raceWithSignal(signal, Promise.race(promises));
          validateActive(signal);
          return output;
        } finally {
          unsubscribe();
        }
      });
      return (predicate, timeout) => catchRejection(take(predicate, timeout));
    };
    var getListenerEntryPropsFrom = (options) => {
      let {
        type,
        actionCreator,
        matcher,
        predicate,
        effect
      } = options;
      if (type) {
        predicate = createAction(type).match;
      } else if (actionCreator) {
        type = actionCreator.type;
        predicate = actionCreator.match;
      } else if (matcher) {
        predicate = matcher;
      } else if (predicate) ;
      else {
        throw new Error(formatProdErrorMessage(21));
      }
      assertFunction(effect);
      return {
        predicate,
        type,
        effect
      };
    };
    var createListenerEntry = /* @__PURE__ */ assign((options) => {
      const {
        type,
        predicate,
        effect
      } = getListenerEntryPropsFrom(options);
      const entry = {
        id: nanoid(),
        effect,
        type,
        predicate,
        pending: /* @__PURE__ */ new Set(),
        unsubscribe: () => {
          throw new Error(formatProdErrorMessage(22));
        }
      };
      return entry;
    }, {
      withTypes: () => createListenerEntry
    });
    var findListenerEntry = (listenerMap, options) => {
      const {
        type,
        effect,
        predicate
      } = getListenerEntryPropsFrom(options);
      return Array.from(listenerMap.values()).find((entry) => {
        const matchPredicateOrType = typeof type === "string" ? entry.type === type : entry.predicate === predicate;
        return matchPredicateOrType && entry.effect === effect;
      });
    };
    var cancelActiveListeners = (entry) => {
      entry.pending.forEach((controller) => {
        controller.abort(listenerCancelled);
      });
    };
    var createClearListenerMiddleware = (listenerMap, executingListeners) => {
      return () => {
        for (const listener2 of executingListeners.keys()) {
          cancelActiveListeners(listener2);
        }
        listenerMap.clear();
      };
    };
    var safelyNotifyError = (errorHandler, errorToNotify, errorInfo) => {
      try {
        errorHandler(errorToNotify, errorInfo);
      } catch (errorHandlerError) {
        setTimeout(() => {
          throw errorHandlerError;
        }, 0);
      }
    };
    var addListener = /* @__PURE__ */ assign(/* @__PURE__ */ createAction(`${alm}/add`), {
      withTypes: () => addListener
    });
    var clearAllListeners = /* @__PURE__ */ createAction(`${alm}/removeAll`);
    var removeListener = /* @__PURE__ */ assign(/* @__PURE__ */ createAction(`${alm}/remove`), {
      withTypes: () => removeListener
    });
    var defaultErrorHandler = (...args) => {
      console.error(`${alm}/error`, ...args);
    };
    var createListenerMiddleware = (middlewareOptions = {}) => {
      const listenerMap = /* @__PURE__ */ new Map();
      const executingListeners = /* @__PURE__ */ new Map();
      const trackExecutingListener = (entry) => {
        var _a;
        const count = (_a = executingListeners.get(entry)) != null ? _a : 0;
        executingListeners.set(entry, count + 1);
      };
      const untrackExecutingListener = (entry) => {
        var _a;
        const count = (_a = executingListeners.get(entry)) != null ? _a : 1;
        if (count === 1) {
          executingListeners.delete(entry);
        } else {
          executingListeners.set(entry, count - 1);
        }
      };
      const {
        extra,
        onError = defaultErrorHandler
      } = middlewareOptions;
      assertFunction(onError);
      const insertEntry = (entry) => {
        entry.unsubscribe = () => listenerMap.delete(entry.id);
        listenerMap.set(entry.id, entry);
        return (cancelOptions) => {
          entry.unsubscribe();
          if (cancelOptions == null ? void 0 : cancelOptions.cancelActive) {
            cancelActiveListeners(entry);
          }
        };
      };
      const startListening = (options) => {
        var _a;
        const entry = (_a = findListenerEntry(listenerMap, options)) != null ? _a : createListenerEntry(options);
        return insertEntry(entry);
      };
      assign(startListening, {
        withTypes: () => startListening
      });
      const stopListening = (options) => {
        const entry = findListenerEntry(listenerMap, options);
        if (entry) {
          entry.unsubscribe();
          if (options.cancelActive) {
            cancelActiveListeners(entry);
          }
        }
        return !!entry;
      };
      assign(stopListening, {
        withTypes: () => stopListening
      });
      const notifyListener = (entry, action, api2, getOriginalState) => __async(exports, null, function* () {
        const internalTaskController = new AbortController();
        const take = createTakePattern(startListening, internalTaskController.signal);
        const autoJoinPromises = [];
        try {
          entry.pending.add(internalTaskController);
          trackExecutingListener(entry);
          yield Promise.resolve(entry.effect(
            action,
            // Use assign() rather than ... to avoid extra helper functions added to bundle
            assign({}, api2, {
              getOriginalState,
              condition: (predicate, timeout) => take(predicate, timeout).then(Boolean),
              take,
              delay: createDelay(internalTaskController.signal),
              pause: createPause(internalTaskController.signal),
              extra,
              signal: internalTaskController.signal,
              fork: createFork(internalTaskController.signal, autoJoinPromises),
              unsubscribe: entry.unsubscribe,
              subscribe: () => {
                listenerMap.set(entry.id, entry);
              },
              cancelActiveListeners: () => {
                entry.pending.forEach((controller, _, set2) => {
                  if (controller !== internalTaskController) {
                    controller.abort(listenerCancelled);
                    set2.delete(controller);
                  }
                });
              },
              cancel: () => {
                internalTaskController.abort(listenerCancelled);
                entry.pending.delete(internalTaskController);
              },
              throwIfCancelled: () => {
                validateActive(internalTaskController.signal);
              }
            })
          ));
        } catch (listenerError) {
          if (!(listenerError instanceof TaskAbortError)) {
            safelyNotifyError(onError, listenerError, {
              raisedBy: "effect"
            });
          }
        } finally {
          yield Promise.all(autoJoinPromises);
          internalTaskController.abort(listenerCompleted);
          untrackExecutingListener(entry);
          entry.pending.delete(internalTaskController);
        }
      });
      const clearListenerMiddleware = createClearListenerMiddleware(listenerMap, executingListeners);
      const middleware = (api2) => (next) => (action) => {
        if (!isAction(action)) {
          return next(action);
        }
        if (addListener.match(action)) {
          return startListening(action.payload);
        }
        if (clearAllListeners.match(action)) {
          clearListenerMiddleware();
          return;
        }
        if (removeListener.match(action)) {
          return stopListening(action.payload);
        }
        let originalState = api2.getState();
        const getOriginalState = () => {
          if (originalState === INTERNAL_NIL_TOKEN) {
            throw new Error(formatProdErrorMessage(23));
          }
          return originalState;
        };
        let result;
        try {
          result = next(action);
          if (listenerMap.size > 0) {
            const currentState = api2.getState();
            const listenerEntries = Array.from(listenerMap.values());
            for (const entry of listenerEntries) {
              let runListener = false;
              try {
                runListener = entry.predicate(action, currentState, originalState);
              } catch (predicateError) {
                runListener = false;
                safelyNotifyError(onError, predicateError, {
                  raisedBy: "predicate"
                });
              }
              if (!runListener) {
                continue;
              }
              notifyListener(entry, action, api2, getOriginalState);
            }
          }
        } finally {
          originalState = INTERNAL_NIL_TOKEN;
        }
        return result;
      };
      return {
        middleware,
        startListening,
        stopListening,
        clearListeners: clearListenerMiddleware
      };
    };
    function formatProdErrorMessage(code) {
      return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
    }
    var initialState$b = {
      layoutType: "horizontal",
      width: 0,
      height: 0,
      margin: {
        top: 5,
        right: 5,
        bottom: 5,
        left: 5
      },
      scale: 1
    };
    var chartLayoutSlice = createSlice({
      name: "chartLayout",
      initialState: initialState$b,
      reducers: {
        setLayout(state, action) {
          state.layoutType = action.payload;
        },
        setChartSize(state, action) {
          state.width = action.payload.width;
          state.height = action.payload.height;
        },
        setMargin(state, action) {
          var _action$payload$top, _action$payload$right, _action$payload$botto, _action$payload$left;
          state.margin.top = (_action$payload$top = action.payload.top) !== null && _action$payload$top !== void 0 ? _action$payload$top : 0;
          state.margin.right = (_action$payload$right = action.payload.right) !== null && _action$payload$right !== void 0 ? _action$payload$right : 0;
          state.margin.bottom = (_action$payload$botto = action.payload.bottom) !== null && _action$payload$botto !== void 0 ? _action$payload$botto : 0;
          state.margin.left = (_action$payload$left = action.payload.left) !== null && _action$payload$left !== void 0 ? _action$payload$left : 0;
        },
        setScale(state, action) {
          state.scale = action.payload;
        }
      }
    });
    var {
      setMargin,
      setLayout,
      setChartSize,
      setScale
    } = chartLayoutSlice.actions;
    var chartLayoutReducer = chartLayoutSlice.reducer;
    function getSliced(arr, startIndex, endIndex) {
      if (!Array.isArray(arr)) {
        return arr;
      }
      if (arr && startIndex + endIndex !== 0) {
        return arr.slice(startIndex, endIndex + 1);
      }
      return arr;
    }
    function ownKeys$D(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$D(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$D(Object(t2), true).forEach(function(r3) {
          _defineProperty$F(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$D(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$F(e, r2, t2) {
      return (r2 = _toPropertyKey$F(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$F(t2) {
      var i = _toPrimitive$F(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$F(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function getValueByDataKey(obj, dataKey, defaultValue) {
      if (isNullish(obj) || isNullish(dataKey)) {
        return defaultValue;
      }
      if (isNumOrStr(dataKey)) {
        return get$2(obj, dataKey, defaultValue);
      }
      if (typeof dataKey === "function") {
        return dataKey(obj);
      }
      return defaultValue;
    }
    var appendOffsetOfLegend = (offset, legendSettings, legendSize) => {
      if (legendSettings && legendSize) {
        var {
          width: boxWidth,
          height: boxHeight
        } = legendSize;
        var {
          align,
          verticalAlign,
          layout
        } = legendSettings;
        if ((layout === "vertical" || layout === "horizontal" && verticalAlign === "middle") && align !== "center" && isNumber(offset[align])) {
          return _objectSpread$D(_objectSpread$D({}, offset), {}, {
            [align]: offset[align] + (boxWidth || 0)
          });
        }
        if ((layout === "horizontal" || layout === "vertical" && align === "center") && verticalAlign !== "middle" && isNumber(offset[verticalAlign])) {
          return _objectSpread$D(_objectSpread$D({}, offset), {}, {
            [verticalAlign]: offset[verticalAlign] + (boxHeight || 0)
          });
        }
      }
      return offset;
    };
    var isCategoricalAxis = (layout, axisType) => layout === "horizontal" && axisType === "xAxis" || layout === "vertical" && axisType === "yAxis" || layout === "centric" && axisType === "angleAxis" || layout === "radial" && axisType === "radiusAxis";
    var getCoordinatesOfGrid = (ticks2, minValue, maxValue, syncWithTicks) => {
      if (syncWithTicks) {
        return ticks2.map((entry) => entry.coordinate);
      }
      var hasMin, hasMax;
      var values = ticks2.map((entry) => {
        if (entry.coordinate === minValue) {
          hasMin = true;
        }
        if (entry.coordinate === maxValue) {
          hasMax = true;
        }
        return entry.coordinate;
      });
      if (!hasMin) {
        values.push(minValue);
      }
      if (!hasMax) {
        values.push(maxValue);
      }
      return values;
    };
    var getTicksOfAxis = (axis, isGrid, isAll) => {
      if (!axis) {
        return null;
      }
      var {
        duplicateDomain,
        type,
        range: range2,
        scale,
        realScaleType,
        isCategorical,
        categoricalDomain,
        tickCount,
        ticks: ticks2,
        niceTicks,
        axisType
      } = axis;
      if (!scale) {
        return null;
      }
      var offsetForBand = realScaleType === "scaleBand" && scale.bandwidth ? scale.bandwidth() / 2 : 2;
      var offset = type === "category" && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;
      offset = axisType === "angleAxis" && range2 && range2.length >= 2 ? mathSign(range2[0] - range2[1]) * 2 * offset : offset;
      if (ticks2 || niceTicks) {
        var result = (ticks2 || niceTicks || []).map((entry, index) => {
          var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;
          return {
            // If the scaleContent is not a number, the coordinate will be NaN.
            // That could be the case for example with a PointScale and a string as domain.
            coordinate: scale(scaleContent) + offset,
            value: entry,
            offset,
            index
          };
        });
        return result.filter((row) => !isNan(row.coordinate));
      }
      if (isCategorical && categoricalDomain) {
        return categoricalDomain.map((entry, index) => ({
          coordinate: scale(entry) + offset,
          value: entry,
          index,
          offset
        }));
      }
      if (scale.ticks && true && tickCount != null) {
        return scale.ticks(tickCount).map((entry, index) => ({
          coordinate: scale(entry) + offset,
          value: entry,
          offset,
          index
        }));
      }
      return scale.domain().map((entry, index) => ({
        coordinate: scale(entry) + offset,
        value: duplicateDomain ? duplicateDomain[entry] : entry,
        index,
        offset
      }));
    };
    var EPS = 1e-4;
    var checkDomainOfScale = (scale) => {
      var domain = scale.domain();
      if (!domain || domain.length <= 2) {
        return;
      }
      var len = domain.length;
      var range2 = scale.range();
      var minValue = Math.min(range2[0], range2[1]) - EPS;
      var maxValue = Math.max(range2[0], range2[1]) + EPS;
      var first = scale(domain[0]);
      var last2 = scale(domain[len - 1]);
      if (first < minValue || first > maxValue || last2 < minValue || last2 > maxValue) {
        scale.domain([domain[0], domain[len - 1]]);
      }
    };
    var truncateByDomain = (value, domain) => {
      if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {
        return value;
      }
      var minValue = Math.min(domain[0], domain[1]);
      var maxValue = Math.max(domain[0], domain[1]);
      var result = [value[0], value[1]];
      if (!isNumber(value[0]) || value[0] < minValue) {
        result[0] = minValue;
      }
      if (!isNumber(value[1]) || value[1] > maxValue) {
        result[1] = maxValue;
      }
      if (result[0] > maxValue) {
        result[0] = maxValue;
      }
      if (result[1] < minValue) {
        result[1] = minValue;
      }
      return result;
    };
    var offsetSign = (series) => {
      var n2 = series.length;
      if (n2 <= 0) {
        return;
      }
      for (var j = 0, m2 = series[0].length; j < m2; ++j) {
        var positive = 0;
        var negative = 0;
        for (var i = 0; i < n2; ++i) {
          var value = isNan(series[i][j][1]) ? series[i][j][0] : series[i][j][1];
          if (value >= 0) {
            series[i][j][0] = positive;
            series[i][j][1] = positive + value;
            positive = series[i][j][1];
          } else {
            series[i][j][0] = negative;
            series[i][j][1] = negative + value;
            negative = series[i][j][1];
          }
        }
      }
    };
    var offsetPositive = (series) => {
      var n2 = series.length;
      if (n2 <= 0) {
        return;
      }
      for (var j = 0, m2 = series[0].length; j < m2; ++j) {
        var positive = 0;
        for (var i = 0; i < n2; ++i) {
          var value = isNan(series[i][j][1]) ? series[i][j][0] : series[i][j][1];
          if (value >= 0) {
            series[i][j][0] = positive;
            series[i][j][1] = positive + value;
            positive = series[i][j][1];
          } else {
            series[i][j][0] = 0;
            series[i][j][1] = 0;
          }
        }
      }
    };
    var STACK_OFFSET_MAP = {
      sign: offsetSign,
      // @ts-expect-error definitelytyped types are incorrect
      expand: stackOffsetExpand,
      // @ts-expect-error definitelytyped types are incorrect
      none: stackOffsetNone,
      // @ts-expect-error definitelytyped types are incorrect
      silhouette: stackOffsetSilhouette,
      // @ts-expect-error definitelytyped types are incorrect
      wiggle: stackOffsetWiggle,
      positive: offsetPositive
    };
    var getStackedData = (data, dataKeys, offsetType) => {
      var offsetAccessor = STACK_OFFSET_MAP[offsetType];
      var stack = shapeStack().keys(dataKeys).value((d, key) => Number(getValueByDataKey(d, key, 0))).order(stackOrderNone).offset(offsetAccessor);
      return stack(data);
    };
    function getNormalizedStackId(publicStackId) {
      return publicStackId == null ? void 0 : String(publicStackId);
    }
    function getCateCoordinateOfLine(_ref2) {
      var {
        axis,
        ticks: ticks2,
        bandSize,
        entry,
        index,
        dataKey
      } = _ref2;
      if (axis.type === "category") {
        if (!axis.allowDuplicatedCategory && axis.dataKey && !isNullish(entry[axis.dataKey])) {
          var matchedTick = findEntryInArray(ticks2, "value", entry[axis.dataKey]);
          if (matchedTick) {
            return matchedTick.coordinate + bandSize / 2;
          }
        }
        return ticks2[index] ? ticks2[index].coordinate + bandSize / 2 : null;
      }
      var value = getValueByDataKey(entry, !isNullish(dataKey) ? dataKey : axis.dataKey);
      return !isNullish(value) ? axis.scale(value) : null;
    }
    var getCateCoordinateOfBar = (_ref2) => {
      var {
        axis,
        ticks: ticks2,
        offset,
        bandSize,
        entry,
        index
      } = _ref2;
      if (axis.type === "category") {
        return ticks2[index] ? ticks2[index].coordinate + offset : null;
      }
      var value = getValueByDataKey(entry, axis.dataKey, axis.scale.domain()[index]);
      return !isNullish(value) ? axis.scale(value) - bandSize / 2 + offset : null;
    };
    var getBaseValueOfBar = (_ref3) => {
      var {
        numericAxis
      } = _ref3;
      var domain = numericAxis.scale.domain();
      if (numericAxis.type === "number") {
        var minValue = Math.min(domain[0], domain[1]);
        var maxValue = Math.max(domain[0], domain[1]);
        if (minValue <= 0 && maxValue >= 0) {
          return 0;
        }
        if (maxValue < 0) {
          return maxValue;
        }
        return minValue;
      }
      return domain[0];
    };
    var getDomainOfSingle = (data) => {
      var flat = data.flat(2).filter(isNumber);
      return [Math.min(...flat), Math.max(...flat)];
    };
    var makeDomainFinite = (domain) => {
      return [domain[0] === Infinity ? 0 : domain[0], domain[1] === -Infinity ? 0 : domain[1]];
    };
    var getDomainOfStackGroups = (stackGroups, startIndex, endIndex) => {
      if (stackGroups == null) {
        return void 0;
      }
      return makeDomainFinite(Object.keys(stackGroups).reduce((result, stackId) => {
        var group = stackGroups[stackId];
        var {
          stackedData
        } = group;
        var domain = stackedData.reduce((res, entry) => {
          var sliced = getSliced(entry, startIndex, endIndex);
          var s2 = getDomainOfSingle(sliced);
          return [Math.min(res[0], s2[0]), Math.max(res[1], s2[1])];
        }, [Infinity, -Infinity]);
        return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];
      }, [Infinity, -Infinity]));
    };
    var MIN_VALUE_REG = /^dataMin[\s]*-[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;
    var MAX_VALUE_REG = /^dataMax[\s]*\+[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;
    var getBandSizeOfAxis = (axis, ticks2, isBar) => {
      if (axis && axis.scale && axis.scale.bandwidth) {
        var bandWidth = axis.scale.bandwidth();
        if (!isBar || bandWidth > 0) {
          return bandWidth;
        }
      }
      if (axis && ticks2 && ticks2.length >= 2) {
        var orderedTicks = sortBy$1(ticks2, (o) => o.coordinate);
        var bandSize = Infinity;
        for (var i = 1, len = orderedTicks.length; i < len; i++) {
          var cur = orderedTicks[i];
          var prev = orderedTicks[i - 1];
          bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);
        }
        return bandSize === Infinity ? 0 : bandSize;
      }
      return isBar ? void 0 : 0;
    };
    function getTooltipEntry(_ref4) {
      var {
        tooltipEntrySettings,
        dataKey,
        payload,
        value,
        name
      } = _ref4;
      return _objectSpread$D(_objectSpread$D({}, tooltipEntrySettings), {}, {
        dataKey,
        payload,
        value,
        name
      });
    }
    function getTooltipNameProp(nameFromItem, dataKey) {
      if (nameFromItem) {
        return String(nameFromItem);
      }
      if (typeof dataKey === "string") {
        return dataKey;
      }
      return void 0;
    }
    var calculateCartesianTooltipPos = (coordinate, layout) => {
      if (layout === "horizontal") {
        return coordinate.chartX;
      }
      if (layout === "vertical") {
        return coordinate.chartY;
      }
      return void 0;
    };
    var calculatePolarTooltipPos = (rangeObj, layout) => {
      if (layout === "centric") {
        return rangeObj.angle;
      }
      return rangeObj.radius;
    };
    var selectChartWidth = (state) => state.layout.width;
    var selectChartHeight = (state) => state.layout.height;
    var selectContainerScale = (state) => state.layout.scale;
    var selectMargin = (state) => state.layout.margin;
    var selectAllXAxes = createSelector((state) => state.cartesianAxis.xAxis, (xAxisMap) => {
      return Object.values(xAxisMap);
    });
    var selectAllYAxes = createSelector((state) => state.cartesianAxis.yAxis, (yAxisMap) => {
      return Object.values(yAxisMap);
    });
    var DATA_ITEM_INDEX_ATTRIBUTE_NAME = "data-recharts-item-index";
    var DATA_ITEM_DATAKEY_ATTRIBUTE_NAME = "data-recharts-item-data-key";
    var DEFAULT_Y_AXIS_WIDTH = 60;
    function ownKeys$C(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$C(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$C(Object(t2), true).forEach(function(r3) {
          _defineProperty$E(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$C(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$E(e, r2, t2) {
      return (r2 = _toPropertyKey$E(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$E(t2) {
      var i = _toPrimitive$E(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$E(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    var selectBrushHeight = (state) => state.brush.height;
    function selectLeftAxesOffset(state) {
      var yAxes = selectAllYAxes(state);
      return yAxes.reduce((result, entry) => {
        if (entry.orientation === "left" && !entry.mirror && !entry.hide) {
          var width = typeof entry.width === "number" ? entry.width : DEFAULT_Y_AXIS_WIDTH;
          return result + width;
        }
        return result;
      }, 0);
    }
    function selectRightAxesOffset(state) {
      var yAxes = selectAllYAxes(state);
      return yAxes.reduce((result, entry) => {
        if (entry.orientation === "right" && !entry.mirror && !entry.hide) {
          var width = typeof entry.width === "number" ? entry.width : DEFAULT_Y_AXIS_WIDTH;
          return result + width;
        }
        return result;
      }, 0);
    }
    function selectTopAxesOffset(state) {
      var xAxes = selectAllXAxes(state);
      return xAxes.reduce((result, entry) => {
        if (entry.orientation === "top" && !entry.mirror && !entry.hide) {
          return result + entry.height;
        }
        return result;
      }, 0);
    }
    function selectBottomAxesOffset(state) {
      var xAxes = selectAllXAxes(state);
      return xAxes.reduce((result, entry) => {
        if (entry.orientation === "bottom" && !entry.mirror && !entry.hide) {
          return result + entry.height;
        }
        return result;
      }, 0);
    }
    var selectChartOffsetInternal = createSelector([selectChartWidth, selectChartHeight, selectMargin, selectBrushHeight, selectLeftAxesOffset, selectRightAxesOffset, selectTopAxesOffset, selectBottomAxesOffset, selectLegendSettings, selectLegendSize], (chartWidth, chartHeight, margin, brushHeight, leftAxesOffset, rightAxesOffset, topAxesOffset, bottomAxesOffset, legendSettings, legendSize) => {
      var offsetH = {
        left: (margin.left || 0) + leftAxesOffset,
        right: (margin.right || 0) + rightAxesOffset
      };
      var offsetV = {
        top: (margin.top || 0) + topAxesOffset,
        bottom: (margin.bottom || 0) + bottomAxesOffset
      };
      var offset = _objectSpread$C(_objectSpread$C({}, offsetV), offsetH);
      var brushBottom = offset.bottom;
      offset.bottom += brushHeight;
      offset = appendOffsetOfLegend(offset, legendSettings, legendSize);
      var offsetWidth = chartWidth - offset.left - offset.right;
      var offsetHeight = chartHeight - offset.top - offset.bottom;
      return _objectSpread$C(_objectSpread$C({
        brushBottom
      }, offset), {}, {
        // never return negative values for height and width
        width: Math.max(offsetWidth, 0),
        height: Math.max(offsetHeight, 0)
      });
    });
    var selectChartViewBox = createSelector(selectChartOffsetInternal, (offset) => ({
      x: offset.left,
      y: offset.top,
      width: offset.width,
      height: offset.height
    }));
    var selectAxisViewBox = createSelector(selectChartWidth, selectChartHeight, (width, height) => ({
      x: 0,
      y: 0,
      width,
      height
    }));
    var PanoramaContext = /* @__PURE__ */ reactExports.createContext(null);
    var useIsPanorama = () => reactExports.useContext(PanoramaContext) != null;
    var selectBrushSettings = (state) => state.brush;
    var selectBrushDimensions = createSelector([selectBrushSettings, selectChartOffsetInternal, selectMargin], (brushSettings, offset, margin) => ({
      height: brushSettings.height,
      x: isNumber(brushSettings.x) ? brushSettings.x : offset.left,
      y: isNumber(brushSettings.y) ? brushSettings.y : offset.top + offset.height + offset.brushBottom - ((margin === null || margin === void 0 ? void 0 : margin.bottom) || 0),
      width: isNumber(brushSettings.width) ? brushSettings.width : offset.width
    }));
    var throttle$2 = {};
    var debounce$1 = {};
    var debounce = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      function debounce2(func, debounceMs, { signal, edges } = {}) {
        let pendingThis = void 0;
        let pendingArgs = null;
        const leading = edges != null && edges.includes("leading");
        const trailing = edges == null || edges.includes("trailing");
        const invoke = () => {
          if (pendingArgs !== null) {
            func.apply(pendingThis, pendingArgs);
            pendingThis = void 0;
            pendingArgs = null;
          }
        };
        const onTimerEnd = () => {
          if (trailing) {
            invoke();
          }
          cancel();
        };
        let timeoutId = null;
        const schedule = () => {
          if (timeoutId != null) {
            clearTimeout(timeoutId);
          }
          timeoutId = setTimeout(() => {
            timeoutId = null;
            onTimerEnd();
          }, debounceMs);
        };
        const cancelTimer = () => {
          if (timeoutId !== null) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
        };
        const cancel = () => {
          cancelTimer();
          pendingThis = void 0;
          pendingArgs = null;
        };
        const flush = () => {
          invoke();
        };
        const debounced = function(...args) {
          if (signal == null ? void 0 : signal.aborted) {
            return;
          }
          pendingThis = this;
          pendingArgs = args;
          const isFirstCall = timeoutId == null;
          schedule();
          if (leading && isFirstCall) {
            invoke();
          }
        };
        debounced.schedule = schedule;
        debounced.cancel = cancel;
        debounced.flush = flush;
        signal == null ? void 0 : signal.addEventListener("abort", cancel, { once: true });
        return debounced;
      }
      exports$1.debounce = debounce2;
    })(debounce);
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const debounce$12 = debounce;
      function debounce$2(func, debounceMs = 0, options = {}) {
        if (typeof options !== "object") {
          options = {};
        }
        const { leading = false, trailing = true, maxWait } = options;
        const edges = Array(2);
        if (leading) {
          edges[0] = "leading";
        }
        if (trailing) {
          edges[1] = "trailing";
        }
        let result = void 0;
        let pendingAt = null;
        const _debounced = debounce$12.debounce(function(...args) {
          result = func.apply(this, args);
          pendingAt = null;
        }, debounceMs, { edges });
        const debounced = function(...args) {
          if (maxWait != null) {
            if (pendingAt === null) {
              pendingAt = Date.now();
            }
            if (Date.now() - pendingAt >= maxWait) {
              result = func.apply(this, args);
              pendingAt = Date.now();
              _debounced.cancel();
              _debounced.schedule();
              return result;
            }
          }
          _debounced.apply(this, args);
          return result;
        };
        const flush = () => {
          _debounced.flush();
          return result;
        };
        debounced.cancel = _debounced.cancel;
        debounced.flush = flush;
        return debounced;
      }
      exports$1.debounce = debounce$2;
    })(debounce$1);
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const debounce2 = debounce$1;
      function throttle2(func, throttleMs = 0, options = {}) {
        const { leading = true, trailing = true } = options;
        return debounce2.debounce(func, throttleMs, {
          leading,
          maxWait: throttleMs,
          trailing
        });
      }
      exports$1.throttle = throttle2;
    })(throttle$2);
    var throttle = throttle$2.throttle;
    const throttle$1 = /* @__PURE__ */ getDefaultExportFromCjs(throttle);
    var warn = function warn2(condition, format2) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      if (typeof console !== "undefined" && console.warn) {
        if (format2 === void 0) {
          console.warn("LogUtils requires an error message argument");
        }
        if (!condition) {
          if (format2 === void 0) {
            console.warn("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
          } else {
            var argIndex = 0;
            console.warn(format2.replace(/%s/g, () => args[argIndex++]));
          }
        }
      }
    };
    var calculateChartDimensions = (containerWidth, containerHeight, props) => {
      var {
        width = "100%",
        height = "100%",
        aspect,
        maxHeight
      } = props;
      var calculatedWidth = isPercent(width) ? containerWidth : Number(width);
      var calculatedHeight = isPercent(height) ? containerHeight : Number(height);
      if (aspect && aspect > 0) {
        if (calculatedWidth) {
          calculatedHeight = calculatedWidth / aspect;
        } else if (calculatedHeight) {
          calculatedWidth = calculatedHeight * aspect;
        }
        if (maxHeight && calculatedHeight != null && calculatedHeight > maxHeight) {
          calculatedHeight = maxHeight;
        }
      }
      return {
        calculatedWidth,
        calculatedHeight
      };
    };
    var bothOverflow = {
      width: 0,
      height: 0,
      overflow: "visible"
    };
    var overflowX = {
      width: 0,
      overflowX: "visible"
    };
    var overflowY = {
      height: 0,
      overflowY: "visible"
    };
    var noStyle = {};
    var getInnerDivStyle = (props) => {
      var {
        width,
        height
      } = props;
      var isWidthPercent = isPercent(width);
      var isHeightPercent = isPercent(height);
      if (isWidthPercent && isHeightPercent) {
        return bothOverflow;
      }
      if (isWidthPercent) {
        return overflowX;
      }
      if (isHeightPercent) {
        return overflowY;
      }
      return noStyle;
    };
    function getDefaultWidthAndHeight(_ref2) {
      var {
        width,
        height,
        aspect
      } = _ref2;
      var calculatedWidth = width;
      var calculatedHeight = height;
      if (calculatedWidth === void 0 && calculatedHeight === void 0) {
        calculatedWidth = "100%";
        calculatedHeight = "100%";
      } else if (calculatedWidth === void 0) {
        calculatedWidth = aspect && aspect > 0 ? void 0 : "100%";
      } else if (calculatedHeight === void 0) {
        calculatedHeight = aspect && aspect > 0 ? void 0 : "100%";
      }
      return {
        width: calculatedWidth,
        height: calculatedHeight
      };
    }
    function isWellBehavedNumber(n2) {
      return Number.isFinite(n2);
    }
    function isPositiveNumber(n2) {
      return typeof n2 === "number" && n2 > 0 && Number.isFinite(n2);
    }
    function _extends$q() {
      return _extends$q = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$q.apply(null, arguments);
    }
    function ownKeys$B(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$B(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$B(Object(t2), true).forEach(function(r3) {
          _defineProperty$D(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$B(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$D(e, r2, t2) {
      return (r2 = _toPropertyKey$D(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$D(t2) {
      var i = _toPrimitive$D(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$D(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    var ResponsiveContainerContext = /* @__PURE__ */ reactExports.createContext({
      width: -1,
      height: -1
    });
    function isAcceptableSize(size) {
      return isPositiveNumber(size.width) && isPositiveNumber(size.height);
    }
    function ResponsiveContainerContextProvider(_ref2) {
      var {
        children,
        width,
        height
      } = _ref2;
      var size = reactExports.useMemo(() => ({
        width,
        height
      }), [width, height]);
      if (!isAcceptableSize(size)) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(ResponsiveContainerContext.Provider, {
        value: size
      }, children);
    }
    var useResponsiveContainerContext = () => reactExports.useContext(ResponsiveContainerContext);
    var SizeDetectorContainer = /* @__PURE__ */ reactExports.forwardRef((_ref2, ref) => {
      var {
        aspect,
        initialDimension = {
          width: -1,
          height: -1
        },
        width,
        height,
        /*
         * default min-width to 0 if not specified - 'auto' causes issues with flexbox
         * https://github.com/recharts/recharts/issues/172
         */
        minWidth = 0,
        minHeight,
        maxHeight,
        children,
        debounce: debounce2 = 0,
        id: id2,
        className,
        onResize,
        style = {}
      } = _ref2;
      var containerRef = reactExports.useRef(null);
      var onResizeRef = reactExports.useRef();
      onResizeRef.current = onResize;
      reactExports.useImperativeHandle(ref, () => containerRef.current);
      var [sizes, setSizes] = reactExports.useState({
        containerWidth: initialDimension.width,
        containerHeight: initialDimension.height
      });
      var setContainerSize = reactExports.useCallback((newWidth, newHeight) => {
        setSizes((prevState) => {
          var roundedWidth = Math.round(newWidth);
          var roundedHeight = Math.round(newHeight);
          if (prevState.containerWidth === roundedWidth && prevState.containerHeight === roundedHeight) {
            return prevState;
          }
          return {
            containerWidth: roundedWidth,
            containerHeight: roundedHeight
          };
        });
      }, []);
      reactExports.useEffect(() => {
        if (containerRef.current == null || typeof ResizeObserver === "undefined") {
          return noop$2;
        }
        var callback = (entries) => {
          var _onResizeRef$current;
          var {
            width: containerWidth3,
            height: containerHeight3
          } = entries[0].contentRect;
          setContainerSize(containerWidth3, containerHeight3);
          (_onResizeRef$current = onResizeRef.current) === null || _onResizeRef$current === void 0 || _onResizeRef$current.call(onResizeRef, containerWidth3, containerHeight3);
        };
        if (debounce2 > 0) {
          callback = throttle$1(callback, debounce2, {
            trailing: true,
            leading: false
          });
        }
        var observer = new ResizeObserver(callback);
        var {
          width: containerWidth2,
          height: containerHeight2
        } = containerRef.current.getBoundingClientRect();
        setContainerSize(containerWidth2, containerHeight2);
        observer.observe(containerRef.current);
        return () => {
          observer.disconnect();
        };
      }, [setContainerSize, debounce2]);
      var {
        containerWidth,
        containerHeight
      } = sizes;
      warn(!aspect || aspect > 0, "The aspect(%s) must be greater than zero.", aspect);
      var {
        calculatedWidth,
        calculatedHeight
      } = calculateChartDimensions(containerWidth, containerHeight, {
        width,
        height,
        aspect,
        maxHeight
      });
      warn(calculatedWidth != null && calculatedWidth > 0 || calculatedHeight != null && calculatedHeight > 0, "The width(%s) and height(%s) of chart should be greater than 0,\n       please check the style of container, or the props width(%s) and height(%s),\n       or add a minWidth(%s) or minHeight(%s) or use aspect(%s) to control the\n       height and width.", calculatedWidth, calculatedHeight, width, height, minWidth, minHeight, aspect);
      return /* @__PURE__ */ reactExports.createElement("div", {
        id: id2 ? "".concat(id2) : void 0,
        className: clsx("recharts-responsive-container", className),
        style: _objectSpread$B(_objectSpread$B({}, style), {}, {
          width,
          height,
          minWidth,
          minHeight,
          maxHeight
        }),
        ref: containerRef
      }, /* @__PURE__ */ reactExports.createElement("div", {
        style: getInnerDivStyle({
          width,
          height
        })
      }, /* @__PURE__ */ reactExports.createElement(ResponsiveContainerContextProvider, {
        width: calculatedWidth,
        height: calculatedHeight
      }, children)));
    });
    var ResponsiveContainer = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var responsiveContainerContext = useResponsiveContainerContext();
      if (isPositiveNumber(responsiveContainerContext.width) && isPositiveNumber(responsiveContainerContext.height)) {
        return props.children;
      }
      var {
        width,
        height
      } = getDefaultWidthAndHeight({
        width: props.width,
        height: props.height,
        aspect: props.aspect
      });
      var {
        calculatedWidth,
        calculatedHeight
      } = calculateChartDimensions(void 0, void 0, {
        width,
        height,
        aspect: props.aspect,
        maxHeight: props.maxHeight
      });
      if (isNumber(calculatedWidth) && isNumber(calculatedHeight)) {
        return /* @__PURE__ */ reactExports.createElement(ResponsiveContainerContextProvider, {
          width: calculatedWidth,
          height: calculatedHeight
        }, props.children);
      }
      return /* @__PURE__ */ reactExports.createElement(SizeDetectorContainer, _extends$q({}, props, {
        width,
        height,
        ref
      }));
    });
    function cartesianViewBoxToTrapezoid(box) {
      if (!box) {
        return void 0;
      }
      return {
        x: box.x,
        y: box.y,
        upperWidth: "upperWidth" in box ? box.upperWidth : box.width,
        lowerWidth: "lowerWidth" in box ? box.lowerWidth : box.width,
        width: box.width,
        height: box.height
      };
    }
    var useViewBox = () => {
      var _useAppSelector;
      var panorama = useIsPanorama();
      var rootViewBox = useAppSelector(selectChartViewBox);
      var brushDimensions = useAppSelector(selectBrushDimensions);
      var brushPadding = (_useAppSelector = useAppSelector(selectBrushSettings)) === null || _useAppSelector === void 0 ? void 0 : _useAppSelector.padding;
      if (!panorama || !brushDimensions || !brushPadding) {
        return rootViewBox;
      }
      return {
        width: brushDimensions.width - brushPadding.left - brushPadding.right,
        height: brushDimensions.height - brushPadding.top - brushPadding.bottom,
        x: brushPadding.left,
        y: brushPadding.top
      };
    };
    var manyComponentsThrowErrorsIfOffsetIsUndefined = {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      width: 0,
      height: 0,
      brushBottom: 0
    };
    var useOffsetInternal = () => {
      var _useAppSelector2;
      return (_useAppSelector2 = useAppSelector(selectChartOffsetInternal)) !== null && _useAppSelector2 !== void 0 ? _useAppSelector2 : manyComponentsThrowErrorsIfOffsetIsUndefined;
    };
    var useChartWidth = () => {
      return useAppSelector(selectChartWidth);
    };
    var useChartHeight = () => {
      return useAppSelector(selectChartHeight);
    };
    var useMargin = () => {
      return useAppSelector((state) => state.layout.margin);
    };
    var selectChartLayout = (state) => state.layout.layoutType;
    var useChartLayout = () => useAppSelector(selectChartLayout);
    var useCartesianChartLayout = () => {
      var layout = useChartLayout();
      if (layout === "horizontal" || layout === "vertical") {
        return layout;
      }
      return void 0;
    };
    var useIsInChartContext = () => {
      var layout = useChartLayout();
      return layout !== void 0;
    };
    var ReportChartSize = (props) => {
      var dispatch = useAppDispatch();
      var isPanorama = useIsPanorama();
      var {
        width: widthFromProps,
        height: heightFromProps
      } = props;
      var responsiveContainerCalculations = useResponsiveContainerContext();
      var width = widthFromProps;
      var height = heightFromProps;
      if (responsiveContainerCalculations) {
        width = responsiveContainerCalculations.width > 0 ? responsiveContainerCalculations.width : widthFromProps;
        height = responsiveContainerCalculations.height > 0 ? responsiveContainerCalculations.height : heightFromProps;
      }
      reactExports.useEffect(() => {
        if (!isPanorama && isPositiveNumber(width) && isPositiveNumber(height)) {
          dispatch(setChartSize({
            width,
            height
          }));
        }
      }, [dispatch, isPanorama, width, height]);
      return null;
    };
    var NOTHING = Symbol.for("immer-nothing");
    var DRAFTABLE = Symbol.for("immer-draftable");
    var DRAFT_STATE = Symbol.for("immer-state");
    function die(error, ...args) {
      throw new Error(
        `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
      );
    }
    var getPrototypeOf = Object.getPrototypeOf;
    function isDraft(value) {
      return !!value && !!value[DRAFT_STATE];
    }
    function isDraftable(value) {
      var _a;
      if (!value)
        return false;
      return isPlainObject$3(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_a = value.constructor) == null ? void 0 : _a[DRAFTABLE]) || isMap(value) || isSet(value);
    }
    var objectCtorString = Object.prototype.constructor.toString();
    var cachedCtorStrings = /* @__PURE__ */ new WeakMap();
    function isPlainObject$3(value) {
      if (!value || typeof value !== "object")
        return false;
      const proto = Object.getPrototypeOf(value);
      if (proto === null || proto === Object.prototype)
        return true;
      const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
      if (Ctor === Object)
        return true;
      if (typeof Ctor !== "function")
        return false;
      let ctorString = cachedCtorStrings.get(Ctor);
      if (ctorString === void 0) {
        ctorString = Function.toString.call(Ctor);
        cachedCtorStrings.set(Ctor, ctorString);
      }
      return ctorString === objectCtorString;
    }
    function each(obj, iter, strict = true) {
      if (getArchtype(obj) === 0) {
        const keys = strict ? Reflect.ownKeys(obj) : Object.keys(obj);
        keys.forEach((key) => {
          iter(key, obj[key], obj);
        });
      } else {
        obj.forEach((entry, index) => iter(index, entry, obj));
      }
    }
    function getArchtype(thing) {
      const state = thing[DRAFT_STATE];
      return state ? state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
    }
    function has(thing, prop) {
      return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
    }
    function set(thing, propOrOldValue, value) {
      const t2 = getArchtype(thing);
      if (t2 === 2)
        thing.set(propOrOldValue, value);
      else if (t2 === 3) {
        thing.add(value);
      } else
        thing[propOrOldValue] = value;
    }
    function is$2(x2, y2) {
      if (x2 === y2) {
        return x2 !== 0 || 1 / x2 === 1 / y2;
      } else {
        return x2 !== x2 && y2 !== y2;
      }
    }
    function isMap(target) {
      return target instanceof Map;
    }
    function isSet(target) {
      return target instanceof Set;
    }
    function latest(state) {
      return state.copy_ || state.base_;
    }
    function shallowCopy(base, strict) {
      if (isMap(base)) {
        return new Map(base);
      }
      if (isSet(base)) {
        return new Set(base);
      }
      if (Array.isArray(base))
        return Array.prototype.slice.call(base);
      const isPlain = isPlainObject$3(base);
      if (strict === true || strict === "class_only" && !isPlain) {
        const descriptors = Object.getOwnPropertyDescriptors(base);
        delete descriptors[DRAFT_STATE];
        let keys = Reflect.ownKeys(descriptors);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const desc = descriptors[key];
          if (desc.writable === false) {
            desc.writable = true;
            desc.configurable = true;
          }
          if (desc.get || desc.set)
            descriptors[key] = {
              configurable: true,
              writable: true,
              // could live with !!desc.set as well here...
              enumerable: desc.enumerable,
              value: base[key]
            };
        }
        return Object.create(getPrototypeOf(base), descriptors);
      } else {
        const proto = getPrototypeOf(base);
        if (proto !== null && isPlain) {
          return __spreadValues({}, base);
        }
        const obj = Object.create(proto);
        return Object.assign(obj, base);
      }
    }
    function freeze(obj, deep = false) {
      if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
        return obj;
      if (getArchtype(obj) > 1) {
        Object.defineProperties(obj, {
          set: dontMutateMethodOverride,
          add: dontMutateMethodOverride,
          clear: dontMutateMethodOverride,
          delete: dontMutateMethodOverride
        });
      }
      Object.freeze(obj);
      if (deep)
        Object.values(obj).forEach((value) => freeze(value, true));
      return obj;
    }
    function dontMutateFrozenCollections() {
      die(2);
    }
    var dontMutateMethodOverride = {
      value: dontMutateFrozenCollections
    };
    function isFrozen(obj) {
      if (obj === null || typeof obj !== "object")
        return true;
      return Object.isFrozen(obj);
    }
    var plugins = {};
    function getPlugin(pluginKey) {
      const plugin = plugins[pluginKey];
      if (!plugin) {
        die(0, pluginKey);
      }
      return plugin;
    }
    var currentScope;
    function getCurrentScope() {
      return currentScope;
    }
    function createScope(parent_, immer_) {
      return {
        drafts_: [],
        parent_,
        immer_,
        // Whenever the modified draft contains a draft from another scope, we
        // need to prevent auto-freezing so the unowned draft can be finalized.
        canAutoFreeze_: true,
        unfinalizedDrafts_: 0
      };
    }
    function usePatchesInScope(scope, patchListener) {
      if (patchListener) {
        getPlugin("Patches");
        scope.patches_ = [];
        scope.inversePatches_ = [];
        scope.patchListener_ = patchListener;
      }
    }
    function revokeScope(scope) {
      leaveScope(scope);
      scope.drafts_.forEach(revokeDraft);
      scope.drafts_ = null;
    }
    function leaveScope(scope) {
      if (scope === currentScope) {
        currentScope = scope.parent_;
      }
    }
    function enterScope(immer2) {
      return currentScope = createScope(currentScope, immer2);
    }
    function revokeDraft(draft) {
      const state = draft[DRAFT_STATE];
      if (state.type_ === 0 || state.type_ === 1)
        state.revoke_();
      else
        state.revoked_ = true;
    }
    function processResult(result, scope) {
      scope.unfinalizedDrafts_ = scope.drafts_.length;
      const baseDraft = scope.drafts_[0];
      const isReplaced = result !== void 0 && result !== baseDraft;
      if (isReplaced) {
        if (baseDraft[DRAFT_STATE].modified_) {
          revokeScope(scope);
          die(4);
        }
        if (isDraftable(result)) {
          result = finalize(scope, result);
          if (!scope.parent_)
            maybeFreeze(scope, result);
        }
        if (scope.patches_) {
          getPlugin("Patches").generateReplacementPatches_(
            baseDraft[DRAFT_STATE].base_,
            result,
            scope.patches_,
            scope.inversePatches_
          );
        }
      } else {
        result = finalize(scope, baseDraft, []);
      }
      revokeScope(scope);
      if (scope.patches_) {
        scope.patchListener_(scope.patches_, scope.inversePatches_);
      }
      return result !== NOTHING ? result : void 0;
    }
    function finalize(rootScope, value, path) {
      if (isFrozen(value))
        return value;
      const useStrictIteration = rootScope.immer_.shouldUseStrictIteration();
      const state = value[DRAFT_STATE];
      if (!state) {
        each(
          value,
          (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path),
          useStrictIteration
        );
        return value;
      }
      if (state.scope_ !== rootScope)
        return value;
      if (!state.modified_) {
        maybeFreeze(rootScope, state.base_, true);
        return state.base_;
      }
      if (!state.finalized_) {
        state.finalized_ = true;
        state.scope_.unfinalizedDrafts_--;
        const result = state.copy_;
        let resultEach = result;
        let isSet2 = false;
        if (state.type_ === 3) {
          resultEach = new Set(result);
          result.clear();
          isSet2 = true;
        }
        each(
          resultEach,
          (key, childValue) => finalizeProperty(
            rootScope,
            state,
            result,
            key,
            childValue,
            path,
            isSet2
          ),
          useStrictIteration
        );
        maybeFreeze(rootScope, result, false);
        if (path && rootScope.patches_) {
          getPlugin("Patches").generatePatches_(
            state,
            path,
            rootScope.patches_,
            rootScope.inversePatches_
          );
        }
      }
      return state.copy_;
    }
    function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
      if (childValue == null) {
        return;
      }
      if (typeof childValue !== "object" && !targetIsSet) {
        return;
      }
      const childIsFrozen = isFrozen(childValue);
      if (childIsFrozen && !targetIsSet) {
        return;
      }
      if (isDraft(childValue)) {
        const path = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
        !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
        const res = finalize(rootScope, childValue, path);
        set(targetObject, prop, res);
        if (isDraft(res)) {
          rootScope.canAutoFreeze_ = false;
        } else
          return;
      } else if (targetIsSet) {
        targetObject.add(childValue);
      }
      if (isDraftable(childValue) && !childIsFrozen) {
        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
          return;
        }
        if (parentState && parentState.base_ && parentState.base_[prop] === childValue && childIsFrozen) {
          return;
        }
        finalize(rootScope, childValue);
        if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && (isMap(targetObject) ? targetObject.has(prop) : Object.prototype.propertyIsEnumerable.call(targetObject, prop)))
          maybeFreeze(rootScope, childValue);
      }
    }
    function maybeFreeze(scope, value, deep = false) {
      if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
        freeze(value, deep);
      }
    }
    function createProxyProxy(base, parent) {
      const isArray2 = Array.isArray(base);
      const state = {
        type_: isArray2 ? 1 : 0,
        // Track which produce call this is associated with.
        scope_: parent ? parent.scope_ : getCurrentScope(),
        // True for both shallow and deep changes.
        modified_: false,
        // Used during finalization.
        finalized_: false,
        // Track which properties have been assigned (true) or deleted (false).
        assigned_: {},
        // The parent draft state.
        parent_: parent,
        // The base state.
        base_: base,
        // The base proxy.
        draft_: null,
        // set below
        // The base copy with any updated values.
        copy_: null,
        // Called by the `produce` function.
        revoke_: null,
        isManual_: false
      };
      let target = state;
      let traps = objectTraps;
      if (isArray2) {
        target = [state];
        traps = arrayTraps;
      }
      const { revoke, proxy } = Proxy.revocable(target, traps);
      state.draft_ = proxy;
      state.revoke_ = revoke;
      return proxy;
    }
    var objectTraps = {
      get(state, prop) {
        if (prop === DRAFT_STATE)
          return state;
        const source = latest(state);
        if (!has(source, prop)) {
          return readPropFromProto(state, source, prop);
        }
        const value = source[prop];
        if (state.finalized_ || !isDraftable(value)) {
          return value;
        }
        if (value === peek(state.base_, prop)) {
          prepareCopy(state);
          return state.copy_[prop] = createProxy(value, state);
        }
        return value;
      },
      has(state, prop) {
        return prop in latest(state);
      },
      ownKeys(state) {
        return Reflect.ownKeys(latest(state));
      },
      set(state, prop, value) {
        const desc = getDescriptorFromProto(latest(state), prop);
        if (desc == null ? void 0 : desc.set) {
          desc.set.call(state.draft_, value);
          return true;
        }
        if (!state.modified_) {
          const current2 = peek(latest(state), prop);
          const currentState = current2 == null ? void 0 : current2[DRAFT_STATE];
          if (currentState && currentState.base_ === value) {
            state.copy_[prop] = value;
            state.assigned_[prop] = false;
            return true;
          }
          if (is$2(value, current2) && (value !== void 0 || has(state.base_, prop)))
            return true;
          prepareCopy(state);
          markChanged(state);
        }
        if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
        (value !== void 0 || prop in state.copy_) || // special case: NaN
        Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
          return true;
        state.copy_[prop] = value;
        state.assigned_[prop] = true;
        return true;
      },
      deleteProperty(state, prop) {
        if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
          state.assigned_[prop] = false;
          prepareCopy(state);
          markChanged(state);
        } else {
          delete state.assigned_[prop];
        }
        if (state.copy_) {
          delete state.copy_[prop];
        }
        return true;
      },
      // Note: We never coerce `desc.value` into an Immer draft, because we can't make
      // the same guarantee in ES5 mode.
      getOwnPropertyDescriptor(state, prop) {
        const owner = latest(state);
        const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
        if (!desc)
          return desc;
        return {
          writable: true,
          configurable: state.type_ !== 1 || prop !== "length",
          enumerable: desc.enumerable,
          value: owner[prop]
        };
      },
      defineProperty() {
        die(11);
      },
      getPrototypeOf(state) {
        return getPrototypeOf(state.base_);
      },
      setPrototypeOf() {
        die(12);
      }
    };
    var arrayTraps = {};
    each(objectTraps, (key, fn) => {
      arrayTraps[key] = function() {
        arguments[0] = arguments[0][0];
        return fn.apply(this, arguments);
      };
    });
    arrayTraps.deleteProperty = function(state, prop) {
      return arrayTraps.set.call(this, state, prop, void 0);
    };
    arrayTraps.set = function(state, prop, value) {
      return objectTraps.set.call(this, state[0], prop, value, state[0]);
    };
    function peek(draft, prop) {
      const state = draft[DRAFT_STATE];
      const source = state ? latest(state) : draft;
      return source[prop];
    }
    function readPropFromProto(state, source, prop) {
      var _a;
      const desc = getDescriptorFromProto(source, prop);
      return desc ? `value` in desc ? desc.value : (
        // This is a very special case, if the prop is a getter defined by the
        // prototype, we should invoke it with the draft as context!
        (_a = desc.get) == null ? void 0 : _a.call(state.draft_)
      ) : void 0;
    }
    function getDescriptorFromProto(source, prop) {
      if (!(prop in source))
        return void 0;
      let proto = getPrototypeOf(source);
      while (proto) {
        const desc = Object.getOwnPropertyDescriptor(proto, prop);
        if (desc)
          return desc;
        proto = getPrototypeOf(proto);
      }
      return void 0;
    }
    function markChanged(state) {
      if (!state.modified_) {
        state.modified_ = true;
        if (state.parent_) {
          markChanged(state.parent_);
        }
      }
    }
    function prepareCopy(state) {
      if (!state.copy_) {
        state.copy_ = shallowCopy(
          state.base_,
          state.scope_.immer_.useStrictShallowCopy_
        );
      }
    }
    var Immer2 = class {
      constructor(config2) {
        this.autoFreeze_ = true;
        this.useStrictShallowCopy_ = false;
        this.useStrictIteration_ = true;
        this.produce = (base, recipe, patchListener) => {
          if (typeof base === "function" && typeof recipe !== "function") {
            const defaultBase = recipe;
            recipe = base;
            const self2 = this;
            return function curriedProduce(base2 = defaultBase, ...args) {
              return self2.produce(base2, (draft) => recipe.call(this, draft, ...args));
            };
          }
          if (typeof recipe !== "function")
            die(6);
          if (patchListener !== void 0 && typeof patchListener !== "function")
            die(7);
          let result;
          if (isDraftable(base)) {
            const scope = enterScope(this);
            const proxy = createProxy(base, void 0);
            let hasError = true;
            try {
              result = recipe(proxy);
              hasError = false;
            } finally {
              if (hasError)
                revokeScope(scope);
              else
                leaveScope(scope);
            }
            usePatchesInScope(scope, patchListener);
            return processResult(result, scope);
          } else if (!base || typeof base !== "object") {
            result = recipe(base);
            if (result === void 0)
              result = base;
            if (result === NOTHING)
              result = void 0;
            if (this.autoFreeze_)
              freeze(result, true);
            if (patchListener) {
              const p2 = [];
              const ip = [];
              getPlugin("Patches").generateReplacementPatches_(base, result, p2, ip);
              patchListener(p2, ip);
            }
            return result;
          } else
            die(1, base);
        };
        this.produceWithPatches = (base, recipe) => {
          if (typeof base === "function") {
            return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
          }
          let patches, inversePatches;
          const result = this.produce(base, recipe, (p2, ip) => {
            patches = p2;
            inversePatches = ip;
          });
          return [result, patches, inversePatches];
        };
        if (typeof (config2 == null ? void 0 : config2.autoFreeze) === "boolean")
          this.setAutoFreeze(config2.autoFreeze);
        if (typeof (config2 == null ? void 0 : config2.useStrictShallowCopy) === "boolean")
          this.setUseStrictShallowCopy(config2.useStrictShallowCopy);
        if (typeof (config2 == null ? void 0 : config2.useStrictIteration) === "boolean")
          this.setUseStrictIteration(config2.useStrictIteration);
      }
      createDraft(base) {
        if (!isDraftable(base))
          die(8);
        if (isDraft(base))
          base = current(base);
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        proxy[DRAFT_STATE].isManual_ = true;
        leaveScope(scope);
        return proxy;
      }
      finishDraft(draft, patchListener) {
        const state = draft && draft[DRAFT_STATE];
        if (!state || !state.isManual_)
          die(9);
        const { scope_: scope } = state;
        usePatchesInScope(scope, patchListener);
        return processResult(void 0, scope);
      }
      /**
       * Pass true to automatically freeze all copies created by Immer.
       *
       * By default, auto-freezing is enabled.
       */
      setAutoFreeze(value) {
        this.autoFreeze_ = value;
      }
      /**
       * Pass true to enable strict shallow copy.
       *
       * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
       */
      setUseStrictShallowCopy(value) {
        this.useStrictShallowCopy_ = value;
      }
      /**
       * Pass false to use faster iteration that skips non-enumerable properties
       * but still handles symbols for compatibility.
       *
       * By default, strict iteration is enabled (includes all own properties).
       */
      setUseStrictIteration(value) {
        this.useStrictIteration_ = value;
      }
      shouldUseStrictIteration() {
        return this.useStrictIteration_;
      }
      applyPatches(base, patches) {
        let i;
        for (i = patches.length - 1; i >= 0; i--) {
          const patch = patches[i];
          if (patch.path.length === 0 && patch.op === "replace") {
            base = patch.value;
            break;
          }
        }
        if (i > -1) {
          patches = patches.slice(i + 1);
        }
        const applyPatchesImpl = getPlugin("Patches").applyPatches_;
        if (isDraft(base)) {
          return applyPatchesImpl(base, patches);
        }
        return this.produce(
          base,
          (draft) => applyPatchesImpl(draft, patches)
        );
      }
    };
    function createProxy(value, parent) {
      const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
      const scope = parent ? parent.scope_ : getCurrentScope();
      scope.drafts_.push(draft);
      return draft;
    }
    function current(value) {
      if (!isDraft(value))
        die(10, value);
      return currentImpl(value);
    }
    function currentImpl(value) {
      if (!isDraftable(value) || isFrozen(value))
        return value;
      const state = value[DRAFT_STATE];
      let copy2;
      let strict = true;
      if (state) {
        if (!state.modified_)
          return state.base_;
        state.finalized_ = true;
        copy2 = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
        strict = state.scope_.immer_.shouldUseStrictIteration();
      } else {
        copy2 = shallowCopy(value, true);
      }
      each(
        copy2,
        (key, childValue) => {
          set(copy2, key, currentImpl(childValue));
        },
        strict
      );
      if (state) {
        state.finalized_ = false;
      }
      return copy2;
    }
    var immer = new Immer2();
    immer.produce;
    function castDraft(value) {
      return value;
    }
    var initialState$a = {
      settings: {
        layout: "horizontal",
        align: "center",
        verticalAlign: "middle",
        itemSorter: "value"
      },
      size: {
        width: 0,
        height: 0
      },
      payload: []
    };
    var legendSlice = createSlice({
      name: "legend",
      initialState: initialState$a,
      reducers: {
        setLegendSize(state, action) {
          state.size.width = action.payload.width;
          state.size.height = action.payload.height;
        },
        setLegendSettings(state, action) {
          state.settings.align = action.payload.align;
          state.settings.layout = action.payload.layout;
          state.settings.verticalAlign = action.payload.verticalAlign;
          state.settings.itemSorter = action.payload.itemSorter;
        },
        addLegendPayload: {
          reducer(state, action) {
            state.payload.push(castDraft(action.payload));
          },
          prepare: prepareAutoBatched()
        },
        replaceLegendPayload: {
          reducer(state, action) {
            var {
              prev,
              next
            } = action.payload;
            var index = current$1(state).payload.indexOf(castDraft(prev));
            if (index > -1) {
              state.payload[index] = castDraft(next);
            }
          },
          prepare: prepareAutoBatched()
        },
        removeLegendPayload: {
          reducer(state, action) {
            var index = current$1(state).payload.indexOf(castDraft(action.payload));
            if (index > -1) {
              state.payload.splice(index, 1);
            }
          },
          prepare: prepareAutoBatched()
        }
      }
    });
    var {
      setLegendSize,
      setLegendSettings,
      addLegendPayload,
      replaceLegendPayload,
      removeLegendPayload
    } = legendSlice.actions;
    var legendReducer = legendSlice.reducer;
    var _excluded$m = ["contextPayload"];
    function _extends$p() {
      return _extends$p = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$p.apply(null, arguments);
    }
    function ownKeys$A(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$A(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$A(Object(t2), true).forEach(function(r3) {
          _defineProperty$C(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$A(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$C(e, r2, t2) {
      return (r2 = _toPropertyKey$C(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$C(t2) {
      var i = _toPrimitive$C(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$C(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function _objectWithoutProperties$m(e, t2) {
      if (null == e) return {};
      var o, r2, i = _objectWithoutPropertiesLoose$m(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e);
        for (r2 = 0; r2 < n2.length; r2++) o = n2[r2], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose$m(r2, e) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    function defaultUniqBy$1(entry) {
      return entry.value;
    }
    function LegendContent(props) {
      var {
        contextPayload
      } = props, otherProps = _objectWithoutProperties$m(props, _excluded$m);
      var finalPayload = getUniqPayload(contextPayload, props.payloadUniqBy, defaultUniqBy$1);
      var contentProps = _objectSpread$A(_objectSpread$A({}, otherProps), {}, {
        payload: finalPayload
      });
      if (/* @__PURE__ */ reactExports.isValidElement(props.content)) {
        return /* @__PURE__ */ reactExports.cloneElement(props.content, contentProps);
      }
      if (typeof props.content === "function") {
        return /* @__PURE__ */ reactExports.createElement(props.content, contentProps);
      }
      return /* @__PURE__ */ reactExports.createElement(DefaultLegendContent, contentProps);
    }
    function getDefaultPosition(style, props, margin, chartWidth, chartHeight, box) {
      var {
        layout,
        align,
        verticalAlign
      } = props;
      var hPos, vPos;
      if (!style || (style.left === void 0 || style.left === null) && (style.right === void 0 || style.right === null)) {
        if (align === "center" && layout === "vertical") {
          hPos = {
            left: ((chartWidth || 0) - box.width) / 2
          };
        } else {
          hPos = align === "right" ? {
            right: margin && margin.right || 0
          } : {
            left: margin && margin.left || 0
          };
        }
      }
      if (!style || (style.top === void 0 || style.top === null) && (style.bottom === void 0 || style.bottom === null)) {
        if (verticalAlign === "middle") {
          vPos = {
            top: ((chartHeight || 0) - box.height) / 2
          };
        } else {
          vPos = verticalAlign === "bottom" ? {
            bottom: margin && margin.bottom || 0
          } : {
            top: margin && margin.top || 0
          };
        }
      }
      return _objectSpread$A(_objectSpread$A({}, hPos), vPos);
    }
    function LegendSettingsDispatcher(props) {
      var dispatch = useAppDispatch();
      reactExports.useEffect(() => {
        dispatch(setLegendSettings(props));
      }, [dispatch, props]);
      return null;
    }
    function LegendSizeDispatcher(props) {
      var dispatch = useAppDispatch();
      reactExports.useEffect(() => {
        dispatch(setLegendSize(props));
        return () => {
          dispatch(setLegendSize({
            width: 0,
            height: 0
          }));
        };
      }, [dispatch, props]);
      return null;
    }
    function getWidthOrHeight(layout, height, width, maxWidth) {
      if (layout === "vertical" && isNumber(height)) {
        return {
          height
        };
      }
      if (layout === "horizontal") {
        return {
          width: width || maxWidth
        };
      }
      return null;
    }
    var legendDefaultProps = {
      align: "center",
      iconSize: 14,
      itemSorter: "value",
      layout: "horizontal",
      verticalAlign: "bottom"
    };
    function Legend(outsideProps) {
      var props = resolveDefaultProps(outsideProps, legendDefaultProps);
      var contextPayload = useLegendPayload();
      var legendPortalFromContext = useLegendPortal();
      var margin = useMargin();
      var {
        width: widthFromProps,
        height: heightFromProps,
        wrapperStyle,
        portal: portalFromProps
      } = props;
      var [lastBoundingBox, updateBoundingBox] = useElementOffset([contextPayload]);
      var chartWidth = useChartWidth();
      var chartHeight = useChartHeight();
      if (chartWidth == null || chartHeight == null) {
        return null;
      }
      var maxWidth = chartWidth - ((margin === null || margin === void 0 ? void 0 : margin.left) || 0) - ((margin === null || margin === void 0 ? void 0 : margin.right) || 0);
      var widthOrHeight = getWidthOrHeight(props.layout, heightFromProps, widthFromProps, maxWidth);
      var outerStyle = portalFromProps ? wrapperStyle : _objectSpread$A(_objectSpread$A({
        position: "absolute",
        width: (widthOrHeight === null || widthOrHeight === void 0 ? void 0 : widthOrHeight.width) || widthFromProps || "auto",
        height: (widthOrHeight === null || widthOrHeight === void 0 ? void 0 : widthOrHeight.height) || heightFromProps || "auto"
      }, getDefaultPosition(wrapperStyle, props, margin, chartWidth, chartHeight, lastBoundingBox)), wrapperStyle);
      var legendPortal = portalFromProps !== null && portalFromProps !== void 0 ? portalFromProps : legendPortalFromContext;
      if (legendPortal == null || contextPayload == null) {
        return null;
      }
      var legendElement = /* @__PURE__ */ reactExports.createElement("div", {
        className: "recharts-legend-wrapper",
        style: outerStyle,
        ref: updateBoundingBox
      }, /* @__PURE__ */ reactExports.createElement(LegendSettingsDispatcher, {
        layout: props.layout,
        align: props.align,
        verticalAlign: props.verticalAlign,
        itemSorter: props.itemSorter
      }), !portalFromProps && /* @__PURE__ */ reactExports.createElement(LegendSizeDispatcher, {
        width: lastBoundingBox.width,
        height: lastBoundingBox.height
      }), /* @__PURE__ */ reactExports.createElement(LegendContent, _extends$p({}, props, widthOrHeight, {
        margin,
        chartWidth,
        chartHeight,
        contextPayload
      })));
      return /* @__PURE__ */ reactDomExports.createPortal(legendElement, legendPortal);
    }
    Legend.displayName = "Legend";
    function _extends$o() {
      return _extends$o = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$o.apply(null, arguments);
    }
    function ownKeys$z(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$z(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$z(Object(t2), true).forEach(function(r3) {
          _defineProperty$B(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$z(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$B(e, r2, t2) {
      return (r2 = _toPropertyKey$B(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$B(t2) {
      var i = _toPrimitive$B(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$B(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function defaultFormatter(value) {
      return Array.isArray(value) && isNumOrStr(value[0]) && isNumOrStr(value[1]) ? value.join(" ~ ") : value;
    }
    var DefaultTooltipContent = (props) => {
      var {
        separator = " : ",
        contentStyle = {},
        itemStyle = {},
        labelStyle = {},
        payload,
        formatter,
        itemSorter,
        wrapperClassName,
        labelClassName,
        label,
        labelFormatter,
        accessibilityLayer = false
      } = props;
      var renderContent2 = () => {
        if (payload && payload.length) {
          var listStyle = {
            padding: 0,
            margin: 0
          };
          var items = (itemSorter ? sortBy$1(payload, itemSorter) : payload).map((entry, i) => {
            if (entry.type === "none") {
              return null;
            }
            var finalFormatter = entry.formatter || formatter || defaultFormatter;
            var {
              value,
              name
            } = entry;
            var finalValue = value;
            var finalName = name;
            if (finalFormatter) {
              var formatted = finalFormatter(value, name, entry, i, payload);
              if (Array.isArray(formatted)) {
                [finalValue, finalName] = formatted;
              } else if (formatted != null) {
                finalValue = formatted;
              } else {
                return null;
              }
            }
            var finalItemStyle = _objectSpread$z({
              display: "block",
              paddingTop: 4,
              paddingBottom: 4,
              color: entry.color || "#000"
            }, itemStyle);
            return /* @__PURE__ */ reactExports.createElement("li", {
              className: "recharts-tooltip-item",
              key: "tooltip-item-".concat(i),
              style: finalItemStyle
            }, isNumOrStr(finalName) ? /* @__PURE__ */ reactExports.createElement("span", {
              className: "recharts-tooltip-item-name"
            }, finalName) : null, isNumOrStr(finalName) ? /* @__PURE__ */ reactExports.createElement("span", {
              className: "recharts-tooltip-item-separator"
            }, separator) : null, /* @__PURE__ */ reactExports.createElement("span", {
              className: "recharts-tooltip-item-value"
            }, finalValue), /* @__PURE__ */ reactExports.createElement("span", {
              className: "recharts-tooltip-item-unit"
            }, entry.unit || ""));
          });
          return /* @__PURE__ */ reactExports.createElement("ul", {
            className: "recharts-tooltip-item-list",
            style: listStyle
          }, items);
        }
        return null;
      };
      var finalStyle = _objectSpread$z({
        margin: 0,
        padding: 10,
        backgroundColor: "#fff",
        border: "1px solid #ccc",
        whiteSpace: "nowrap"
      }, contentStyle);
      var finalLabelStyle = _objectSpread$z({
        margin: 0
      }, labelStyle);
      var hasLabel = !isNullish(label);
      var finalLabel = hasLabel ? label : "";
      var wrapperCN = clsx("recharts-default-tooltip", wrapperClassName);
      var labelCN = clsx("recharts-tooltip-label", labelClassName);
      if (hasLabel && labelFormatter && payload !== void 0 && payload !== null) {
        finalLabel = labelFormatter(label, payload);
      }
      var accessibilityAttributes = accessibilityLayer ? {
        role: "status",
        "aria-live": "assertive"
      } : {};
      return /* @__PURE__ */ reactExports.createElement("div", _extends$o({
        className: wrapperCN,
        style: finalStyle
      }, accessibilityAttributes), /* @__PURE__ */ reactExports.createElement("p", {
        className: labelCN,
        style: finalLabelStyle
      }, /* @__PURE__ */ reactExports.isValidElement(finalLabel) ? finalLabel : "".concat(finalLabel)), renderContent2());
    };
    var CSS_CLASS_PREFIX = "recharts-tooltip-wrapper";
    var TOOLTIP_HIDDEN = {
      visibility: "hidden"
    };
    function getTooltipCSSClassName(_ref2) {
      var {
        coordinate,
        translateX,
        translateY
      } = _ref2;
      return clsx(CSS_CLASS_PREFIX, {
        ["".concat(CSS_CLASS_PREFIX, "-right")]: isNumber(translateX) && coordinate && isNumber(coordinate.x) && translateX >= coordinate.x,
        ["".concat(CSS_CLASS_PREFIX, "-left")]: isNumber(translateX) && coordinate && isNumber(coordinate.x) && translateX < coordinate.x,
        ["".concat(CSS_CLASS_PREFIX, "-bottom")]: isNumber(translateY) && coordinate && isNumber(coordinate.y) && translateY >= coordinate.y,
        ["".concat(CSS_CLASS_PREFIX, "-top")]: isNumber(translateY) && coordinate && isNumber(coordinate.y) && translateY < coordinate.y
      });
    }
    function getTooltipTranslateXY(_ref2) {
      var {
        allowEscapeViewBox,
        coordinate,
        key,
        offsetTopLeft,
        position,
        reverseDirection,
        tooltipDimension,
        viewBox,
        viewBoxDimension
      } = _ref2;
      if (position && isNumber(position[key])) {
        return position[key];
      }
      var negative = coordinate[key] - tooltipDimension - (offsetTopLeft > 0 ? offsetTopLeft : 0);
      var positive = coordinate[key] + offsetTopLeft;
      if (allowEscapeViewBox[key]) {
        return reverseDirection[key] ? negative : positive;
      }
      var viewBoxKey = viewBox[key];
      if (viewBoxKey == null) {
        return 0;
      }
      if (reverseDirection[key]) {
        var _tooltipBoundary = negative;
        var _viewBoxBoundary = viewBoxKey;
        if (_tooltipBoundary < _viewBoxBoundary) {
          return Math.max(positive, viewBoxKey);
        }
        return Math.max(negative, viewBoxKey);
      }
      if (viewBoxDimension == null) {
        return 0;
      }
      var tooltipBoundary = positive + tooltipDimension;
      var viewBoxBoundary = viewBoxKey + viewBoxDimension;
      if (tooltipBoundary > viewBoxBoundary) {
        return Math.max(negative, viewBoxKey);
      }
      return Math.max(positive, viewBoxKey);
    }
    function getTransformStyle(_ref3) {
      var {
        translateX,
        translateY,
        useTranslate3d
      } = _ref3;
      return {
        transform: useTranslate3d ? "translate3d(".concat(translateX, "px, ").concat(translateY, "px, 0)") : "translate(".concat(translateX, "px, ").concat(translateY, "px)")
      };
    }
    function getTooltipTranslate(_ref4) {
      var {
        allowEscapeViewBox,
        coordinate,
        offsetTopLeft,
        position,
        reverseDirection,
        tooltipBox,
        useTranslate3d,
        viewBox
      } = _ref4;
      var cssProperties, translateX, translateY;
      if (tooltipBox.height > 0 && tooltipBox.width > 0 && coordinate) {
        translateX = getTooltipTranslateXY({
          allowEscapeViewBox,
          coordinate,
          key: "x",
          offsetTopLeft,
          position,
          reverseDirection,
          tooltipDimension: tooltipBox.width,
          viewBox,
          viewBoxDimension: viewBox.width
        });
        translateY = getTooltipTranslateXY({
          allowEscapeViewBox,
          coordinate,
          key: "y",
          offsetTopLeft,
          position,
          reverseDirection,
          tooltipDimension: tooltipBox.height,
          viewBox,
          viewBoxDimension: viewBox.height
        });
        cssProperties = getTransformStyle({
          translateX,
          translateY,
          useTranslate3d
        });
      } else {
        cssProperties = TOOLTIP_HIDDEN;
      }
      return {
        cssProperties,
        cssClasses: getTooltipCSSClassName({
          translateX,
          translateY,
          coordinate
        })
      };
    }
    function ownKeys$y(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$y(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$y(Object(t2), true).forEach(function(r3) {
          _defineProperty$A(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$y(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$A(e, r2, t2) {
      return (r2 = _toPropertyKey$A(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$A(t2) {
      var i = _toPrimitive$A(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$A(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    class TooltipBoundingBox extends reactExports.PureComponent {
      constructor() {
        super(...arguments);
        _defineProperty$A(this, "state", {
          dismissed: false,
          dismissedAtCoordinate: {
            x: 0,
            y: 0
          }
        });
        _defineProperty$A(this, "handleKeyDown", (event) => {
          if (event.key === "Escape") {
            var _this$props$coordinat, _this$props$coordinat2, _this$props$coordinat3, _this$props$coordinat4;
            this.setState({
              dismissed: true,
              dismissedAtCoordinate: {
                x: (_this$props$coordinat = (_this$props$coordinat2 = this.props.coordinate) === null || _this$props$coordinat2 === void 0 ? void 0 : _this$props$coordinat2.x) !== null && _this$props$coordinat !== void 0 ? _this$props$coordinat : 0,
                y: (_this$props$coordinat3 = (_this$props$coordinat4 = this.props.coordinate) === null || _this$props$coordinat4 === void 0 ? void 0 : _this$props$coordinat4.y) !== null && _this$props$coordinat3 !== void 0 ? _this$props$coordinat3 : 0
              }
            });
          }
        });
      }
      componentDidMount() {
        document.addEventListener("keydown", this.handleKeyDown);
      }
      componentWillUnmount() {
        document.removeEventListener("keydown", this.handleKeyDown);
      }
      componentDidUpdate() {
        var _this$props$coordinat5, _this$props$coordinat6;
        if (!this.state.dismissed) {
          return;
        }
        if (((_this$props$coordinat5 = this.props.coordinate) === null || _this$props$coordinat5 === void 0 ? void 0 : _this$props$coordinat5.x) !== this.state.dismissedAtCoordinate.x || ((_this$props$coordinat6 = this.props.coordinate) === null || _this$props$coordinat6 === void 0 ? void 0 : _this$props$coordinat6.y) !== this.state.dismissedAtCoordinate.y) {
          this.state.dismissed = false;
        }
      }
      render() {
        var {
          active,
          allowEscapeViewBox,
          animationDuration,
          animationEasing,
          children,
          coordinate,
          hasPayload,
          isAnimationActive,
          offset,
          position,
          reverseDirection,
          useTranslate3d,
          viewBox,
          wrapperStyle,
          lastBoundingBox,
          innerRef,
          hasPortalFromProps
        } = this.props;
        var {
          cssClasses,
          cssProperties
        } = getTooltipTranslate({
          allowEscapeViewBox,
          coordinate,
          offsetTopLeft: offset,
          position,
          reverseDirection,
          tooltipBox: {
            height: lastBoundingBox.height,
            width: lastBoundingBox.width
          },
          useTranslate3d,
          viewBox
        });
        var positionStyles = hasPortalFromProps ? {} : _objectSpread$y(_objectSpread$y({
          transition: isAnimationActive && active ? "transform ".concat(animationDuration, "ms ").concat(animationEasing) : void 0
        }, cssProperties), {}, {
          pointerEvents: "none",
          visibility: !this.state.dismissed && active && hasPayload ? "visible" : "hidden",
          position: "absolute",
          top: 0,
          left: 0
        });
        var outerStyle = _objectSpread$y(_objectSpread$y({}, positionStyles), {}, {
          visibility: !this.state.dismissed && active && hasPayload ? "visible" : "hidden"
        }, wrapperStyle);
        return (
          // This element allow listening to the `Escape` key. See https://github.com/recharts/recharts/pull/2925
          /* @__PURE__ */ reactExports.createElement("div", {
            // @ts-expect-error typescript library does not recognize xmlns attribute, but it's required for an HTML chunk inside SVG.
            xmlns: "http://www.w3.org/1999/xhtml",
            tabIndex: -1,
            className: cssClasses,
            style: outerStyle,
            ref: innerRef
          }, children)
        );
      }
    }
    var useAccessibilityLayer = () => {
      var _useAppSelector;
      return (_useAppSelector = useAppSelector((state) => state.rootProps.accessibilityLayer)) !== null && _useAppSelector !== void 0 ? _useAppSelector : true;
    };
    function _extends$n() {
      return _extends$n = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$n.apply(null, arguments);
    }
    function ownKeys$x(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$x(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$x(Object(t2), true).forEach(function(r3) {
          _defineProperty$z(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$x(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$z(e, r2, t2) {
      return (r2 = _toPropertyKey$z(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$z(t2) {
      var i = _toPrimitive$z(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$z(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    var CURVE_FACTORIES = {
      curveBasisClosed,
      curveBasisOpen,
      curveBasis,
      curveBumpX: bumpX,
      curveBumpY: bumpY,
      curveLinearClosed,
      curveLinear,
      curveMonotoneX: monotoneX,
      curveMonotoneY: monotoneY,
      curveNatural,
      curveStep,
      curveStepAfter: stepAfter,
      curveStepBefore: stepBefore
    };
    var defined = (p2) => isWellBehavedNumber(p2.x) && isWellBehavedNumber(p2.y);
    var areaDefined = (d) => d.base != null && defined(d.base) && defined(d);
    var getX = (p2) => p2.x;
    var getY = (p2) => p2.y;
    var getCurveFactory = (type, layout) => {
      if (typeof type === "function") {
        return type;
      }
      var name = "curve".concat(upperFirst(type));
      if ((name === "curveMonotone" || name === "curveBump") && layout) {
        return CURVE_FACTORIES["".concat(name).concat(layout === "vertical" ? "Y" : "X")];
      }
      return CURVE_FACTORIES[name] || curveLinear;
    };
    var getPath$1 = (_ref2) => {
      var {
        type = "linear",
        points = [],
        baseLine,
        layout,
        connectNulls = false
      } = _ref2;
      var curveFactory = getCurveFactory(type, layout);
      var formatPoints = connectNulls ? points.filter(defined) : points;
      var lineFunction;
      if (Array.isArray(baseLine)) {
        var areaPoints = points.map((entry, index) => _objectSpread$x(_objectSpread$x({}, entry), {}, {
          base: baseLine[index]
        }));
        if (layout === "vertical") {
          lineFunction = shapeArea().y(getY).x1(getX).x0((d) => d.base.x);
        } else {
          lineFunction = shapeArea().x(getX).y1(getY).y0((d) => d.base.y);
        }
        var _nullableLineFunction = lineFunction.defined(areaDefined).curve(curveFactory);
        var finalPoints = connectNulls ? areaPoints.filter(areaDefined) : areaPoints;
        return _nullableLineFunction(finalPoints);
      }
      if (layout === "vertical" && isNumber(baseLine)) {
        lineFunction = shapeArea().y(getY).x1(getX).x0(baseLine);
      } else if (isNumber(baseLine)) {
        lineFunction = shapeArea().x(getX).y1(getY).y0(baseLine);
      } else {
        lineFunction = shapeLine().x(getX).y(getY);
      }
      var nullableLineFunction = lineFunction.defined(defined).curve(curveFactory);
      return nullableLineFunction(formatPoints);
    };
    var Curve = (props) => {
      var {
        className,
        points,
        path,
        pathRef
      } = props;
      if ((!points || !points.length) && !path) {
        return null;
      }
      var realPath = points && points.length ? getPath$1(props) : path;
      return /* @__PURE__ */ reactExports.createElement("path", _extends$n({}, svgPropertiesNoEvents(props), adaptEventHandlers(props), {
        className: clsx("recharts-curve", className),
        d: realPath === null ? void 0 : realPath,
        ref: pathRef
      }));
    };
    var _excluded$l = ["x", "y", "top", "left", "width", "height", "className"];
    function _extends$m() {
      return _extends$m = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$m.apply(null, arguments);
    }
    function ownKeys$w(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$w(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$w(Object(t2), true).forEach(function(r3) {
          _defineProperty$y(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$w(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$y(e, r2, t2) {
      return (r2 = _toPropertyKey$y(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$y(t2) {
      var i = _toPrimitive$y(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$y(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function _objectWithoutProperties$l(e, t2) {
      if (null == e) return {};
      var o, r2, i = _objectWithoutPropertiesLoose$l(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e);
        for (r2 = 0; r2 < n2.length; r2++) o = n2[r2], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose$l(r2, e) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    var getPath = (x2, y2, width, height, top, left) => {
      return "M".concat(x2, ",").concat(top, "v").concat(height, "M").concat(left, ",").concat(y2, "h").concat(width);
    };
    var Cross = (_ref2) => {
      var {
        x: x2 = 0,
        y: y2 = 0,
        top = 0,
        left = 0,
        width = 0,
        height = 0,
        className
      } = _ref2, rest = _objectWithoutProperties$l(_ref2, _excluded$l);
      var props = _objectSpread$w({
        x: x2,
        y: y2,
        top,
        left,
        width,
        height
      }, rest);
      if (!isNumber(x2) || !isNumber(y2) || !isNumber(width) || !isNumber(height) || !isNumber(top) || !isNumber(left)) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement("path", _extends$m({}, svgPropertiesAndEvents(props), {
        className: clsx("recharts-cross", className),
        d: getPath(x2, y2, width, height, top, left)
      }));
    };
    function getCursorRectangle(layout, activeCoordinate, offset, tooltipAxisBandSize) {
      var halfSize = tooltipAxisBandSize / 2;
      return {
        stroke: "none",
        fill: "#ccc",
        x: layout === "horizontal" ? activeCoordinate.x - halfSize : offset.left + 0.5,
        y: layout === "horizontal" ? offset.top + 0.5 : activeCoordinate.y - halfSize,
        width: layout === "horizontal" ? tooltipAxisBandSize : offset.width - 1,
        height: layout === "horizontal" ? offset.height - 1 : tooltipAxisBandSize
      };
    }
    function ownKeys$v(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$v(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$v(Object(t2), true).forEach(function(r3) {
          _defineProperty$x(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$v(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$x(e, r2, t2) {
      return (r2 = _toPropertyKey$x(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$x(t2) {
      var i = _toPrimitive$x(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$x(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    var getDashCase = (name) => name.replace(/([A-Z])/g, (v2) => "-".concat(v2.toLowerCase()));
    var getTransitionVal = (props, duration, easing) => props.map((prop) => "".concat(getDashCase(prop), " ").concat(duration, "ms ").concat(easing)).join(",");
    var getIntersectionKeys = (preObj, nextObj) => [Object.keys(preObj), Object.keys(nextObj)].reduce((a2, b) => a2.filter((c2) => b.includes(c2)));
    var mapObject = (fn, obj) => Object.keys(obj).reduce((res, key) => _objectSpread$v(_objectSpread$v({}, res), {}, {
      [key]: fn(key, obj[key])
    }), {});
    function ownKeys$u(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$u(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$u(Object(t2), true).forEach(function(r3) {
          _defineProperty$w(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$u(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$w(e, r2, t2) {
      return (r2 = _toPropertyKey$w(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$w(t2) {
      var i = _toPrimitive$w(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$w(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    var alpha = (begin, end, k2) => begin + (end - begin) * k2;
    var needContinue = (_ref2) => {
      var {
        from: from2,
        to: to2
      } = _ref2;
      return from2 !== to2;
    };
    var calStepperVals = (easing, preVals, steps) => {
      var nextStepVals = mapObject((key, val) => {
        if (needContinue(val)) {
          var [newX, newV] = easing(val.from, val.to, val.velocity);
          return _objectSpread$u(_objectSpread$u({}, val), {}, {
            from: newX,
            velocity: newV
          });
        }
        return val;
      }, preVals);
      if (steps < 1) {
        return mapObject((key, val) => {
          if (needContinue(val)) {
            return _objectSpread$u(_objectSpread$u({}, val), {}, {
              velocity: alpha(val.velocity, nextStepVals[key].velocity, steps),
              from: alpha(val.from, nextStepVals[key].from, steps)
            });
          }
          return val;
        }, preVals);
      }
      return calStepperVals(easing, nextStepVals, steps - 1);
    };
    function createStepperUpdate(from2, to2, easing, interKeys, render, timeoutController) {
      var preTime;
      var stepperStyle = interKeys.reduce((res, key) => _objectSpread$u(_objectSpread$u({}, res), {}, {
        [key]: {
          from: from2[key],
          velocity: 0,
          to: to2[key]
        }
      }), {});
      var getCurrStyle = () => mapObject((key, val) => val.from, stepperStyle);
      var shouldStopAnimation = () => !Object.values(stepperStyle).filter(needContinue).length;
      var stopAnimation = null;
      var stepperUpdate = (now) => {
        if (!preTime) {
          preTime = now;
        }
        var deltaTime = now - preTime;
        var steps = deltaTime / easing.dt;
        stepperStyle = calStepperVals(easing, stepperStyle, steps);
        render(_objectSpread$u(_objectSpread$u(_objectSpread$u({}, from2), to2), getCurrStyle()));
        preTime = now;
        if (!shouldStopAnimation()) {
          stopAnimation = timeoutController.setTimeout(stepperUpdate);
        }
      };
      return () => {
        stopAnimation = timeoutController.setTimeout(stepperUpdate);
        return () => {
          var _stopAnimation;
          (_stopAnimation = stopAnimation) === null || _stopAnimation === void 0 || _stopAnimation();
        };
      };
    }
    function createTimingUpdate(from2, to2, easing, duration, interKeys, render, timeoutController) {
      var stopAnimation = null;
      var timingStyle = interKeys.reduce((res, key) => _objectSpread$u(_objectSpread$u({}, res), {}, {
        [key]: [from2[key], to2[key]]
      }), {});
      var beginTime;
      var timingUpdate = (now) => {
        if (!beginTime) {
          beginTime = now;
        }
        var t2 = (now - beginTime) / duration;
        var currStyle = mapObject((key, val) => alpha(...val, easing(t2)), timingStyle);
        render(_objectSpread$u(_objectSpread$u(_objectSpread$u({}, from2), to2), currStyle));
        if (t2 < 1) {
          stopAnimation = timeoutController.setTimeout(timingUpdate);
        } else {
          var finalStyle = mapObject((key, val) => alpha(...val, easing(1)), timingStyle);
          render(_objectSpread$u(_objectSpread$u(_objectSpread$u({}, from2), to2), finalStyle));
        }
      };
      return () => {
        stopAnimation = timeoutController.setTimeout(timingUpdate);
        return () => {
          var _stopAnimation2;
          (_stopAnimation2 = stopAnimation) === null || _stopAnimation2 === void 0 || _stopAnimation2();
        };
      };
    }
    const configUpdate = (from2, to2, easing, duration, render, timeoutController) => {
      var interKeys = getIntersectionKeys(from2, to2);
      if (easing == null) {
        return () => {
          render(_objectSpread$u(_objectSpread$u({}, from2), to2));
          return () => {
          };
        };
      }
      return easing.isStepper === true ? createStepperUpdate(from2, to2, easing, interKeys, render, timeoutController) : createTimingUpdate(from2, to2, easing, duration, interKeys, render, timeoutController);
    };
    var ACCURACY = 1e-4;
    var cubicBezierFactor = (c1, c2) => [0, 3 * c1, 3 * c2 - 6 * c1, 3 * c1 - 3 * c2 + 1];
    var evaluatePolynomial = (params, t2) => params.map((param, i) => param * __pow(t2, i)).reduce((pre, curr) => pre + curr);
    var cubicBezier = (c1, c2) => (t2) => {
      var params = cubicBezierFactor(c1, c2);
      return evaluatePolynomial(params, t2);
    };
    var derivativeCubicBezier = (c1, c2) => (t2) => {
      var params = cubicBezierFactor(c1, c2);
      var newParams = [...params.map((param, i) => param * i).slice(1), 0];
      return evaluatePolynomial(newParams, t2);
    };
    var getBezierCoordinates = function getBezierCoordinates2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (args.length === 1) {
        switch (args[0]) {
          case "linear":
            return [0, 0, 1, 1];
          case "ease":
            return [0.25, 0.1, 0.25, 1];
          case "ease-in":
            return [0.42, 0, 1, 1];
          case "ease-out":
            return [0.42, 0, 0.58, 1];
          case "ease-in-out":
            return [0, 0, 0.58, 1];
          default: {
            var _easing$;
            var easing = args[0].split("(");
            if (easing[0] === "cubic-bezier" && ((_easing$ = easing[1]) === null || _easing$ === void 0 ? void 0 : _easing$.split(")")[0].split(",").length) === 4) {
              var coords = easing[1].split(")")[0].split(",").map((x2) => parseFloat(x2));
              return [coords[0], coords[1], coords[2], coords[3]];
            }
          }
        }
      }
      if (args.length === 4) {
        return args;
      }
      return [0, 0, 1, 1];
    };
    var createBezierEasing = (x1, y1, x2, y2) => {
      var curveX = cubicBezier(x1, x2);
      var curveY = cubicBezier(y1, y2);
      var derCurveX = derivativeCubicBezier(x1, x2);
      var rangeValue = (value) => {
        if (value > 1) {
          return 1;
        }
        if (value < 0) {
          return 0;
        }
        return value;
      };
      var bezier = (_t) => {
        var t2 = _t > 1 ? 1 : _t;
        var x3 = t2;
        for (var i = 0; i < 8; ++i) {
          var evalT = curveX(x3) - t2;
          var derVal = derCurveX(x3);
          if (Math.abs(evalT - t2) < ACCURACY || derVal < ACCURACY) {
            return curveY(x3);
          }
          x3 = rangeValue(x3 - evalT / derVal);
        }
        return curveY(x3);
      };
      bezier.isStepper = false;
      return bezier;
    };
    var configBezier = function configBezier2() {
      return createBezierEasing(...getBezierCoordinates(...arguments));
    };
    var configSpring = function configSpring2() {
      var config2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var {
        stiff = 100,
        damping = 8,
        dt = 17
      } = config2;
      var stepper = (currX, destX, currV) => {
        var FSpring = -(currX - destX) * stiff;
        var FDamping = currV * damping;
        var newV = currV + (FSpring - FDamping) * dt / 1e3;
        var newX = currV * dt / 1e3 + currX;
        if (Math.abs(newX - destX) < ACCURACY && Math.abs(newV) < ACCURACY) {
          return [destX, 0];
        }
        return [newX, newV];
      };
      stepper.isStepper = true;
      stepper.dt = dt;
      return stepper;
    };
    var configEasing = (easing) => {
      if (typeof easing === "string") {
        switch (easing) {
          case "ease":
          case "ease-in-out":
          case "ease-out":
          case "ease-in":
          case "linear":
            return configBezier(easing);
          case "spring":
            return configSpring();
          default:
            if (easing.split("(")[0] === "cubic-bezier") {
              return configBezier(easing);
            }
        }
      }
      if (typeof easing === "function") {
        return easing;
      }
      return null;
    };
    function createAnimateManager(timeoutController) {
      var currStyle;
      var handleChange = () => null;
      var shouldStop = false;
      var cancelTimeout = null;
      var setStyle = (_style) => {
        if (shouldStop) {
          return;
        }
        if (Array.isArray(_style)) {
          if (!_style.length) {
            return;
          }
          var styles = _style;
          var [curr, ...restStyles] = styles;
          if (typeof curr === "number") {
            cancelTimeout = timeoutController.setTimeout(setStyle.bind(null, restStyles), curr);
            return;
          }
          setStyle(curr);
          cancelTimeout = timeoutController.setTimeout(setStyle.bind(null, restStyles));
          return;
        }
        if (typeof _style === "string") {
          currStyle = _style;
          handleChange(currStyle);
        }
        if (typeof _style === "object") {
          currStyle = _style;
          handleChange(currStyle);
        }
        if (typeof _style === "function") {
          _style();
        }
      };
      return {
        stop: () => {
          shouldStop = true;
        },
        start: (style) => {
          shouldStop = false;
          if (cancelTimeout) {
            cancelTimeout();
            cancelTimeout = null;
          }
          setStyle(style);
        },
        subscribe: (_handleChange) => {
          handleChange = _handleChange;
          return () => {
            handleChange = () => null;
          };
        },
        getTimeoutController: () => timeoutController
      };
    }
    class RequestAnimationFrameTimeoutController {
      setTimeout(callback) {
        var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var startTime = performance.now();
        var requestId = null;
        var executeCallback = (now) => {
          if (now - startTime >= delay) {
            callback(now);
          } else if (typeof requestAnimationFrame === "function") {
            requestId = requestAnimationFrame(executeCallback);
          }
        };
        requestId = requestAnimationFrame(executeCallback);
        return () => {
          if (requestId != null) {
            cancelAnimationFrame(requestId);
          }
        };
      }
    }
    function createDefaultAnimationManager() {
      return createAnimateManager(new RequestAnimationFrameTimeoutController());
    }
    var AnimationManagerContext = /* @__PURE__ */ reactExports.createContext(createDefaultAnimationManager);
    function useAnimationManager(animationId, animationManagerFromProps) {
      var contextAnimationManager = reactExports.useContext(AnimationManagerContext);
      return reactExports.useMemo(() => animationManagerFromProps !== null && animationManagerFromProps !== void 0 ? animationManagerFromProps : contextAnimationManager(animationId), [animationId, animationManagerFromProps, contextAnimationManager]);
    }
    var parseIsSsrByDefault = () => !(typeof window !== "undefined" && window.document && Boolean(window.document.createElement) && window.setTimeout);
    var Global = {
      devToolsEnabled: false,
      isSsr: parseIsSsrByDefault()
    };
    var defaultJavascriptAnimateProps = {
      begin: 0,
      duration: 1e3,
      easing: "ease",
      isActive: true,
      canBegin: true,
      onAnimationEnd: () => {
      },
      onAnimationStart: () => {
      }
    };
    var from = {
      t: 0
    };
    var to = {
      t: 1
    };
    function JavascriptAnimate(outsideProps) {
      var props = resolveDefaultProps(outsideProps, defaultJavascriptAnimateProps);
      var {
        isActive: isActiveProp,
        canBegin,
        duration,
        easing,
        begin,
        onAnimationEnd,
        onAnimationStart,
        children
      } = props;
      var isActive = isActiveProp === "auto" ? !Global.isSsr : isActiveProp;
      var animationManager = useAnimationManager(props.animationId, props.animationManager);
      var [style, setStyle] = reactExports.useState(isActive ? from : to);
      var stopJSAnimation = reactExports.useRef(null);
      reactExports.useEffect(() => {
        if (!isActive) {
          setStyle(to);
        }
      }, [isActive]);
      reactExports.useEffect(() => {
        if (!isActive || !canBegin) {
          return noop$2;
        }
        var startAnimation = configUpdate(from, to, configEasing(easing), duration, setStyle, animationManager.getTimeoutController());
        var onAnimationActive = () => {
          stopJSAnimation.current = startAnimation();
        };
        animationManager.start([onAnimationStart, begin, onAnimationActive, duration, onAnimationEnd]);
        return () => {
          animationManager.stop();
          if (stopJSAnimation.current) {
            stopJSAnimation.current();
          }
          onAnimationEnd();
        };
      }, [isActive, canBegin, duration, easing, begin, onAnimationStart, onAnimationEnd, animationManager]);
      return children(style.t);
    }
    function useAnimationId(input) {
      var prefix2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "animation-";
      var animationId = reactExports.useRef(uniqueId(prefix2));
      var prevProps = reactExports.useRef(input);
      if (prevProps.current !== input) {
        animationId.current = uniqueId(prefix2);
        prevProps.current = input;
      }
      return animationId.current;
    }
    var _excluded$k = ["radius"], _excluded2$a = ["radius"];
    function ownKeys$t(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$t(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$t(Object(t2), true).forEach(function(r3) {
          _defineProperty$v(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$t(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$v(e, r2, t2) {
      return (r2 = _toPropertyKey$v(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$v(t2) {
      var i = _toPrimitive$v(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$v(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function _extends$l() {
      return _extends$l = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$l.apply(null, arguments);
    }
    function _objectWithoutProperties$k(e, t2) {
      if (null == e) return {};
      var o, r2, i = _objectWithoutPropertiesLoose$k(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e);
        for (r2 = 0; r2 < n2.length; r2++) o = n2[r2], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose$k(r2, e) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    var getRectanglePath = (x2, y2, width, height, radius) => {
      var maxRadius = Math.min(Math.abs(width) / 2, Math.abs(height) / 2);
      var ySign = height >= 0 ? 1 : -1;
      var xSign = width >= 0 ? 1 : -1;
      var clockWise = height >= 0 && width >= 0 || height < 0 && width < 0 ? 1 : 0;
      var path;
      if (maxRadius > 0 && radius instanceof Array) {
        var newRadius = [0, 0, 0, 0];
        for (var i = 0, len = 4; i < len; i++) {
          newRadius[i] = radius[i] > maxRadius ? maxRadius : radius[i];
        }
        path = "M".concat(x2, ",").concat(y2 + ySign * newRadius[0]);
        if (newRadius[0] > 0) {
          path += "A ".concat(newRadius[0], ",").concat(newRadius[0], ",0,0,").concat(clockWise, ",").concat(x2 + xSign * newRadius[0], ",").concat(y2);
        }
        path += "L ".concat(x2 + width - xSign * newRadius[1], ",").concat(y2);
        if (newRadius[1] > 0) {
          path += "A ".concat(newRadius[1], ",").concat(newRadius[1], ",0,0,").concat(clockWise, ",\n        ").concat(x2 + width, ",").concat(y2 + ySign * newRadius[1]);
        }
        path += "L ".concat(x2 + width, ",").concat(y2 + height - ySign * newRadius[2]);
        if (newRadius[2] > 0) {
          path += "A ".concat(newRadius[2], ",").concat(newRadius[2], ",0,0,").concat(clockWise, ",\n        ").concat(x2 + width - xSign * newRadius[2], ",").concat(y2 + height);
        }
        path += "L ".concat(x2 + xSign * newRadius[3], ",").concat(y2 + height);
        if (newRadius[3] > 0) {
          path += "A ".concat(newRadius[3], ",").concat(newRadius[3], ",0,0,").concat(clockWise, ",\n        ").concat(x2, ",").concat(y2 + height - ySign * newRadius[3]);
        }
        path += "Z";
      } else if (maxRadius > 0 && radius === +radius && radius > 0) {
        var _newRadius = Math.min(maxRadius, radius);
        path = "M ".concat(x2, ",").concat(y2 + ySign * _newRadius, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2 + xSign * _newRadius, ",").concat(y2, "\n            L ").concat(x2 + width - xSign * _newRadius, ",").concat(y2, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2 + width, ",").concat(y2 + ySign * _newRadius, "\n            L ").concat(x2 + width, ",").concat(y2 + height - ySign * _newRadius, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2 + width - xSign * _newRadius, ",").concat(y2 + height, "\n            L ").concat(x2 + xSign * _newRadius, ",").concat(y2 + height, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2, ",").concat(y2 + height - ySign * _newRadius, " Z");
      } else {
        path = "M ".concat(x2, ",").concat(y2, " h ").concat(width, " v ").concat(height, " h ").concat(-width, " Z");
      }
      return path;
    };
    var defaultRectangleProps = {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      // The radius of border
      // The radius of four corners when radius is a number
      // The radius of left-top, right-top, right-bottom, left-bottom when radius is an array
      radius: 0,
      isAnimationActive: false,
      isUpdateAnimationActive: false,
      animationBegin: 0,
      animationDuration: 1500,
      animationEasing: "ease"
    };
    var Rectangle = (rectangleProps) => {
      var props = resolveDefaultProps(rectangleProps, defaultRectangleProps);
      var pathRef = reactExports.useRef(null);
      var [totalLength, setTotalLength] = reactExports.useState(-1);
      reactExports.useEffect(() => {
        if (pathRef.current && pathRef.current.getTotalLength) {
          try {
            var pathTotalLength = pathRef.current.getTotalLength();
            if (pathTotalLength) {
              setTotalLength(pathTotalLength);
            }
          } catch (_unused) {
          }
        }
      }, []);
      var {
        x: x2,
        y: y2,
        width,
        height,
        radius,
        className
      } = props;
      var {
        animationEasing,
        animationDuration,
        animationBegin,
        isAnimationActive,
        isUpdateAnimationActive
      } = props;
      var prevWidthRef = reactExports.useRef(width);
      var prevHeightRef = reactExports.useRef(height);
      var prevXRef = reactExports.useRef(x2);
      var prevYRef = reactExports.useRef(y2);
      var animationIdInput = reactExports.useMemo(() => ({
        x: x2,
        y: y2,
        width,
        height,
        radius
      }), [x2, y2, width, height, radius]);
      var animationId = useAnimationId(animationIdInput, "rectangle-");
      if (x2 !== +x2 || y2 !== +y2 || width !== +width || height !== +height || width === 0 || height === 0) {
        return null;
      }
      var layerClass = clsx("recharts-rectangle", className);
      if (!isUpdateAnimationActive) {
        var _svgPropertiesAndEven = svgPropertiesAndEvents(props), {
          radius: _
        } = _svgPropertiesAndEven, otherPathProps = _objectWithoutProperties$k(_svgPropertiesAndEven, _excluded$k);
        return /* @__PURE__ */ reactExports.createElement("path", _extends$l({}, otherPathProps, {
          radius: typeof radius === "number" ? radius : void 0,
          className: layerClass,
          d: getRectanglePath(x2, y2, width, height, radius)
        }));
      }
      var prevWidth = prevWidthRef.current;
      var prevHeight = prevHeightRef.current;
      var prevX = prevXRef.current;
      var prevY = prevYRef.current;
      var from2 = "0px ".concat(totalLength === -1 ? 1 : totalLength, "px");
      var to2 = "".concat(totalLength, "px 0px");
      var transition = getTransitionVal(["strokeDasharray"], animationDuration, typeof animationEasing === "string" ? animationEasing : defaultRectangleProps.animationEasing);
      return /* @__PURE__ */ reactExports.createElement(JavascriptAnimate, {
        animationId,
        key: animationId,
        canBegin: totalLength > 0,
        duration: animationDuration,
        easing: animationEasing,
        isActive: isUpdateAnimationActive,
        begin: animationBegin
      }, (t2) => {
        var currWidth = interpolate$1(prevWidth, width, t2);
        var currHeight = interpolate$1(prevHeight, height, t2);
        var currX = interpolate$1(prevX, x2, t2);
        var currY = interpolate$1(prevY, y2, t2);
        if (pathRef.current) {
          prevWidthRef.current = currWidth;
          prevHeightRef.current = currHeight;
          prevXRef.current = currX;
          prevYRef.current = currY;
        }
        var animationStyle;
        if (!isAnimationActive) {
          animationStyle = {
            strokeDasharray: to2
          };
        } else if (t2 > 0) {
          animationStyle = {
            transition,
            strokeDasharray: to2
          };
        } else {
          animationStyle = {
            strokeDasharray: from2
          };
        }
        var _svgPropertiesAndEven2 = svgPropertiesAndEvents(props), {
          radius: _2
        } = _svgPropertiesAndEven2, otherPathProps2 = _objectWithoutProperties$k(_svgPropertiesAndEven2, _excluded2$a);
        return /* @__PURE__ */ reactExports.createElement("path", _extends$l({}, otherPathProps2, {
          radius: typeof radius === "number" ? radius : void 0,
          className: layerClass,
          d: getRectanglePath(currX, currY, currWidth, currHeight, radius),
          ref: pathRef,
          style: _objectSpread$t(_objectSpread$t({}, animationStyle), props.style)
        }));
      });
    };
    function ownKeys$s(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$s(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$s(Object(t2), true).forEach(function(r3) {
          _defineProperty$u(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$s(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$u(e, r2, t2) {
      return (r2 = _toPropertyKey$u(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$u(t2) {
      var i = _toPrimitive$u(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$u(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    var RADIAN = Math.PI / 180;
    var radianToDegree = (angleInRadian) => angleInRadian * 180 / Math.PI;
    var polarToCartesian = (cx, cy, radius, angle) => ({
      x: cx + Math.cos(-RADIAN * angle) * radius,
      y: cy + Math.sin(-RADIAN * angle) * radius
    });
    var getMaxRadius = function getMaxRadius2(width, height) {
      var offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
      return Math.min(Math.abs(width - (offset.left || 0) - (offset.right || 0)), Math.abs(height - (offset.top || 0) - (offset.bottom || 0))) / 2;
    };
    var distanceBetweenPoints = (point2, anotherPoint) => {
      var {
        x: x1,
        y: y1
      } = point2;
      var {
        x: x2,
        y: y2
      } = anotherPoint;
      return Math.sqrt(__pow(x1 - x2, 2) + __pow(y1 - y2, 2));
    };
    var getAngleOfPoint = (_ref2, _ref22) => {
      var {
        x: x2,
        y: y2
      } = _ref2;
      var {
        cx,
        cy
      } = _ref22;
      var radius = distanceBetweenPoints({
        x: x2,
        y: y2
      }, {
        x: cx,
        y: cy
      });
      if (radius <= 0) {
        return {
          radius,
          angle: 0
        };
      }
      var cos2 = (x2 - cx) / radius;
      var angleInRadian = Math.acos(cos2);
      if (y2 > cy) {
        angleInRadian = 2 * Math.PI - angleInRadian;
      }
      return {
        radius,
        angle: radianToDegree(angleInRadian),
        angleInRadian
      };
    };
    var formatAngleOfSector = (_ref3) => {
      var {
        startAngle,
        endAngle
      } = _ref3;
      var startCnt = Math.floor(startAngle / 360);
      var endCnt = Math.floor(endAngle / 360);
      var min2 = Math.min(startCnt, endCnt);
      return {
        startAngle: startAngle - min2 * 360,
        endAngle: endAngle - min2 * 360
      };
    };
    var reverseFormatAngleOfSector = (angle, _ref4) => {
      var {
        startAngle,
        endAngle
      } = _ref4;
      var startCnt = Math.floor(startAngle / 360);
      var endCnt = Math.floor(endAngle / 360);
      var min2 = Math.min(startCnt, endCnt);
      return angle + min2 * 360;
    };
    var inRangeOfSector = (_ref5, viewBox) => {
      var {
        chartX: x2,
        chartY: y2
      } = _ref5;
      var {
        radius,
        angle
      } = getAngleOfPoint({
        x: x2,
        y: y2
      }, viewBox);
      var {
        innerRadius,
        outerRadius
      } = viewBox;
      if (radius < innerRadius || radius > outerRadius) {
        return null;
      }
      if (radius === 0) {
        return null;
      }
      var {
        startAngle,
        endAngle
      } = formatAngleOfSector(viewBox);
      var formatAngle = angle;
      var inRange;
      if (startAngle <= endAngle) {
        while (formatAngle > endAngle) {
          formatAngle -= 360;
        }
        while (formatAngle < startAngle) {
          formatAngle += 360;
        }
        inRange = formatAngle >= startAngle && formatAngle <= endAngle;
      } else {
        while (formatAngle > startAngle) {
          formatAngle -= 360;
        }
        while (formatAngle < endAngle) {
          formatAngle += 360;
        }
        inRange = formatAngle >= endAngle && formatAngle <= startAngle;
      }
      if (inRange) {
        return _objectSpread$s(_objectSpread$s({}, viewBox), {}, {
          radius,
          angle: reverseFormatAngleOfSector(formatAngle, viewBox)
        });
      }
      return null;
    };
    function getRadialCursorPoints(activeCoordinate) {
      var {
        cx,
        cy,
        radius,
        startAngle,
        endAngle
      } = activeCoordinate;
      var startPoint = polarToCartesian(cx, cy, radius, startAngle);
      var endPoint = polarToCartesian(cx, cy, radius, endAngle);
      return {
        points: [startPoint, endPoint],
        cx,
        cy,
        radius,
        startAngle,
        endAngle
      };
    }
    function _extends$k() {
      return _extends$k = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$k.apply(null, arguments);
    }
    var getDeltaAngle$1 = (startAngle, endAngle) => {
      var sign2 = mathSign(endAngle - startAngle);
      var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 359.999);
      return sign2 * deltaAngle;
    };
    var getTangentCircle = (_ref2) => {
      var {
        cx,
        cy,
        radius,
        angle,
        sign: sign2,
        isExternal,
        cornerRadius,
        cornerIsExternal
      } = _ref2;
      var centerRadius = cornerRadius * (isExternal ? 1 : -1) + radius;
      var theta = Math.asin(cornerRadius / centerRadius) / RADIAN;
      var centerAngle = cornerIsExternal ? angle : angle + sign2 * theta;
      var center = polarToCartesian(cx, cy, centerRadius, centerAngle);
      var circleTangency = polarToCartesian(cx, cy, radius, centerAngle);
      var lineTangencyAngle = cornerIsExternal ? angle - sign2 * theta : angle;
      var lineTangency = polarToCartesian(cx, cy, centerRadius * Math.cos(theta * RADIAN), lineTangencyAngle);
      return {
        center,
        circleTangency,
        lineTangency,
        theta
      };
    };
    var getSectorPath = (_ref2) => {
      var {
        cx,
        cy,
        innerRadius,
        outerRadius,
        startAngle,
        endAngle
      } = _ref2;
      var angle = getDeltaAngle$1(startAngle, endAngle);
      var tempEndAngle = startAngle + angle;
      var outerStartPoint = polarToCartesian(cx, cy, outerRadius, startAngle);
      var outerEndPoint = polarToCartesian(cx, cy, outerRadius, tempEndAngle);
      var path = "M ".concat(outerStartPoint.x, ",").concat(outerStartPoint.y, "\n    A ").concat(outerRadius, ",").concat(outerRadius, ",0,\n    ").concat(+(Math.abs(angle) > 180), ",").concat(+(startAngle > tempEndAngle), ",\n    ").concat(outerEndPoint.x, ",").concat(outerEndPoint.y, "\n  ");
      if (innerRadius > 0) {
        var innerStartPoint = polarToCartesian(cx, cy, innerRadius, startAngle);
        var innerEndPoint = polarToCartesian(cx, cy, innerRadius, tempEndAngle);
        path += "L ".concat(innerEndPoint.x, ",").concat(innerEndPoint.y, "\n            A ").concat(innerRadius, ",").concat(innerRadius, ",0,\n            ").concat(+(Math.abs(angle) > 180), ",").concat(+(startAngle <= tempEndAngle), ",\n            ").concat(innerStartPoint.x, ",").concat(innerStartPoint.y, " Z");
      } else {
        path += "L ".concat(cx, ",").concat(cy, " Z");
      }
      return path;
    };
    var getSectorWithCorner = (_ref3) => {
      var {
        cx,
        cy,
        innerRadius,
        outerRadius,
        cornerRadius,
        forceCornerRadius,
        cornerIsExternal,
        startAngle,
        endAngle
      } = _ref3;
      var sign2 = mathSign(endAngle - startAngle);
      var {
        circleTangency: soct,
        lineTangency: solt,
        theta: sot
      } = getTangentCircle({
        cx,
        cy,
        radius: outerRadius,
        angle: startAngle,
        sign: sign2,
        cornerRadius,
        cornerIsExternal
      });
      var {
        circleTangency: eoct,
        lineTangency: eolt,
        theta: eot
      } = getTangentCircle({
        cx,
        cy,
        radius: outerRadius,
        angle: endAngle,
        sign: -sign2,
        cornerRadius,
        cornerIsExternal
      });
      var outerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sot - eot;
      if (outerArcAngle < 0) {
        if (forceCornerRadius) {
          return "M ".concat(solt.x, ",").concat(solt.y, "\n        a").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,1,").concat(cornerRadius * 2, ",0\n        a").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,1,").concat(-cornerRadius * 2, ",0\n      ");
        }
        return getSectorPath({
          cx,
          cy,
          innerRadius,
          outerRadius,
          startAngle,
          endAngle
        });
      }
      var path = "M ".concat(solt.x, ",").concat(solt.y, "\n    A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(soct.x, ",").concat(soct.y, "\n    A").concat(outerRadius, ",").concat(outerRadius, ",0,").concat(+(outerArcAngle > 180), ",").concat(+(sign2 < 0), ",").concat(eoct.x, ",").concat(eoct.y, "\n    A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(eolt.x, ",").concat(eolt.y, "\n  ");
      if (innerRadius > 0) {
        var {
          circleTangency: sict,
          lineTangency: silt,
          theta: sit
        } = getTangentCircle({
          cx,
          cy,
          radius: innerRadius,
          angle: startAngle,
          sign: sign2,
          isExternal: true,
          cornerRadius,
          cornerIsExternal
        });
        var {
          circleTangency: eict,
          lineTangency: eilt,
          theta: eit
        } = getTangentCircle({
          cx,
          cy,
          radius: innerRadius,
          angle: endAngle,
          sign: -sign2,
          isExternal: true,
          cornerRadius,
          cornerIsExternal
        });
        var innerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sit - eit;
        if (innerArcAngle < 0 && cornerRadius === 0) {
          return "".concat(path, "L").concat(cx, ",").concat(cy, "Z");
        }
        path += "L".concat(eilt.x, ",").concat(eilt.y, "\n      A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(eict.x, ",").concat(eict.y, "\n      A").concat(innerRadius, ",").concat(innerRadius, ",0,").concat(+(innerArcAngle > 180), ",").concat(+(sign2 > 0), ",").concat(sict.x, ",").concat(sict.y, "\n      A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(silt.x, ",").concat(silt.y, "Z");
      } else {
        path += "L".concat(cx, ",").concat(cy, "Z");
      }
      return path;
    };
    var defaultSectorProps = {
      cx: 0,
      cy: 0,
      innerRadius: 0,
      outerRadius: 0,
      startAngle: 0,
      endAngle: 0,
      cornerRadius: 0,
      forceCornerRadius: false,
      cornerIsExternal: false
    };
    var Sector = (sectorProps) => {
      var props = resolveDefaultProps(sectorProps, defaultSectorProps);
      var {
        cx,
        cy,
        innerRadius,
        outerRadius,
        cornerRadius,
        forceCornerRadius,
        cornerIsExternal,
        startAngle,
        endAngle,
        className
      } = props;
      if (outerRadius < innerRadius || startAngle === endAngle) {
        return null;
      }
      var layerClass = clsx("recharts-sector", className);
      var deltaRadius = outerRadius - innerRadius;
      var cr = getPercentValue(cornerRadius, deltaRadius, 0, true);
      var path;
      if (cr > 0 && Math.abs(startAngle - endAngle) < 360) {
        path = getSectorWithCorner({
          cx,
          cy,
          innerRadius,
          outerRadius,
          cornerRadius: Math.min(cr, deltaRadius / 2),
          forceCornerRadius,
          cornerIsExternal,
          startAngle,
          endAngle
        });
      } else {
        path = getSectorPath({
          cx,
          cy,
          innerRadius,
          outerRadius,
          startAngle,
          endAngle
        });
      }
      return /* @__PURE__ */ reactExports.createElement("path", _extends$k({}, svgPropertiesAndEvents(props), {
        className: layerClass,
        d: path
      }));
    };
    function getCursorPoints(layout, activeCoordinate, offset) {
      if (layout === "horizontal") {
        return [{
          x: activeCoordinate.x,
          y: offset.top
        }, {
          x: activeCoordinate.x,
          y: offset.top + offset.height
        }];
      }
      if (layout === "vertical") {
        return [{
          x: offset.left,
          y: activeCoordinate.y
        }, {
          x: offset.left + offset.width,
          y: activeCoordinate.y
        }];
      }
      if (isPolarCoordinate(activeCoordinate)) {
        if (layout === "centric") {
          var {
            cx,
            cy,
            innerRadius,
            outerRadius,
            angle
          } = activeCoordinate;
          var innerPoint = polarToCartesian(cx, cy, innerRadius, angle);
          var outerPoint = polarToCartesian(cx, cy, outerRadius, angle);
          return [{
            x: innerPoint.x,
            y: innerPoint.y
          }, {
            x: outerPoint.x,
            y: outerPoint.y
          }];
        }
        return getRadialCursorPoints(activeCoordinate);
      }
      return void 0;
    }
    var range$4 = {};
    var toFinite = {};
    var toNumber = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const isSymbol$1 = isSymbol;
      function toNumber2(value) {
        if (isSymbol$1.isSymbol(value)) {
          return NaN;
        }
        return Number(value);
      }
      exports$1.toNumber = toNumber2;
    })(toNumber);
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const toNumber$1 = toNumber;
      function toFinite2(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber$1.toNumber(value);
        if (value === Infinity || value === -Infinity) {
          const sign2 = value < 0 ? -1 : 1;
          return sign2 * Number.MAX_VALUE;
        }
        return value === value ? value : 0;
      }
      exports$1.toFinite = toFinite2;
    })(toFinite);
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const isIterateeCall$1 = isIterateeCall;
      const toFinite$1 = toFinite;
      function range2(start, end, step) {
        if (step && typeof step !== "number" && isIterateeCall$1.isIterateeCall(start, end, step)) {
          end = step = void 0;
        }
        start = toFinite$1.toFinite(start);
        if (end === void 0) {
          end = start;
          start = 0;
        } else {
          end = toFinite$1.toFinite(end);
        }
        step = step === void 0 ? start < end ? 1 : -1 : toFinite$1.toFinite(step);
        const length = Math.max(Math.ceil((end - start) / (step || 1)), 0);
        const result = new Array(length);
        for (let index = 0; index < length; index++) {
          result[index] = start;
          start += step;
        }
        return result;
      }
      exports$1.range = range2;
    })(range$4);
    var range$2 = range$4.range;
    const range$3 = /* @__PURE__ */ getDefaultExportFromCjs(range$2);
    function ascending(a2, b) {
      return a2 == null || b == null ? NaN : a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
    }
    function descending(a2, b) {
      return a2 == null || b == null ? NaN : b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
    }
    function bisector(f2) {
      let compare1, compare2, delta;
      if (f2.length !== 2) {
        compare1 = ascending;
        compare2 = (d, x2) => ascending(f2(d), x2);
        delta = (d, x2) => f2(d) - x2;
      } else {
        compare1 = f2 === ascending || f2 === descending ? f2 : zero$1;
        compare2 = f2;
        delta = f2;
      }
      function left(a2, x2, lo = 0, hi2 = a2.length) {
        if (lo < hi2) {
          if (compare1(x2, x2) !== 0) return hi2;
          do {
            const mid = lo + hi2 >>> 1;
            if (compare2(a2[mid], x2) < 0) lo = mid + 1;
            else hi2 = mid;
          } while (lo < hi2);
        }
        return lo;
      }
      function right(a2, x2, lo = 0, hi2 = a2.length) {
        if (lo < hi2) {
          if (compare1(x2, x2) !== 0) return hi2;
          do {
            const mid = lo + hi2 >>> 1;
            if (compare2(a2[mid], x2) <= 0) lo = mid + 1;
            else hi2 = mid;
          } while (lo < hi2);
        }
        return lo;
      }
      function center(a2, x2, lo = 0, hi2 = a2.length) {
        const i = left(a2, x2, lo, hi2 - 1);
        return i > lo && delta(a2[i - 1], x2) > -delta(a2[i], x2) ? i - 1 : i;
      }
      return { left, center, right };
    }
    function zero$1() {
      return 0;
    }
    function number$2(x2) {
      return x2 === null ? NaN : +x2;
    }
    function* numbers(values, valueof) {
      {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            yield value;
          }
        }
      }
    }
    const ascendingBisect = bisector(ascending);
    const bisectRight = ascendingBisect.right;
    bisector(number$2).center;
    class InternMap extends Map {
      constructor(entries, key = keyof) {
        super();
        Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
        if (entries != null) for (const [key2, value] of entries) this.set(key2, value);
      }
      get(key) {
        return super.get(intern_get(this, key));
      }
      has(key) {
        return super.has(intern_get(this, key));
      }
      set(key, value) {
        return super.set(intern_set(this, key), value);
      }
      delete(key) {
        return super.delete(intern_delete(this, key));
      }
    }
    function intern_get({ _intern, _key }, value) {
      const key = _key(value);
      return _intern.has(key) ? _intern.get(key) : value;
    }
    function intern_set({ _intern, _key }, value) {
      const key = _key(value);
      if (_intern.has(key)) return _intern.get(key);
      _intern.set(key, value);
      return value;
    }
    function intern_delete({ _intern, _key }, value) {
      const key = _key(value);
      if (_intern.has(key)) {
        value = _intern.get(key);
        _intern.delete(key);
      }
      return value;
    }
    function keyof(value) {
      return value !== null && typeof value === "object" ? value.valueOf() : value;
    }
    function compareDefined(compare = ascending) {
      if (compare === ascending) return ascendingDefined;
      if (typeof compare !== "function") throw new TypeError("compare is not a function");
      return (a2, b) => {
        const x2 = compare(a2, b);
        if (x2 || x2 === 0) return x2;
        return (compare(b, b) === 0) - (compare(a2, a2) === 0);
      };
    }
    function ascendingDefined(a2, b) {
      return (a2 == null || !(a2 >= a2)) - (b == null || !(b >= b)) || (a2 < b ? -1 : a2 > b ? 1 : 0);
    }
    const e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
    function tickSpec(start, stop, count) {
      const step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
      let i1, i2, inc;
      if (power < 0) {
        inc = Math.pow(10, -power) / factor;
        i1 = Math.round(start * inc);
        i2 = Math.round(stop * inc);
        if (i1 / inc < start) ++i1;
        if (i2 / inc > stop) --i2;
        inc = -inc;
      } else {
        inc = Math.pow(10, power) * factor;
        i1 = Math.round(start / inc);
        i2 = Math.round(stop / inc);
        if (i1 * inc < start) ++i1;
        if (i2 * inc > stop) --i2;
      }
      if (i2 < i1 && 0.5 <= count && count < 2) return tickSpec(start, stop, count * 2);
      return [i1, i2, inc];
    }
    function ticks(start, stop, count) {
      stop = +stop, start = +start, count = +count;
      if (!(count > 0)) return [];
      if (start === stop) return [start];
      const reverse2 = stop < start, [i1, i2, inc] = reverse2 ? tickSpec(stop, start, count) : tickSpec(start, stop, count);
      if (!(i2 >= i1)) return [];
      const n2 = i2 - i1 + 1, ticks2 = new Array(n2);
      if (reverse2) {
        if (inc < 0) for (let i = 0; i < n2; ++i) ticks2[i] = (i2 - i) / -inc;
        else for (let i = 0; i < n2; ++i) ticks2[i] = (i2 - i) * inc;
      } else {
        if (inc < 0) for (let i = 0; i < n2; ++i) ticks2[i] = (i1 + i) / -inc;
        else for (let i = 0; i < n2; ++i) ticks2[i] = (i1 + i) * inc;
      }
      return ticks2;
    }
    function tickIncrement(start, stop, count) {
      stop = +stop, start = +start, count = +count;
      return tickSpec(start, stop, count)[2];
    }
    function tickStep(start, stop, count) {
      stop = +stop, start = +start, count = +count;
      const reverse2 = stop < start, inc = reverse2 ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);
      return (reverse2 ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
    }
    function max(values, valueof) {
      let max2;
      {
        for (const value of values) {
          if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
            max2 = value;
          }
        }
      }
      return max2;
    }
    function min(values, valueof) {
      let min2;
      {
        for (const value of values) {
          if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
            min2 = value;
          }
        }
      }
      return min2;
    }
    function quickselect(array2, k2, left = 0, right = Infinity, compare) {
      k2 = Math.floor(k2);
      left = Math.floor(Math.max(0, left));
      right = Math.floor(Math.min(array2.length - 1, right));
      if (!(left <= k2 && k2 <= right)) return array2;
      compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
      while (right > left) {
        if (right - left > 600) {
          const n2 = right - left + 1;
          const m2 = k2 - left + 1;
          const z2 = Math.log(n2);
          const s2 = 0.5 * Math.exp(2 * z2 / 3);
          const sd2 = 0.5 * Math.sqrt(z2 * s2 * (n2 - s2) / n2) * (m2 - n2 / 2 < 0 ? -1 : 1);
          const newLeft = Math.max(left, Math.floor(k2 - m2 * s2 / n2 + sd2));
          const newRight = Math.min(right, Math.floor(k2 + (n2 - m2) * s2 / n2 + sd2));
          quickselect(array2, k2, newLeft, newRight, compare);
        }
        const t2 = array2[k2];
        let i = left;
        let j = right;
        swap(array2, left, k2);
        if (compare(array2[right], t2) > 0) swap(array2, left, right);
        while (i < j) {
          swap(array2, i, j), ++i, --j;
          while (compare(array2[i], t2) < 0) ++i;
          while (compare(array2[j], t2) > 0) --j;
        }
        if (compare(array2[left], t2) === 0) swap(array2, left, j);
        else ++j, swap(array2, j, right);
        if (j <= k2) left = j + 1;
        if (k2 <= j) right = j - 1;
      }
      return array2;
    }
    function swap(array2, i, j) {
      const t2 = array2[i];
      array2[i] = array2[j];
      array2[j] = t2;
    }
    function quantile$1(values, p2, valueof) {
      values = Float64Array.from(numbers(values));
      if (!(n2 = values.length) || isNaN(p2 = +p2)) return;
      if (p2 <= 0 || n2 < 2) return min(values);
      if (p2 >= 1) return max(values);
      var n2, i = (n2 - 1) * p2, i0 = Math.floor(i), value0 = max(quickselect(values, i0).subarray(0, i0 + 1)), value1 = min(values.subarray(i0 + 1));
      return value0 + (value1 - value0) * (i - i0);
    }
    function quantileSorted(values, p2, valueof = number$2) {
      if (!(n2 = values.length) || isNaN(p2 = +p2)) return;
      if (p2 <= 0 || n2 < 2) return +valueof(values[0], 0, values);
      if (p2 >= 1) return +valueof(values[n2 - 1], n2 - 1, values);
      var n2, i = (n2 - 1) * p2, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);
      return value0 + (value1 - value0) * (i - i0);
    }
    function range$1(start, stop, step) {
      start = +start, stop = +stop, step = (n2 = arguments.length) < 2 ? (stop = start, start = 0, 1) : n2 < 3 ? 1 : +step;
      var i = -1, n2 = Math.max(0, Math.ceil((stop - start) / step)) | 0, range2 = new Array(n2);
      while (++i < n2) {
        range2[i] = start + i * step;
      }
      return range2;
    }
    function initRange(domain, range2) {
      switch (arguments.length) {
        case 0:
          break;
        case 1:
          this.range(domain);
          break;
        default:
          this.range(range2).domain(domain);
          break;
      }
      return this;
    }
    function initInterpolator(domain, interpolator) {
      switch (arguments.length) {
        case 0:
          break;
        case 1: {
          if (typeof domain === "function") this.interpolator(domain);
          else this.range(domain);
          break;
        }
        default: {
          this.domain(domain);
          if (typeof interpolator === "function") this.interpolator(interpolator);
          else this.range(interpolator);
          break;
        }
      }
      return this;
    }
    const implicit = Symbol("implicit");
    function ordinal() {
      var index = new InternMap(), domain = [], range2 = [], unknown = implicit;
      function scale(d) {
        let i = index.get(d);
        if (i === void 0) {
          if (unknown !== implicit) return unknown;
          index.set(d, i = domain.push(d) - 1);
        }
        return range2[i % range2.length];
      }
      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [], index = new InternMap();
        for (const value of _) {
          if (index.has(value)) continue;
          index.set(value, domain.push(value) - 1);
        }
        return scale;
      };
      scale.range = function(_) {
        return arguments.length ? (range2 = Array.from(_), scale) : range2.slice();
      };
      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };
      scale.copy = function() {
        return ordinal(domain, range2).unknown(unknown);
      };
      initRange.apply(scale, arguments);
      return scale;
    }
    function band() {
      var scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange = scale.range, r0 = 0, r1 = 1, step, bandwidth, round2 = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
      delete scale.unknown;
      function rescale() {
        var n2 = domain().length, reverse2 = r1 < r0, start = reverse2 ? r1 : r0, stop = reverse2 ? r0 : r1;
        step = (stop - start) / Math.max(1, n2 - paddingInner + paddingOuter * 2);
        if (round2) step = Math.floor(step);
        start += (stop - start - step * (n2 - paddingInner)) * align;
        bandwidth = step * (1 - paddingInner);
        if (round2) start = Math.round(start), bandwidth = Math.round(bandwidth);
        var values = range$1(n2).map(function(i) {
          return start + step * i;
        });
        return ordinalRange(reverse2 ? values.reverse() : values);
      }
      scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
      };
      scale.range = function(_) {
        return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
      };
      scale.rangeRound = function(_) {
        return [r0, r1] = _, r0 = +r0, r1 = +r1, round2 = true, rescale();
      };
      scale.bandwidth = function() {
        return bandwidth;
      };
      scale.step = function() {
        return step;
      };
      scale.round = function(_) {
        return arguments.length ? (round2 = !!_, rescale()) : round2;
      };
      scale.padding = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
      };
      scale.paddingInner = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
      };
      scale.paddingOuter = function(_) {
        return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
      };
      scale.align = function(_) {
        return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
      };
      scale.copy = function() {
        return band(domain(), [r0, r1]).round(round2).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
      };
      return initRange.apply(rescale(), arguments);
    }
    function pointish(scale) {
      var copy2 = scale.copy;
      scale.padding = scale.paddingOuter;
      delete scale.paddingInner;
      delete scale.paddingOuter;
      scale.copy = function() {
        return pointish(copy2());
      };
      return scale;
    }
    function point() {
      return pointish(band.apply(null, arguments).paddingInner(1));
    }
    function define(constructor, factory, prototype) {
      constructor.prototype = factory.prototype = prototype;
      prototype.constructor = constructor;
    }
    function extend(parent, definition) {
      var prototype = Object.create(parent.prototype);
      for (var key in definition) prototype[key] = definition[key];
      return prototype;
    }
    function Color() {
    }
    var darker = 0.7;
    var brighter = 1 / darker;
    var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
    var named = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    };
    define(Color, color, {
      copy(channels) {
        return Object.assign(new this.constructor(), this, channels);
      },
      displayable() {
        return this.rgb().displayable();
      },
      hex: color_formatHex,
      // Deprecated! Use color.formatHex.
      formatHex: color_formatHex,
      formatHex8: color_formatHex8,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });
    function color_formatHex() {
      return this.rgb().formatHex();
    }
    function color_formatHex8() {
      return this.rgb().formatHex8();
    }
    function color_formatHsl() {
      return hslConvert(this).formatHsl();
    }
    function color_formatRgb() {
      return this.rgb().formatRgb();
    }
    function color(format2) {
      var m2, l2;
      format2 = (format2 + "").trim().toLowerCase();
      return (m2 = reHex.exec(format2)) ? (l2 = m2[1].length, m2 = parseInt(m2[1], 16), l2 === 6 ? rgbn(m2) : l2 === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l2 === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l2 === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format2)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format2)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format2)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format2)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
    }
    function rgbn(n2) {
      return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
    }
    function rgba(r2, g, b, a2) {
      if (a2 <= 0) r2 = g = b = NaN;
      return new Rgb(r2, g, b, a2);
    }
    function rgbConvert(o) {
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Rgb();
      o = o.rgb();
      return new Rgb(o.r, o.g, o.b, o.opacity);
    }
    function rgb$1(r2, g, b, opacity) {
      return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g, b, opacity == null ? 1 : opacity);
    }
    function Rgb(r2, g, b, opacity) {
      this.r = +r2;
      this.g = +g;
      this.b = +b;
      this.opacity = +opacity;
    }
    define(Rgb, rgb$1, extend(Color, {
      brighter(k2) {
        k2 = k2 == null ? brighter : Math.pow(brighter, k2);
        return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
      },
      darker(k2) {
        k2 = k2 == null ? darker : Math.pow(darker, k2);
        return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
      },
      rgb() {
        return this;
      },
      clamp() {
        return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
      },
      displayable() {
        return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: rgb_formatHex,
      // Deprecated! Use color.formatHex.
      formatHex: rgb_formatHex,
      formatHex8: rgb_formatHex8,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));
    function rgb_formatHex() {
      return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
    }
    function rgb_formatHex8() {
      return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
    }
    function rgb_formatRgb() {
      const a2 = clampa(this.opacity);
      return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
    }
    function clampa(opacity) {
      return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
    }
    function clampi(value) {
      return Math.max(0, Math.min(255, Math.round(value) || 0));
    }
    function hex(value) {
      value = clampi(value);
      return (value < 16 ? "0" : "") + value.toString(16);
    }
    function hsla(h, s2, l2, a2) {
      if (a2 <= 0) h = s2 = l2 = NaN;
      else if (l2 <= 0 || l2 >= 1) h = s2 = NaN;
      else if (s2 <= 0) h = NaN;
      return new Hsl(h, s2, l2, a2);
    }
    function hslConvert(o) {
      if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Hsl();
      if (o instanceof Hsl) return o;
      o = o.rgb();
      var r2 = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r2, g, b), max2 = Math.max(r2, g, b), h = NaN, s2 = max2 - min2, l2 = (max2 + min2) / 2;
      if (s2) {
        if (r2 === max2) h = (g - b) / s2 + (g < b) * 6;
        else if (g === max2) h = (b - r2) / s2 + 2;
        else h = (r2 - g) / s2 + 4;
        s2 /= l2 < 0.5 ? max2 + min2 : 2 - max2 - min2;
        h *= 60;
      } else {
        s2 = l2 > 0 && l2 < 1 ? 0 : h;
      }
      return new Hsl(h, s2, l2, o.opacity);
    }
    function hsl(h, s2, l2, opacity) {
      return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l2, opacity == null ? 1 : opacity);
    }
    function Hsl(h, s2, l2, opacity) {
      this.h = +h;
      this.s = +s2;
      this.l = +l2;
      this.opacity = +opacity;
    }
    define(Hsl, hsl, extend(Color, {
      brighter(k2) {
        k2 = k2 == null ? brighter : Math.pow(brighter, k2);
        return new Hsl(this.h, this.s, this.l * k2, this.opacity);
      },
      darker(k2) {
        k2 = k2 == null ? darker : Math.pow(darker, k2);
        return new Hsl(this.h, this.s, this.l * k2, this.opacity);
      },
      rgb() {
        var h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m2 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s2, m1 = 2 * l2 - m2;
        return new Rgb(
          hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
          hsl2rgb(h, m1, m2),
          hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
          this.opacity
        );
      },
      clamp() {
        return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
      },
      displayable() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
      },
      formatHsl() {
        const a2 = clampa(this.opacity);
        return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
      }
    }));
    function clamph(value) {
      value = (value || 0) % 360;
      return value < 0 ? value + 360 : value;
    }
    function clampt(value) {
      return Math.max(0, Math.min(1, value || 0));
    }
    function hsl2rgb(h, m1, m2) {
      return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
    }
    const constant = (x2) => () => x2;
    function linear$1(a2, d) {
      return function(t2) {
        return a2 + t2 * d;
      };
    }
    function exponential(a2, b, y2) {
      return a2 = Math.pow(a2, y2), b = Math.pow(b, y2) - a2, y2 = 1 / y2, function(t2) {
        return Math.pow(a2 + t2 * b, y2);
      };
    }
    function gamma(y2) {
      return (y2 = +y2) === 1 ? nogamma : function(a2, b) {
        return b - a2 ? exponential(a2, b, y2) : constant(isNaN(a2) ? b : a2);
      };
    }
    function nogamma(a2, b) {
      var d = b - a2;
      return d ? linear$1(a2, d) : constant(isNaN(a2) ? b : a2);
    }
    const rgb = function rgbGamma(y2) {
      var color2 = gamma(y2);
      function rgb2(start, end) {
        var r2 = color2((start = rgb$1(start)).r, (end = rgb$1(end)).r), g = color2(start.g, end.g), b = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
        return function(t2) {
          start.r = r2(t2);
          start.g = g(t2);
          start.b = b(t2);
          start.opacity = opacity(t2);
          return start + "";
        };
      }
      rgb2.gamma = rgbGamma;
      return rgb2;
    }(1);
    function numberArray(a2, b) {
      if (!b) b = [];
      var n2 = a2 ? Math.min(b.length, a2.length) : 0, c2 = b.slice(), i;
      return function(t2) {
        for (i = 0; i < n2; ++i) c2[i] = a2[i] * (1 - t2) + b[i] * t2;
        return c2;
      };
    }
    function isNumberArray(x2) {
      return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
    }
    function genericArray(a2, b) {
      var nb2 = b ? b.length : 0, na = a2 ? Math.min(nb2, a2.length) : 0, x2 = new Array(na), c2 = new Array(nb2), i;
      for (i = 0; i < na; ++i) x2[i] = interpolate(a2[i], b[i]);
      for (; i < nb2; ++i) c2[i] = b[i];
      return function(t2) {
        for (i = 0; i < na; ++i) c2[i] = x2[i](t2);
        return c2;
      };
    }
    function date$1(a2, b) {
      var d = /* @__PURE__ */ new Date();
      return a2 = +a2, b = +b, function(t2) {
        return d.setTime(a2 * (1 - t2) + b * t2), d;
      };
    }
    function interpolateNumber(a2, b) {
      return a2 = +a2, b = +b, function(t2) {
        return a2 * (1 - t2) + b * t2;
      };
    }
    function object(a2, b) {
      var i = {}, c2 = {}, k2;
      if (a2 === null || typeof a2 !== "object") a2 = {};
      if (b === null || typeof b !== "object") b = {};
      for (k2 in b) {
        if (k2 in a2) {
          i[k2] = interpolate(a2[k2], b[k2]);
        } else {
          c2[k2] = b[k2];
        }
      }
      return function(t2) {
        for (k2 in i) c2[k2] = i[k2](t2);
        return c2;
      };
    }
    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
    function zero(b) {
      return function() {
        return b;
      };
    }
    function one(b) {
      return function(t2) {
        return b(t2) + "";
      };
    }
    function string(a2, b) {
      var bi2 = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s2 = [], q2 = [];
      a2 = a2 + "", b = b + "";
      while ((am = reA.exec(a2)) && (bm = reB.exec(b))) {
        if ((bs = bm.index) > bi2) {
          bs = b.slice(bi2, bs);
          if (s2[i]) s2[i] += bs;
          else s2[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) {
          if (s2[i]) s2[i] += bm;
          else s2[++i] = bm;
        } else {
          s2[++i] = null;
          q2.push({ i, x: interpolateNumber(am, bm) });
        }
        bi2 = reB.lastIndex;
      }
      if (bi2 < b.length) {
        bs = b.slice(bi2);
        if (s2[i]) s2[i] += bs;
        else s2[++i] = bs;
      }
      return s2.length < 2 ? q2[0] ? one(q2[0].x) : zero(b) : (b = q2.length, function(t2) {
        for (var i2 = 0, o; i2 < b; ++i2) s2[(o = q2[i2]).i] = o.x(t2);
        return s2.join("");
      });
    }
    function interpolate(a2, b) {
      var t2 = typeof b, c2;
      return b == null || t2 === "boolean" ? constant(b) : (t2 === "number" ? interpolateNumber : t2 === "string" ? (c2 = color(b)) ? (b = c2, rgb) : string : b instanceof color ? rgb : b instanceof Date ? date$1 : isNumberArray(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object : interpolateNumber)(a2, b);
    }
    function interpolateRound(a2, b) {
      return a2 = +a2, b = +b, function(t2) {
        return Math.round(a2 * (1 - t2) + b * t2);
      };
    }
    function piecewise(interpolate$12, values) {
      if (values === void 0) values = interpolate$12, interpolate$12 = interpolate;
      var i = 0, n2 = values.length - 1, v2 = values[0], I2 = new Array(n2 < 0 ? 0 : n2);
      while (i < n2) I2[i] = interpolate$12(v2, v2 = values[++i]);
      return function(t2) {
        var i2 = Math.max(0, Math.min(n2 - 1, Math.floor(t2 *= n2)));
        return I2[i2](t2 - i2);
      };
    }
    function constants(x2) {
      return function() {
        return x2;
      };
    }
    function number$1(x2) {
      return +x2;
    }
    var unit = [0, 1];
    function identity$3(x2) {
      return x2;
    }
    function normalize(a2, b) {
      return (b -= a2 = +a2) ? function(x2) {
        return (x2 - a2) / b;
      } : constants(isNaN(b) ? NaN : 0.5);
    }
    function clamper(a2, b) {
      var t2;
      if (a2 > b) t2 = a2, a2 = b, b = t2;
      return function(x2) {
        return Math.max(a2, Math.min(b, x2));
      };
    }
    function bimap(domain, range2, interpolate2) {
      var d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
      if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate2(r1, r0);
      else d0 = normalize(d0, d1), r0 = interpolate2(r0, r1);
      return function(x2) {
        return r0(d0(x2));
      };
    }
    function polymap(domain, range2, interpolate2) {
      var j = Math.min(domain.length, range2.length) - 1, d = new Array(j), r2 = new Array(j), i = -1;
      if (domain[j] < domain[0]) {
        domain = domain.slice().reverse();
        range2 = range2.slice().reverse();
      }
      while (++i < j) {
        d[i] = normalize(domain[i], domain[i + 1]);
        r2[i] = interpolate2(range2[i], range2[i + 1]);
      }
      return function(x2) {
        var i2 = bisectRight(domain, x2, 1, j) - 1;
        return r2[i2](d[i2](x2));
      };
    }
    function copy$1(source, target) {
      return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
    }
    function transformer$2() {
      var domain = unit, range2 = unit, interpolate$12 = interpolate, transform, untransform, unknown, clamp = identity$3, piecewise2, output, input;
      function rescale() {
        var n2 = Math.min(domain.length, range2.length);
        if (clamp !== identity$3) clamp = clamper(domain[0], domain[n2 - 1]);
        piecewise2 = n2 > 2 ? polymap : bimap;
        output = input = null;
        return scale;
      }
      function scale(x2) {
        return x2 == null || isNaN(x2 = +x2) ? unknown : (output || (output = piecewise2(domain.map(transform), range2, interpolate$12)))(transform(clamp(x2)));
      }
      scale.invert = function(y2) {
        return clamp(untransform((input || (input = piecewise2(range2, domain.map(transform), interpolateNumber)))(y2)));
      };
      scale.domain = function(_) {
        return arguments.length ? (domain = Array.from(_, number$1), rescale()) : domain.slice();
      };
      scale.range = function(_) {
        return arguments.length ? (range2 = Array.from(_), rescale()) : range2.slice();
      };
      scale.rangeRound = function(_) {
        return range2 = Array.from(_), interpolate$12 = interpolateRound, rescale();
      };
      scale.clamp = function(_) {
        return arguments.length ? (clamp = _ ? true : identity$3, rescale()) : clamp !== identity$3;
      };
      scale.interpolate = function(_) {
        return arguments.length ? (interpolate$12 = _, rescale()) : interpolate$12;
      };
      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };
      return function(t2, u2) {
        transform = t2, untransform = u2;
        return rescale();
      };
    }
    function continuous() {
      return transformer$2()(identity$3, identity$3);
    }
    function formatDecimal(x2) {
      return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
    }
    function formatDecimalParts(x2, p2) {
      if ((i = (x2 = p2 ? x2.toExponential(p2 - 1) : x2.toExponential()).indexOf("e")) < 0) return null;
      var i, coefficient = x2.slice(0, i);
      return [
        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
        +x2.slice(i + 1)
      ];
    }
    function exponent(x2) {
      return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
    }
    function formatGroup(grouping, thousands) {
      return function(value, width) {
        var i = value.length, t2 = [], j = 0, g = grouping[0], length = 0;
        while (i > 0 && g > 0) {
          if (length + g + 1 > width) g = Math.max(1, width - length);
          t2.push(value.substring(i -= g, i + g));
          if ((length += g + 1) > width) break;
          g = grouping[j = (j + 1) % grouping.length];
        }
        return t2.reverse().join(thousands);
      };
    }
    function formatNumerals(numerals) {
      return function(value) {
        return value.replace(/[0-9]/g, function(i) {
          return numerals[+i];
        });
      };
    }
    var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
    function formatSpecifier(specifier) {
      if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
      var match;
      return new FormatSpecifier({
        fill: match[1],
        align: match[2],
        sign: match[3],
        symbol: match[4],
        zero: match[5],
        width: match[6],
        comma: match[7],
        precision: match[8] && match[8].slice(1),
        trim: match[9],
        type: match[10]
      });
    }
    formatSpecifier.prototype = FormatSpecifier.prototype;
    function FormatSpecifier(specifier) {
      this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
      this.align = specifier.align === void 0 ? ">" : specifier.align + "";
      this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
      this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
      this.zero = !!specifier.zero;
      this.width = specifier.width === void 0 ? void 0 : +specifier.width;
      this.comma = !!specifier.comma;
      this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
      this.trim = !!specifier.trim;
      this.type = specifier.type === void 0 ? "" : specifier.type + "";
    }
    FormatSpecifier.prototype.toString = function() {
      return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
    };
    function formatTrim(s2) {
      out: for (var n2 = s2.length, i = 1, i0 = -1, i1; i < n2; ++i) {
        switch (s2[i]) {
          case ".":
            i0 = i1 = i;
            break;
          case "0":
            if (i0 === 0) i0 = i;
            i1 = i;
            break;
          default:
            if (!+s2[i]) break out;
            if (i0 > 0) i0 = 0;
            break;
        }
      }
      return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
    }
    var prefixExponent;
    function formatPrefixAuto(x2, p2) {
      var d = formatDecimalParts(x2, p2);
      if (!d) return x2 + "";
      var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n2 = coefficient.length;
      return i === n2 ? coefficient : i > n2 ? coefficient + new Array(i - n2 + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x2, Math.max(0, p2 + i - 1))[0];
    }
    function formatRounded(x2, p2) {
      var d = formatDecimalParts(x2, p2);
      if (!d) return x2 + "";
      var coefficient = d[0], exponent2 = d[1];
      return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
    }
    const formatTypes = {
      "%": (x2, p2) => (x2 * 100).toFixed(p2),
      "b": (x2) => Math.round(x2).toString(2),
      "c": (x2) => x2 + "",
      "d": formatDecimal,
      "e": (x2, p2) => x2.toExponential(p2),
      "f": (x2, p2) => x2.toFixed(p2),
      "g": (x2, p2) => x2.toPrecision(p2),
      "o": (x2) => Math.round(x2).toString(8),
      "p": (x2, p2) => formatRounded(x2 * 100, p2),
      "r": formatRounded,
      "s": formatPrefixAuto,
      "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
      "x": (x2) => Math.round(x2).toString(16)
    };
    function identity$2(x2) {
      return x2;
    }
    var map$1 = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
    function formatLocale$1(locale2) {
      var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity$2 : formatGroup(map$1.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity$2 : formatNumerals(map$1.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
      function newFormat(specifier) {
        specifier = formatSpecifier(specifier);
        var fill = specifier.fill, align = specifier.align, sign2 = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
        if (type === "n") comma = true, type = "g";
        else if (!formatTypes[type]) precision === void 0 && (precision = 12), trim = true, type = "g";
        if (zero2 || fill === "0" && align === "=") zero2 = true, fill = "0", align = "=";
        var prefix2 = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix2 = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
        var formatType = formatTypes[type], maybeSuffix = /[defgprs%]/.test(type);
        precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
        function format2(value) {
          var valuePrefix = prefix2, valueSuffix = suffix2, i, n2, c2;
          if (type === "c") {
            valueSuffix = formatType(value) + valueSuffix;
            value = "";
          } else {
            value = +value;
            var valueNegative = value < 0 || 1 / value < 0;
            value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
            if (trim) value = formatTrim(value);
            if (valueNegative && +value === 0 && sign2 !== "+") valueNegative = false;
            valuePrefix = (valueNegative ? sign2 === "(" ? sign2 : minus : sign2 === "-" || sign2 === "(" ? "" : sign2) + valuePrefix;
            valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign2 === "(" ? ")" : "");
            if (maybeSuffix) {
              i = -1, n2 = value.length;
              while (++i < n2) {
                if (c2 = value.charCodeAt(i), 48 > c2 || c2 > 57) {
                  valueSuffix = (c2 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                  value = value.slice(0, i);
                  break;
                }
              }
            }
          }
          if (comma && !zero2) value = group(value, Infinity);
          var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
          if (comma && zero2) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
          switch (align) {
            case "<":
              value = valuePrefix + value + valueSuffix + padding;
              break;
            case "=":
              value = valuePrefix + padding + value + valueSuffix;
              break;
            case "^":
              value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
              break;
            default:
              value = padding + valuePrefix + value + valueSuffix;
              break;
          }
          return numerals(value);
        }
        format2.toString = function() {
          return specifier + "";
        };
        return format2;
      }
      function formatPrefix2(specifier, value) {
        var f2 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3, k2 = Math.pow(10, -e), prefix2 = prefixes[8 + e / 3];
        return function(value2) {
          return f2(k2 * value2) + prefix2;
        };
      }
      return {
        format: newFormat,
        formatPrefix: formatPrefix2
      };
    }
    var locale$1;
    var format;
    var formatPrefix;
    defaultLocale$1({
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });
    function defaultLocale$1(definition) {
      locale$1 = formatLocale$1(definition);
      format = locale$1.format;
      formatPrefix = locale$1.formatPrefix;
      return locale$1;
    }
    function precisionFixed(step) {
      return Math.max(0, -exponent(Math.abs(step)));
    }
    function precisionPrefix(step, value) {
      return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
    }
    function precisionRound(step, max2) {
      step = Math.abs(step), max2 = Math.abs(max2) - step;
      return Math.max(0, exponent(max2) - exponent(step)) + 1;
    }
    function tickFormat(start, stop, count, specifier) {
      var step = tickStep(start, stop, count), precision;
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      switch (specifier.type) {
        case "s": {
          var value = Math.max(Math.abs(start), Math.abs(stop));
          if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
          return formatPrefix(specifier, value);
        }
        case "":
        case "e":
        case "g":
        case "p":
        case "r": {
          if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
          break;
        }
        case "f":
        case "%": {
          if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
          break;
        }
      }
      return format(specifier);
    }
    function linearish(scale) {
      var domain = scale.domain;
      scale.ticks = function(count) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
      };
      scale.tickFormat = function(count, specifier) {
        var d = domain();
        return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
      };
      scale.nice = function(count) {
        if (count == null) count = 10;
        var d = domain();
        var i0 = 0;
        var i1 = d.length - 1;
        var start = d[i0];
        var stop = d[i1];
        var prestep;
        var step;
        var maxIter = 10;
        if (stop < start) {
          step = start, start = stop, stop = step;
          step = i0, i0 = i1, i1 = step;
        }
        while (maxIter-- > 0) {
          step = tickIncrement(start, stop, count);
          if (step === prestep) {
            d[i0] = start;
            d[i1] = stop;
            return domain(d);
          } else if (step > 0) {
            start = Math.floor(start / step) * step;
            stop = Math.ceil(stop / step) * step;
          } else if (step < 0) {
            start = Math.ceil(start * step) / step;
            stop = Math.floor(stop * step) / step;
          } else {
            break;
          }
          prestep = step;
        }
        return scale;
      };
      return scale;
    }
    function linear() {
      var scale = continuous();
      scale.copy = function() {
        return copy$1(scale, linear());
      };
      initRange.apply(scale, arguments);
      return linearish(scale);
    }
    function identity$1(domain) {
      var unknown;
      function scale(x2) {
        return x2 == null || isNaN(x2 = +x2) ? unknown : x2;
      }
      scale.invert = scale;
      scale.domain = scale.range = function(_) {
        return arguments.length ? (domain = Array.from(_, number$1), scale) : domain.slice();
      };
      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };
      scale.copy = function() {
        return identity$1(domain).unknown(unknown);
      };
      domain = arguments.length ? Array.from(domain, number$1) : [0, 1];
      return linearish(scale);
    }
    function nice(domain, interval) {
      domain = domain.slice();
      var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t2;
      if (x1 < x0) {
        t2 = i0, i0 = i1, i1 = t2;
        t2 = x0, x0 = x1, x1 = t2;
      }
      domain[i0] = interval.floor(x0);
      domain[i1] = interval.ceil(x1);
      return domain;
    }
    function transformLog(x2) {
      return Math.log(x2);
    }
    function transformExp(x2) {
      return Math.exp(x2);
    }
    function transformLogn(x2) {
      return -Math.log(-x2);
    }
    function transformExpn(x2) {
      return -Math.exp(-x2);
    }
    function pow10(x2) {
      return isFinite(x2) ? +("1e" + x2) : x2 < 0 ? 0 : x2;
    }
    function powp(base) {
      return base === 10 ? pow10 : base === Math.E ? Math.exp : (x2) => Math.pow(base, x2);
    }
    function logp(base) {
      return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x2) => Math.log(x2) / base);
    }
    function reflect(f2) {
      return (x2, k2) => -f2(-x2, k2);
    }
    function loggish(transform) {
      const scale = transform(transformLog, transformExp);
      const domain = scale.domain;
      let base = 10;
      let logs;
      let pows;
      function rescale() {
        logs = logp(base), pows = powp(base);
        if (domain()[0] < 0) {
          logs = reflect(logs), pows = reflect(pows);
          transform(transformLogn, transformExpn);
        } else {
          transform(transformLog, transformExp);
        }
        return scale;
      }
      scale.base = function(_) {
        return arguments.length ? (base = +_, rescale()) : base;
      };
      scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
      };
      scale.ticks = (count) => {
        const d = domain();
        let u2 = d[0];
        let v2 = d[d.length - 1];
        const r2 = v2 < u2;
        if (r2) [u2, v2] = [v2, u2];
        let i = logs(u2);
        let j = logs(v2);
        let k2;
        let t2;
        const n2 = count == null ? 10 : +count;
        let z2 = [];
        if (!(base % 1) && j - i < n2) {
          i = Math.floor(i), j = Math.ceil(j);
          if (u2 > 0) for (; i <= j; ++i) {
            for (k2 = 1; k2 < base; ++k2) {
              t2 = i < 0 ? k2 / pows(-i) : k2 * pows(i);
              if (t2 < u2) continue;
              if (t2 > v2) break;
              z2.push(t2);
            }
          }
          else for (; i <= j; ++i) {
            for (k2 = base - 1; k2 >= 1; --k2) {
              t2 = i > 0 ? k2 / pows(-i) : k2 * pows(i);
              if (t2 < u2) continue;
              if (t2 > v2) break;
              z2.push(t2);
            }
          }
          if (z2.length * 2 < n2) z2 = ticks(u2, v2, n2);
        } else {
          z2 = ticks(i, j, Math.min(j - i, n2)).map(pows);
        }
        return r2 ? z2.reverse() : z2;
      };
      scale.tickFormat = (count, specifier) => {
        if (count == null) count = 10;
        if (specifier == null) specifier = base === 10 ? "s" : ",";
        if (typeof specifier !== "function") {
          if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
          specifier = format(specifier);
        }
        if (count === Infinity) return specifier;
        const k2 = Math.max(1, base * count / scale.ticks().length);
        return (d) => {
          let i = d / pows(Math.round(logs(d)));
          if (i * base < base - 0.5) i *= base;
          return i <= k2 ? specifier(d) : "";
        };
      };
      scale.nice = () => {
        return domain(nice(domain(), {
          floor: (x2) => pows(Math.floor(logs(x2))),
          ceil: (x2) => pows(Math.ceil(logs(x2)))
        }));
      };
      return scale;
    }
    function log() {
      const scale = loggish(transformer$2()).domain([1, 10]);
      scale.copy = () => copy$1(scale, log()).base(scale.base());
      initRange.apply(scale, arguments);
      return scale;
    }
    function transformSymlog(c2) {
      return function(x2) {
        return Math.sign(x2) * Math.log1p(Math.abs(x2 / c2));
      };
    }
    function transformSymexp(c2) {
      return function(x2) {
        return Math.sign(x2) * Math.expm1(Math.abs(x2)) * c2;
      };
    }
    function symlogish(transform) {
      var c2 = 1, scale = transform(transformSymlog(c2), transformSymexp(c2));
      scale.constant = function(_) {
        return arguments.length ? transform(transformSymlog(c2 = +_), transformSymexp(c2)) : c2;
      };
      return linearish(scale);
    }
    function symlog() {
      var scale = symlogish(transformer$2());
      scale.copy = function() {
        return copy$1(scale, symlog()).constant(scale.constant());
      };
      return initRange.apply(scale, arguments);
    }
    function transformPow(exponent2) {
      return function(x2) {
        return x2 < 0 ? -Math.pow(-x2, exponent2) : Math.pow(x2, exponent2);
      };
    }
    function transformSqrt(x2) {
      return x2 < 0 ? -Math.sqrt(-x2) : Math.sqrt(x2);
    }
    function transformSquare(x2) {
      return x2 < 0 ? -x2 * x2 : x2 * x2;
    }
    function powish(transform) {
      var scale = transform(identity$3, identity$3), exponent2 = 1;
      function rescale() {
        return exponent2 === 1 ? transform(identity$3, identity$3) : exponent2 === 0.5 ? transform(transformSqrt, transformSquare) : transform(transformPow(exponent2), transformPow(1 / exponent2));
      }
      scale.exponent = function(_) {
        return arguments.length ? (exponent2 = +_, rescale()) : exponent2;
      };
      return linearish(scale);
    }
    function pow() {
      var scale = powish(transformer$2());
      scale.copy = function() {
        return copy$1(scale, pow()).exponent(scale.exponent());
      };
      initRange.apply(scale, arguments);
      return scale;
    }
    function sqrt() {
      return pow.apply(null, arguments).exponent(0.5);
    }
    function square(x2) {
      return Math.sign(x2) * x2 * x2;
    }
    function unsquare(x2) {
      return Math.sign(x2) * Math.sqrt(Math.abs(x2));
    }
    function radial() {
      var squared = continuous(), range2 = [0, 1], round2 = false, unknown;
      function scale(x2) {
        var y2 = unsquare(squared(x2));
        return isNaN(y2) ? unknown : round2 ? Math.round(y2) : y2;
      }
      scale.invert = function(y2) {
        return squared.invert(square(y2));
      };
      scale.domain = function(_) {
        return arguments.length ? (squared.domain(_), scale) : squared.domain();
      };
      scale.range = function(_) {
        return arguments.length ? (squared.range((range2 = Array.from(_, number$1)).map(square)), scale) : range2.slice();
      };
      scale.rangeRound = function(_) {
        return scale.range(_).round(true);
      };
      scale.round = function(_) {
        return arguments.length ? (round2 = !!_, scale) : round2;
      };
      scale.clamp = function(_) {
        return arguments.length ? (squared.clamp(_), scale) : squared.clamp();
      };
      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };
      scale.copy = function() {
        return radial(squared.domain(), range2).round(round2).clamp(squared.clamp()).unknown(unknown);
      };
      initRange.apply(scale, arguments);
      return linearish(scale);
    }
    function quantile() {
      var domain = [], range2 = [], thresholds = [], unknown;
      function rescale() {
        var i = 0, n2 = Math.max(1, range2.length);
        thresholds = new Array(n2 - 1);
        while (++i < n2) thresholds[i - 1] = quantileSorted(domain, i / n2);
        return scale;
      }
      function scale(x2) {
        return x2 == null || isNaN(x2 = +x2) ? unknown : range2[bisectRight(thresholds, x2)];
      }
      scale.invertExtent = function(y2) {
        var i = range2.indexOf(y2);
        return i < 0 ? [NaN, NaN] : [
          i > 0 ? thresholds[i - 1] : domain[0],
          i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
        ];
      };
      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [];
        for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
        domain.sort(ascending);
        return rescale();
      };
      scale.range = function(_) {
        return arguments.length ? (range2 = Array.from(_), rescale()) : range2.slice();
      };
      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };
      scale.quantiles = function() {
        return thresholds.slice();
      };
      scale.copy = function() {
        return quantile().domain(domain).range(range2).unknown(unknown);
      };
      return initRange.apply(scale, arguments);
    }
    function quantize() {
      var x0 = 0, x1 = 1, n2 = 1, domain = [0.5], range2 = [0, 1], unknown;
      function scale(x2) {
        return x2 != null && x2 <= x2 ? range2[bisectRight(domain, x2, 0, n2)] : unknown;
      }
      function rescale() {
        var i = -1;
        domain = new Array(n2);
        while (++i < n2) domain[i] = ((i + 1) * x1 - (i - n2) * x0) / (n2 + 1);
        return scale;
      }
      scale.domain = function(_) {
        return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
      };
      scale.range = function(_) {
        return arguments.length ? (n2 = (range2 = Array.from(_)).length - 1, rescale()) : range2.slice();
      };
      scale.invertExtent = function(y2) {
        var i = range2.indexOf(y2);
        return i < 0 ? [NaN, NaN] : i < 1 ? [x0, domain[0]] : i >= n2 ? [domain[n2 - 1], x1] : [domain[i - 1], domain[i]];
      };
      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : scale;
      };
      scale.thresholds = function() {
        return domain.slice();
      };
      scale.copy = function() {
        return quantize().domain([x0, x1]).range(range2).unknown(unknown);
      };
      return initRange.apply(linearish(scale), arguments);
    }
    function threshold() {
      var domain = [0.5], range2 = [0, 1], unknown, n2 = 1;
      function scale(x2) {
        return x2 != null && x2 <= x2 ? range2[bisectRight(domain, x2, 0, n2)] : unknown;
      }
      scale.domain = function(_) {
        return arguments.length ? (domain = Array.from(_), n2 = Math.min(domain.length, range2.length - 1), scale) : domain.slice();
      };
      scale.range = function(_) {
        return arguments.length ? (range2 = Array.from(_), n2 = Math.min(domain.length, range2.length - 1), scale) : range2.slice();
      };
      scale.invertExtent = function(y2) {
        var i = range2.indexOf(y2);
        return [domain[i - 1], domain[i]];
      };
      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };
      scale.copy = function() {
        return threshold().domain(domain).range(range2).unknown(unknown);
      };
      return initRange.apply(scale, arguments);
    }
    const t0 = /* @__PURE__ */ new Date(), t1 = /* @__PURE__ */ new Date();
    function timeInterval(floori, offseti, count, field) {
      function interval(date2) {
        return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
      }
      interval.floor = (date2) => {
        return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
      };
      interval.ceil = (date2) => {
        return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
      };
      interval.round = (date2) => {
        const d0 = interval(date2), d1 = interval.ceil(date2);
        return date2 - d0 < d1 - date2 ? d0 : d1;
      };
      interval.offset = (date2, step) => {
        return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
      };
      interval.range = (start, stop, step) => {
        const range2 = [];
        start = interval.ceil(start);
        step = step == null ? 1 : Math.floor(step);
        if (!(start < stop) || !(step > 0)) return range2;
        let previous;
        do
          range2.push(previous = /* @__PURE__ */ new Date(+start)), offseti(start, step), floori(start);
        while (previous < start && start < stop);
        return range2;
      };
      interval.filter = (test) => {
        return timeInterval((date2) => {
          if (date2 >= date2) while (floori(date2), !test(date2)) date2.setTime(date2 - 1);
        }, (date2, step) => {
          if (date2 >= date2) {
            if (step < 0) while (++step <= 0) {
              while (offseti(date2, -1), !test(date2)) {
              }
            }
            else while (--step >= 0) {
              while (offseti(date2, 1), !test(date2)) {
              }
            }
          }
        });
      };
      if (count) {
        interval.count = (start, end) => {
          t0.setTime(+start), t1.setTime(+end);
          floori(t0), floori(t1);
          return Math.floor(count(t0, t1));
        };
        interval.every = (step) => {
          step = Math.floor(step);
          return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? (d) => field(d) % step === 0 : (d) => interval.count(0, d) % step === 0);
        };
      }
      return interval;
    }
    const millisecond = timeInterval(() => {
    }, (date2, step) => {
      date2.setTime(+date2 + step);
    }, (start, end) => {
      return end - start;
    });
    millisecond.every = (k2) => {
      k2 = Math.floor(k2);
      if (!isFinite(k2) || !(k2 > 0)) return null;
      if (!(k2 > 1)) return millisecond;
      return timeInterval((date2) => {
        date2.setTime(Math.floor(date2 / k2) * k2);
      }, (date2, step) => {
        date2.setTime(+date2 + step * k2);
      }, (start, end) => {
        return (end - start) / k2;
      });
    };
    millisecond.range;
    const durationSecond = 1e3;
    const durationMinute = durationSecond * 60;
    const durationHour = durationMinute * 60;
    const durationDay = durationHour * 24;
    const durationWeek = durationDay * 7;
    const durationMonth = durationDay * 30;
    const durationYear = durationDay * 365;
    const second = timeInterval((date2) => {
      date2.setTime(date2 - date2.getMilliseconds());
    }, (date2, step) => {
      date2.setTime(+date2 + step * durationSecond);
    }, (start, end) => {
      return (end - start) / durationSecond;
    }, (date2) => {
      return date2.getUTCSeconds();
    });
    second.range;
    const timeMinute = timeInterval((date2) => {
      date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
    }, (date2, step) => {
      date2.setTime(+date2 + step * durationMinute);
    }, (start, end) => {
      return (end - start) / durationMinute;
    }, (date2) => {
      return date2.getMinutes();
    });
    timeMinute.range;
    const utcMinute = timeInterval((date2) => {
      date2.setUTCSeconds(0, 0);
    }, (date2, step) => {
      date2.setTime(+date2 + step * durationMinute);
    }, (start, end) => {
      return (end - start) / durationMinute;
    }, (date2) => {
      return date2.getUTCMinutes();
    });
    utcMinute.range;
    const timeHour = timeInterval((date2) => {
      date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
    }, (date2, step) => {
      date2.setTime(+date2 + step * durationHour);
    }, (start, end) => {
      return (end - start) / durationHour;
    }, (date2) => {
      return date2.getHours();
    });
    timeHour.range;
    const utcHour = timeInterval((date2) => {
      date2.setUTCMinutes(0, 0, 0);
    }, (date2, step) => {
      date2.setTime(+date2 + step * durationHour);
    }, (start, end) => {
      return (end - start) / durationHour;
    }, (date2) => {
      return date2.getUTCHours();
    });
    utcHour.range;
    const timeDay = timeInterval(
      (date2) => date2.setHours(0, 0, 0, 0),
      (date2, step) => date2.setDate(date2.getDate() + step),
      (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
      (date2) => date2.getDate() - 1
    );
    timeDay.range;
    const utcDay = timeInterval((date2) => {
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setUTCDate(date2.getUTCDate() + step);
    }, (start, end) => {
      return (end - start) / durationDay;
    }, (date2) => {
      return date2.getUTCDate() - 1;
    });
    utcDay.range;
    const unixDay = timeInterval((date2) => {
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setUTCDate(date2.getUTCDate() + step);
    }, (start, end) => {
      return (end - start) / durationDay;
    }, (date2) => {
      return Math.floor(date2 / durationDay);
    });
    unixDay.range;
    function timeWeekday(i) {
      return timeInterval((date2) => {
        date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
        date2.setHours(0, 0, 0, 0);
      }, (date2, step) => {
        date2.setDate(date2.getDate() + step * 7);
      }, (start, end) => {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
      });
    }
    const timeSunday = timeWeekday(0);
    const timeMonday = timeWeekday(1);
    const timeTuesday = timeWeekday(2);
    const timeWednesday = timeWeekday(3);
    const timeThursday = timeWeekday(4);
    const timeFriday = timeWeekday(5);
    const timeSaturday = timeWeekday(6);
    timeSunday.range;
    timeMonday.range;
    timeTuesday.range;
    timeWednesday.range;
    timeThursday.range;
    timeFriday.range;
    timeSaturday.range;
    function utcWeekday(i) {
      return timeInterval((date2) => {
        date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
        date2.setUTCHours(0, 0, 0, 0);
      }, (date2, step) => {
        date2.setUTCDate(date2.getUTCDate() + step * 7);
      }, (start, end) => {
        return (end - start) / durationWeek;
      });
    }
    const utcSunday = utcWeekday(0);
    const utcMonday = utcWeekday(1);
    const utcTuesday = utcWeekday(2);
    const utcWednesday = utcWeekday(3);
    const utcThursday = utcWeekday(4);
    const utcFriday = utcWeekday(5);
    const utcSaturday = utcWeekday(6);
    utcSunday.range;
    utcMonday.range;
    utcTuesday.range;
    utcWednesday.range;
    utcThursday.range;
    utcFriday.range;
    utcSaturday.range;
    const timeMonth = timeInterval((date2) => {
      date2.setDate(1);
      date2.setHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setMonth(date2.getMonth() + step);
    }, (start, end) => {
      return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
    }, (date2) => {
      return date2.getMonth();
    });
    timeMonth.range;
    const utcMonth = timeInterval((date2) => {
      date2.setUTCDate(1);
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setUTCMonth(date2.getUTCMonth() + step);
    }, (start, end) => {
      return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
    }, (date2) => {
      return date2.getUTCMonth();
    });
    utcMonth.range;
    const timeYear = timeInterval((date2) => {
      date2.setMonth(0, 1);
      date2.setHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setFullYear(date2.getFullYear() + step);
    }, (start, end) => {
      return end.getFullYear() - start.getFullYear();
    }, (date2) => {
      return date2.getFullYear();
    });
    timeYear.every = (k2) => {
      return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {
        date2.setFullYear(Math.floor(date2.getFullYear() / k2) * k2);
        date2.setMonth(0, 1);
        date2.setHours(0, 0, 0, 0);
      }, (date2, step) => {
        date2.setFullYear(date2.getFullYear() + step * k2);
      });
    };
    timeYear.range;
    const utcYear = timeInterval((date2) => {
      date2.setUTCMonth(0, 1);
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setUTCFullYear(date2.getUTCFullYear() + step);
    }, (start, end) => {
      return end.getUTCFullYear() - start.getUTCFullYear();
    }, (date2) => {
      return date2.getUTCFullYear();
    });
    utcYear.every = (k2) => {
      return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {
        date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k2) * k2);
        date2.setUTCMonth(0, 1);
        date2.setUTCHours(0, 0, 0, 0);
      }, (date2, step) => {
        date2.setUTCFullYear(date2.getUTCFullYear() + step * k2);
      });
    };
    utcYear.range;
    function ticker(year, month, week, day, hour, minute) {
      const tickIntervals = [
        [second, 1, durationSecond],
        [second, 5, 5 * durationSecond],
        [second, 15, 15 * durationSecond],
        [second, 30, 30 * durationSecond],
        [minute, 1, durationMinute],
        [minute, 5, 5 * durationMinute],
        [minute, 15, 15 * durationMinute],
        [minute, 30, 30 * durationMinute],
        [hour, 1, durationHour],
        [hour, 3, 3 * durationHour],
        [hour, 6, 6 * durationHour],
        [hour, 12, 12 * durationHour],
        [day, 1, durationDay],
        [day, 2, 2 * durationDay],
        [week, 1, durationWeek],
        [month, 1, durationMonth],
        [month, 3, 3 * durationMonth],
        [year, 1, durationYear]
      ];
      function ticks2(start, stop, count) {
        const reverse2 = stop < start;
        if (reverse2) [start, stop] = [stop, start];
        const interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
        const ticks3 = interval ? interval.range(start, +stop + 1) : [];
        return reverse2 ? ticks3.reverse() : ticks3;
      }
      function tickInterval(start, stop, count) {
        const target = Math.abs(stop - start) / count;
        const i = bisector(([, , step2]) => step2).right(tickIntervals, target);
        if (i === tickIntervals.length) return year.every(tickStep(start / durationYear, stop / durationYear, count));
        if (i === 0) return millisecond.every(Math.max(tickStep(start, stop, count), 1));
        const [t2, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        return t2.every(step);
      }
      return [ticks2, tickInterval];
    }
    const [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
    const [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);
    function localDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
        date2.setFullYear(d.y);
        return date2;
      }
      return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
    }
    function utcDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
        date2.setUTCFullYear(d.y);
        return date2;
      }
      return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
    }
    function newDate(y2, m2, d) {
      return { y: y2, m: m2, d, H: 0, M: 0, S: 0, L: 0 };
    }
    function formatLocale(locale2) {
      var locale_dateTime = locale2.dateTime, locale_date = locale2.date, locale_time = locale2.time, locale_periods = locale2.periods, locale_weekdays = locale2.days, locale_shortWeekdays = locale2.shortDays, locale_months = locale2.months, locale_shortMonths = locale2.shortMonths;
      var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
      var formats = {
        "a": formatShortWeekday,
        "A": formatWeekday,
        "b": formatShortMonth,
        "B": formatMonth,
        "c": null,
        "d": formatDayOfMonth,
        "e": formatDayOfMonth,
        "f": formatMicroseconds,
        "g": formatYearISO,
        "G": formatFullYearISO,
        "H": formatHour24,
        "I": formatHour12,
        "j": formatDayOfYear,
        "L": formatMilliseconds,
        "m": formatMonthNumber,
        "M": formatMinutes,
        "p": formatPeriod,
        "q": formatQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatSeconds,
        "u": formatWeekdayNumberMonday,
        "U": formatWeekNumberSunday,
        "V": formatWeekNumberISO,
        "w": formatWeekdayNumberSunday,
        "W": formatWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatYear,
        "Y": formatFullYear,
        "Z": formatZone,
        "%": formatLiteralPercent
      };
      var utcFormats = {
        "a": formatUTCShortWeekday,
        "A": formatUTCWeekday,
        "b": formatUTCShortMonth,
        "B": formatUTCMonth,
        "c": null,
        "d": formatUTCDayOfMonth,
        "e": formatUTCDayOfMonth,
        "f": formatUTCMicroseconds,
        "g": formatUTCYearISO,
        "G": formatUTCFullYearISO,
        "H": formatUTCHour24,
        "I": formatUTCHour12,
        "j": formatUTCDayOfYear,
        "L": formatUTCMilliseconds,
        "m": formatUTCMonthNumber,
        "M": formatUTCMinutes,
        "p": formatUTCPeriod,
        "q": formatUTCQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatUTCSeconds,
        "u": formatUTCWeekdayNumberMonday,
        "U": formatUTCWeekNumberSunday,
        "V": formatUTCWeekNumberISO,
        "w": formatUTCWeekdayNumberSunday,
        "W": formatUTCWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatUTCYear,
        "Y": formatUTCFullYear,
        "Z": formatUTCZone,
        "%": formatLiteralPercent
      };
      var parses = {
        "a": parseShortWeekday,
        "A": parseWeekday,
        "b": parseShortMonth,
        "B": parseMonth,
        "c": parseLocaleDateTime,
        "d": parseDayOfMonth,
        "e": parseDayOfMonth,
        "f": parseMicroseconds,
        "g": parseYear,
        "G": parseFullYear,
        "H": parseHour24,
        "I": parseHour24,
        "j": parseDayOfYear,
        "L": parseMilliseconds,
        "m": parseMonthNumber,
        "M": parseMinutes,
        "p": parsePeriod,
        "q": parseQuarter,
        "Q": parseUnixTimestamp,
        "s": parseUnixTimestampSeconds,
        "S": parseSeconds,
        "u": parseWeekdayNumberMonday,
        "U": parseWeekNumberSunday,
        "V": parseWeekNumberISO,
        "w": parseWeekdayNumberSunday,
        "W": parseWeekNumberMonday,
        "x": parseLocaleDate,
        "X": parseLocaleTime,
        "y": parseYear,
        "Y": parseFullYear,
        "Z": parseZone,
        "%": parseLiteralPercent
      };
      formats.x = newFormat(locale_date, formats);
      formats.X = newFormat(locale_time, formats);
      formats.c = newFormat(locale_dateTime, formats);
      utcFormats.x = newFormat(locale_date, utcFormats);
      utcFormats.X = newFormat(locale_time, utcFormats);
      utcFormats.c = newFormat(locale_dateTime, utcFormats);
      function newFormat(specifier, formats2) {
        return function(date2) {
          var string2 = [], i = -1, j = 0, n2 = specifier.length, c2, pad2, format2;
          if (!(date2 instanceof Date)) date2 = /* @__PURE__ */ new Date(+date2);
          while (++i < n2) {
            if (specifier.charCodeAt(i) === 37) {
              string2.push(specifier.slice(j, i));
              if ((pad2 = pads[c2 = specifier.charAt(++i)]) != null) c2 = specifier.charAt(++i);
              else pad2 = c2 === "e" ? " " : "0";
              if (format2 = formats2[c2]) c2 = format2(date2, pad2);
              string2.push(c2);
              j = i + 1;
            }
          }
          string2.push(specifier.slice(j, i));
          return string2.join("");
        };
      }
      function newParse(specifier, Z2) {
        return function(string2) {
          var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string2 += "", 0), week, day;
          if (i != string2.length) return null;
          if ("Q" in d) return new Date(d.Q);
          if ("s" in d) return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
          if (Z2 && !("Z" in d)) d.Z = 0;
          if ("p" in d) d.H = d.H % 12 + d.p * 12;
          if (d.m === void 0) d.m = "q" in d ? d.q : 0;
          if ("V" in d) {
            if (d.V < 1 || d.V > 53) return null;
            if (!("w" in d)) d.w = 1;
            if ("Z" in d) {
              week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
              week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
              week = utcDay.offset(week, (d.V - 1) * 7);
              d.y = week.getUTCFullYear();
              d.m = week.getUTCMonth();
              d.d = week.getUTCDate() + (d.w + 6) % 7;
            } else {
              week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
              week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
              week = timeDay.offset(week, (d.V - 1) * 7);
              d.y = week.getFullYear();
              d.m = week.getMonth();
              d.d = week.getDate() + (d.w + 6) % 7;
            }
          } else if ("W" in d || "U" in d) {
            if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
            day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
            d.m = 0;
            d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
          }
          if ("Z" in d) {
            d.H += d.Z / 100 | 0;
            d.M += d.Z % 100;
            return utcDate(d);
          }
          return localDate(d);
        };
      }
      function parseSpecifier(d, specifier, string2, j) {
        var i = 0, n2 = specifier.length, m2 = string2.length, c2, parse;
        while (i < n2) {
          if (j >= m2) return -1;
          c2 = specifier.charCodeAt(i++);
          if (c2 === 37) {
            c2 = specifier.charAt(i++);
            parse = parses[c2 in pads ? specifier.charAt(i++) : c2];
            if (!parse || (j = parse(d, string2, j)) < 0) return -1;
          } else if (c2 != string2.charCodeAt(j++)) {
            return -1;
          }
        }
        return j;
      }
      function parsePeriod(d, string2, i) {
        var n2 = periodRe.exec(string2.slice(i));
        return n2 ? (d.p = periodLookup.get(n2[0].toLowerCase()), i + n2[0].length) : -1;
      }
      function parseShortWeekday(d, string2, i) {
        var n2 = shortWeekdayRe.exec(string2.slice(i));
        return n2 ? (d.w = shortWeekdayLookup.get(n2[0].toLowerCase()), i + n2[0].length) : -1;
      }
      function parseWeekday(d, string2, i) {
        var n2 = weekdayRe.exec(string2.slice(i));
        return n2 ? (d.w = weekdayLookup.get(n2[0].toLowerCase()), i + n2[0].length) : -1;
      }
      function parseShortMonth(d, string2, i) {
        var n2 = shortMonthRe.exec(string2.slice(i));
        return n2 ? (d.m = shortMonthLookup.get(n2[0].toLowerCase()), i + n2[0].length) : -1;
      }
      function parseMonth(d, string2, i) {
        var n2 = monthRe.exec(string2.slice(i));
        return n2 ? (d.m = monthLookup.get(n2[0].toLowerCase()), i + n2[0].length) : -1;
      }
      function parseLocaleDateTime(d, string2, i) {
        return parseSpecifier(d, locale_dateTime, string2, i);
      }
      function parseLocaleDate(d, string2, i) {
        return parseSpecifier(d, locale_date, string2, i);
      }
      function parseLocaleTime(d, string2, i) {
        return parseSpecifier(d, locale_time, string2, i);
      }
      function formatShortWeekday(d) {
        return locale_shortWeekdays[d.getDay()];
      }
      function formatWeekday(d) {
        return locale_weekdays[d.getDay()];
      }
      function formatShortMonth(d) {
        return locale_shortMonths[d.getMonth()];
      }
      function formatMonth(d) {
        return locale_months[d.getMonth()];
      }
      function formatPeriod(d) {
        return locale_periods[+(d.getHours() >= 12)];
      }
      function formatQuarter(d) {
        return 1 + ~~(d.getMonth() / 3);
      }
      function formatUTCShortWeekday(d) {
        return locale_shortWeekdays[d.getUTCDay()];
      }
      function formatUTCWeekday(d) {
        return locale_weekdays[d.getUTCDay()];
      }
      function formatUTCShortMonth(d) {
        return locale_shortMonths[d.getUTCMonth()];
      }
      function formatUTCMonth(d) {
        return locale_months[d.getUTCMonth()];
      }
      function formatUTCPeriod(d) {
        return locale_periods[+(d.getUTCHours() >= 12)];
      }
      function formatUTCQuarter(d) {
        return 1 + ~~(d.getUTCMonth() / 3);
      }
      return {
        format: function(specifier) {
          var f2 = newFormat(specifier += "", formats);
          f2.toString = function() {
            return specifier;
          };
          return f2;
        },
        parse: function(specifier) {
          var p2 = newParse(specifier += "", false);
          p2.toString = function() {
            return specifier;
          };
          return p2;
        },
        utcFormat: function(specifier) {
          var f2 = newFormat(specifier += "", utcFormats);
          f2.toString = function() {
            return specifier;
          };
          return f2;
        },
        utcParse: function(specifier) {
          var p2 = newParse(specifier += "", true);
          p2.toString = function() {
            return specifier;
          };
          return p2;
        }
      };
    }
    var pads = { "-": "", "_": " ", "0": "0" }, numberRe = /^\s*\d+/, percentRe = /^%/, requoteRe = /[\\^$*+?|[\]().{}]/g;
    function pad(value, fill, width) {
      var sign2 = value < 0 ? "-" : "", string2 = (sign2 ? -value : value) + "", length = string2.length;
      return sign2 + (length < width ? new Array(width - length + 1).join(fill) + string2 : string2);
    }
    function requote(s2) {
      return s2.replace(requoteRe, "\\$&");
    }
    function formatRe(names) {
      return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
    }
    function formatLookup(names) {
      return new Map(names.map((name, i) => [name.toLowerCase(), i]));
    }
    function parseWeekdayNumberSunday(d, string2, i) {
      var n2 = numberRe.exec(string2.slice(i, i + 1));
      return n2 ? (d.w = +n2[0], i + n2[0].length) : -1;
    }
    function parseWeekdayNumberMonday(d, string2, i) {
      var n2 = numberRe.exec(string2.slice(i, i + 1));
      return n2 ? (d.u = +n2[0], i + n2[0].length) : -1;
    }
    function parseWeekNumberSunday(d, string2, i) {
      var n2 = numberRe.exec(string2.slice(i, i + 2));
      return n2 ? (d.U = +n2[0], i + n2[0].length) : -1;
    }
    function parseWeekNumberISO(d, string2, i) {
      var n2 = numberRe.exec(string2.slice(i, i + 2));
      return n2 ? (d.V = +n2[0], i + n2[0].length) : -1;
    }
    function parseWeekNumberMonday(d, string2, i) {
      var n2 = numberRe.exec(string2.slice(i, i + 2));
      return n2 ? (d.W = +n2[0], i + n2[0].length) : -1;
    }
    function parseFullYear(d, string2, i) {
      var n2 = numberRe.exec(string2.slice(i, i + 4));
      return n2 ? (d.y = +n2[0], i + n2[0].length) : -1;
    }
    function parseYear(d, string2, i) {
      var n2 = numberRe.exec(string2.slice(i, i + 2));
      return n2 ? (d.y = +n2[0] + (+n2[0] > 68 ? 1900 : 2e3), i + n2[0].length) : -1;
    }
    function parseZone(d, string2, i) {
      var n2 = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string2.slice(i, i + 6));
      return n2 ? (d.Z = n2[1] ? 0 : -(n2[2] + (n2[3] || "00")), i + n2[0].length) : -1;
    }
    function parseQuarter(d, string2, i) {
      var n2 = numberRe.exec(string2.slice(i, i + 1));
      return n2 ? (d.q = n2[0] * 3 - 3, i + n2[0].length) : -1;
    }
    function parseMonthNumber(d, string2, i) {
      var n2 = numberRe.exec(string2.slice(i, i + 2));
      return n2 ? (d.m = n2[0] - 1, i + n2[0].length) : -1;
    }
    function parseDayOfMonth(d, string2, i) {
      var n2 = numberRe.exec(string2.slice(i, i + 2));
      return n2 ? (d.d = +n2[0], i + n2[0].length) : -1;
    }
    function parseDayOfYear(d, string2, i) {
      var n2 = numberRe.exec(string2.slice(i, i + 3));
      return n2 ? (d.m = 0, d.d = +n2[0], i + n2[0].length) : -1;
    }
    function parseHour24(d, string2, i) {
      var n2 = numberRe.exec(string2.slice(i, i + 2));
      return n2 ? (d.H = +n2[0], i + n2[0].length) : -1;
    }
    function parseMinutes(d, string2, i) {
      var n2 = numberRe.exec(string2.slice(i, i + 2));
      return n2 ? (d.M = +n2[0], i + n2[0].length) : -1;
    }
    function parseSeconds(d, string2, i) {
      var n2 = numberRe.exec(string2.slice(i, i + 2));
      return n2 ? (d.S = +n2[0], i + n2[0].length) : -1;
    }
    function parseMilliseconds(d, string2, i) {
      var n2 = numberRe.exec(string2.slice(i, i + 3));
      return n2 ? (d.L = +n2[0], i + n2[0].length) : -1;
    }
    function parseMicroseconds(d, string2, i) {
      var n2 = numberRe.exec(string2.slice(i, i + 6));
      return n2 ? (d.L = Math.floor(n2[0] / 1e3), i + n2[0].length) : -1;
    }
    function parseLiteralPercent(d, string2, i) {
      var n2 = percentRe.exec(string2.slice(i, i + 1));
      return n2 ? i + n2[0].length : -1;
    }
    function parseUnixTimestamp(d, string2, i) {
      var n2 = numberRe.exec(string2.slice(i));
      return n2 ? (d.Q = +n2[0], i + n2[0].length) : -1;
    }
    function parseUnixTimestampSeconds(d, string2, i) {
      var n2 = numberRe.exec(string2.slice(i));
      return n2 ? (d.s = +n2[0], i + n2[0].length) : -1;
    }
    function formatDayOfMonth(d, p2) {
      return pad(d.getDate(), p2, 2);
    }
    function formatHour24(d, p2) {
      return pad(d.getHours(), p2, 2);
    }
    function formatHour12(d, p2) {
      return pad(d.getHours() % 12 || 12, p2, 2);
    }
    function formatDayOfYear(d, p2) {
      return pad(1 + timeDay.count(timeYear(d), d), p2, 3);
    }
    function formatMilliseconds(d, p2) {
      return pad(d.getMilliseconds(), p2, 3);
    }
    function formatMicroseconds(d, p2) {
      return formatMilliseconds(d, p2) + "000";
    }
    function formatMonthNumber(d, p2) {
      return pad(d.getMonth() + 1, p2, 2);
    }
    function formatMinutes(d, p2) {
      return pad(d.getMinutes(), p2, 2);
    }
    function formatSeconds(d, p2) {
      return pad(d.getSeconds(), p2, 2);
    }
    function formatWeekdayNumberMonday(d) {
      var day = d.getDay();
      return day === 0 ? 7 : day;
    }
    function formatWeekNumberSunday(d, p2) {
      return pad(timeSunday.count(timeYear(d) - 1, d), p2, 2);
    }
    function dISO(d) {
      var day = d.getDay();
      return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
    }
    function formatWeekNumberISO(d, p2) {
      d = dISO(d);
      return pad(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p2, 2);
    }
    function formatWeekdayNumberSunday(d) {
      return d.getDay();
    }
    function formatWeekNumberMonday(d, p2) {
      return pad(timeMonday.count(timeYear(d) - 1, d), p2, 2);
    }
    function formatYear(d, p2) {
      return pad(d.getFullYear() % 100, p2, 2);
    }
    function formatYearISO(d, p2) {
      d = dISO(d);
      return pad(d.getFullYear() % 100, p2, 2);
    }
    function formatFullYear(d, p2) {
      return pad(d.getFullYear() % 1e4, p2, 4);
    }
    function formatFullYearISO(d, p2) {
      var day = d.getDay();
      d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
      return pad(d.getFullYear() % 1e4, p2, 4);
    }
    function formatZone(d) {
      var z2 = d.getTimezoneOffset();
      return (z2 > 0 ? "-" : (z2 *= -1, "+")) + pad(z2 / 60 | 0, "0", 2) + pad(z2 % 60, "0", 2);
    }
    function formatUTCDayOfMonth(d, p2) {
      return pad(d.getUTCDate(), p2, 2);
    }
    function formatUTCHour24(d, p2) {
      return pad(d.getUTCHours(), p2, 2);
    }
    function formatUTCHour12(d, p2) {
      return pad(d.getUTCHours() % 12 || 12, p2, 2);
    }
    function formatUTCDayOfYear(d, p2) {
      return pad(1 + utcDay.count(utcYear(d), d), p2, 3);
    }
    function formatUTCMilliseconds(d, p2) {
      return pad(d.getUTCMilliseconds(), p2, 3);
    }
    function formatUTCMicroseconds(d, p2) {
      return formatUTCMilliseconds(d, p2) + "000";
    }
    function formatUTCMonthNumber(d, p2) {
      return pad(d.getUTCMonth() + 1, p2, 2);
    }
    function formatUTCMinutes(d, p2) {
      return pad(d.getUTCMinutes(), p2, 2);
    }
    function formatUTCSeconds(d, p2) {
      return pad(d.getUTCSeconds(), p2, 2);
    }
    function formatUTCWeekdayNumberMonday(d) {
      var dow = d.getUTCDay();
      return dow === 0 ? 7 : dow;
    }
    function formatUTCWeekNumberSunday(d, p2) {
      return pad(utcSunday.count(utcYear(d) - 1, d), p2, 2);
    }
    function UTCdISO(d) {
      var day = d.getUTCDay();
      return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
    }
    function formatUTCWeekNumberISO(d, p2) {
      d = UTCdISO(d);
      return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p2, 2);
    }
    function formatUTCWeekdayNumberSunday(d) {
      return d.getUTCDay();
    }
    function formatUTCWeekNumberMonday(d, p2) {
      return pad(utcMonday.count(utcYear(d) - 1, d), p2, 2);
    }
    function formatUTCYear(d, p2) {
      return pad(d.getUTCFullYear() % 100, p2, 2);
    }
    function formatUTCYearISO(d, p2) {
      d = UTCdISO(d);
      return pad(d.getUTCFullYear() % 100, p2, 2);
    }
    function formatUTCFullYear(d, p2) {
      return pad(d.getUTCFullYear() % 1e4, p2, 4);
    }
    function formatUTCFullYearISO(d, p2) {
      var day = d.getUTCDay();
      d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
      return pad(d.getUTCFullYear() % 1e4, p2, 4);
    }
    function formatUTCZone() {
      return "+0000";
    }
    function formatLiteralPercent() {
      return "%";
    }
    function formatUnixTimestamp(d) {
      return +d;
    }
    function formatUnixTimestampSeconds(d) {
      return Math.floor(+d / 1e3);
    }
    var locale;
    var timeFormat;
    var utcFormat;
    defaultLocale({
      dateTime: "%x, %X",
      date: "%-m/%-d/%Y",
      time: "%-I:%M:%S %p",
      periods: ["AM", "PM"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });
    function defaultLocale(definition) {
      locale = formatLocale(definition);
      timeFormat = locale.format;
      locale.parse;
      utcFormat = locale.utcFormat;
      locale.utcParse;
      return locale;
    }
    function date(t2) {
      return new Date(t2);
    }
    function number(t2) {
      return t2 instanceof Date ? +t2 : +/* @__PURE__ */ new Date(+t2);
    }
    function calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2) {
      var scale = continuous(), invert = scale.invert, domain = scale.domain;
      var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear2 = format2("%Y");
      function tickFormat2(date2) {
        return (second2(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth : formatYear2)(date2);
      }
      scale.invert = function(y2) {
        return new Date(invert(y2));
      };
      scale.domain = function(_) {
        return arguments.length ? domain(Array.from(_, number)) : domain().map(date);
      };
      scale.ticks = function(interval) {
        var d = domain();
        return ticks2(d[0], d[d.length - 1], interval == null ? 10 : interval);
      };
      scale.tickFormat = function(count, specifier) {
        return specifier == null ? tickFormat2 : format2(specifier);
      };
      scale.nice = function(interval) {
        var d = domain();
        if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
        return interval ? domain(nice(d, interval)) : scale;
      };
      scale.copy = function() {
        return copy$1(scale, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2));
      };
      return scale;
    }
    function time() {
      return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
    }
    function utcTime() {
      return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
    }
    function transformer$1() {
      var x0 = 0, x1 = 1, t02, t12, k10, transform, interpolator = identity$3, clamp = false, unknown;
      function scale(x2) {
        return x2 == null || isNaN(x2 = +x2) ? unknown : interpolator(k10 === 0 ? 0.5 : (x2 = (transform(x2) - t02) * k10, clamp ? Math.max(0, Math.min(1, x2)) : x2));
      }
      scale.domain = function(_) {
        return arguments.length ? ([x0, x1] = _, t02 = transform(x0 = +x0), t12 = transform(x1 = +x1), k10 = t02 === t12 ? 0 : 1 / (t12 - t02), scale) : [x0, x1];
      };
      scale.clamp = function(_) {
        return arguments.length ? (clamp = !!_, scale) : clamp;
      };
      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };
      function range2(interpolate2) {
        return function(_) {
          var r0, r1;
          return arguments.length ? ([r0, r1] = _, interpolator = interpolate2(r0, r1), scale) : [interpolator(0), interpolator(1)];
        };
      }
      scale.range = range2(interpolate);
      scale.rangeRound = range2(interpolateRound);
      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };
      return function(t2) {
        transform = t2, t02 = t2(x0), t12 = t2(x1), k10 = t02 === t12 ? 0 : 1 / (t12 - t02);
        return scale;
      };
    }
    function copy(source, target) {
      return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
    }
    function sequential() {
      var scale = linearish(transformer$1()(identity$3));
      scale.copy = function() {
        return copy(scale, sequential());
      };
      return initInterpolator.apply(scale, arguments);
    }
    function sequentialLog() {
      var scale = loggish(transformer$1()).domain([1, 10]);
      scale.copy = function() {
        return copy(scale, sequentialLog()).base(scale.base());
      };
      return initInterpolator.apply(scale, arguments);
    }
    function sequentialSymlog() {
      var scale = symlogish(transformer$1());
      scale.copy = function() {
        return copy(scale, sequentialSymlog()).constant(scale.constant());
      };
      return initInterpolator.apply(scale, arguments);
    }
    function sequentialPow() {
      var scale = powish(transformer$1());
      scale.copy = function() {
        return copy(scale, sequentialPow()).exponent(scale.exponent());
      };
      return initInterpolator.apply(scale, arguments);
    }
    function sequentialSqrt() {
      return sequentialPow.apply(null, arguments).exponent(0.5);
    }
    function sequentialQuantile() {
      var domain = [], interpolator = identity$3;
      function scale(x2) {
        if (x2 != null && !isNaN(x2 = +x2)) return interpolator((bisectRight(domain, x2, 1) - 1) / (domain.length - 1));
      }
      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [];
        for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
        domain.sort(ascending);
        return scale;
      };
      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };
      scale.range = function() {
        return domain.map((d, i) => interpolator(i / (domain.length - 1)));
      };
      scale.quantiles = function(n2) {
        return Array.from({ length: n2 + 1 }, (_, i) => quantile$1(domain, i / n2));
      };
      scale.copy = function() {
        return sequentialQuantile(interpolator).domain(domain);
      };
      return initInterpolator.apply(scale, arguments);
    }
    function transformer() {
      var x0 = 0, x1 = 0.5, x2 = 1, s2 = 1, t02, t12, t2, k10, k21, interpolator = identity$3, transform, clamp = false, unknown;
      function scale(x3) {
        return isNaN(x3 = +x3) ? unknown : (x3 = 0.5 + ((x3 = +transform(x3)) - t12) * (s2 * x3 < s2 * t12 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x3)) : x3));
      }
      scale.domain = function(_) {
        return arguments.length ? ([x0, x1, x2] = _, t02 = transform(x0 = +x0), t12 = transform(x1 = +x1), t2 = transform(x2 = +x2), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t2 ? 0 : 0.5 / (t2 - t12), s2 = t12 < t02 ? -1 : 1, scale) : [x0, x1, x2];
      };
      scale.clamp = function(_) {
        return arguments.length ? (clamp = !!_, scale) : clamp;
      };
      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };
      function range2(interpolate2) {
        return function(_) {
          var r0, r1, r2;
          return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate2, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
        };
      }
      scale.range = range2(interpolate);
      scale.rangeRound = range2(interpolateRound);
      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };
      return function(t3) {
        transform = t3, t02 = t3(x0), t12 = t3(x1), t2 = t3(x2), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t2 ? 0 : 0.5 / (t2 - t12), s2 = t12 < t02 ? -1 : 1;
        return scale;
      };
    }
    function diverging() {
      var scale = linearish(transformer()(identity$3));
      scale.copy = function() {
        return copy(scale, diverging());
      };
      return initInterpolator.apply(scale, arguments);
    }
    function divergingLog() {
      var scale = loggish(transformer()).domain([0.1, 1, 10]);
      scale.copy = function() {
        return copy(scale, divergingLog()).base(scale.base());
      };
      return initInterpolator.apply(scale, arguments);
    }
    function divergingSymlog() {
      var scale = symlogish(transformer());
      scale.copy = function() {
        return copy(scale, divergingSymlog()).constant(scale.constant());
      };
      return initInterpolator.apply(scale, arguments);
    }
    function divergingPow() {
      var scale = powish(transformer());
      scale.copy = function() {
        return copy(scale, divergingPow()).exponent(scale.exponent());
      };
      return initInterpolator.apply(scale, arguments);
    }
    function divergingSqrt() {
      return divergingPow.apply(null, arguments).exponent(0.5);
    }
    const d3Scales = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      scaleBand: band,
      scaleDiverging: diverging,
      scaleDivergingLog: divergingLog,
      scaleDivergingPow: divergingPow,
      scaleDivergingSqrt: divergingSqrt,
      scaleDivergingSymlog: divergingSymlog,
      scaleIdentity: identity$1,
      scaleImplicit: implicit,
      scaleLinear: linear,
      scaleLog: log,
      scaleOrdinal: ordinal,
      scalePoint: point,
      scalePow: pow,
      scaleQuantile: quantile,
      scaleQuantize: quantize,
      scaleRadial: radial,
      scaleSequential: sequential,
      scaleSequentialLog: sequentialLog,
      scaleSequentialPow: sequentialPow,
      scaleSequentialQuantile: sequentialQuantile,
      scaleSequentialSqrt: sequentialSqrt,
      scaleSequentialSymlog: sequentialSymlog,
      scaleSqrt: sqrt,
      scaleSymlog: symlog,
      scaleThreshold: threshold,
      scaleTime: time,
      scaleUtc: utcTime,
      tickFormat
    }, Symbol.toStringTag, { value: "Module" }));
    var selectChartDataWithIndexes = (state) => state.chartData;
    var selectChartDataAndAlwaysIgnoreIndexes = createSelector([selectChartDataWithIndexes], (dataState) => {
      var dataEndIndex = dataState.chartData != null ? dataState.chartData.length - 1 : 0;
      return {
        chartData: dataState.chartData,
        computedData: dataState.computedData,
        dataEndIndex,
        dataStartIndex: 0
      };
    });
    var selectChartDataWithIndexesIfNotInPanorama = (state, _unused1, _unused2, isPanorama) => {
      if (isPanorama) {
        return selectChartDataAndAlwaysIgnoreIndexes(state);
      }
      return selectChartDataWithIndexes(state);
    };
    function isWellFormedNumberDomain(v2) {
      if (Array.isArray(v2) && v2.length === 2) {
        var [min2, max2] = v2;
        if (isWellBehavedNumber(min2) && isWellBehavedNumber(max2)) {
          return true;
        }
      }
      return false;
    }
    function extendDomain(providedDomain, boundaryDomain, allowDataOverflow) {
      if (allowDataOverflow) {
        return providedDomain;
      }
      return [Math.min(providedDomain[0], boundaryDomain[0]), Math.max(providedDomain[1], boundaryDomain[1])];
    }
    function numericalDomainSpecifiedWithoutRequiringData(userDomain, allowDataOverflow) {
      if (!allowDataOverflow) {
        return void 0;
      }
      if (typeof userDomain === "function") {
        return void 0;
      }
      if (Array.isArray(userDomain) && userDomain.length === 2) {
        var [providedMin, providedMax] = userDomain;
        var finalMin, finalMax;
        if (isWellBehavedNumber(providedMin)) {
          finalMin = providedMin;
        } else if (typeof providedMin === "function") {
          return void 0;
        }
        if (isWellBehavedNumber(providedMax)) {
          finalMax = providedMax;
        } else if (typeof providedMax === "function") {
          return void 0;
        }
        var candidate = [finalMin, finalMax];
        if (isWellFormedNumberDomain(candidate)) {
          return candidate;
        }
      }
      return void 0;
    }
    function parseNumericalUserDomain(userDomain, dataDomain, allowDataOverflow) {
      if (!allowDataOverflow && dataDomain == null) {
        return void 0;
      }
      if (typeof userDomain === "function" && dataDomain != null) {
        try {
          var result = userDomain(dataDomain, allowDataOverflow);
          if (isWellFormedNumberDomain(result)) {
            return extendDomain(result, dataDomain, allowDataOverflow);
          }
        } catch (_unused) {
        }
      }
      if (Array.isArray(userDomain) && userDomain.length === 2) {
        var [providedMin, providedMax] = userDomain;
        var finalMin, finalMax;
        if (providedMin === "auto") {
          if (dataDomain != null) {
            finalMin = Math.min(...dataDomain);
          }
        } else if (isNumber(providedMin)) {
          finalMin = providedMin;
        } else if (typeof providedMin === "function") {
          try {
            if (dataDomain != null) {
              finalMin = providedMin(dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[0]);
            }
          } catch (_unused2) {
          }
        } else if (typeof providedMin === "string" && MIN_VALUE_REG.test(providedMin)) {
          var match = MIN_VALUE_REG.exec(providedMin);
          if (match == null || dataDomain == null) {
            finalMin = void 0;
          } else {
            var value = +match[1];
            finalMin = dataDomain[0] - value;
          }
        } else {
          finalMin = dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[0];
        }
        if (providedMax === "auto") {
          if (dataDomain != null) {
            finalMax = Math.max(...dataDomain);
          }
        } else if (isNumber(providedMax)) {
          finalMax = providedMax;
        } else if (typeof providedMax === "function") {
          try {
            if (dataDomain != null) {
              finalMax = providedMax(dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[1]);
            }
          } catch (_unused3) {
          }
        } else if (typeof providedMax === "string" && MAX_VALUE_REG.test(providedMax)) {
          var _match = MAX_VALUE_REG.exec(providedMax);
          if (_match == null || dataDomain == null) {
            finalMax = void 0;
          } else {
            var _value = +_match[1];
            finalMax = dataDomain[1] + _value;
          }
        } else {
          finalMax = dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[1];
        }
        var candidate = [finalMin, finalMax];
        if (isWellFormedNumberDomain(candidate)) {
          if (dataDomain == null) {
            return candidate;
          }
          return extendDomain(candidate, dataDomain, allowDataOverflow);
        }
      }
      return void 0;
    }
    var MAX_DIGITS = 1e9, defaults = {
      // These values must be integers within the stated ranges (inclusive).
      // Most of these values can be changed during run-time using `Decimal.config`.
      // The maximum number of significant digits of the result of a calculation or base conversion.
      // E.g. `Decimal.config({ precision: 20 });`
      precision: 20,
      // 1 to MAX_DIGITS
      // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,
      // `toFixed`, `toPrecision` and `toSignificantDigits`.
      //
      // ROUND_UP         0 Away from zero.
      // ROUND_DOWN       1 Towards zero.
      // ROUND_CEIL       2 Towards +Infinity.
      // ROUND_FLOOR      3 Towards -Infinity.
      // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      //
      // E.g.
      // `Decimal.rounding = 4;`
      // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
      rounding: 4,
      // 0 to 8
      // The exponent value at and beneath which `toString` returns exponential notation.
      // JavaScript numbers: -7
      toExpNeg: -7,
      // 0 to -MAX_E
      // The exponent value at and above which `toString` returns exponential notation.
      // JavaScript numbers: 21
      toExpPos: 21,
      // 0 to MAX_E
      // The natural logarithm of 10.
      // 115 digits
      LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
    }, Decimal, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", exponentOutOfRange = decimalError + "Exponent out of range: ", mathfloor = Math.floor, mathpow = Math.pow, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, ONE, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, MAX_E = mathfloor(MAX_SAFE_INTEGER / LOG_BASE), P = {};
    P.absoluteValue = P.abs = function() {
      var x2 = new this.constructor(this);
      if (x2.s) x2.s = 1;
      return x2;
    };
    P.comparedTo = P.cmp = function(y2) {
      var i, j, xdL, ydL, x2 = this;
      y2 = new x2.constructor(y2);
      if (x2.s !== y2.s) return x2.s || -y2.s;
      if (x2.e !== y2.e) return x2.e > y2.e ^ x2.s < 0 ? 1 : -1;
      xdL = x2.d.length;
      ydL = y2.d.length;
      for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
        if (x2.d[i] !== y2.d[i]) return x2.d[i] > y2.d[i] ^ x2.s < 0 ? 1 : -1;
      }
      return xdL === ydL ? 0 : xdL > ydL ^ x2.s < 0 ? 1 : -1;
    };
    P.decimalPlaces = P.dp = function() {
      var x2 = this, w2 = x2.d.length - 1, dp = (w2 - x2.e) * LOG_BASE;
      w2 = x2.d[w2];
      if (w2) for (; w2 % 10 == 0; w2 /= 10) dp--;
      return dp < 0 ? 0 : dp;
    };
    P.dividedBy = P.div = function(y2) {
      return divide(this, new this.constructor(y2));
    };
    P.dividedToIntegerBy = P.idiv = function(y2) {
      var x2 = this, Ctor = x2.constructor;
      return round(divide(x2, new Ctor(y2), 0, 1), Ctor.precision);
    };
    P.equals = P.eq = function(y2) {
      return !this.cmp(y2);
    };
    P.exponent = function() {
      return getBase10Exponent(this);
    };
    P.greaterThan = P.gt = function(y2) {
      return this.cmp(y2) > 0;
    };
    P.greaterThanOrEqualTo = P.gte = function(y2) {
      return this.cmp(y2) >= 0;
    };
    P.isInteger = P.isint = function() {
      return this.e > this.d.length - 2;
    };
    P.isNegative = P.isneg = function() {
      return this.s < 0;
    };
    P.isPositive = P.ispos = function() {
      return this.s > 0;
    };
    P.isZero = function() {
      return this.s === 0;
    };
    P.lessThan = P.lt = function(y2) {
      return this.cmp(y2) < 0;
    };
    P.lessThanOrEqualTo = P.lte = function(y2) {
      return this.cmp(y2) < 1;
    };
    P.logarithm = P.log = function(base) {
      var r2, x2 = this, Ctor = x2.constructor, pr = Ctor.precision, wpr = pr + 5;
      if (base === void 0) {
        base = new Ctor(10);
      } else {
        base = new Ctor(base);
        if (base.s < 1 || base.eq(ONE)) throw Error(decimalError + "NaN");
      }
      if (x2.s < 1) throw Error(decimalError + (x2.s ? "NaN" : "-Infinity"));
      if (x2.eq(ONE)) return new Ctor(0);
      external = false;
      r2 = divide(ln(x2, wpr), ln(base, wpr), wpr);
      external = true;
      return round(r2, pr);
    };
    P.minus = P.sub = function(y2) {
      var x2 = this;
      y2 = new x2.constructor(y2);
      return x2.s == y2.s ? subtract(x2, y2) : add(x2, (y2.s = -y2.s, y2));
    };
    P.modulo = P.mod = function(y2) {
      var q2, x2 = this, Ctor = x2.constructor, pr = Ctor.precision;
      y2 = new Ctor(y2);
      if (!y2.s) throw Error(decimalError + "NaN");
      if (!x2.s) return round(new Ctor(x2), pr);
      external = false;
      q2 = divide(x2, y2, 0, 1).times(y2);
      external = true;
      return x2.minus(q2);
    };
    P.naturalExponential = P.exp = function() {
      return exp(this);
    };
    P.naturalLogarithm = P.ln = function() {
      return ln(this);
    };
    P.negated = P.neg = function() {
      var x2 = new this.constructor(this);
      x2.s = -x2.s || 0;
      return x2;
    };
    P.plus = P.add = function(y2) {
      var x2 = this;
      y2 = new x2.constructor(y2);
      return x2.s == y2.s ? add(x2, y2) : subtract(x2, (y2.s = -y2.s, y2));
    };
    P.precision = P.sd = function(z2) {
      var e, sd2, w2, x2 = this;
      if (z2 !== void 0 && z2 !== !!z2 && z2 !== 1 && z2 !== 0) throw Error(invalidArgument + z2);
      e = getBase10Exponent(x2) + 1;
      w2 = x2.d.length - 1;
      sd2 = w2 * LOG_BASE + 1;
      w2 = x2.d[w2];
      if (w2) {
        for (; w2 % 10 == 0; w2 /= 10) sd2--;
        for (w2 = x2.d[0]; w2 >= 10; w2 /= 10) sd2++;
      }
      return z2 && e > sd2 ? e : sd2;
    };
    P.squareRoot = P.sqrt = function() {
      var e, n2, pr, r2, s2, t2, wpr, x2 = this, Ctor = x2.constructor;
      if (x2.s < 1) {
        if (!x2.s) return new Ctor(0);
        throw Error(decimalError + "NaN");
      }
      e = getBase10Exponent(x2);
      external = false;
      s2 = Math.sqrt(+x2);
      if (s2 == 0 || s2 == 1 / 0) {
        n2 = digitsToString(x2.d);
        if ((n2.length + e) % 2 == 0) n2 += "0";
        s2 = Math.sqrt(n2);
        e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
        if (s2 == 1 / 0) {
          n2 = "5e" + e;
        } else {
          n2 = s2.toExponential();
          n2 = n2.slice(0, n2.indexOf("e") + 1) + e;
        }
        r2 = new Ctor(n2);
      } else {
        r2 = new Ctor(s2.toString());
      }
      pr = Ctor.precision;
      s2 = wpr = pr + 3;
      for (; ; ) {
        t2 = r2;
        r2 = t2.plus(divide(x2, t2, wpr + 2)).times(0.5);
        if (digitsToString(t2.d).slice(0, wpr) === (n2 = digitsToString(r2.d)).slice(0, wpr)) {
          n2 = n2.slice(wpr - 3, wpr + 1);
          if (s2 == wpr && n2 == "4999") {
            round(t2, pr + 1, 0);
            if (t2.times(t2).eq(x2)) {
              r2 = t2;
              break;
            }
          } else if (n2 != "9999") {
            break;
          }
          wpr += 4;
        }
      }
      external = true;
      return round(r2, pr);
    };
    P.times = P.mul = function(y2) {
      var carry, e, i, k2, r2, rL, t2, xdL, ydL, x2 = this, Ctor = x2.constructor, xd2 = x2.d, yd2 = (y2 = new Ctor(y2)).d;
      if (!x2.s || !y2.s) return new Ctor(0);
      y2.s *= x2.s;
      e = x2.e + y2.e;
      xdL = xd2.length;
      ydL = yd2.length;
      if (xdL < ydL) {
        r2 = xd2;
        xd2 = yd2;
        yd2 = r2;
        rL = xdL;
        xdL = ydL;
        ydL = rL;
      }
      r2 = [];
      rL = xdL + ydL;
      for (i = rL; i--; ) r2.push(0);
      for (i = ydL; --i >= 0; ) {
        carry = 0;
        for (k2 = xdL + i; k2 > i; ) {
          t2 = r2[k2] + yd2[i] * xd2[k2 - i - 1] + carry;
          r2[k2--] = t2 % BASE | 0;
          carry = t2 / BASE | 0;
        }
        r2[k2] = (r2[k2] + carry) % BASE | 0;
      }
      for (; !r2[--rL]; ) r2.pop();
      if (carry) ++e;
      else r2.shift();
      y2.d = r2;
      y2.e = e;
      return external ? round(y2, Ctor.precision) : y2;
    };
    P.toDecimalPlaces = P.todp = function(dp, rm) {
      var x2 = this, Ctor = x2.constructor;
      x2 = new Ctor(x2);
      if (dp === void 0) return x2;
      checkInt32(dp, 0, MAX_DIGITS);
      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);
      return round(x2, dp + getBase10Exponent(x2) + 1, rm);
    };
    P.toExponential = function(dp, rm) {
      var str, x2 = this, Ctor = x2.constructor;
      if (dp === void 0) {
        str = toString(x2, true);
      } else {
        checkInt32(dp, 0, MAX_DIGITS);
        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);
        x2 = round(new Ctor(x2), dp + 1, rm);
        str = toString(x2, true, dp + 1);
      }
      return str;
    };
    P.toFixed = function(dp, rm) {
      var str, y2, x2 = this, Ctor = x2.constructor;
      if (dp === void 0) return toString(x2);
      checkInt32(dp, 0, MAX_DIGITS);
      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);
      y2 = round(new Ctor(x2), dp + getBase10Exponent(x2) + 1, rm);
      str = toString(y2.abs(), false, dp + getBase10Exponent(y2) + 1);
      return x2.isneg() && !x2.isZero() ? "-" + str : str;
    };
    P.toInteger = P.toint = function() {
      var x2 = this, Ctor = x2.constructor;
      return round(new Ctor(x2), getBase10Exponent(x2) + 1, Ctor.rounding);
    };
    P.toNumber = function() {
      return +this;
    };
    P.toPower = P.pow = function(y2) {
      var e, k2, pr, r2, sign2, yIsInt, x2 = this, Ctor = x2.constructor, guard = 12, yn = +(y2 = new Ctor(y2));
      if (!y2.s) return new Ctor(ONE);
      x2 = new Ctor(x2);
      if (!x2.s) {
        if (y2.s < 1) throw Error(decimalError + "Infinity");
        return x2;
      }
      if (x2.eq(ONE)) return x2;
      pr = Ctor.precision;
      if (y2.eq(ONE)) return round(x2, pr);
      e = y2.e;
      k2 = y2.d.length - 1;
      yIsInt = e >= k2;
      sign2 = x2.s;
      if (!yIsInt) {
        if (sign2 < 0) throw Error(decimalError + "NaN");
      } else if ((k2 = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
        r2 = new Ctor(ONE);
        e = Math.ceil(pr / LOG_BASE + 4);
        external = false;
        for (; ; ) {
          if (k2 % 2) {
            r2 = r2.times(x2);
            truncate(r2.d, e);
          }
          k2 = mathfloor(k2 / 2);
          if (k2 === 0) break;
          x2 = x2.times(x2);
          truncate(x2.d, e);
        }
        external = true;
        return y2.s < 0 ? new Ctor(ONE).div(r2) : round(r2, pr);
      }
      sign2 = sign2 < 0 && y2.d[Math.max(e, k2)] & 1 ? -1 : 1;
      x2.s = 1;
      external = false;
      r2 = y2.times(ln(x2, pr + guard));
      external = true;
      r2 = exp(r2);
      r2.s = sign2;
      return r2;
    };
    P.toPrecision = function(sd2, rm) {
      var e, str, x2 = this, Ctor = x2.constructor;
      if (sd2 === void 0) {
        e = getBase10Exponent(x2);
        str = toString(x2, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
      } else {
        checkInt32(sd2, 1, MAX_DIGITS);
        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);
        x2 = round(new Ctor(x2), sd2, rm);
        e = getBase10Exponent(x2);
        str = toString(x2, sd2 <= e || e <= Ctor.toExpNeg, sd2);
      }
      return str;
    };
    P.toSignificantDigits = P.tosd = function(sd2, rm) {
      var x2 = this, Ctor = x2.constructor;
      if (sd2 === void 0) {
        sd2 = Ctor.precision;
        rm = Ctor.rounding;
      } else {
        checkInt32(sd2, 1, MAX_DIGITS);
        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);
      }
      return round(new Ctor(x2), sd2, rm);
    };
    P.toString = P.valueOf = P.val = P.toJSON = P[Symbol.for("nodejs.util.inspect.custom")] = function() {
      var x2 = this, e = getBase10Exponent(x2), Ctor = x2.constructor;
      return toString(x2, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
    };
    function add(x2, y2) {
      var carry, d, e, i, k2, len, xd2, yd2, Ctor = x2.constructor, pr = Ctor.precision;
      if (!x2.s || !y2.s) {
        if (!y2.s) y2 = new Ctor(x2);
        return external ? round(y2, pr) : y2;
      }
      xd2 = x2.d;
      yd2 = y2.d;
      k2 = x2.e;
      e = y2.e;
      xd2 = xd2.slice();
      i = k2 - e;
      if (i) {
        if (i < 0) {
          d = xd2;
          i = -i;
          len = yd2.length;
        } else {
          d = yd2;
          e = k2;
          len = xd2.length;
        }
        k2 = Math.ceil(pr / LOG_BASE);
        len = k2 > len ? k2 + 1 : len + 1;
        if (i > len) {
          i = len;
          d.length = 1;
        }
        d.reverse();
        for (; i--; ) d.push(0);
        d.reverse();
      }
      len = xd2.length;
      i = yd2.length;
      if (len - i < 0) {
        i = len;
        d = yd2;
        yd2 = xd2;
        xd2 = d;
      }
      for (carry = 0; i; ) {
        carry = (xd2[--i] = xd2[i] + yd2[i] + carry) / BASE | 0;
        xd2[i] %= BASE;
      }
      if (carry) {
        xd2.unshift(carry);
        ++e;
      }
      for (len = xd2.length; xd2[--len] == 0; ) xd2.pop();
      y2.d = xd2;
      y2.e = e;
      return external ? round(y2, pr) : y2;
    }
    function checkInt32(i, min2, max2) {
      if (i !== ~~i || i < min2 || i > max2) {
        throw Error(invalidArgument + i);
      }
    }
    function digitsToString(d) {
      var i, k2, ws, indexOfLastWord = d.length - 1, str = "", w2 = d[0];
      if (indexOfLastWord > 0) {
        str += w2;
        for (i = 1; i < indexOfLastWord; i++) {
          ws = d[i] + "";
          k2 = LOG_BASE - ws.length;
          if (k2) str += getZeroString(k2);
          str += ws;
        }
        w2 = d[i];
        ws = w2 + "";
        k2 = LOG_BASE - ws.length;
        if (k2) str += getZeroString(k2);
      } else if (w2 === 0) {
        return "0";
      }
      for (; w2 % 10 === 0; ) w2 /= 10;
      return str + w2;
    }
    var divide = /* @__PURE__ */ function() {
      function multiplyInteger(x2, k2) {
        var temp, carry = 0, i = x2.length;
        for (x2 = x2.slice(); i--; ) {
          temp = x2[i] * k2 + carry;
          x2[i] = temp % BASE | 0;
          carry = temp / BASE | 0;
        }
        if (carry) x2.unshift(carry);
        return x2;
      }
      function compare(a2, b, aL, bL) {
        var i, r2;
        if (aL != bL) {
          r2 = aL > bL ? 1 : -1;
        } else {
          for (i = r2 = 0; i < aL; i++) {
            if (a2[i] != b[i]) {
              r2 = a2[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }
        return r2;
      }
      function subtract2(a2, b, aL) {
        var i = 0;
        for (; aL--; ) {
          a2[aL] -= i;
          i = a2[aL] < b[aL] ? 1 : 0;
          a2[aL] = i * BASE + a2[aL] - b[aL];
        }
        for (; !a2[0] && a2.length > 1; ) a2.shift();
      }
      return function(x2, y2, pr, dp) {
        var cmp, e, i, k2, prod, prodL, q2, qd2, rem, remL, rem0, sd2, t2, xi2, xL, yd0, yL, yz, Ctor = x2.constructor, sign2 = x2.s == y2.s ? 1 : -1, xd2 = x2.d, yd2 = y2.d;
        if (!x2.s) return new Ctor(x2);
        if (!y2.s) throw Error(decimalError + "Division by zero");
        e = x2.e - y2.e;
        yL = yd2.length;
        xL = xd2.length;
        q2 = new Ctor(sign2);
        qd2 = q2.d = [];
        for (i = 0; yd2[i] == (xd2[i] || 0); ) ++i;
        if (yd2[i] > (xd2[i] || 0)) --e;
        if (pr == null) {
          sd2 = pr = Ctor.precision;
        } else if (dp) {
          sd2 = pr + (getBase10Exponent(x2) - getBase10Exponent(y2)) + 1;
        } else {
          sd2 = pr;
        }
        if (sd2 < 0) return new Ctor(0);
        sd2 = sd2 / LOG_BASE + 2 | 0;
        i = 0;
        if (yL == 1) {
          k2 = 0;
          yd2 = yd2[0];
          sd2++;
          for (; (i < xL || k2) && sd2--; i++) {
            t2 = k2 * BASE + (xd2[i] || 0);
            qd2[i] = t2 / yd2 | 0;
            k2 = t2 % yd2 | 0;
          }
        } else {
          k2 = BASE / (yd2[0] + 1) | 0;
          if (k2 > 1) {
            yd2 = multiplyInteger(yd2, k2);
            xd2 = multiplyInteger(xd2, k2);
            yL = yd2.length;
            xL = xd2.length;
          }
          xi2 = yL;
          rem = xd2.slice(0, yL);
          remL = rem.length;
          for (; remL < yL; ) rem[remL++] = 0;
          yz = yd2.slice();
          yz.unshift(0);
          yd0 = yd2[0];
          if (yd2[1] >= BASE / 2) ++yd0;
          do {
            k2 = 0;
            cmp = compare(yd2, rem, yL, remL);
            if (cmp < 0) {
              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * BASE + (rem[1] || 0);
              k2 = rem0 / yd0 | 0;
              if (k2 > 1) {
                if (k2 >= BASE) k2 = BASE - 1;
                prod = multiplyInteger(yd2, k2);
                prodL = prod.length;
                remL = rem.length;
                cmp = compare(prod, rem, prodL, remL);
                if (cmp == 1) {
                  k2--;
                  subtract2(prod, yL < prodL ? yz : yd2, prodL);
                }
              } else {
                if (k2 == 0) cmp = k2 = 1;
                prod = yd2.slice();
              }
              prodL = prod.length;
              if (prodL < remL) prod.unshift(0);
              subtract2(rem, prod, remL);
              if (cmp == -1) {
                remL = rem.length;
                cmp = compare(yd2, rem, yL, remL);
                if (cmp < 1) {
                  k2++;
                  subtract2(rem, yL < remL ? yz : yd2, remL);
                }
              }
              remL = rem.length;
            } else if (cmp === 0) {
              k2++;
              rem = [0];
            }
            qd2[i++] = k2;
            if (cmp && rem[0]) {
              rem[remL++] = xd2[xi2] || 0;
            } else {
              rem = [xd2[xi2]];
              remL = 1;
            }
          } while ((xi2++ < xL || rem[0] !== void 0) && sd2--);
        }
        if (!qd2[0]) qd2.shift();
        q2.e = e;
        return round(q2, dp ? pr + getBase10Exponent(q2) + 1 : pr);
      };
    }();
    function exp(x2, sd2) {
      var denominator, guard, pow2, sum, t2, wpr, i = 0, k2 = 0, Ctor = x2.constructor, pr = Ctor.precision;
      if (getBase10Exponent(x2) > 16) throw Error(exponentOutOfRange + getBase10Exponent(x2));
      if (!x2.s) return new Ctor(ONE);
      {
        external = false;
        wpr = pr;
      }
      t2 = new Ctor(0.03125);
      while (x2.abs().gte(0.1)) {
        x2 = x2.times(t2);
        k2 += 5;
      }
      guard = Math.log(mathpow(2, k2)) / Math.LN10 * 2 + 5 | 0;
      wpr += guard;
      denominator = pow2 = sum = new Ctor(ONE);
      Ctor.precision = wpr;
      for (; ; ) {
        pow2 = round(pow2.times(x2), wpr);
        denominator = denominator.times(++i);
        t2 = sum.plus(divide(pow2, denominator, wpr));
        if (digitsToString(t2.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
          while (k2--) sum = round(sum.times(sum), wpr);
          Ctor.precision = pr;
          return sd2 == null ? (external = true, round(sum, pr)) : sum;
        }
        sum = t2;
      }
    }
    function getBase10Exponent(x2) {
      var e = x2.e * LOG_BASE, w2 = x2.d[0];
      for (; w2 >= 10; w2 /= 10) e++;
      return e;
    }
    function getLn10(Ctor, sd2, pr) {
      if (sd2 > Ctor.LN10.sd()) {
        external = true;
        if (pr) Ctor.precision = pr;
        throw Error(decimalError + "LN10 precision limit exceeded");
      }
      return round(new Ctor(Ctor.LN10), sd2);
    }
    function getZeroString(k2) {
      var zs = "";
      for (; k2--; ) zs += "0";
      return zs;
    }
    function ln(y2, sd2) {
      var c2, c0, denominator, e, numerator, sum, t2, wpr, x2, n2 = 1, guard = 10, x3 = y2, xd2 = x3.d, Ctor = x3.constructor, pr = Ctor.precision;
      if (x3.s < 1) throw Error(decimalError + (x3.s ? "NaN" : "-Infinity"));
      if (x3.eq(ONE)) return new Ctor(0);
      if (sd2 == null) {
        external = false;
        wpr = pr;
      } else {
        wpr = sd2;
      }
      if (x3.eq(10)) {
        if (sd2 == null) external = true;
        return getLn10(Ctor, wpr);
      }
      wpr += guard;
      Ctor.precision = wpr;
      c2 = digitsToString(xd2);
      c0 = c2.charAt(0);
      e = getBase10Exponent(x3);
      if (Math.abs(e) < 15e14) {
        while (c0 < 7 && c0 != 1 || c0 == 1 && c2.charAt(1) > 3) {
          x3 = x3.times(y2);
          c2 = digitsToString(x3.d);
          c0 = c2.charAt(0);
          n2++;
        }
        e = getBase10Exponent(x3);
        if (c0 > 1) {
          x3 = new Ctor("0." + c2);
          e++;
        } else {
          x3 = new Ctor(c0 + "." + c2.slice(1));
        }
      } else {
        t2 = getLn10(Ctor, wpr + 2, pr).times(e + "");
        x3 = ln(new Ctor(c0 + "." + c2.slice(1)), wpr - guard).plus(t2);
        Ctor.precision = pr;
        return sd2 == null ? (external = true, round(x3, pr)) : x3;
      }
      sum = numerator = x3 = divide(x3.minus(ONE), x3.plus(ONE), wpr);
      x2 = round(x3.times(x3), wpr);
      denominator = 3;
      for (; ; ) {
        numerator = round(numerator.times(x2), wpr);
        t2 = sum.plus(divide(numerator, new Ctor(denominator), wpr));
        if (digitsToString(t2.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
          sum = sum.times(2);
          if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
          sum = divide(sum, new Ctor(n2), wpr);
          Ctor.precision = pr;
          return sd2 == null ? (external = true, round(sum, pr)) : sum;
        }
        sum = t2;
        denominator += 2;
      }
    }
    function parseDecimal(x2, str) {
      var e, i, len;
      if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
      if ((i = str.search(/e/i)) > 0) {
        if (e < 0) e = i;
        e += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e < 0) {
        e = str.length;
      }
      for (i = 0; str.charCodeAt(i) === 48; ) ++i;
      for (len = str.length; str.charCodeAt(len - 1) === 48; ) --len;
      str = str.slice(i, len);
      if (str) {
        len -= i;
        e = e - i - 1;
        x2.e = mathfloor(e / LOG_BASE);
        x2.d = [];
        i = (e + 1) % LOG_BASE;
        if (e < 0) i += LOG_BASE;
        if (i < len) {
          if (i) x2.d.push(+str.slice(0, i));
          for (len -= LOG_BASE; i < len; ) x2.d.push(+str.slice(i, i += LOG_BASE));
          str = str.slice(i);
          i = LOG_BASE - str.length;
        } else {
          i -= len;
        }
        for (; i--; ) str += "0";
        x2.d.push(+str);
        if (external && (x2.e > MAX_E || x2.e < -MAX_E)) throw Error(exponentOutOfRange + e);
      } else {
        x2.s = 0;
        x2.e = 0;
        x2.d = [0];
      }
      return x2;
    }
    function round(x2, sd2, rm) {
      var i, j, k2, n2, rd2, doRound, w2, xdi, xd2 = x2.d;
      for (n2 = 1, k2 = xd2[0]; k2 >= 10; k2 /= 10) n2++;
      i = sd2 - n2;
      if (i < 0) {
        i += LOG_BASE;
        j = sd2;
        w2 = xd2[xdi = 0];
      } else {
        xdi = Math.ceil((i + 1) / LOG_BASE);
        k2 = xd2.length;
        if (xdi >= k2) return x2;
        w2 = k2 = xd2[xdi];
        for (n2 = 1; k2 >= 10; k2 /= 10) n2++;
        i %= LOG_BASE;
        j = i - LOG_BASE + n2;
      }
      if (rm !== void 0) {
        k2 = mathpow(10, n2 - j - 1);
        rd2 = w2 / k2 % 10 | 0;
        doRound = sd2 < 0 || xd2[xdi + 1] !== void 0 || w2 % k2;
        doRound = rm < 4 ? (rd2 || doRound) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd2 > 5 || rd2 == 5 && (rm == 4 || doRound || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i > 0 ? j > 0 ? w2 / mathpow(10, n2 - j) : 0 : xd2[xdi - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
      }
      if (sd2 < 1 || !xd2[0]) {
        if (doRound) {
          k2 = getBase10Exponent(x2);
          xd2.length = 1;
          sd2 = sd2 - k2 - 1;
          xd2[0] = mathpow(10, (LOG_BASE - sd2 % LOG_BASE) % LOG_BASE);
          x2.e = mathfloor(-sd2 / LOG_BASE) || 0;
        } else {
          xd2.length = 1;
          xd2[0] = x2.e = x2.s = 0;
        }
        return x2;
      }
      if (i == 0) {
        xd2.length = xdi;
        k2 = 1;
        xdi--;
      } else {
        xd2.length = xdi + 1;
        k2 = mathpow(10, LOG_BASE - i);
        xd2[xdi] = j > 0 ? (w2 / mathpow(10, n2 - j) % mathpow(10, j) | 0) * k2 : 0;
      }
      if (doRound) {
        for (; ; ) {
          if (xdi == 0) {
            if ((xd2[0] += k2) == BASE) {
              xd2[0] = 1;
              ++x2.e;
            }
            break;
          } else {
            xd2[xdi] += k2;
            if (xd2[xdi] != BASE) break;
            xd2[xdi--] = 0;
            k2 = 1;
          }
        }
      }
      for (i = xd2.length; xd2[--i] === 0; ) xd2.pop();
      if (external && (x2.e > MAX_E || x2.e < -MAX_E)) {
        throw Error(exponentOutOfRange + getBase10Exponent(x2));
      }
      return x2;
    }
    function subtract(x2, y2) {
      var d, e, i, j, k2, len, xd2, xe2, xLTy, yd2, Ctor = x2.constructor, pr = Ctor.precision;
      if (!x2.s || !y2.s) {
        if (y2.s) y2.s = -y2.s;
        else y2 = new Ctor(x2);
        return external ? round(y2, pr) : y2;
      }
      xd2 = x2.d;
      yd2 = y2.d;
      e = y2.e;
      xe2 = x2.e;
      xd2 = xd2.slice();
      k2 = xe2 - e;
      if (k2) {
        xLTy = k2 < 0;
        if (xLTy) {
          d = xd2;
          k2 = -k2;
          len = yd2.length;
        } else {
          d = yd2;
          e = xe2;
          len = xd2.length;
        }
        i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
        if (k2 > i) {
          k2 = i;
          d.length = 1;
        }
        d.reverse();
        for (i = k2; i--; ) d.push(0);
        d.reverse();
      } else {
        i = xd2.length;
        len = yd2.length;
        xLTy = i < len;
        if (xLTy) len = i;
        for (i = 0; i < len; i++) {
          if (xd2[i] != yd2[i]) {
            xLTy = xd2[i] < yd2[i];
            break;
          }
        }
        k2 = 0;
      }
      if (xLTy) {
        d = xd2;
        xd2 = yd2;
        yd2 = d;
        y2.s = -y2.s;
      }
      len = xd2.length;
      for (i = yd2.length - len; i > 0; --i) xd2[len++] = 0;
      for (i = yd2.length; i > k2; ) {
        if (xd2[--i] < yd2[i]) {
          for (j = i; j && xd2[--j] === 0; ) xd2[j] = BASE - 1;
          --xd2[j];
          xd2[i] += BASE;
        }
        xd2[i] -= yd2[i];
      }
      for (; xd2[--len] === 0; ) xd2.pop();
      for (; xd2[0] === 0; xd2.shift()) --e;
      if (!xd2[0]) return new Ctor(0);
      y2.d = xd2;
      y2.e = e;
      return external ? round(y2, pr) : y2;
    }
    function toString(x2, isExp, sd2) {
      var k2, e = getBase10Exponent(x2), str = digitsToString(x2.d), len = str.length;
      if (isExp) {
        if (sd2 && (k2 = sd2 - len) > 0) {
          str = str.charAt(0) + "." + str.slice(1) + getZeroString(k2);
        } else if (len > 1) {
          str = str.charAt(0) + "." + str.slice(1);
        }
        str = str + (e < 0 ? "e" : "e+") + e;
      } else if (e < 0) {
        str = "0." + getZeroString(-e - 1) + str;
        if (sd2 && (k2 = sd2 - len) > 0) str += getZeroString(k2);
      } else if (e >= len) {
        str += getZeroString(e + 1 - len);
        if (sd2 && (k2 = sd2 - e - 1) > 0) str = str + "." + getZeroString(k2);
      } else {
        if ((k2 = e + 1) < len) str = str.slice(0, k2) + "." + str.slice(k2);
        if (sd2 && (k2 = sd2 - len) > 0) {
          if (e + 1 === len) str += ".";
          str += getZeroString(k2);
        }
      }
      return x2.s < 0 ? "-" + str : str;
    }
    function truncate(arr, len) {
      if (arr.length > len) {
        arr.length = len;
        return true;
      }
    }
    function clone(obj) {
      var i, p2, ps;
      function Decimal2(value) {
        var x2 = this;
        if (!(x2 instanceof Decimal2)) return new Decimal2(value);
        x2.constructor = Decimal2;
        if (value instanceof Decimal2) {
          x2.s = value.s;
          x2.e = value.e;
          x2.d = (value = value.d) ? value.slice() : value;
          return;
        }
        if (typeof value === "number") {
          if (value * 0 !== 0) {
            throw Error(invalidArgument + value);
          }
          if (value > 0) {
            x2.s = 1;
          } else if (value < 0) {
            value = -value;
            x2.s = -1;
          } else {
            x2.s = 0;
            x2.e = 0;
            x2.d = [0];
            return;
          }
          if (value === ~~value && value < 1e7) {
            x2.e = 0;
            x2.d = [value];
            return;
          }
          return parseDecimal(x2, value.toString());
        } else if (typeof value !== "string") {
          throw Error(invalidArgument + value);
        }
        if (value.charCodeAt(0) === 45) {
          value = value.slice(1);
          x2.s = -1;
        } else {
          x2.s = 1;
        }
        if (isDecimal.test(value)) parseDecimal(x2, value);
        else throw Error(invalidArgument + value);
      }
      Decimal2.prototype = P;
      Decimal2.ROUND_UP = 0;
      Decimal2.ROUND_DOWN = 1;
      Decimal2.ROUND_CEIL = 2;
      Decimal2.ROUND_FLOOR = 3;
      Decimal2.ROUND_HALF_UP = 4;
      Decimal2.ROUND_HALF_DOWN = 5;
      Decimal2.ROUND_HALF_EVEN = 6;
      Decimal2.ROUND_HALF_CEIL = 7;
      Decimal2.ROUND_HALF_FLOOR = 8;
      Decimal2.clone = clone;
      Decimal2.config = Decimal2.set = config;
      if (obj === void 0) obj = {};
      if (obj) {
        ps = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"];
        for (i = 0; i < ps.length; ) if (!obj.hasOwnProperty(p2 = ps[i++])) obj[p2] = this[p2];
      }
      Decimal2.config(obj);
      return Decimal2;
    }
    function config(obj) {
      if (!obj || typeof obj !== "object") {
        throw Error(decimalError + "Object expected");
      }
      var i, p2, v2, ps = [
        "precision",
        1,
        MAX_DIGITS,
        "rounding",
        0,
        8,
        "toExpNeg",
        -1 / 0,
        0,
        "toExpPos",
        0,
        1 / 0
      ];
      for (i = 0; i < ps.length; i += 3) {
        if ((v2 = obj[p2 = ps[i]]) !== void 0) {
          if (mathfloor(v2) === v2 && v2 >= ps[i + 1] && v2 <= ps[i + 2]) this[p2] = v2;
          else throw Error(invalidArgument + p2 + ": " + v2);
        }
      }
      if ((v2 = obj[p2 = "LN10"]) !== void 0) {
        if (v2 == Math.LN10) this[p2] = new this(v2);
        else throw Error(invalidArgument + p2 + ": " + v2);
      }
      return this;
    }
    var Decimal = clone(defaults);
    ONE = new Decimal(1);
    const Decimal$1 = Decimal;
    var identity = (i) => i;
    var PLACE_HOLDER = {};
    var isPlaceHolder = (val) => val === PLACE_HOLDER;
    var curry0 = (fn) => function _curried() {
      if (arguments.length === 0 || arguments.length === 1 && isPlaceHolder(arguments.length <= 0 ? void 0 : arguments[0])) {
        return _curried;
      }
      return fn(...arguments);
    };
    var curryN = (n2, fn) => {
      if (n2 === 1) {
        return fn;
      }
      return curry0(function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var argsLength = args.filter((arg) => arg !== PLACE_HOLDER).length;
        if (argsLength >= n2) {
          return fn(...args);
        }
        return curryN(n2 - argsLength, curry0(function() {
          for (var _len2 = arguments.length, restArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            restArgs[_key2] = arguments[_key2];
          }
          var newArgs = args.map((arg) => isPlaceHolder(arg) ? restArgs.shift() : arg);
          return fn(...newArgs, ...restArgs);
        }));
      });
    };
    var curry = (fn) => curryN(fn.length, fn);
    var range = (begin, end) => {
      var arr = [];
      for (var i = begin; i < end; ++i) {
        arr[i - begin] = i;
      }
      return arr;
    };
    var map = curry((fn, arr) => {
      if (Array.isArray(arr)) {
        return arr.map(fn);
      }
      return Object.keys(arr).map((key) => arr[key]).map(fn);
    });
    var compose = function compose2() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      if (!args.length) {
        return identity;
      }
      var fns = args.reverse();
      var firstFn = fns[0];
      var tailsFn = fns.slice(1);
      return function() {
        return tailsFn.reduce((res, fn) => fn(res), firstFn(...arguments));
      };
    };
    var reverse = (arr) => {
      if (Array.isArray(arr)) {
        return arr.reverse();
      }
      return arr.split("").reverse().join("");
    };
    function getDigitCount(value) {
      var result;
      if (value === 0) {
        result = 1;
      } else {
        result = Math.floor(new Decimal$1(value).abs().log(10).toNumber()) + 1;
      }
      return result;
    }
    function rangeStep(start, end, step) {
      var num = new Decimal$1(start);
      var i = 0;
      var result = [];
      while (num.lt(end) && i < 1e5) {
        result.push(num.toNumber());
        num = num.add(step);
        i++;
      }
      return result;
    }
    var getValidInterval = (_ref2) => {
      var [min2, max2] = _ref2;
      var [validMin, validMax] = [min2, max2];
      if (min2 > max2) {
        [validMin, validMax] = [max2, min2];
      }
      return [validMin, validMax];
    };
    var getFormatStep = (roughStep, allowDecimals, correctionFactor) => {
      if (roughStep.lte(0)) {
        return new Decimal$1(0);
      }
      var digitCount = getDigitCount(roughStep.toNumber());
      var digitCountValue = new Decimal$1(10).pow(digitCount);
      var stepRatio = roughStep.div(digitCountValue);
      var stepRatioScale = digitCount !== 1 ? 0.05 : 0.1;
      var amendStepRatio = new Decimal$1(Math.ceil(stepRatio.div(stepRatioScale).toNumber())).add(correctionFactor).mul(stepRatioScale);
      var formatStep = amendStepRatio.mul(digitCountValue);
      return allowDecimals ? new Decimal$1(formatStep.toNumber()) : new Decimal$1(Math.ceil(formatStep.toNumber()));
    };
    var getTickOfSingleValue = (value, tickCount, allowDecimals) => {
      var step = new Decimal$1(1);
      var middle = new Decimal$1(value);
      if (!middle.isint() && allowDecimals) {
        var absVal = Math.abs(value);
        if (absVal < 1) {
          step = new Decimal$1(10).pow(getDigitCount(value) - 1);
          middle = new Decimal$1(Math.floor(middle.div(step).toNumber())).mul(step);
        } else if (absVal > 1) {
          middle = new Decimal$1(Math.floor(value));
        }
      } else if (value === 0) {
        middle = new Decimal$1(Math.floor((tickCount - 1) / 2));
      } else if (!allowDecimals) {
        middle = new Decimal$1(Math.floor(value));
      }
      var middleIndex = Math.floor((tickCount - 1) / 2);
      var fn = compose(map((n2) => middle.add(new Decimal$1(n2 - middleIndex).mul(step)).toNumber()), range);
      return fn(0, tickCount);
    };
    var _calculateStep = function calculateStep(min2, max2, tickCount, allowDecimals) {
      var correctionFactor = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
      if (!Number.isFinite((max2 - min2) / (tickCount - 1))) {
        return {
          step: new Decimal$1(0),
          tickMin: new Decimal$1(0),
          tickMax: new Decimal$1(0)
        };
      }
      var step = getFormatStep(new Decimal$1(max2).sub(min2).div(tickCount - 1), allowDecimals, correctionFactor);
      var middle;
      if (min2 <= 0 && max2 >= 0) {
        middle = new Decimal$1(0);
      } else {
        middle = new Decimal$1(min2).add(max2).div(2);
        middle = middle.sub(new Decimal$1(middle).mod(step));
      }
      var belowCount = Math.ceil(middle.sub(min2).div(step).toNumber());
      var upCount = Math.ceil(new Decimal$1(max2).sub(middle).div(step).toNumber());
      var scaleCount = belowCount + upCount + 1;
      if (scaleCount > tickCount) {
        return _calculateStep(min2, max2, tickCount, allowDecimals, correctionFactor + 1);
      }
      if (scaleCount < tickCount) {
        upCount = max2 > 0 ? upCount + (tickCount - scaleCount) : upCount;
        belowCount = max2 > 0 ? belowCount : belowCount + (tickCount - scaleCount);
      }
      return {
        step,
        tickMin: middle.sub(new Decimal$1(belowCount).mul(step)),
        tickMax: middle.add(new Decimal$1(upCount).mul(step))
      };
    };
    var getNiceTickValues = function getNiceTickValues2(_ref2) {
      var [min2, max2] = _ref2;
      var tickCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6;
      var allowDecimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var count = Math.max(tickCount, 2);
      var [cormin, cormax] = getValidInterval([min2, max2]);
      if (cormin === -Infinity || cormax === Infinity) {
        var _values = cormax === Infinity ? [cormin, ...range(0, tickCount - 1).map(() => Infinity)] : [...range(0, tickCount - 1).map(() => -Infinity), cormax];
        return min2 > max2 ? reverse(_values) : _values;
      }
      if (cormin === cormax) {
        return getTickOfSingleValue(cormin, tickCount, allowDecimals);
      }
      var {
        step,
        tickMin,
        tickMax
      } = _calculateStep(cormin, cormax, count, allowDecimals, 0);
      var values = rangeStep(tickMin, tickMax.add(new Decimal$1(0.1).mul(step)), step);
      return min2 > max2 ? reverse(values) : values;
    };
    var getTickValuesFixedDomain = function getTickValuesFixedDomain2(_ref3, tickCount) {
      var [min2, max2] = _ref3;
      var allowDecimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var [cormin, cormax] = getValidInterval([min2, max2]);
      if (cormin === -Infinity || cormax === Infinity) {
        return [min2, max2];
      }
      if (cormin === cormax) {
        return [cormin];
      }
      var count = Math.max(tickCount, 2);
      var step = getFormatStep(new Decimal$1(cormax).sub(cormin).div(count - 1), allowDecimals, 0);
      var values = [...rangeStep(new Decimal$1(cormin), new Decimal$1(cormax), step), cormax];
      if (allowDecimals === false) {
        values = values.map((value) => Math.round(value));
      }
      return min2 > max2 ? reverse(values) : values;
    };
    var selectRootMaxBarSize = (state) => state.rootProps.maxBarSize;
    var selectBarGap = (state) => state.rootProps.barGap;
    var selectBarCategoryGap = (state) => state.rootProps.barCategoryGap;
    var selectRootBarSize = (state) => state.rootProps.barSize;
    var selectStackOffsetType = (state) => state.rootProps.stackOffset;
    var selectReverseStackOrder = (state) => state.rootProps.reverseStackOrder;
    var selectChartName = (state) => state.options.chartName;
    var selectSyncId = (state) => state.rootProps.syncId;
    var selectSyncMethod = (state) => state.rootProps.syncMethod;
    var selectEventEmitter = (state) => state.options.eventEmitter;
    var selectChartBaseValue = (state) => state.rootProps.baseValue;
    var DefaultZIndexes = {
      /**
       * CartesianGrid and PolarGrid
       */
      grid: -100,
      /**
       * Background of Bar and RadialBar.
       * This is not visible by default but can be enabled by setting background={true} on Bar or RadialBar.
       */
      barBackground: -50,
      /*
       * other chart elements or custom elements without specific zIndex
       * render in here, at zIndex 0
       */
      /**
       * Area, Pie, Radar, and ReferenceArea
       */
      area: 100,
      /**
       * Cursor is embedded inside Tooltip and controlled by it.
       * The Tooltip itself has a separate portal and is not included in the zIndex system;
       * Cursor is the decoration inside the chart area. CursorRectangle is a rectangle box.
       * It renders below bar so that in a stacked bar chart the cursor rectangle does not hide the other bars.
       */
      cursorRectangle: 200,
      /**
       * Bar and RadialBar
       */
      bar: 300,
      /**
       * Line and ReferenceLine, and ErrorBor
       */
      line: 400,
      /**
       * XAxis and YAxis and PolarAngleAxis and PolarRadiusAxis ticks and lines and children
       */
      axis: 500,
      /**
       * Scatter and ReferenceDot,
       * and Dots of Line and Area and Radar if they have dot=true
       */
      scatter: 600,
      /**
       * Hovering over a Bar or RadialBar renders a highlight rectangle
       */
      activeBar: 1e3,
      /**
       * Cursor is embedded inside Tooltip and controlled by it.
       * The Tooltip itself has a separate portal and is not included in the zIndex system;
       * Cursor is the decoration inside the chart area, usually a cross or a box.
       * CursorLine is a line cursor rendered in Line, Area, Scatter, Radar charts.
       * It renders above the Line and Scatter so that it is always visible.
       * It renders below active dot so that the dot is always visible and shows the current point.
       * We're also assuming that the active dot is small enough that it does not fully cover the cursor line.
       *
       * This also applies to the radial cursor in RadialBarChart.
       */
      cursorLine: 1100,
      /**
       * Hovering over a Point in Line, Area, Scatter, Radar renders a highlight dot
       */
      activeDot: 1200,
      /**
       * LabelList and Label, including Axis labels
       */
      label: 2e3
    };
    var defaultPolarAngleAxisProps = {
      allowDuplicatedCategory: true,
      // if I set this to false then Tooltip synchronisation stops working in Radar, wtf
      angleAxisId: 0,
      reversed: false,
      scale: "auto",
      tick: true,
      type: "category"
    };
    var defaultPolarRadiusAxisProps = {
      allowDataOverflow: false,
      allowDuplicatedCategory: true,
      radiusAxisId: 0,
      scale: "auto",
      tick: true,
      tickCount: 5,
      type: "number"
    };
    var combineAxisRangeWithReverse = (axisSettings, axisRange) => {
      if (!axisSettings || !axisRange) {
        return void 0;
      }
      if (axisSettings !== null && axisSettings !== void 0 && axisSettings.reversed) {
        return [axisRange[1], axisRange[0]];
      }
      return axisRange;
    };
    var implicitAngleAxis = {
      allowDataOverflow: false,
      allowDecimals: false,
      allowDuplicatedCategory: false,
      // defaultPolarAngleAxisProps.allowDuplicatedCategory has it set to true but the actual axis rendering ignores the prop because reasons,
      dataKey: void 0,
      domain: void 0,
      id: defaultPolarAngleAxisProps.angleAxisId,
      includeHidden: false,
      name: void 0,
      reversed: defaultPolarAngleAxisProps.reversed,
      scale: defaultPolarAngleAxisProps.scale,
      tick: defaultPolarAngleAxisProps.tick,
      tickCount: void 0,
      ticks: void 0,
      type: defaultPolarAngleAxisProps.type,
      unit: void 0
    };
    var implicitRadiusAxis = {
      allowDataOverflow: defaultPolarRadiusAxisProps.allowDataOverflow,
      allowDecimals: false,
      allowDuplicatedCategory: defaultPolarRadiusAxisProps.allowDuplicatedCategory,
      dataKey: void 0,
      domain: void 0,
      id: defaultPolarRadiusAxisProps.radiusAxisId,
      includeHidden: false,
      name: void 0,
      reversed: false,
      scale: defaultPolarRadiusAxisProps.scale,
      tick: defaultPolarRadiusAxisProps.tick,
      tickCount: defaultPolarRadiusAxisProps.tickCount,
      ticks: void 0,
      type: defaultPolarRadiusAxisProps.type,
      unit: void 0
    };
    var implicitRadialBarAngleAxis = {
      allowDataOverflow: false,
      allowDecimals: false,
      allowDuplicatedCategory: defaultPolarAngleAxisProps.allowDuplicatedCategory,
      dataKey: void 0,
      domain: void 0,
      id: defaultPolarAngleAxisProps.angleAxisId,
      includeHidden: false,
      name: void 0,
      reversed: false,
      scale: defaultPolarAngleAxisProps.scale,
      tick: defaultPolarAngleAxisProps.tick,
      tickCount: void 0,
      ticks: void 0,
      type: "number",
      unit: void 0
    };
    var implicitRadialBarRadiusAxis = {
      allowDataOverflow: defaultPolarRadiusAxisProps.allowDataOverflow,
      allowDecimals: false,
      allowDuplicatedCategory: defaultPolarRadiusAxisProps.allowDuplicatedCategory,
      dataKey: void 0,
      domain: void 0,
      id: defaultPolarRadiusAxisProps.radiusAxisId,
      includeHidden: false,
      name: void 0,
      reversed: false,
      scale: defaultPolarRadiusAxisProps.scale,
      tick: defaultPolarRadiusAxisProps.tick,
      tickCount: defaultPolarRadiusAxisProps.tickCount,
      ticks: void 0,
      type: "category",
      unit: void 0
    };
    var selectAngleAxis = (state, angleAxisId) => {
      if (state.polarAxis.angleAxis[angleAxisId] != null) {
        return state.polarAxis.angleAxis[angleAxisId];
      }
      if (state.layout.layoutType === "radial") {
        return implicitRadialBarAngleAxis;
      }
      return implicitAngleAxis;
    };
    var selectRadiusAxis = (state, radiusAxisId) => {
      if (state.polarAxis.radiusAxis[radiusAxisId] != null) {
        return state.polarAxis.radiusAxis[radiusAxisId];
      }
      if (state.layout.layoutType === "radial") {
        return implicitRadialBarRadiusAxis;
      }
      return implicitRadiusAxis;
    };
    var selectPolarOptions = (state) => state.polarOptions;
    var selectMaxRadius = createSelector([selectChartWidth, selectChartHeight, selectChartOffsetInternal], getMaxRadius);
    var selectInnerRadius = createSelector([selectPolarOptions, selectMaxRadius], (polarChartOptions, maxRadius) => {
      if (polarChartOptions == null) {
        return void 0;
      }
      return getPercentValue(polarChartOptions.innerRadius, maxRadius, 0);
    });
    var selectOuterRadius = createSelector([selectPolarOptions, selectMaxRadius], (polarChartOptions, maxRadius) => {
      if (polarChartOptions == null) {
        return void 0;
      }
      return getPercentValue(polarChartOptions.outerRadius, maxRadius, maxRadius * 0.8);
    });
    var combineAngleAxisRange = (polarOptions) => {
      if (polarOptions == null) {
        return [0, 0];
      }
      var {
        startAngle,
        endAngle
      } = polarOptions;
      return [startAngle, endAngle];
    };
    var selectAngleAxisRange = createSelector([selectPolarOptions], combineAngleAxisRange);
    createSelector([selectAngleAxis, selectAngleAxisRange], combineAxisRangeWithReverse);
    var selectRadiusAxisRange = createSelector([selectMaxRadius, selectInnerRadius, selectOuterRadius], (maxRadius, innerRadius, outerRadius) => {
      if (maxRadius == null || innerRadius == null || outerRadius == null) {
        return void 0;
      }
      return [innerRadius, outerRadius];
    });
    createSelector([selectRadiusAxis, selectRadiusAxisRange], combineAxisRangeWithReverse);
    var selectPolarViewBox = createSelector([selectChartLayout, selectPolarOptions, selectInnerRadius, selectOuterRadius, selectChartWidth, selectChartHeight], (layout, polarOptions, innerRadius, outerRadius, width, height) => {
      if (layout !== "centric" && layout !== "radial" || polarOptions == null || innerRadius == null || outerRadius == null) {
        return void 0;
      }
      var {
        cx,
        cy,
        startAngle,
        endAngle
      } = polarOptions;
      return {
        cx: getPercentValue(cx, width, width / 2),
        cy: getPercentValue(cy, height, height / 2),
        innerRadius,
        outerRadius,
        startAngle,
        endAngle,
        clockWise: false
        // this property look useful, why not use it?
      };
    });
    var pickAxisType = (_state, axisType) => axisType;
    var pickAxisId = (_state, _axisType, axisId) => axisId;
    function getStackSeriesIdentifier(graphicalItem) {
      return graphicalItem === null || graphicalItem === void 0 ? void 0 : graphicalItem.id;
    }
    function combineDisplayedStackedData(stackedGraphicalItems, _ref2, tooltipAxisSettings) {
      var {
        chartData = []
      } = _ref2;
      var {
        allowDuplicatedCategory,
        dataKey: tooltipDataKey
      } = tooltipAxisSettings;
      var knownItemsByDataKey = /* @__PURE__ */ new Map();
      stackedGraphicalItems.forEach((item) => {
        var _item$data;
        var resolvedData = (_item$data = item.data) !== null && _item$data !== void 0 ? _item$data : chartData;
        if (resolvedData == null || resolvedData.length === 0) {
          return;
        }
        var stackIdentifier = getStackSeriesIdentifier(item);
        resolvedData.forEach((entry, index) => {
          var tooltipValue = tooltipDataKey == null || allowDuplicatedCategory ? index : String(getValueByDataKey(entry, tooltipDataKey, null));
          var numericValue = getValueByDataKey(entry, item.dataKey, 0);
          var curr;
          if (knownItemsByDataKey.has(tooltipValue)) {
            curr = knownItemsByDataKey.get(tooltipValue);
          } else {
            curr = {};
          }
          Object.assign(curr, {
            [stackIdentifier]: numericValue
          });
          knownItemsByDataKey.set(tooltipValue, curr);
        });
      });
      return Array.from(knownItemsByDataKey.values());
    }
    function isStacked(graphicalItem) {
      return graphicalItem.stackId != null && graphicalItem.dataKey != null;
    }
    var numberDomainEqualityCheck = (a2, b) => {
      if (a2 === b) {
        return true;
      }
      if (a2 == null || b == null) {
        return false;
      }
      return a2[0] === b[0] && a2[1] === b[1];
    };
    function emptyArraysAreEqualCheck(a2, b) {
      if (Array.isArray(a2) && Array.isArray(b) && a2.length === 0 && b.length === 0) {
        return true;
      }
      return a2 === b;
    }
    function arrayContentsAreEqualCheck(a2, b) {
      if (a2.length === b.length) {
        for (var i = 0; i < a2.length; i++) {
          if (a2[i] !== b[i]) {
            return false;
          }
        }
        return true;
      }
      return false;
    }
    var selectTooltipAxisType = (state) => {
      var layout = selectChartLayout(state);
      if (layout === "horizontal") {
        return "xAxis";
      }
      if (layout === "vertical") {
        return "yAxis";
      }
      if (layout === "centric") {
        return "angleAxis";
      }
      return "radiusAxis";
    };
    var selectTooltipAxisId = (state) => state.tooltip.settings.axisId;
    function ownKeys$r(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$r(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$r(Object(t2), true).forEach(function(r3) {
          _defineProperty$t(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$r(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$t(e, r2, t2) {
      return (r2 = _toPropertyKey$t(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$t(t2) {
      var i = _toPrimitive$t(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$t(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    var defaultNumericDomain = [0, "auto"];
    var implicitXAxis = {
      allowDataOverflow: false,
      allowDecimals: true,
      allowDuplicatedCategory: true,
      angle: 0,
      dataKey: void 0,
      domain: void 0,
      height: 30,
      hide: true,
      id: 0,
      includeHidden: false,
      interval: "preserveEnd",
      minTickGap: 5,
      mirror: false,
      name: void 0,
      orientation: "bottom",
      padding: {
        left: 0,
        right: 0
      },
      reversed: false,
      scale: "auto",
      tick: true,
      tickCount: 5,
      tickFormatter: void 0,
      ticks: void 0,
      type: "category",
      unit: void 0
    };
    var selectXAxisSettingsNoDefaults = (state, axisId) => {
      return state.cartesianAxis.xAxis[axisId];
    };
    var selectXAxisSettings = (state, axisId) => {
      var axis = selectXAxisSettingsNoDefaults(state, axisId);
      if (axis == null) {
        return implicitXAxis;
      }
      return axis;
    };
    var implicitYAxis = {
      allowDataOverflow: false,
      allowDecimals: true,
      allowDuplicatedCategory: true,
      angle: 0,
      dataKey: void 0,
      domain: defaultNumericDomain,
      hide: true,
      id: 0,
      includeHidden: false,
      interval: "preserveEnd",
      minTickGap: 5,
      mirror: false,
      name: void 0,
      orientation: "left",
      padding: {
        top: 0,
        bottom: 0
      },
      reversed: false,
      scale: "auto",
      tick: true,
      tickCount: 5,
      tickFormatter: void 0,
      ticks: void 0,
      type: "number",
      unit: void 0,
      width: DEFAULT_Y_AXIS_WIDTH
    };
    var selectYAxisSettingsNoDefaults = (state, axisId) => {
      return state.cartesianAxis.yAxis[axisId];
    };
    var selectYAxisSettings = (state, axisId) => {
      var axis = selectYAxisSettingsNoDefaults(state, axisId);
      if (axis == null) {
        return implicitYAxis;
      }
      return axis;
    };
    var implicitZAxis = {
      domain: [0, "auto"],
      includeHidden: false,
      reversed: false,
      allowDataOverflow: false,
      allowDuplicatedCategory: false,
      dataKey: void 0,
      id: 0,
      name: "",
      range: [64, 64],
      scale: "auto",
      type: "number",
      unit: ""
    };
    var selectZAxisSettings = (state, axisId) => {
      var axis = state.cartesianAxis.zAxis[axisId];
      if (axis == null) {
        return implicitZAxis;
      }
      return axis;
    };
    var selectBaseAxis = (state, axisType, axisId) => {
      switch (axisType) {
        case "xAxis": {
          return selectXAxisSettings(state, axisId);
        }
        case "yAxis": {
          return selectYAxisSettings(state, axisId);
        }
        case "zAxis": {
          return selectZAxisSettings(state, axisId);
        }
        case "angleAxis": {
          return selectAngleAxis(state, axisId);
        }
        case "radiusAxis": {
          return selectRadiusAxis(state, axisId);
        }
        default:
          throw new Error("Unexpected axis type: ".concat(axisType));
      }
    };
    var selectCartesianAxisSettings = (state, axisType, axisId) => {
      switch (axisType) {
        case "xAxis": {
          return selectXAxisSettings(state, axisId);
        }
        case "yAxis": {
          return selectYAxisSettings(state, axisId);
        }
        default:
          throw new Error("Unexpected axis type: ".concat(axisType));
      }
    };
    var selectAxisSettings = (state, axisType, axisId) => {
      switch (axisType) {
        case "xAxis": {
          return selectXAxisSettings(state, axisId);
        }
        case "yAxis": {
          return selectYAxisSettings(state, axisId);
        }
        case "angleAxis": {
          return selectAngleAxis(state, axisId);
        }
        case "radiusAxis": {
          return selectRadiusAxis(state, axisId);
        }
        default:
          throw new Error("Unexpected axis type: ".concat(axisType));
      }
    };
    var selectHasBar = (state) => state.graphicalItems.cartesianItems.some((item) => item.type === "bar") || state.graphicalItems.polarItems.some((item) => item.type === "radialBar");
    function itemAxisPredicate(axisType, axisId) {
      return (item) => {
        switch (axisType) {
          case "xAxis":
            return "xAxisId" in item && item.xAxisId === axisId;
          case "yAxis":
            return "yAxisId" in item && item.yAxisId === axisId;
          case "zAxis":
            return "zAxisId" in item && item.zAxisId === axisId;
          case "angleAxis":
            return "angleAxisId" in item && item.angleAxisId === axisId;
          case "radiusAxis":
            return "radiusAxisId" in item && item.radiusAxisId === axisId;
          default:
            return false;
        }
      };
    }
    var selectUnfilteredCartesianItems = (state) => state.graphicalItems.cartesianItems;
    var selectAxisPredicate$1 = createSelector([pickAxisType, pickAxisId], itemAxisPredicate);
    var combineGraphicalItemsSettings = (graphicalItems, axisSettings, axisPredicate) => graphicalItems.filter(axisPredicate).filter((item) => {
      if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.includeHidden) === true) {
        return true;
      }
      return !item.hide;
    });
    var selectCartesianItemsSettings = createSelector([selectUnfilteredCartesianItems, selectBaseAxis, selectAxisPredicate$1], combineGraphicalItemsSettings, {
      memoizeOptions: {
        resultEqualityCheck: emptyArraysAreEqualCheck
      }
    });
    var selectStackedCartesianItemsSettings = createSelector([selectCartesianItemsSettings], (cartesianItems) => {
      return cartesianItems.filter((item) => item.type === "area" || item.type === "bar").filter(isStacked);
    });
    var filterGraphicalNotStackedItems = (cartesianItems) => cartesianItems.filter((item) => !("stackId" in item) || item.stackId === void 0);
    var selectCartesianItemsSettingsExceptStacked = createSelector([selectCartesianItemsSettings], filterGraphicalNotStackedItems);
    var combineGraphicalItemsData = (cartesianItems) => cartesianItems.map((item) => item.data).filter(Boolean).flat(1);
    var selectCartesianGraphicalItemsData = createSelector([selectCartesianItemsSettings], combineGraphicalItemsData, {
      memoizeOptions: {
        resultEqualityCheck: emptyArraysAreEqualCheck
      }
    });
    var combineDisplayedData = (graphicalItemsData, _ref2) => {
      var {
        chartData = [],
        dataStartIndex,
        dataEndIndex
      } = _ref2;
      if (graphicalItemsData.length > 0) {
        return graphicalItemsData;
      }
      return chartData.slice(dataStartIndex, dataEndIndex + 1);
    };
    var selectDisplayedData$1 = createSelector([selectCartesianGraphicalItemsData, selectChartDataWithIndexesIfNotInPanorama], combineDisplayedData);
    var combineAppliedValues = (data, axisSettings, items) => {
      if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) {
        return data.map((item) => ({
          value: getValueByDataKey(item, axisSettings.dataKey)
        }));
      }
      if (items.length > 0) {
        return items.map((item) => item.dataKey).flatMap((dataKey) => data.map((entry) => ({
          value: getValueByDataKey(entry, dataKey)
        })));
      }
      return data.map((entry) => ({
        value: entry
      }));
    };
    var selectAllAppliedValues = createSelector([selectDisplayedData$1, selectBaseAxis, selectCartesianItemsSettings], combineAppliedValues);
    function isErrorBarRelevantForAxisType(axisType, errorBar) {
      switch (axisType) {
        case "xAxis":
          return errorBar.direction === "x";
        case "yAxis":
          return errorBar.direction === "y";
        default:
          return false;
      }
    }
    function makeNumber(val) {
      if (isNumOrStr(val) || val instanceof Date) {
        var n2 = Number(val);
        if (isWellBehavedNumber(n2)) {
          return n2;
        }
      }
      return void 0;
    }
    function makeDomain(val) {
      if (Array.isArray(val)) {
        var attempt = [makeNumber(val[0]), makeNumber(val[1])];
        if (isWellFormedNumberDomain(attempt)) {
          return attempt;
        }
        return void 0;
      }
      var n2 = makeNumber(val);
      if (n2 == null) {
        return void 0;
      }
      return [n2, n2];
    }
    function onlyAllowNumbers(data) {
      return data.map(makeNumber).filter(isNotNil);
    }
    function getErrorDomainByDataKey(entry, appliedValue, relevantErrorBars) {
      if (!relevantErrorBars || typeof appliedValue !== "number" || isNan(appliedValue)) {
        return [];
      }
      if (!relevantErrorBars.length) {
        return [];
      }
      return onlyAllowNumbers(relevantErrorBars.flatMap((eb2) => {
        var errorValue = getValueByDataKey(entry, eb2.dataKey);
        var lowBound, highBound;
        if (Array.isArray(errorValue)) {
          [lowBound, highBound] = errorValue;
        } else {
          lowBound = highBound = errorValue;
        }
        if (!isWellBehavedNumber(lowBound) || !isWellBehavedNumber(highBound)) {
          return void 0;
        }
        return [appliedValue - lowBound, appliedValue + highBound];
      }));
    }
    var selectTooltipAxis = (state) => {
      var axisType = selectTooltipAxisType(state);
      var axisId = selectTooltipAxisId(state);
      return selectAxisSettings(state, axisType, axisId);
    };
    var selectTooltipAxisDataKey = createSelector([selectTooltipAxis], (axis) => axis === null || axis === void 0 ? void 0 : axis.dataKey);
    var selectDisplayedStackedData = createSelector([selectStackedCartesianItemsSettings, selectChartDataWithIndexesIfNotInPanorama, selectTooltipAxis], combineDisplayedStackedData);
    var combineStackGroups = (displayedData, items, stackOffsetType, reverseStackOrder) => {
      var initialItemsGroups = {};
      var itemsGroup = items.reduce((acc, item) => {
        if (item.stackId == null) {
          return acc;
        }
        if (acc[item.stackId] == null) {
          acc[item.stackId] = [];
        }
        acc[item.stackId].push(item);
        return acc;
      }, initialItemsGroups);
      return Object.fromEntries(Object.entries(itemsGroup).map((_ref2) => {
        var [stackId, graphicalItems] = _ref2;
        var orderedGraphicalItems = reverseStackOrder ? [...graphicalItems].reverse() : graphicalItems;
        var dataKeys = orderedGraphicalItems.map(getStackSeriesIdentifier);
        return [stackId, {
          // @ts-expect-error getStackedData requires that the input is array of objects, Recharts does not test for that
          stackedData: getStackedData(displayedData, dataKeys, stackOffsetType),
          graphicalItems: orderedGraphicalItems
        }];
      }));
    };
    var selectStackGroups = createSelector([selectDisplayedStackedData, selectStackedCartesianItemsSettings, selectStackOffsetType, selectReverseStackOrder], combineStackGroups);
    var combineDomainOfStackGroups = (stackGroups, _ref3, axisType, domainFromUserPreference) => {
      var {
        dataStartIndex,
        dataEndIndex
      } = _ref3;
      if (domainFromUserPreference != null) {
        return void 0;
      }
      if (axisType === "zAxis") {
        return void 0;
      }
      var domainOfStackGroups = getDomainOfStackGroups(stackGroups, dataStartIndex, dataEndIndex);
      if (domainOfStackGroups != null && domainOfStackGroups[0] === 0 && domainOfStackGroups[1] === 0) {
        return void 0;
      }
      return domainOfStackGroups;
    };
    var selectAllowsDataOverflow = createSelector([selectBaseAxis], (axisSettings) => axisSettings.allowDataOverflow);
    var getDomainDefinition = (axisSettings) => {
      var _axisSettings$domain;
      if (axisSettings == null || !("domain" in axisSettings)) {
        return defaultNumericDomain;
      }
      if (axisSettings.domain != null) {
        return axisSettings.domain;
      }
      if (axisSettings.ticks != null) {
        if (axisSettings.type === "number") {
          var allValues = onlyAllowNumbers(axisSettings.ticks);
          return [Math.min(...allValues), Math.max(...allValues)];
        }
        if (axisSettings.type === "category") {
          return axisSettings.ticks.map(String);
        }
      }
      return (_axisSettings$domain = axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.domain) !== null && _axisSettings$domain !== void 0 ? _axisSettings$domain : defaultNumericDomain;
    };
    var selectDomainDefinition = createSelector([selectBaseAxis], getDomainDefinition);
    var selectDomainFromUserPreference = createSelector([selectDomainDefinition, selectAllowsDataOverflow], numericalDomainSpecifiedWithoutRequiringData);
    var selectDomainOfStackGroups = createSelector([selectStackGroups, selectChartDataWithIndexes, pickAxisType, selectDomainFromUserPreference], combineDomainOfStackGroups, {
      memoizeOptions: {
        resultEqualityCheck: numberDomainEqualityCheck
      }
    });
    var selectAllErrorBarSettings = (state) => state.errorBars;
    var combineRelevantErrorBarSettings = (cartesianItemsSettings, allErrorBarSettings, axisType) => {
      return cartesianItemsSettings.flatMap((item) => {
        return allErrorBarSettings[item.id];
      }).filter(Boolean).filter((e) => {
        return isErrorBarRelevantForAxisType(axisType, e);
      });
    };
    var mergeDomains = function mergeDomains2() {
      for (var _len = arguments.length, domains = new Array(_len), _key = 0; _key < _len; _key++) {
        domains[_key] = arguments[_key];
      }
      var allDomains = domains.filter(Boolean);
      if (allDomains.length === 0) {
        return void 0;
      }
      var allValues = allDomains.flat();
      var min2 = Math.min(...allValues);
      var max2 = Math.max(...allValues);
      return [min2, max2];
    };
    var combineDomainOfAllAppliedNumericalValuesIncludingErrorValues = (data, axisSettings, items, errorBars, axisType) => {
      var lowerEnd, upperEnd;
      if (items.length > 0) {
        data.forEach((entry) => {
          items.forEach((item) => {
            var _errorBars$item$id, _axisSettings$dataKey;
            var relevantErrorBars = (_errorBars$item$id = errorBars[item.id]) === null || _errorBars$item$id === void 0 ? void 0 : _errorBars$item$id.filter((errorBar) => isErrorBarRelevantForAxisType(axisType, errorBar));
            var valueByDataKey = getValueByDataKey(entry, (_axisSettings$dataKey = axisSettings.dataKey) !== null && _axisSettings$dataKey !== void 0 ? _axisSettings$dataKey : item.dataKey);
            var errorDomain = getErrorDomainByDataKey(entry, valueByDataKey, relevantErrorBars);
            if (errorDomain.length >= 2) {
              var localLower = Math.min(...errorDomain);
              var localUpper = Math.max(...errorDomain);
              if (lowerEnd == null || localLower < lowerEnd) {
                lowerEnd = localLower;
              }
              if (upperEnd == null || localUpper > upperEnd) {
                upperEnd = localUpper;
              }
            }
            var dataValueDomain = makeDomain(valueByDataKey);
            if (dataValueDomain != null) {
              lowerEnd = lowerEnd == null ? dataValueDomain[0] : Math.min(lowerEnd, dataValueDomain[0]);
              upperEnd = upperEnd == null ? dataValueDomain[1] : Math.max(upperEnd, dataValueDomain[1]);
            }
          });
        });
      }
      if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) {
        data.forEach((item) => {
          var dataValueDomain = makeDomain(getValueByDataKey(item, axisSettings.dataKey));
          if (dataValueDomain != null) {
            lowerEnd = lowerEnd == null ? dataValueDomain[0] : Math.min(lowerEnd, dataValueDomain[0]);
            upperEnd = upperEnd == null ? dataValueDomain[1] : Math.max(upperEnd, dataValueDomain[1]);
          }
        });
      }
      if (isWellBehavedNumber(lowerEnd) && isWellBehavedNumber(upperEnd)) {
        return [lowerEnd, upperEnd];
      }
      return void 0;
    };
    var selectDomainOfAllAppliedNumericalValuesIncludingErrorValues$1 = createSelector([selectDisplayedData$1, selectBaseAxis, selectCartesianItemsSettingsExceptStacked, selectAllErrorBarSettings, pickAxisType], combineDomainOfAllAppliedNumericalValuesIncludingErrorValues, {
      memoizeOptions: {
        resultEqualityCheck: numberDomainEqualityCheck
      }
    });
    function onlyAllowNumbersAndStringsAndDates(item) {
      var {
        value
      } = item;
      if (isNumOrStr(value) || value instanceof Date) {
        return value;
      }
      return void 0;
    }
    var computeDomainOfTypeCategory = (allDataSquished, axisSettings, isCategorical) => {
      var categoricalDomain = allDataSquished.map(onlyAllowNumbersAndStringsAndDates).filter((v2) => v2 != null);
      if (isCategorical && (axisSettings.dataKey == null || axisSettings.allowDuplicatedCategory && hasDuplicate(categoricalDomain))) {
        return range$3(0, allDataSquished.length);
      }
      if (axisSettings.allowDuplicatedCategory) {
        return categoricalDomain;
      }
      return Array.from(new Set(categoricalDomain));
    };
    var selectReferenceDots = (state) => state.referenceElements.dots;
    var filterReferenceElements = (elements, axisType, axisId) => {
      return elements.filter((el2) => el2.ifOverflow === "extendDomain").filter((el2) => {
        if (axisType === "xAxis") {
          return el2.xAxisId === axisId;
        }
        return el2.yAxisId === axisId;
      });
    };
    var selectReferenceDotsByAxis = createSelector([selectReferenceDots, pickAxisType, pickAxisId], filterReferenceElements);
    var selectReferenceAreas = (state) => state.referenceElements.areas;
    var selectReferenceAreasByAxis = createSelector([selectReferenceAreas, pickAxisType, pickAxisId], filterReferenceElements);
    var selectReferenceLines = (state) => state.referenceElements.lines;
    var selectReferenceLinesByAxis = createSelector([selectReferenceLines, pickAxisType, pickAxisId], filterReferenceElements);
    var combineDotsDomain = (dots, axisType) => {
      var allCoords = onlyAllowNumbers(dots.map((dot) => axisType === "xAxis" ? dot.x : dot.y));
      if (allCoords.length === 0) {
        return void 0;
      }
      return [Math.min(...allCoords), Math.max(...allCoords)];
    };
    var selectReferenceDotsDomain = createSelector(selectReferenceDotsByAxis, pickAxisType, combineDotsDomain);
    var combineAreasDomain = (areas, axisType) => {
      var allCoords = onlyAllowNumbers(areas.flatMap((area) => [axisType === "xAxis" ? area.x1 : area.y1, axisType === "xAxis" ? area.x2 : area.y2]));
      if (allCoords.length === 0) {
        return void 0;
      }
      return [Math.min(...allCoords), Math.max(...allCoords)];
    };
    var selectReferenceAreasDomain = createSelector([selectReferenceAreasByAxis, pickAxisType], combineAreasDomain);
    function extractXCoordinates(line) {
      var _line$segment;
      if (line.x != null) {
        return onlyAllowNumbers([line.x]);
      }
      var segmentCoordinates = (_line$segment = line.segment) === null || _line$segment === void 0 ? void 0 : _line$segment.map((s2) => s2.x);
      if (segmentCoordinates == null || segmentCoordinates.length === 0) {
        return [];
      }
      return onlyAllowNumbers(segmentCoordinates);
    }
    function extractYCoordinates(line) {
      var _line$segment2;
      if (line.y != null) {
        return onlyAllowNumbers([line.y]);
      }
      var segmentCoordinates = (_line$segment2 = line.segment) === null || _line$segment2 === void 0 ? void 0 : _line$segment2.map((s2) => s2.y);
      if (segmentCoordinates == null || segmentCoordinates.length === 0) {
        return [];
      }
      return onlyAllowNumbers(segmentCoordinates);
    }
    var combineLinesDomain = (lines, axisType) => {
      var allCoords = lines.flatMap((line) => axisType === "xAxis" ? extractXCoordinates(line) : extractYCoordinates(line));
      if (allCoords.length === 0) {
        return void 0;
      }
      return [Math.min(...allCoords), Math.max(...allCoords)];
    };
    var selectReferenceLinesDomain = createSelector([selectReferenceLinesByAxis, pickAxisType], combineLinesDomain);
    var selectReferenceElementsDomain = createSelector(selectReferenceDotsDomain, selectReferenceLinesDomain, selectReferenceAreasDomain, (dotsDomain, linesDomain, areasDomain) => {
      return mergeDomains(dotsDomain, areasDomain, linesDomain);
    });
    var combineNumericalDomain = (axisSettings, domainDefinition, domainFromUserPreference, domainOfStackGroups, dataAndErrorBarsDomain, referenceElementsDomain, layout, axisType) => {
      if (domainFromUserPreference != null) {
        return domainFromUserPreference;
      }
      var shouldIncludeDomainOfStackGroups = layout === "vertical" && axisType === "xAxis" || layout === "horizontal" && axisType === "yAxis";
      var mergedDomains = shouldIncludeDomainOfStackGroups ? mergeDomains(domainOfStackGroups, referenceElementsDomain, dataAndErrorBarsDomain) : mergeDomains(referenceElementsDomain, dataAndErrorBarsDomain);
      return parseNumericalUserDomain(domainDefinition, mergedDomains, axisSettings.allowDataOverflow);
    };
    var selectNumericalDomain = createSelector([selectBaseAxis, selectDomainDefinition, selectDomainFromUserPreference, selectDomainOfStackGroups, selectDomainOfAllAppliedNumericalValuesIncludingErrorValues$1, selectReferenceElementsDomain, selectChartLayout, pickAxisType], combineNumericalDomain, {
      memoizeOptions: {
        resultEqualityCheck: numberDomainEqualityCheck
      }
    });
    var expandDomain = [0, 1];
    var combineAxisDomain = (axisSettings, layout, displayedData, allAppliedValues, stackOffsetType, axisType, numericalDomain) => {
      if ((axisSettings == null || displayedData == null || displayedData.length === 0) && numericalDomain === void 0) {
        return void 0;
      }
      var {
        dataKey,
        type
      } = axisSettings;
      var isCategorical = isCategoricalAxis(layout, axisType);
      if (isCategorical && dataKey == null) {
        var _displayedData$length;
        return range$3(0, (_displayedData$length = displayedData === null || displayedData === void 0 ? void 0 : displayedData.length) !== null && _displayedData$length !== void 0 ? _displayedData$length : 0);
      }
      if (type === "category") {
        return computeDomainOfTypeCategory(allAppliedValues, axisSettings, isCategorical);
      }
      if (stackOffsetType === "expand") {
        return expandDomain;
      }
      return numericalDomain;
    };
    var selectAxisDomain = createSelector([selectBaseAxis, selectChartLayout, selectDisplayedData$1, selectAllAppliedValues, selectStackOffsetType, pickAxisType, selectNumericalDomain], combineAxisDomain);
    var combineRealScaleType = (axisConfig, layout, hasBar, chartType, axisType) => {
      if (axisConfig == null) {
        return void 0;
      }
      var {
        scale,
        type
      } = axisConfig;
      if (scale === "auto") {
        if (layout === "radial" && axisType === "radiusAxis") {
          return "band";
        }
        if (layout === "radial" && axisType === "angleAxis") {
          return "linear";
        }
        if (type === "category" && chartType && (chartType.indexOf("LineChart") >= 0 || chartType.indexOf("AreaChart") >= 0 || chartType.indexOf("ComposedChart") >= 0 && !hasBar)) {
          return "point";
        }
        if (type === "category") {
          return "band";
        }
        return "linear";
      }
      if (typeof scale === "string") {
        var name = "scale".concat(upperFirst(scale));
        return name in d3Scales ? name : "point";
      }
      return void 0;
    };
    var selectRealScaleType = createSelector([selectBaseAxis, selectChartLayout, selectHasBar, selectChartName, pickAxisType], combineRealScaleType);
    function getD3ScaleFromType(realScaleType) {
      if (realScaleType == null) {
        return void 0;
      }
      if (realScaleType in d3Scales) {
        return d3Scales[realScaleType]();
      }
      var name = "scale".concat(upperFirst(realScaleType));
      if (name in d3Scales) {
        return d3Scales[name]();
      }
      return void 0;
    }
    function combineScaleFunction(axis, realScaleType, axisDomain, axisRange) {
      if (axisDomain == null || axisRange == null) {
        return void 0;
      }
      if (typeof axis.scale === "function") {
        return axis.scale.copy().domain(axisDomain).range(axisRange);
      }
      var d3ScaleFunction = getD3ScaleFromType(realScaleType);
      if (d3ScaleFunction == null) {
        return void 0;
      }
      var scale = d3ScaleFunction.domain(axisDomain).range(axisRange);
      checkDomainOfScale(scale);
      return scale;
    }
    var combineNiceTicks = (axisDomain, axisSettings, realScaleType) => {
      var domainDefinition = getDomainDefinition(axisSettings);
      if (realScaleType !== "auto" && realScaleType !== "linear") {
        return void 0;
      }
      if (axisSettings != null && axisSettings.tickCount && Array.isArray(domainDefinition) && (domainDefinition[0] === "auto" || domainDefinition[1] === "auto") && isWellFormedNumberDomain(axisDomain)) {
        return getNiceTickValues(axisDomain, axisSettings.tickCount, axisSettings.allowDecimals);
      }
      if (axisSettings != null && axisSettings.tickCount && axisSettings.type === "number" && isWellFormedNumberDomain(axisDomain)) {
        return getTickValuesFixedDomain(axisDomain, axisSettings.tickCount, axisSettings.allowDecimals);
      }
      return void 0;
    };
    var selectNiceTicks = createSelector([selectAxisDomain, selectAxisSettings, selectRealScaleType], combineNiceTicks);
    var combineAxisDomainWithNiceTicks = (axisSettings, domain, niceTicks, axisType) => {
      if (
        /*
         * Angle axis for some reason uses nice ticks when rendering axis tick labels,
         * but doesn't use nice ticks for extending domain like all the other axes do.
         * Not really sure why? Is there a good reason,
         * or is it just because someone added support for nice ticks to the other axes and forgot this one?
         */
        axisType !== "angleAxis" && (axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.type) === "number" && isWellFormedNumberDomain(domain) && Array.isArray(niceTicks) && niceTicks.length > 0
      ) {
        var minFromDomain = domain[0];
        var minFromTicks = niceTicks[0];
        var maxFromDomain = domain[1];
        var maxFromTicks = niceTicks[niceTicks.length - 1];
        return [Math.min(minFromDomain, minFromTicks), Math.max(maxFromDomain, maxFromTicks)];
      }
      return domain;
    };
    var selectAxisDomainIncludingNiceTicks = createSelector([selectBaseAxis, selectAxisDomain, selectNiceTicks, pickAxisType], combineAxisDomainWithNiceTicks);
    var selectSmallestDistanceBetweenValues = createSelector(selectAllAppliedValues, selectBaseAxis, (allDataSquished, axisSettings) => {
      if (!axisSettings || axisSettings.type !== "number") {
        return void 0;
      }
      var smallestDistanceBetweenValues = Infinity;
      var sortedValues = Array.from(onlyAllowNumbers(allDataSquished.map((d) => d.value))).sort((a2, b) => a2 - b);
      if (sortedValues.length < 2) {
        return Infinity;
      }
      var diff = sortedValues[sortedValues.length - 1] - sortedValues[0];
      if (diff === 0) {
        return Infinity;
      }
      for (var i = 0; i < sortedValues.length - 1; i++) {
        var distance = sortedValues[i + 1] - sortedValues[i];
        smallestDistanceBetweenValues = Math.min(smallestDistanceBetweenValues, distance);
      }
      return smallestDistanceBetweenValues / diff;
    });
    var selectCalculatedPadding = createSelector(selectSmallestDistanceBetweenValues, selectChartLayout, selectBarCategoryGap, selectChartOffsetInternal, (_1, _2, _3, padding) => padding, (smallestDistanceInPercent, layout, barCategoryGap, offset, padding) => {
      if (!isWellBehavedNumber(smallestDistanceInPercent)) {
        return 0;
      }
      var rangeWidth = layout === "vertical" ? offset.height : offset.width;
      if (padding === "gap") {
        return smallestDistanceInPercent * rangeWidth / 2;
      }
      if (padding === "no-gap") {
        var gap = getPercentValue(barCategoryGap, smallestDistanceInPercent * rangeWidth);
        var halfBand = smallestDistanceInPercent * rangeWidth / 2;
        return halfBand - gap - (halfBand - gap) / rangeWidth * gap;
      }
      return 0;
    });
    var selectCalculatedXAxisPadding = (state, axisId) => {
      var xAxisSettings = selectXAxisSettings(state, axisId);
      if (xAxisSettings == null || typeof xAxisSettings.padding !== "string") {
        return 0;
      }
      return selectCalculatedPadding(state, "xAxis", axisId, xAxisSettings.padding);
    };
    var selectCalculatedYAxisPadding = (state, axisId) => {
      var yAxisSettings = selectYAxisSettings(state, axisId);
      if (yAxisSettings == null || typeof yAxisSettings.padding !== "string") {
        return 0;
      }
      return selectCalculatedPadding(state, "yAxis", axisId, yAxisSettings.padding);
    };
    var selectXAxisPadding = createSelector(selectXAxisSettings, selectCalculatedXAxisPadding, (xAxisSettings, calculated) => {
      var _padding$left, _padding$right;
      if (xAxisSettings == null) {
        return {
          left: 0,
          right: 0
        };
      }
      var {
        padding
      } = xAxisSettings;
      if (typeof padding === "string") {
        return {
          left: calculated,
          right: calculated
        };
      }
      return {
        left: ((_padding$left = padding.left) !== null && _padding$left !== void 0 ? _padding$left : 0) + calculated,
        right: ((_padding$right = padding.right) !== null && _padding$right !== void 0 ? _padding$right : 0) + calculated
      };
    });
    var selectYAxisPadding = createSelector(selectYAxisSettings, selectCalculatedYAxisPadding, (yAxisSettings, calculated) => {
      var _padding$top, _padding$bottom;
      if (yAxisSettings == null) {
        return {
          top: 0,
          bottom: 0
        };
      }
      var {
        padding
      } = yAxisSettings;
      if (typeof padding === "string") {
        return {
          top: calculated,
          bottom: calculated
        };
      }
      return {
        top: ((_padding$top = padding.top) !== null && _padding$top !== void 0 ? _padding$top : 0) + calculated,
        bottom: ((_padding$bottom = padding.bottom) !== null && _padding$bottom !== void 0 ? _padding$bottom : 0) + calculated
      };
    });
    var combineXAxisRange = createSelector([selectChartOffsetInternal, selectXAxisPadding, selectBrushDimensions, selectBrushSettings, (_state, _axisId, isPanorama) => isPanorama], (offset, padding, brushDimensions, _ref4, isPanorama) => {
      var {
        padding: brushPadding
      } = _ref4;
      if (isPanorama) {
        return [brushPadding.left, brushDimensions.width - brushPadding.right];
      }
      return [offset.left + padding.left, offset.left + offset.width - padding.right];
    });
    var combineYAxisRange = createSelector([selectChartOffsetInternal, selectChartLayout, selectYAxisPadding, selectBrushDimensions, selectBrushSettings, (_state, _axisId, isPanorama) => isPanorama], (offset, layout, padding, brushDimensions, _ref5, isPanorama) => {
      var {
        padding: brushPadding
      } = _ref5;
      if (isPanorama) {
        return [brushDimensions.height - brushPadding.bottom, brushPadding.top];
      }
      if (layout === "horizontal") {
        return [offset.top + offset.height - padding.bottom, offset.top + padding.top];
      }
      return [offset.top + padding.top, offset.top + offset.height - padding.bottom];
    });
    var selectAxisRange = (state, axisType, axisId, isPanorama) => {
      var _selectZAxisSettings;
      switch (axisType) {
        case "xAxis":
          return combineXAxisRange(state, axisId, isPanorama);
        case "yAxis":
          return combineYAxisRange(state, axisId, isPanorama);
        case "zAxis":
          return (_selectZAxisSettings = selectZAxisSettings(state, axisId)) === null || _selectZAxisSettings === void 0 ? void 0 : _selectZAxisSettings.range;
        case "angleAxis":
          return selectAngleAxisRange(state);
        case "radiusAxis":
          return selectRadiusAxisRange(state, axisId);
        default:
          return void 0;
      }
    };
    var selectAxisRangeWithReverse = createSelector([selectBaseAxis, selectAxisRange], combineAxisRangeWithReverse);
    var selectAxisScale = createSelector([selectBaseAxis, selectRealScaleType, selectAxisDomainIncludingNiceTicks, selectAxisRangeWithReverse], combineScaleFunction);
    createSelector([selectCartesianItemsSettings, selectAllErrorBarSettings, pickAxisType], combineRelevantErrorBarSettings);
    function compareIds(a2, b) {
      if (a2.id < b.id) {
        return -1;
      }
      if (a2.id > b.id) {
        return 1;
      }
      return 0;
    }
    var pickAxisOrientation = (_state, orientation2) => orientation2;
    var pickMirror = (_state, _orientation, mirror) => mirror;
    var selectAllXAxesWithOffsetType = createSelector(selectAllXAxes, pickAxisOrientation, pickMirror, (allAxes, orientation2, mirror) => allAxes.filter((axis) => axis.orientation === orientation2).filter((axis) => axis.mirror === mirror).sort(compareIds));
    var selectAllYAxesWithOffsetType = createSelector(selectAllYAxes, pickAxisOrientation, pickMirror, (allAxes, orientation2, mirror) => allAxes.filter((axis) => axis.orientation === orientation2).filter((axis) => axis.mirror === mirror).sort(compareIds));
    var getXAxisSize = (offset, axisSettings) => {
      return {
        width: offset.width,
        height: axisSettings.height
      };
    };
    var getYAxisSize = (offset, axisSettings) => {
      var width = typeof axisSettings.width === "number" ? axisSettings.width : DEFAULT_Y_AXIS_WIDTH;
      return {
        width,
        height: offset.height
      };
    };
    var selectXAxisSize = createSelector(selectChartOffsetInternal, selectXAxisSettings, getXAxisSize);
    var combineXAxisPositionStartingPoint = (offset, orientation2, chartHeight) => {
      switch (orientation2) {
        case "top":
          return offset.top;
        case "bottom":
          return chartHeight - offset.bottom;
        default:
          return 0;
      }
    };
    var combineYAxisPositionStartingPoint = (offset, orientation2, chartWidth) => {
      switch (orientation2) {
        case "left":
          return offset.left;
        case "right":
          return chartWidth - offset.right;
        default:
          return 0;
      }
    };
    var selectAllXAxesOffsetSteps = createSelector(selectChartHeight, selectChartOffsetInternal, selectAllXAxesWithOffsetType, pickAxisOrientation, pickMirror, (chartHeight, offset, allAxesWithSameOffsetType, orientation2, mirror) => {
      var steps = {};
      var position;
      allAxesWithSameOffsetType.forEach((axis) => {
        var axisSize = getXAxisSize(offset, axis);
        if (position == null) {
          position = combineXAxisPositionStartingPoint(offset, orientation2, chartHeight);
        }
        var needSpace = orientation2 === "top" && !mirror || orientation2 === "bottom" && mirror;
        steps[axis.id] = position - Number(needSpace) * axisSize.height;
        position += (needSpace ? -1 : 1) * axisSize.height;
      });
      return steps;
    });
    var selectAllYAxesOffsetSteps = createSelector(selectChartWidth, selectChartOffsetInternal, selectAllYAxesWithOffsetType, pickAxisOrientation, pickMirror, (chartWidth, offset, allAxesWithSameOffsetType, orientation2, mirror) => {
      var steps = {};
      var position;
      allAxesWithSameOffsetType.forEach((axis) => {
        var axisSize = getYAxisSize(offset, axis);
        if (position == null) {
          position = combineYAxisPositionStartingPoint(offset, orientation2, chartWidth);
        }
        var needSpace = orientation2 === "left" && !mirror || orientation2 === "right" && mirror;
        steps[axis.id] = position - Number(needSpace) * axisSize.width;
        position += (needSpace ? -1 : 1) * axisSize.width;
      });
      return steps;
    });
    var selectXAxisOffsetSteps = (state, axisId) => {
      var axisSettings = selectXAxisSettings(state, axisId);
      if (axisSettings == null) {
        return void 0;
      }
      return selectAllXAxesOffsetSteps(state, axisSettings.orientation, axisSettings.mirror);
    };
    var selectXAxisPosition = createSelector([selectChartOffsetInternal, selectXAxisSettings, selectXAxisOffsetSteps, (_, axisId) => axisId], (offset, axisSettings, allSteps, axisId) => {
      if (axisSettings == null) {
        return void 0;
      }
      var stepOfThisAxis = allSteps === null || allSteps === void 0 ? void 0 : allSteps[axisId];
      if (stepOfThisAxis == null) {
        return {
          x: offset.left,
          y: 0
        };
      }
      return {
        x: offset.left,
        y: stepOfThisAxis
      };
    });
    var selectYAxisOffsetSteps = (state, axisId) => {
      var axisSettings = selectYAxisSettings(state, axisId);
      if (axisSettings == null) {
        return void 0;
      }
      return selectAllYAxesOffsetSteps(state, axisSettings.orientation, axisSettings.mirror);
    };
    var selectYAxisPosition = createSelector([selectChartOffsetInternal, selectYAxisSettings, selectYAxisOffsetSteps, (_, axisId) => axisId], (offset, axisSettings, allSteps, axisId) => {
      if (axisSettings == null) {
        return void 0;
      }
      var stepOfThisAxis = allSteps === null || allSteps === void 0 ? void 0 : allSteps[axisId];
      if (stepOfThisAxis == null) {
        return {
          x: 0,
          y: offset.top
        };
      }
      return {
        x: stepOfThisAxis,
        y: offset.top
      };
    });
    var selectYAxisSize = createSelector(selectChartOffsetInternal, selectYAxisSettings, (offset, axisSettings) => {
      var width = typeof axisSettings.width === "number" ? axisSettings.width : DEFAULT_Y_AXIS_WIDTH;
      return {
        width,
        height: offset.height
      };
    });
    var selectCartesianAxisSize = (state, axisType, axisId) => {
      switch (axisType) {
        case "xAxis": {
          return selectXAxisSize(state, axisId).width;
        }
        case "yAxis": {
          return selectYAxisSize(state, axisId).height;
        }
        default: {
          return void 0;
        }
      }
    };
    var combineDuplicateDomain = (chartLayout, appliedValues, axis, axisType) => {
      if (axis == null) {
        return void 0;
      }
      var {
        allowDuplicatedCategory,
        type,
        dataKey
      } = axis;
      var isCategorical = isCategoricalAxis(chartLayout, axisType);
      var allData = appliedValues.map((av) => av.value);
      if (dataKey && isCategorical && type === "category" && allowDuplicatedCategory && hasDuplicate(allData)) {
        return allData;
      }
      return void 0;
    };
    var selectDuplicateDomain = createSelector([selectChartLayout, selectAllAppliedValues, selectBaseAxis, pickAxisType], combineDuplicateDomain);
    var combineCategoricalDomain = (layout, appliedValues, axis, axisType) => {
      if (axis == null || axis.dataKey == null) {
        return void 0;
      }
      var {
        type,
        scale
      } = axis;
      var isCategorical = isCategoricalAxis(layout, axisType);
      if (isCategorical && (type === "number" || scale !== "auto")) {
        return appliedValues.map((d) => d.value);
      }
      return void 0;
    };
    var selectCategoricalDomain = createSelector([selectChartLayout, selectAllAppliedValues, selectAxisSettings, pickAxisType], combineCategoricalDomain);
    var selectAxisPropsNeededForCartesianGridTicksGenerator = createSelector([selectChartLayout, selectCartesianAxisSettings, selectRealScaleType, selectAxisScale, selectDuplicateDomain, selectCategoricalDomain, selectAxisRange, selectNiceTicks, pickAxisType], (layout, axis, realScaleType, scale, duplicateDomain, categoricalDomain, axisRange, niceTicks, axisType) => {
      if (axis == null) {
        return void 0;
      }
      var isCategorical = isCategoricalAxis(layout, axisType);
      return {
        angle: axis.angle,
        interval: axis.interval,
        minTickGap: axis.minTickGap,
        orientation: axis.orientation,
        tick: axis.tick,
        tickCount: axis.tickCount,
        tickFormatter: axis.tickFormatter,
        ticks: axis.ticks,
        type: axis.type,
        unit: axis.unit,
        axisType,
        categoricalDomain,
        duplicateDomain,
        isCategorical,
        niceTicks,
        range: axisRange,
        realScaleType,
        scale
      };
    });
    var combineAxisTicks = (layout, axis, realScaleType, scale, niceTicks, axisRange, duplicateDomain, categoricalDomain, axisType) => {
      if (axis == null || scale == null) {
        return void 0;
      }
      var isCategorical = isCategoricalAxis(layout, axisType);
      var {
        type,
        ticks: ticks2,
        tickCount
      } = axis;
      var offsetForBand = realScaleType === "scaleBand" && typeof scale.bandwidth === "function" ? scale.bandwidth() / 2 : 2;
      var offset = type === "category" && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;
      offset = axisType === "angleAxis" && axisRange != null && axisRange.length >= 2 ? mathSign(axisRange[0] - axisRange[1]) * 2 * offset : offset;
      var ticksOrNiceTicks = ticks2 || niceTicks;
      if (ticksOrNiceTicks) {
        var result = ticksOrNiceTicks.map((entry, index) => {
          var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;
          return {
            index,
            // If the scaleContent is not a number, the coordinate will be NaN.
            // That could be the case for example with a PointScale and a string as domain.
            coordinate: scale(scaleContent) + offset,
            value: entry,
            offset
          };
        });
        return result.filter((row) => isWellBehavedNumber(row.coordinate));
      }
      if (isCategorical && categoricalDomain) {
        return categoricalDomain.map((entry, index) => ({
          coordinate: scale(entry) + offset,
          value: entry,
          index,
          offset
        })).filter((row) => isWellBehavedNumber(row.coordinate));
      }
      if (scale.ticks) {
        return scale.ticks(tickCount).map((entry) => ({
          coordinate: scale(entry) + offset,
          value: entry,
          offset
        }));
      }
      return scale.domain().map((entry, index) => ({
        coordinate: scale(entry) + offset,
        value: duplicateDomain ? duplicateDomain[entry] : entry,
        index,
        offset
      }));
    };
    var selectTicksOfAxis = createSelector([selectChartLayout, selectAxisSettings, selectRealScaleType, selectAxisScale, selectNiceTicks, selectAxisRange, selectDuplicateDomain, selectCategoricalDomain, pickAxisType], combineAxisTicks);
    var combineGraphicalItemTicks = (layout, axis, scale, axisRange, duplicateDomain, categoricalDomain, axisType) => {
      if (axis == null || scale == null || axisRange == null || axisRange[0] === axisRange[1]) {
        return void 0;
      }
      var isCategorical = isCategoricalAxis(layout, axisType);
      var {
        tickCount
      } = axis;
      var offset = 0;
      offset = axisType === "angleAxis" && (axisRange === null || axisRange === void 0 ? void 0 : axisRange.length) >= 2 ? mathSign(axisRange[0] - axisRange[1]) * 2 * offset : offset;
      if (isCategorical && categoricalDomain) {
        return categoricalDomain.map((entry, index) => ({
          coordinate: scale(entry) + offset,
          value: entry,
          index,
          offset
        }));
      }
      if (scale.ticks) {
        return scale.ticks(tickCount).map((entry) => ({
          coordinate: scale(entry) + offset,
          value: entry,
          offset
        }));
      }
      return scale.domain().map((entry, index) => ({
        coordinate: scale(entry) + offset,
        value: duplicateDomain ? duplicateDomain[entry] : entry,
        index,
        offset
      }));
    };
    var selectTicksOfGraphicalItem = createSelector([selectChartLayout, selectAxisSettings, selectAxisScale, selectAxisRange, selectDuplicateDomain, selectCategoricalDomain, pickAxisType], combineGraphicalItemTicks);
    var selectAxisWithScale = createSelector(selectBaseAxis, selectAxisScale, (axis, scale) => {
      if (axis == null || scale == null) {
        return void 0;
      }
      return _objectSpread$r(_objectSpread$r({}, axis), {}, {
        scale
      });
    });
    var selectZAxisScale = createSelector([selectBaseAxis, selectRealScaleType, selectAxisDomain, selectAxisRangeWithReverse], combineScaleFunction);
    createSelector((state, _axisType, axisId) => selectZAxisSettings(state, axisId), selectZAxisScale, (axis, scale) => {
      if (axis == null || scale == null) {
        return void 0;
      }
      return _objectSpread$r(_objectSpread$r({}, axis), {}, {
        scale
      });
    });
    var selectChartDirection = createSelector([selectChartLayout, selectAllXAxes, selectAllYAxes], (layout, allXAxes, allYAxes) => {
      switch (layout) {
        case "horizontal": {
          return allXAxes.some((axis) => axis.reversed) ? "right-to-left" : "left-to-right";
        }
        case "vertical": {
          return allYAxes.some((axis) => axis.reversed) ? "bottom-to-top" : "top-to-bottom";
        }
        case "centric":
        case "radial": {
          return "left-to-right";
        }
        default: {
          return void 0;
        }
      }
    });
    var selectDefaultTooltipEventType = (state) => state.options.defaultTooltipEventType;
    var selectValidateTooltipEventTypes = (state) => state.options.validateTooltipEventTypes;
    function combineTooltipEventType(shared, defaultTooltipEventType, validateTooltipEventTypes) {
      if (shared == null) {
        return defaultTooltipEventType;
      }
      var eventType = shared ? "axis" : "item";
      if (validateTooltipEventTypes == null) {
        return defaultTooltipEventType;
      }
      return validateTooltipEventTypes.includes(eventType) ? eventType : defaultTooltipEventType;
    }
    function selectTooltipEventType$1(state, shared) {
      var defaultTooltipEventType = selectDefaultTooltipEventType(state);
      var validateTooltipEventTypes = selectValidateTooltipEventTypes(state);
      return combineTooltipEventType(shared, defaultTooltipEventType, validateTooltipEventTypes);
    }
    function useTooltipEventType(shared) {
      return useAppSelector((state) => selectTooltipEventType$1(state, shared));
    }
    var combineActiveLabel = (tooltipTicks, activeIndex) => {
      var _tooltipTicks$n;
      var n2 = Number(activeIndex);
      if (isNan(n2) || activeIndex == null) {
        return void 0;
      }
      return n2 >= 0 ? tooltipTicks === null || tooltipTicks === void 0 || (_tooltipTicks$n = tooltipTicks[n2]) === null || _tooltipTicks$n === void 0 ? void 0 : _tooltipTicks$n.value : void 0;
    };
    var selectTooltipSettings = (state) => state.tooltip.settings;
    var noInteraction = {
      active: false,
      index: null,
      dataKey: void 0,
      graphicalItemId: void 0,
      coordinate: void 0
    };
    var initialState$9 = {
      itemInteraction: {
        click: noInteraction,
        hover: noInteraction
      },
      axisInteraction: {
        click: noInteraction,
        hover: noInteraction
      },
      keyboardInteraction: noInteraction,
      syncInteraction: {
        active: false,
        index: null,
        dataKey: void 0,
        label: void 0,
        coordinate: void 0,
        sourceViewBox: void 0,
        graphicalItemId: void 0
      },
      tooltipItemPayloads: [],
      settings: {
        shared: void 0,
        trigger: "hover",
        axisId: 0,
        active: false,
        defaultIndex: void 0
      }
    };
    var tooltipSlice = createSlice({
      name: "tooltip",
      initialState: initialState$9,
      reducers: {
        addTooltipEntrySettings: {
          reducer(state, action) {
            state.tooltipItemPayloads.push(castDraft(action.payload));
          },
          prepare: prepareAutoBatched()
        },
        replaceTooltipEntrySettings: {
          reducer(state, action) {
            var {
              prev,
              next
            } = action.payload;
            var index = current$1(state).tooltipItemPayloads.indexOf(castDraft(prev));
            if (index > -1) {
              state.tooltipItemPayloads[index] = castDraft(next);
            }
          },
          prepare: prepareAutoBatched()
        },
        removeTooltipEntrySettings: {
          reducer(state, action) {
            var index = current$1(state).tooltipItemPayloads.indexOf(castDraft(action.payload));
            if (index > -1) {
              state.tooltipItemPayloads.splice(index, 1);
            }
          },
          prepare: prepareAutoBatched()
        },
        setTooltipSettingsState(state, action) {
          state.settings = action.payload;
        },
        setActiveMouseOverItemIndex(state, action) {
          state.syncInteraction.active = false;
          state.keyboardInteraction.active = false;
          state.itemInteraction.hover.active = true;
          state.itemInteraction.hover.index = action.payload.activeIndex;
          state.itemInteraction.hover.dataKey = action.payload.activeDataKey;
          state.itemInteraction.hover.graphicalItemId = action.payload.activeGraphicalItemId;
          state.itemInteraction.hover.coordinate = action.payload.activeCoordinate;
        },
        mouseLeaveChart(state) {
          state.itemInteraction.hover.active = false;
          state.axisInteraction.hover.active = false;
        },
        mouseLeaveItem(state) {
          state.itemInteraction.hover.active = false;
        },
        setActiveClickItemIndex(state, action) {
          state.syncInteraction.active = false;
          state.itemInteraction.click.active = true;
          state.keyboardInteraction.active = false;
          state.itemInteraction.click.index = action.payload.activeIndex;
          state.itemInteraction.click.dataKey = action.payload.activeDataKey;
          state.itemInteraction.click.graphicalItemId = action.payload.activeGraphicalItemId;
          state.itemInteraction.click.coordinate = action.payload.activeCoordinate;
        },
        setMouseOverAxisIndex(state, action) {
          state.syncInteraction.active = false;
          state.axisInteraction.hover.active = true;
          state.keyboardInteraction.active = false;
          state.axisInteraction.hover.index = action.payload.activeIndex;
          state.axisInteraction.hover.dataKey = action.payload.activeDataKey;
          state.axisInteraction.hover.coordinate = action.payload.activeCoordinate;
        },
        setMouseClickAxisIndex(state, action) {
          state.syncInteraction.active = false;
          state.keyboardInteraction.active = false;
          state.axisInteraction.click.active = true;
          state.axisInteraction.click.index = action.payload.activeIndex;
          state.axisInteraction.click.dataKey = action.payload.activeDataKey;
          state.axisInteraction.click.coordinate = action.payload.activeCoordinate;
        },
        setSyncInteraction(state, action) {
          state.syncInteraction = action.payload;
        },
        setKeyboardInteraction(state, action) {
          state.keyboardInteraction.active = action.payload.active;
          state.keyboardInteraction.index = action.payload.activeIndex;
          state.keyboardInteraction.coordinate = action.payload.activeCoordinate;
          state.keyboardInteraction.dataKey = action.payload.activeDataKey;
        }
      }
    });
    var {
      addTooltipEntrySettings,
      replaceTooltipEntrySettings,
      removeTooltipEntrySettings,
      setTooltipSettingsState,
      setActiveMouseOverItemIndex,
      mouseLeaveItem,
      mouseLeaveChart,
      setActiveClickItemIndex,
      setMouseOverAxisIndex,
      setMouseClickAxisIndex,
      setSyncInteraction,
      setKeyboardInteraction
    } = tooltipSlice.actions;
    var tooltipReducer = tooltipSlice.reducer;
    function ownKeys$q(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$q(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$q(Object(t2), true).forEach(function(r3) {
          _defineProperty$s(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$q(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$s(e, r2, t2) {
      return (r2 = _toPropertyKey$s(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$s(t2) {
      var i = _toPrimitive$s(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$s(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function chooseAppropriateMouseInteraction(tooltipState, tooltipEventType, trigger) {
      if (tooltipEventType === "axis") {
        if (trigger === "click") {
          return tooltipState.axisInteraction.click;
        }
        return tooltipState.axisInteraction.hover;
      }
      if (trigger === "click") {
        return tooltipState.itemInteraction.click;
      }
      return tooltipState.itemInteraction.hover;
    }
    function hasBeenActivePreviously(tooltipInteractionState) {
      return tooltipInteractionState.index != null;
    }
    var combineTooltipInteractionState = (tooltipState, tooltipEventType, trigger, defaultIndex) => {
      if (tooltipEventType == null) {
        return noInteraction;
      }
      var appropriateMouseInteraction = chooseAppropriateMouseInteraction(tooltipState, tooltipEventType, trigger);
      if (appropriateMouseInteraction == null) {
        return noInteraction;
      }
      if (appropriateMouseInteraction.active) {
        return appropriateMouseInteraction;
      }
      if (tooltipState.keyboardInteraction.active) {
        return tooltipState.keyboardInteraction;
      }
      if (tooltipState.syncInteraction.active && tooltipState.syncInteraction.index != null) {
        return tooltipState.syncInteraction;
      }
      var activeFromProps = tooltipState.settings.active === true;
      if (hasBeenActivePreviously(appropriateMouseInteraction)) {
        if (activeFromProps) {
          return _objectSpread$q(_objectSpread$q({}, appropriateMouseInteraction), {}, {
            active: true
          });
        }
      } else if (defaultIndex != null) {
        return {
          active: true,
          coordinate: void 0,
          dataKey: void 0,
          index: defaultIndex,
          graphicalItemId: void 0
        };
      }
      return _objectSpread$q(_objectSpread$q({}, noInteraction), {}, {
        coordinate: appropriateMouseInteraction.coordinate
      });
    };
    function toFiniteNumber(value) {
      if (typeof value === "number") {
        return Number.isFinite(value) ? value : void 0;
      }
      if (value instanceof Date) {
        var numericValue = value.valueOf();
        return Number.isFinite(numericValue) ? numericValue : void 0;
      }
      var parsed = Number(value);
      return Number.isFinite(parsed) ? parsed : void 0;
    }
    function isValueWithinNumberDomain(value, domain) {
      var numericValue = toFiniteNumber(value);
      var lowerBound = domain[0];
      var upperBound = domain[1];
      if (numericValue === void 0) {
        return false;
      }
      var min2 = Math.min(lowerBound, upperBound);
      var max2 = Math.max(lowerBound, upperBound);
      return numericValue >= min2 && numericValue <= max2;
    }
    function isValueWithinDomain(entry, axisDataKey, domain) {
      if (domain == null || axisDataKey == null) {
        return true;
      }
      var value = getValueByDataKey(entry, axisDataKey);
      if (value == null) {
        return true;
      }
      if (!isWellFormedNumberDomain(domain)) {
        return true;
      }
      return isValueWithinNumberDomain(value, domain);
    }
    var combineActiveTooltipIndex = (tooltipInteraction, chartData, axisDataKey, domain) => {
      var desiredIndex = tooltipInteraction === null || tooltipInteraction === void 0 ? void 0 : tooltipInteraction.index;
      if (desiredIndex == null) {
        return null;
      }
      var indexAsNumber = Number(desiredIndex);
      if (!isWellBehavedNumber(indexAsNumber)) {
        return desiredIndex;
      }
      var lowerLimit = 0;
      var upperLimit = Infinity;
      if (chartData.length > 0) {
        upperLimit = chartData.length - 1;
      }
      var clampedIndex = Math.max(lowerLimit, Math.min(indexAsNumber, upperLimit));
      var entry = chartData[clampedIndex];
      if (entry == null) {
        return String(clampedIndex);
      }
      if (!isValueWithinDomain(entry, axisDataKey, domain)) {
        return null;
      }
      return String(clampedIndex);
    };
    var combineCoordinateForDefaultIndex = (width, height, layout, offset, tooltipTicks, defaultIndex, tooltipConfigurations, tooltipPayloadSearcher) => {
      if (defaultIndex == null || tooltipPayloadSearcher == null) {
        return void 0;
      }
      var firstConfiguration = tooltipConfigurations[0];
      var maybePosition = firstConfiguration == null ? void 0 : tooltipPayloadSearcher(firstConfiguration.positions, defaultIndex);
      if (maybePosition != null) {
        return maybePosition;
      }
      var tick = tooltipTicks === null || tooltipTicks === void 0 ? void 0 : tooltipTicks[Number(defaultIndex)];
      if (!tick) {
        return void 0;
      }
      switch (layout) {
        case "horizontal": {
          return {
            x: tick.coordinate,
            y: (offset.top + height) / 2
          };
        }
        default: {
          return {
            x: (offset.left + width) / 2,
            y: tick.coordinate
          };
        }
      }
    };
    var combineTooltipPayloadConfigurations = (tooltipState, tooltipEventType, trigger, defaultIndex) => {
      if (tooltipEventType === "axis") {
        return tooltipState.tooltipItemPayloads;
      }
      if (tooltipState.tooltipItemPayloads.length === 0) {
        return [];
      }
      var filterByDataKey;
      if (trigger === "hover") {
        filterByDataKey = tooltipState.itemInteraction.hover.dataKey;
      } else {
        filterByDataKey = tooltipState.itemInteraction.click.dataKey;
      }
      if (filterByDataKey == null && defaultIndex != null) {
        return [tooltipState.tooltipItemPayloads[0]];
      }
      return tooltipState.tooltipItemPayloads.filter((tpc) => {
        var _tpc$settings;
        return ((_tpc$settings = tpc.settings) === null || _tpc$settings === void 0 ? void 0 : _tpc$settings.dataKey) === filterByDataKey;
      });
    };
    var selectTooltipPayloadSearcher = (state) => state.options.tooltipPayloadSearcher;
    var selectTooltipState = (state) => state.tooltip;
    function ownKeys$p(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$p(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$p(Object(t2), true).forEach(function(r3) {
          _defineProperty$r(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$p(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$r(e, r2, t2) {
      return (r2 = _toPropertyKey$r(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$r(t2) {
      var i = _toPrimitive$r(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$r(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function selectFinalData(dataDefinedOnItem, dataDefinedOnChart) {
      if (dataDefinedOnItem != null) {
        return dataDefinedOnItem;
      }
      return dataDefinedOnChart;
    }
    var combineTooltipPayload = (tooltipPayloadConfigurations, activeIndex, chartDataState, tooltipAxisDataKey, activeLabel, tooltipPayloadSearcher, tooltipEventType) => {
      if (activeIndex == null || tooltipPayloadSearcher == null) {
        return void 0;
      }
      var {
        chartData,
        computedData,
        dataStartIndex,
        dataEndIndex
      } = chartDataState;
      var init = [];
      return tooltipPayloadConfigurations.reduce((agg, _ref2) => {
        var _settings$dataKey;
        var {
          dataDefinedOnItem,
          settings
        } = _ref2;
        var finalData = selectFinalData(dataDefinedOnItem, chartData);
        var sliced = Array.isArray(finalData) ? getSliced(finalData, dataStartIndex, dataEndIndex) : finalData;
        var finalDataKey = (_settings$dataKey = settings === null || settings === void 0 ? void 0 : settings.dataKey) !== null && _settings$dataKey !== void 0 ? _settings$dataKey : tooltipAxisDataKey;
        var finalNameKey = settings === null || settings === void 0 ? void 0 : settings.nameKey;
        var tooltipPayload;
        if (tooltipAxisDataKey && Array.isArray(sliced) && /*
         * findEntryInArray won't work for Scatter because Scatter provides an array of arrays
         * as tooltip payloads and findEntryInArray is not prepared to handle that.
         * Sad but also ScatterChart only allows 'item' tooltipEventType
         * and also this is only a problem if there are multiple Scatters and each has its own data array
         * so let's fix that some other time.
         */
        !Array.isArray(sliced[0]) && /*
         * If the tooltipEventType is 'axis', we should search for the dataKey in the sliced data
         * because thanks to allowDuplicatedCategory=false, the order of elements in the array
         * no longer matches the order of elements in the original data
         * and so we need to search by the active dataKey + label rather than by index.
         *
         * The same happens if multiple graphical items are present in the chart
         * and each of them has its own data array. Those arrays get concatenated
         * and again the tooltip index no longer matches the original data.
         *
         * On the other hand the tooltipEventType 'item' should always search by index
         * because we get the index from interacting over the individual elements
         * which is always accurate, irrespective of the allowDuplicatedCategory setting.
         */
        tooltipEventType === "axis") {
          tooltipPayload = findEntryInArray(sliced, tooltipAxisDataKey, activeLabel);
        } else {
          tooltipPayload = tooltipPayloadSearcher(sliced, activeIndex, computedData, finalNameKey);
        }
        if (Array.isArray(tooltipPayload)) {
          tooltipPayload.forEach((item) => {
            var newSettings = _objectSpread$p(_objectSpread$p({}, settings), {}, {
              name: item.name,
              unit: item.unit,
              // color and fill are erased to keep 100% the identical behaviour to recharts 2.x - but there's nothing stopping us from returning them here. It's technically a breaking change.
              color: void 0,
              // color and fill are erased to keep 100% the identical behaviour to recharts 2.x - but there's nothing stopping us from returning them here. It's technically a breaking change.
              fill: void 0
            });
            agg.push(getTooltipEntry({
              tooltipEntrySettings: newSettings,
              dataKey: item.dataKey,
              payload: item.payload,
              // @ts-expect-error getValueByDataKey does not validate the output type
              value: getValueByDataKey(item.payload, item.dataKey),
              name: item.name
            }));
          });
        } else {
          var _getValueByDataKey;
          agg.push(getTooltipEntry({
            tooltipEntrySettings: settings,
            dataKey: finalDataKey,
            payload: tooltipPayload,
            // @ts-expect-error getValueByDataKey does not validate the output type
            value: getValueByDataKey(tooltipPayload, finalDataKey),
            // @ts-expect-error getValueByDataKey does not validate the output type
            name: (_getValueByDataKey = getValueByDataKey(tooltipPayload, finalNameKey)) !== null && _getValueByDataKey !== void 0 ? _getValueByDataKey : settings === null || settings === void 0 ? void 0 : settings.name
          }));
        }
        return agg;
      }, init);
    };
    var selectTooltipAxisRealScaleType = createSelector([selectTooltipAxis, selectChartLayout, selectHasBar, selectChartName, selectTooltipAxisType], combineRealScaleType);
    var selectAllUnfilteredGraphicalItems = createSelector([(state) => state.graphicalItems.cartesianItems, (state) => state.graphicalItems.polarItems], (cartesianItems, polarItems) => [...cartesianItems, ...polarItems]);
    var selectTooltipAxisPredicate = createSelector([selectTooltipAxisType, selectTooltipAxisId], itemAxisPredicate);
    var selectAllGraphicalItemsSettings = createSelector([selectAllUnfilteredGraphicalItems, selectTooltipAxis, selectTooltipAxisPredicate], combineGraphicalItemsSettings, {
      memoizeOptions: {
        resultEqualityCheck: emptyArraysAreEqualCheck
      }
    });
    var selectAllStackedGraphicalItemsSettings = createSelector([selectAllGraphicalItemsSettings], (graphicalItems) => graphicalItems.filter(isStacked));
    var selectTooltipGraphicalItemsData = createSelector([selectAllGraphicalItemsSettings], combineGraphicalItemsData, {
      memoizeOptions: {
        resultEqualityCheck: emptyArraysAreEqualCheck
      }
    });
    var selectTooltipDisplayedData = createSelector([selectTooltipGraphicalItemsData, selectChartDataWithIndexes], combineDisplayedData);
    var selectTooltipStackedData = createSelector([selectAllStackedGraphicalItemsSettings, selectChartDataWithIndexes, selectTooltipAxis], combineDisplayedStackedData);
    var selectAllTooltipAppliedValues = createSelector([selectTooltipDisplayedData, selectTooltipAxis, selectAllGraphicalItemsSettings], combineAppliedValues);
    var selectTooltipAxisDomainDefinition = createSelector([selectTooltipAxis], getDomainDefinition);
    var selectTooltipDataOverflow = createSelector([selectTooltipAxis], (axisSettings) => axisSettings.allowDataOverflow);
    var selectTooltipDomainFromUserPreferences = createSelector([selectTooltipAxisDomainDefinition, selectTooltipDataOverflow], numericalDomainSpecifiedWithoutRequiringData);
    var selectAllStackedGraphicalItems = createSelector([selectAllGraphicalItemsSettings], (graphicalItems) => graphicalItems.filter(isStacked));
    var selectTooltipStackGroups = createSelector([selectTooltipStackedData, selectAllStackedGraphicalItems, selectStackOffsetType, selectReverseStackOrder], combineStackGroups);
    var selectTooltipDomainOfStackGroups = createSelector([selectTooltipStackGroups, selectChartDataWithIndexes, selectTooltipAxisType, selectTooltipDomainFromUserPreferences], combineDomainOfStackGroups);
    var selectTooltipItemsSettingsExceptStacked = createSelector([selectAllGraphicalItemsSettings], filterGraphicalNotStackedItems);
    var selectDomainOfAllAppliedNumericalValuesIncludingErrorValues = createSelector([selectTooltipDisplayedData, selectTooltipAxis, selectTooltipItemsSettingsExceptStacked, selectAllErrorBarSettings, selectTooltipAxisType], combineDomainOfAllAppliedNumericalValuesIncludingErrorValues, {
      memoizeOptions: {
        resultEqualityCheck: numberDomainEqualityCheck
      }
    });
    var selectReferenceDotsByTooltipAxis = createSelector([selectReferenceDots, selectTooltipAxisType, selectTooltipAxisId], filterReferenceElements);
    var selectTooltipReferenceDotsDomain = createSelector([selectReferenceDotsByTooltipAxis, selectTooltipAxisType], combineDotsDomain);
    var selectReferenceAreasByTooltipAxis = createSelector([selectReferenceAreas, selectTooltipAxisType, selectTooltipAxisId], filterReferenceElements);
    var selectTooltipReferenceAreasDomain = createSelector([selectReferenceAreasByTooltipAxis, selectTooltipAxisType], combineAreasDomain);
    var selectReferenceLinesByTooltipAxis = createSelector([selectReferenceLines, selectTooltipAxisType, selectTooltipAxisId], filterReferenceElements);
    var selectTooltipReferenceLinesDomain = createSelector([selectReferenceLinesByTooltipAxis, selectTooltipAxisType], combineLinesDomain);
    var selectTooltipReferenceElementsDomain = createSelector([selectTooltipReferenceDotsDomain, selectTooltipReferenceLinesDomain, selectTooltipReferenceAreasDomain], mergeDomains);
    var selectTooltipNumericalDomain = createSelector([selectTooltipAxis, selectTooltipAxisDomainDefinition, selectTooltipDomainFromUserPreferences, selectTooltipDomainOfStackGroups, selectDomainOfAllAppliedNumericalValuesIncludingErrorValues, selectTooltipReferenceElementsDomain, selectChartLayout, selectTooltipAxisType], combineNumericalDomain);
    var selectTooltipAxisDomain = createSelector([selectTooltipAxis, selectChartLayout, selectTooltipDisplayedData, selectAllTooltipAppliedValues, selectStackOffsetType, selectTooltipAxisType, selectTooltipNumericalDomain], combineAxisDomain);
    var selectTooltipNiceTicks = createSelector([selectTooltipAxisDomain, selectTooltipAxis, selectTooltipAxisRealScaleType], combineNiceTicks);
    var selectTooltipAxisDomainIncludingNiceTicks = createSelector([selectTooltipAxis, selectTooltipAxisDomain, selectTooltipNiceTicks, selectTooltipAxisType], combineAxisDomainWithNiceTicks);
    var selectTooltipAxisRange = (state) => {
      var axisType = selectTooltipAxisType(state);
      var axisId = selectTooltipAxisId(state);
      var isPanorama = false;
      return selectAxisRange(state, axisType, axisId, isPanorama);
    };
    var selectTooltipAxisRangeWithReverse = createSelector([selectTooltipAxis, selectTooltipAxisRange], combineAxisRangeWithReverse);
    var selectTooltipAxisScale = createSelector([selectTooltipAxis, selectTooltipAxisRealScaleType, selectTooltipAxisDomainIncludingNiceTicks, selectTooltipAxisRangeWithReverse], combineScaleFunction);
    var selectTooltipDuplicateDomain = createSelector([selectChartLayout, selectAllTooltipAppliedValues, selectTooltipAxis, selectTooltipAxisType], combineDuplicateDomain);
    var selectTooltipCategoricalDomain = createSelector([selectChartLayout, selectAllTooltipAppliedValues, selectTooltipAxis, selectTooltipAxisType], combineCategoricalDomain);
    var combineTicksOfTooltipAxis = (layout, axis, realScaleType, scale, range2, duplicateDomain, categoricalDomain, axisType) => {
      if (!axis) {
        return void 0;
      }
      var {
        type
      } = axis;
      var isCategorical = isCategoricalAxis(layout, axisType);
      if (!scale) {
        return void 0;
      }
      var offsetForBand = realScaleType === "scaleBand" && scale.bandwidth ? scale.bandwidth() / 2 : 2;
      var offset = type === "category" && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;
      offset = axisType === "angleAxis" && range2 != null && (range2 === null || range2 === void 0 ? void 0 : range2.length) >= 2 ? mathSign(range2[0] - range2[1]) * 2 * offset : offset;
      if (isCategorical && categoricalDomain) {
        return categoricalDomain.map((entry, index) => ({
          coordinate: scale(entry) + offset,
          value: entry,
          index,
          offset
        }));
      }
      return scale.domain().map((entry, index) => ({
        coordinate: scale(entry) + offset,
        value: duplicateDomain ? duplicateDomain[entry] : entry,
        index,
        offset
      }));
    };
    var selectTooltipAxisTicks = createSelector([selectChartLayout, selectTooltipAxis, selectTooltipAxisRealScaleType, selectTooltipAxisScale, selectTooltipAxisRange, selectTooltipDuplicateDomain, selectTooltipCategoricalDomain, selectTooltipAxisType], combineTicksOfTooltipAxis);
    var selectTooltipEventType = createSelector([selectDefaultTooltipEventType, selectValidateTooltipEventTypes, selectTooltipSettings], (defaultTooltipEventType, validateTooltipEventType, settings) => combineTooltipEventType(settings.shared, defaultTooltipEventType, validateTooltipEventType));
    var selectTooltipTrigger = (state) => state.tooltip.settings.trigger;
    var selectDefaultIndex = (state) => state.tooltip.settings.defaultIndex;
    var selectTooltipInteractionState$1 = createSelector([selectTooltipState, selectTooltipEventType, selectTooltipTrigger, selectDefaultIndex], combineTooltipInteractionState);
    var selectActiveTooltipIndex = createSelector([selectTooltipInteractionState$1, selectTooltipDisplayedData, selectTooltipAxisDataKey, selectTooltipAxisDomain], combineActiveTooltipIndex);
    var selectActiveLabel$1 = createSelector([selectTooltipAxisTicks, selectActiveTooltipIndex], combineActiveLabel);
    var selectActiveTooltipDataKey = createSelector([selectTooltipInteractionState$1], (tooltipInteraction) => {
      if (!tooltipInteraction) {
        return void 0;
      }
      return tooltipInteraction.dataKey;
    });
    var selectActiveTooltipGraphicalItemId = createSelector([selectTooltipInteractionState$1], (tooltipInteraction) => {
      if (!tooltipInteraction) {
        return void 0;
      }
      return tooltipInteraction.graphicalItemId;
    });
    var selectTooltipPayloadConfigurations$1 = createSelector([selectTooltipState, selectTooltipEventType, selectTooltipTrigger, selectDefaultIndex], combineTooltipPayloadConfigurations);
    var selectTooltipCoordinateForDefaultIndex = createSelector([selectChartWidth, selectChartHeight, selectChartLayout, selectChartOffsetInternal, selectTooltipAxisTicks, selectDefaultIndex, selectTooltipPayloadConfigurations$1, selectTooltipPayloadSearcher], combineCoordinateForDefaultIndex);
    var selectActiveTooltipCoordinate = createSelector([selectTooltipInteractionState$1, selectTooltipCoordinateForDefaultIndex], (tooltipInteractionState, defaultIndexCoordinate) => {
      if (tooltipInteractionState !== null && tooltipInteractionState !== void 0 && tooltipInteractionState.coordinate) {
        return tooltipInteractionState.coordinate;
      }
      return defaultIndexCoordinate;
    });
    var selectIsTooltipActive$1 = createSelector([selectTooltipInteractionState$1], (tooltipInteractionState) => tooltipInteractionState.active);
    var selectActiveTooltipPayload = createSelector([selectTooltipPayloadConfigurations$1, selectActiveTooltipIndex, selectChartDataWithIndexes, selectTooltipAxisDataKey, selectActiveLabel$1, selectTooltipPayloadSearcher, selectTooltipEventType], combineTooltipPayload);
    var selectActiveTooltipDataPoints = createSelector([selectActiveTooltipPayload], (payload) => {
      if (payload == null) {
        return void 0;
      }
      var dataPoints = payload.map((p2) => p2.payload).filter((p2) => p2 != null);
      return Array.from(new Set(dataPoints));
    });
    function ownKeys$o(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$o(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$o(Object(t2), true).forEach(function(r3) {
          _defineProperty$q(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$o(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$q(e, r2, t2) {
      return (r2 = _toPropertyKey$q(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$q(t2) {
      var i = _toPrimitive$q(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$q(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    var useTooltipAxis = () => useAppSelector(selectTooltipAxis);
    var useTooltipAxisBandSize = () => {
      var tooltipAxis = useTooltipAxis();
      var tooltipTicks = useAppSelector(selectTooltipAxisTicks);
      var tooltipAxisScale = useAppSelector(selectTooltipAxisScale);
      if (!tooltipAxis || !tooltipAxisScale) {
        return getBandSizeOfAxis(void 0, tooltipTicks);
      }
      return getBandSizeOfAxis(_objectSpread$o(_objectSpread$o({}, tooltipAxis), {}, {
        scale: tooltipAxisScale
      }), tooltipTicks);
    };
    function ownKeys$n(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$n(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$n(Object(t2), true).forEach(function(r3) {
          _defineProperty$p(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$n(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$p(e, r2, t2) {
      return (r2 = _toPropertyKey$p(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$p(t2) {
      var i = _toPrimitive$p(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$p(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    var getActiveCartesianCoordinate = (layout, tooltipTicks, activeIndex, pointer) => {
      var entry = tooltipTicks.find((tick) => tick && tick.index === activeIndex);
      if (entry) {
        if (layout === "horizontal") {
          return {
            x: entry.coordinate,
            y: pointer.chartY
          };
        }
        if (layout === "vertical") {
          return {
            x: pointer.chartX,
            y: entry.coordinate
          };
        }
      }
      return {
        x: 0,
        y: 0
      };
    };
    var getActivePolarCoordinate = (layout, tooltipTicks, activeIndex, rangeObj) => {
      var entry = tooltipTicks.find((tick) => tick && tick.index === activeIndex);
      if (entry) {
        if (layout === "centric") {
          var _angle = entry.coordinate;
          var {
            radius: _radius
          } = rangeObj;
          return _objectSpread$n(_objectSpread$n(_objectSpread$n({}, rangeObj), polarToCartesian(rangeObj.cx, rangeObj.cy, _radius, _angle)), {}, {
            angle: _angle,
            radius: _radius
          });
        }
        var radius = entry.coordinate;
        var {
          angle
        } = rangeObj;
        return _objectSpread$n(_objectSpread$n(_objectSpread$n({}, rangeObj), polarToCartesian(rangeObj.cx, rangeObj.cy, radius, angle)), {}, {
          angle,
          radius
        });
      }
      return {
        angle: 0,
        clockWise: false,
        cx: 0,
        cy: 0,
        endAngle: 0,
        innerRadius: 0,
        outerRadius: 0,
        radius: 0,
        startAngle: 0,
        x: 0,
        y: 0
      };
    };
    function isInCartesianRange(pointer, offset) {
      var {
        chartX: x2,
        chartY: y2
      } = pointer;
      return x2 >= offset.left && x2 <= offset.left + offset.width && y2 >= offset.top && y2 <= offset.top + offset.height;
    }
    var calculateActiveTickIndex = (coordinate, ticks2, unsortedTicks, axisType, range2) => {
      var _ticks$length;
      var index = -1;
      var len = (_ticks$length = ticks2 === null || ticks2 === void 0 ? void 0 : ticks2.length) !== null && _ticks$length !== void 0 ? _ticks$length : 0;
      if (len <= 1 || coordinate == null) {
        return 0;
      }
      if (axisType === "angleAxis" && range2 != null && Math.abs(Math.abs(range2[1] - range2[0]) - 360) <= 1e-6) {
        for (var i = 0; i < len; i++) {
          var before = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate;
          var cur = unsortedTicks[i].coordinate;
          var after = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate;
          var sameDirectionCoord = void 0;
          if (mathSign(cur - before) !== mathSign(after - cur)) {
            var diffInterval = [];
            if (mathSign(after - cur) === mathSign(range2[1] - range2[0])) {
              sameDirectionCoord = after;
              var curInRange = cur + range2[1] - range2[0];
              diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2);
              diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);
            } else {
              sameDirectionCoord = before;
              var afterInRange = after + range2[1] - range2[0];
              diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);
              diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);
            }
            var sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];
            if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {
              ({
                index
              } = unsortedTicks[i]);
              break;
            }
          } else {
            var minValue = Math.min(before, after);
            var maxValue = Math.max(before, after);
            if (coordinate > (minValue + cur) / 2 && coordinate <= (maxValue + cur) / 2) {
              ({
                index
              } = unsortedTicks[i]);
              break;
            }
          }
        }
      } else if (ticks2) {
        for (var _i = 0; _i < len; _i++) {
          if (_i === 0 && coordinate <= (ticks2[_i].coordinate + ticks2[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks2[_i].coordinate + ticks2[_i - 1].coordinate) / 2 && coordinate <= (ticks2[_i].coordinate + ticks2[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks2[_i].coordinate + ticks2[_i - 1].coordinate) / 2) {
            ({
              index
            } = ticks2[_i]);
            break;
          }
        }
      }
      return index;
    };
    var useChartName = () => {
      return useAppSelector(selectChartName);
    };
    var pickTooltipEventType = (_state, tooltipEventType) => tooltipEventType;
    var pickTrigger = (_state, _tooltipEventType, trigger) => trigger;
    var pickDefaultIndex = (_state, _tooltipEventType, _trigger, defaultIndex) => defaultIndex;
    var selectOrderedTooltipTicks = createSelector(selectTooltipAxisTicks, (ticks2) => sortBy$1(ticks2, (o) => o.coordinate));
    var selectTooltipInteractionState = createSelector([selectTooltipState, pickTooltipEventType, pickTrigger, pickDefaultIndex], combineTooltipInteractionState);
    var selectActiveIndex = createSelector([selectTooltipInteractionState, selectTooltipDisplayedData, selectTooltipAxisDataKey, selectTooltipAxisDomain], combineActiveTooltipIndex);
    var selectTooltipDataKey = (state, tooltipEventType, trigger) => {
      if (tooltipEventType == null) {
        return void 0;
      }
      var tooltipState = selectTooltipState(state);
      if (tooltipEventType === "axis") {
        if (trigger === "hover") {
          return tooltipState.axisInteraction.hover.dataKey;
        }
        return tooltipState.axisInteraction.click.dataKey;
      }
      if (trigger === "hover") {
        return tooltipState.itemInteraction.hover.dataKey;
      }
      return tooltipState.itemInteraction.click.dataKey;
    };
    var selectTooltipPayloadConfigurations = createSelector([selectTooltipState, pickTooltipEventType, pickTrigger, pickDefaultIndex], combineTooltipPayloadConfigurations);
    var selectCoordinateForDefaultIndex = createSelector([selectChartWidth, selectChartHeight, selectChartLayout, selectChartOffsetInternal, selectTooltipAxisTicks, pickDefaultIndex, selectTooltipPayloadConfigurations, selectTooltipPayloadSearcher], combineCoordinateForDefaultIndex);
    var selectActiveCoordinate = createSelector([selectTooltipInteractionState, selectCoordinateForDefaultIndex], (tooltipInteractionState, defaultIndexCoordinate) => {
      var _tooltipInteractionSt;
      return (_tooltipInteractionSt = tooltipInteractionState.coordinate) !== null && _tooltipInteractionSt !== void 0 ? _tooltipInteractionSt : defaultIndexCoordinate;
    });
    var selectActiveLabel = createSelector([selectTooltipAxisTicks, selectActiveIndex], combineActiveLabel);
    var selectTooltipPayload = createSelector([selectTooltipPayloadConfigurations, selectActiveIndex, selectChartDataWithIndexes, selectTooltipAxisDataKey, selectActiveLabel, selectTooltipPayloadSearcher, pickTooltipEventType], combineTooltipPayload);
    var selectIsTooltipActive = createSelector([selectTooltipInteractionState, selectActiveIndex], (tooltipInteractionState, activeIndex) => {
      return {
        isActive: tooltipInteractionState.active && activeIndex != null,
        activeIndex
      };
    });
    var combineActiveCartesianProps = (chartEvent, layout, tooltipAxisType, tooltipAxisRange, tooltipTicks, orderedTooltipTicks, offset) => {
      if (!chartEvent || !tooltipAxisType || !tooltipAxisRange || !tooltipTicks) {
        return void 0;
      }
      if (!isInCartesianRange(chartEvent, offset)) {
        return void 0;
      }
      var pos = calculateCartesianTooltipPos(chartEvent, layout);
      var activeIndex = calculateActiveTickIndex(pos, orderedTooltipTicks, tooltipTicks, tooltipAxisType, tooltipAxisRange);
      var activeCoordinate = getActiveCartesianCoordinate(layout, tooltipTicks, activeIndex, chartEvent);
      return {
        activeIndex: String(activeIndex),
        activeCoordinate
      };
    };
    var combineActivePolarProps = (chartEvent, layout, polarViewBox, tooltipAxisType, tooltipAxisRange, tooltipTicks, orderedTooltipTicks) => {
      if (!chartEvent || !tooltipAxisType || !tooltipAxisRange || !tooltipTicks || !polarViewBox) {
        return void 0;
      }
      var rangeObj = inRangeOfSector(chartEvent, polarViewBox);
      if (!rangeObj) {
        return void 0;
      }
      var pos = calculatePolarTooltipPos(rangeObj, layout);
      var activeIndex = calculateActiveTickIndex(pos, orderedTooltipTicks, tooltipTicks, tooltipAxisType, tooltipAxisRange);
      var activeCoordinate = getActivePolarCoordinate(layout, tooltipTicks, activeIndex, rangeObj);
      return {
        activeIndex: String(activeIndex),
        activeCoordinate
      };
    };
    var combineActiveProps = (chartEvent, layout, polarViewBox, tooltipAxisType, tooltipAxisRange, tooltipTicks, orderedTooltipTicks, offset) => {
      if (!chartEvent || !layout || !tooltipAxisType || !tooltipAxisRange || !tooltipTicks) {
        return void 0;
      }
      if (layout === "horizontal" || layout === "vertical") {
        return combineActiveCartesianProps(chartEvent, layout, tooltipAxisType, tooltipAxisRange, tooltipTicks, orderedTooltipTicks, offset);
      }
      return combineActivePolarProps(chartEvent, layout, polarViewBox, tooltipAxisType, tooltipAxisRange, tooltipTicks, orderedTooltipTicks);
    };
    var selectZIndexPortalId = createSelector((state) => state.zIndex.zIndexMap, (_, zIndex) => zIndex, (_, _zIndex, isPanorama) => isPanorama, (zIndexMap, zIndex, isPanorama) => {
      if (zIndex == null) {
        return void 0;
      }
      var entry = zIndexMap[zIndex];
      if (entry == null) {
        return void 0;
      }
      if (isPanorama) {
        return entry.panoramaElementId;
      }
      return entry.elementId;
    });
    var selectAllRegisteredZIndexes = createSelector((state) => state.zIndex.zIndexMap, (zIndexMap) => {
      var allNumbers = Object.keys(zIndexMap).map((zIndexStr) => parseInt(zIndexStr, 10)).concat(Object.values(DefaultZIndexes));
      var uniqueNumbers = Array.from(new Set(allNumbers));
      return uniqueNumbers.sort((a2, b) => a2 - b);
    }, {
      memoizeOptions: {
        resultEqualityCheck: arrayContentsAreEqualCheck
      }
    });
    function ownKeys$m(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$m(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$m(Object(t2), true).forEach(function(r3) {
          _defineProperty$o(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$m(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$o(e, r2, t2) {
      return (r2 = _toPropertyKey$o(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$o(t2) {
      var i = _toPrimitive$o(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$o(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    var seed = {};
    var initialState$8 = {
      zIndexMap: Object.values(DefaultZIndexes).reduce((acc, current2) => _objectSpread$m(_objectSpread$m({}, acc), {}, {
        [current2]: {
          elementId: void 0,
          panoramaElementId: void 0,
          consumers: 0
        }
      }), seed)
    };
    var defaultZIndexSet = new Set(Object.values(DefaultZIndexes));
    function isDefaultZIndex(zIndex) {
      return defaultZIndexSet.has(zIndex);
    }
    var zIndexSlice = createSlice({
      name: "zIndex",
      initialState: initialState$8,
      reducers: {
        registerZIndexPortal: {
          reducer: (state, action) => {
            var {
              zIndex
            } = action.payload;
            if (state.zIndexMap[zIndex]) {
              state.zIndexMap[zIndex].consumers += 1;
            } else {
              state.zIndexMap[zIndex] = {
                consumers: 1,
                elementId: void 0,
                panoramaElementId: void 0
              };
            }
          },
          prepare: prepareAutoBatched()
        },
        unregisterZIndexPortal: {
          reducer: (state, action) => {
            var {
              zIndex
            } = action.payload;
            if (state.zIndexMap[zIndex]) {
              state.zIndexMap[zIndex].consumers -= 1;
              if (state.zIndexMap[zIndex].consumers <= 0 && !isDefaultZIndex(zIndex)) {
                delete state.zIndexMap[zIndex];
              }
            }
          },
          prepare: prepareAutoBatched()
        },
        registerZIndexPortalId: {
          reducer: (state, action) => {
            var {
              zIndex,
              elementId,
              isPanorama
            } = action.payload;
            if (state.zIndexMap[zIndex]) {
              if (isPanorama) {
                state.zIndexMap[zIndex].panoramaElementId = elementId;
              } else {
                state.zIndexMap[zIndex].elementId = elementId;
              }
            } else {
              state.zIndexMap[zIndex] = {
                consumers: 0,
                elementId: isPanorama ? void 0 : elementId,
                panoramaElementId: isPanorama ? elementId : void 0
              };
            }
          },
          prepare: prepareAutoBatched()
        },
        unregisterZIndexPortalId: {
          reducer: (state, action) => {
            var {
              zIndex
            } = action.payload;
            if (state.zIndexMap[zIndex]) {
              if (action.payload.isPanorama) {
                state.zIndexMap[zIndex].panoramaElementId = void 0;
              } else {
                state.zIndexMap[zIndex].elementId = void 0;
              }
            }
          },
          prepare: prepareAutoBatched()
        }
      }
    });
    var {
      registerZIndexPortal,
      unregisterZIndexPortal,
      registerZIndexPortalId,
      unregisterZIndexPortalId
    } = zIndexSlice.actions;
    var zIndexReducer = zIndexSlice.reducer;
    function ZIndexLayer(_ref2) {
      var {
        zIndex,
        children
      } = _ref2;
      var isInChartContext = useIsInChartContext();
      var shouldRenderInPortal = isInChartContext && zIndex !== void 0 && zIndex !== 0;
      var isPanorama = useIsPanorama();
      var dispatch = useAppDispatch();
      reactExports.useLayoutEffect(() => {
        if (!shouldRenderInPortal) {
          return noop$2;
        }
        dispatch(registerZIndexPortal({
          zIndex
        }));
        return () => {
          dispatch(unregisterZIndexPortal({
            zIndex
          }));
        };
      }, [dispatch, zIndex, shouldRenderInPortal]);
      var portalId = useAppSelector((state) => selectZIndexPortalId(state, zIndex, isPanorama));
      if (!shouldRenderInPortal) {
        return children;
      }
      if (!portalId) {
        return null;
      }
      var zIndexPortal = document.getElementById(portalId);
      if (zIndexPortal) {
        return /* @__PURE__ */ reactDomExports.createPortal(children, zIndexPortal);
      }
      return null;
    }
    function _extends$j() {
      return _extends$j = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$j.apply(null, arguments);
    }
    function ownKeys$l(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$l(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$l(Object(t2), true).forEach(function(r3) {
          _defineProperty$n(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$l(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$n(e, r2, t2) {
      return (r2 = _toPropertyKey$n(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$n(t2) {
      var i = _toPrimitive$n(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$n(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function RenderCursor(_ref2) {
      var {
        cursor,
        cursorComp,
        cursorProps
      } = _ref2;
      if (/* @__PURE__ */ reactExports.isValidElement(cursor)) {
        return /* @__PURE__ */ reactExports.cloneElement(cursor, cursorProps);
      }
      return /* @__PURE__ */ reactExports.createElement(cursorComp, cursorProps);
    }
    function CursorInternal(props) {
      var _props$zIndex;
      var {
        coordinate,
        payload,
        index,
        offset,
        tooltipAxisBandSize,
        layout,
        cursor,
        tooltipEventType,
        chartName
      } = props;
      var activeCoordinate = coordinate;
      var activePayload = payload;
      var activeTooltipIndex = index;
      if (!cursor || !activeCoordinate || chartName !== "ScatterChart" && tooltipEventType !== "axis") {
        return null;
      }
      var restProps, cursorComp, preferredZIndex;
      if (chartName === "ScatterChart") {
        restProps = activeCoordinate;
        cursorComp = Cross;
        preferredZIndex = DefaultZIndexes.cursorLine;
      } else if (chartName === "BarChart") {
        restProps = getCursorRectangle(layout, activeCoordinate, offset, tooltipAxisBandSize);
        cursorComp = Rectangle;
        preferredZIndex = DefaultZIndexes.cursorRectangle;
      } else if (layout === "radial" && isPolarCoordinate(activeCoordinate)) {
        var {
          cx,
          cy,
          radius,
          startAngle,
          endAngle
        } = getRadialCursorPoints(activeCoordinate);
        restProps = {
          cx,
          cy,
          startAngle,
          endAngle,
          innerRadius: radius,
          outerRadius: radius
        };
        cursorComp = Sector;
        preferredZIndex = DefaultZIndexes.cursorLine;
      } else {
        restProps = {
          points: getCursorPoints(layout, activeCoordinate, offset)
        };
        cursorComp = Curve;
        preferredZIndex = DefaultZIndexes.cursorLine;
      }
      var extraClassName = typeof cursor === "object" && "className" in cursor ? cursor.className : void 0;
      var cursorProps = _objectSpread$l(_objectSpread$l(_objectSpread$l(_objectSpread$l({
        stroke: "#ccc",
        pointerEvents: "none"
      }, offset), restProps), svgPropertiesNoEventsFromUnknown(cursor)), {}, {
        payload: activePayload,
        payloadIndex: activeTooltipIndex,
        className: clsx("recharts-tooltip-cursor", extraClassName)
      });
      return /* @__PURE__ */ reactExports.createElement(ZIndexLayer, {
        zIndex: (_props$zIndex = props.zIndex) !== null && _props$zIndex !== void 0 ? _props$zIndex : preferredZIndex
      }, /* @__PURE__ */ reactExports.createElement(RenderCursor, {
        cursor,
        cursorComp,
        cursorProps
      }));
    }
    function Cursor(props) {
      var tooltipAxisBandSize = useTooltipAxisBandSize();
      var offset = useOffsetInternal();
      var layout = useChartLayout();
      var chartName = useChartName();
      if (tooltipAxisBandSize == null || offset == null || layout == null || chartName == null) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(CursorInternal, _extends$j({}, props, {
        offset,
        layout,
        tooltipAxisBandSize,
        chartName
      }));
    }
    var TooltipPortalContext = /* @__PURE__ */ reactExports.createContext(null);
    var useTooltipPortal = () => reactExports.useContext(TooltipPortalContext);
    var eventemitter3 = { exports: {} };
    (function(module2) {
      var has2 = Object.prototype.hasOwnProperty, prefix2 = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__) prefix2 = false;
      }
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      function addListener2(emitter, event, fn, context, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener2 = new EE(fn, context || emitter, once), evt = prefix2 ? prefix2 + event : event;
        if (!emitter._events[evt]) emitter._events[evt] = listener2, emitter._eventsCount++;
        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener2);
        else emitter._events[evt] = [emitter._events[evt], listener2];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0) emitter._events = new Events();
        else delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0) return names;
        for (name in events = this._events) {
          if (has2.call(events, name)) names.push(prefix2 ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
        if (!handlers) return [];
        if (handlers.fn) return [handlers.fn];
        for (var i = 0, l2 = handlers.length, ee2 = new Array(l2); i < l2; i++) {
          ee2[i] = handlers[i].fn;
        }
        return ee2;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];
        if (!listeners) return 0;
        if (listeners.fn) return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix2 ? prefix2 + event : event;
        if (!this._events[evt]) return false;
        var listeners = this._events[evt], len = arguments.length, args, i;
        if (listeners.fn) {
          if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j;
          for (i = 0; i < length; i++) {
            if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                break;
              default:
                if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on(event, fn, context) {
        return addListener2(this, event, fn, context, false);
      };
      EventEmitter2.prototype.once = function once(event, fn, context) {
        return addListener2(this, event, fn, context, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener2(event, fn, context, once) {
        var evt = prefix2 ? prefix2 + event : event;
        if (!this._events[evt]) return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events = [], length = listeners.length; i < length; i++) {
            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
              events.push(listeners[i]);
            }
          }
          if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
          else clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix2 ? prefix2 + event : event;
          if (this._events[evt]) clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix2;
      EventEmitter2.EventEmitter = EventEmitter2;
      {
        module2.exports = EventEmitter2;
      }
    })(eventemitter3);
    var eventemitter3Exports = eventemitter3.exports;
    const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
    var eventCenter = new EventEmitter();
    var TOOLTIP_SYNC_EVENT = "recharts.syncEvent.tooltip";
    var BRUSH_SYNC_EVENT = "recharts.syncEvent.brush";
    function arrayTooltipSearcher(data, strIndex) {
      if (!strIndex) return void 0;
      var numIndex = Number.parseInt(strIndex, 10);
      if (isNan(numIndex)) {
        return void 0;
      }
      return data === null || data === void 0 ? void 0 : data[numIndex];
    }
    var initialState$7 = {
      chartName: "",
      tooltipPayloadSearcher: void 0,
      eventEmitter: void 0,
      defaultTooltipEventType: "axis"
    };
    var optionsSlice = createSlice({
      name: "options",
      initialState: initialState$7,
      reducers: {
        createEventEmitter: (state) => {
          if (state.eventEmitter == null) {
            state.eventEmitter = Symbol("rechartsEventEmitter");
          }
        }
      }
    });
    var optionsReducer = optionsSlice.reducer;
    var {
      createEventEmitter
    } = optionsSlice.actions;
    function selectSynchronisedTooltipState(state) {
      return state.tooltip.syncInteraction;
    }
    var initialChartDataState = {
      chartData: void 0,
      computedData: void 0,
      dataStartIndex: 0,
      dataEndIndex: 0
    };
    var chartDataSlice = createSlice({
      name: "chartData",
      initialState: initialChartDataState,
      reducers: {
        setChartData(state, action) {
          state.chartData = action.payload;
          if (action.payload == null) {
            state.dataStartIndex = 0;
            state.dataEndIndex = 0;
            return;
          }
          if (action.payload.length > 0 && state.dataEndIndex !== action.payload.length - 1) {
            state.dataEndIndex = action.payload.length - 1;
          }
        },
        setComputedData(state, action) {
          state.computedData = action.payload;
        },
        setDataStartEndIndexes(state, action) {
          var {
            startIndex,
            endIndex
          } = action.payload;
          if (startIndex != null) {
            state.dataStartIndex = startIndex;
          }
          if (endIndex != null) {
            state.dataEndIndex = endIndex;
          }
        }
      }
    });
    var {
      setChartData,
      setDataStartEndIndexes,
      setComputedData
    } = chartDataSlice.actions;
    var chartDataReducer = chartDataSlice.reducer;
    var _excluded$j = ["x", "y"];
    function ownKeys$k(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$k(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$k(Object(t2), true).forEach(function(r3) {
          _defineProperty$m(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$k(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$m(e, r2, t2) {
      return (r2 = _toPropertyKey$m(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$m(t2) {
      var i = _toPrimitive$m(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$m(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function _objectWithoutProperties$j(e, t2) {
      if (null == e) return {};
      var o, r2, i = _objectWithoutPropertiesLoose$j(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e);
        for (r2 = 0; r2 < n2.length; r2++) o = n2[r2], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose$j(r2, e) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    function useTooltipSyncEventsListener() {
      var mySyncId = useAppSelector(selectSyncId);
      var myEventEmitter = useAppSelector(selectEventEmitter);
      var dispatch = useAppDispatch();
      var syncMethod = useAppSelector(selectSyncMethod);
      var tooltipTicks = useAppSelector(selectTooltipAxisTicks);
      var layout = useChartLayout();
      var viewBox = useViewBox();
      var className = useAppSelector((state) => state.rootProps.className);
      reactExports.useEffect(() => {
        if (mySyncId == null) {
          return noop$2;
        }
        var listener2 = (incomingSyncId, action, emitter) => {
          if (myEventEmitter === emitter) {
            return;
          }
          if (mySyncId !== incomingSyncId) {
            return;
          }
          if (syncMethod === "index") {
            var _action$payload;
            if (viewBox && action !== null && action !== void 0 && (_action$payload = action.payload) !== null && _action$payload !== void 0 && _action$payload.coordinate && action.payload.sourceViewBox) {
              var _action$payload$coord = action.payload.coordinate, {
                x: _x,
                y: _y
              } = _action$payload$coord, otherCoordinateProps = _objectWithoutProperties$j(_action$payload$coord, _excluded$j);
              var {
                x: sourceX,
                y: sourceY,
                width: sourceWidth,
                height: sourceHeight
              } = action.payload.sourceViewBox;
              var scaledCoordinate = _objectSpread$k(_objectSpread$k({}, otherCoordinateProps), {}, {
                x: viewBox.x + (sourceWidth ? (_x - sourceX) / sourceWidth : 0) * viewBox.width,
                y: viewBox.y + (sourceHeight ? (_y - sourceY) / sourceHeight : 0) * viewBox.height
              });
              dispatch(_objectSpread$k(_objectSpread$k({}, action), {}, {
                payload: _objectSpread$k(_objectSpread$k({}, action.payload), {}, {
                  coordinate: scaledCoordinate
                })
              }));
            } else {
              dispatch(action);
            }
            return;
          }
          if (tooltipTicks == null) {
            return;
          }
          var activeTick;
          if (typeof syncMethod === "function") {
            var syncMethodParam = {
              activeTooltipIndex: action.payload.index == null ? void 0 : Number(action.payload.index),
              isTooltipActive: action.payload.active,
              activeIndex: action.payload.index == null ? void 0 : Number(action.payload.index),
              activeLabel: action.payload.label,
              activeDataKey: action.payload.dataKey,
              activeCoordinate: action.payload.coordinate
            };
            var activeTooltipIndex = syncMethod(tooltipTicks, syncMethodParam);
            activeTick = tooltipTicks[activeTooltipIndex];
          } else if (syncMethod === "value") {
            activeTick = tooltipTicks.find((tick) => String(tick.value) === action.payload.label);
          }
          var {
            coordinate
          } = action.payload;
          if (activeTick == null || action.payload.active === false || coordinate == null || viewBox == null) {
            dispatch(setSyncInteraction({
              active: false,
              coordinate: void 0,
              dataKey: void 0,
              index: null,
              label: void 0,
              sourceViewBox: void 0,
              graphicalItemId: void 0
            }));
            return;
          }
          var {
            x: x2,
            y: y2
          } = coordinate;
          var validateChartX = Math.min(x2, viewBox.x + viewBox.width);
          var validateChartY = Math.min(y2, viewBox.y + viewBox.height);
          var activeCoordinate = {
            x: layout === "horizontal" ? activeTick.coordinate : validateChartX,
            y: layout === "horizontal" ? validateChartY : activeTick.coordinate
          };
          var syncAction = setSyncInteraction({
            active: action.payload.active,
            coordinate: activeCoordinate,
            dataKey: action.payload.dataKey,
            index: String(activeTick.index),
            label: action.payload.label,
            sourceViewBox: action.payload.sourceViewBox,
            graphicalItemId: action.payload.graphicalItemId
          });
          dispatch(syncAction);
        };
        eventCenter.on(TOOLTIP_SYNC_EVENT, listener2);
        return () => {
          eventCenter.off(TOOLTIP_SYNC_EVENT, listener2);
        };
      }, [className, dispatch, myEventEmitter, mySyncId, syncMethod, tooltipTicks, layout, viewBox]);
    }
    function useBrushSyncEventsListener() {
      var mySyncId = useAppSelector(selectSyncId);
      var myEventEmitter = useAppSelector(selectEventEmitter);
      var dispatch = useAppDispatch();
      reactExports.useEffect(() => {
        if (mySyncId == null) {
          return noop$2;
        }
        var listener2 = (incomingSyncId, action, emitter) => {
          if (myEventEmitter === emitter) {
            return;
          }
          if (mySyncId === incomingSyncId) {
            dispatch(setDataStartEndIndexes(action));
          }
        };
        eventCenter.on(BRUSH_SYNC_EVENT, listener2);
        return () => {
          eventCenter.off(BRUSH_SYNC_EVENT, listener2);
        };
      }, [dispatch, myEventEmitter, mySyncId]);
    }
    function useSynchronisedEventsFromOtherCharts() {
      var dispatch = useAppDispatch();
      reactExports.useEffect(() => {
        dispatch(createEventEmitter());
      }, [dispatch]);
      useTooltipSyncEventsListener();
      useBrushSyncEventsListener();
    }
    function useTooltipChartSynchronisation(tooltipEventType, trigger, activeCoordinate, activeLabel, activeIndex, isTooltipActive) {
      var activeDataKey = useAppSelector((state) => selectTooltipDataKey(state, tooltipEventType, trigger));
      var eventEmitterSymbol = useAppSelector(selectEventEmitter);
      var syncId = useAppSelector(selectSyncId);
      var syncMethod = useAppSelector(selectSyncMethod);
      var tooltipState = useAppSelector(selectSynchronisedTooltipState);
      var isReceivingSynchronisation = tooltipState === null || tooltipState === void 0 ? void 0 : tooltipState.active;
      var viewBox = useViewBox();
      reactExports.useEffect(() => {
        if (isReceivingSynchronisation) {
          return;
        }
        if (syncId == null) {
          return;
        }
        if (eventEmitterSymbol == null) {
          return;
        }
        var syncAction = setSyncInteraction({
          active: isTooltipActive,
          coordinate: activeCoordinate,
          dataKey: activeDataKey,
          index: activeIndex,
          label: typeof activeLabel === "number" ? String(activeLabel) : activeLabel,
          sourceViewBox: viewBox,
          graphicalItemId: void 0
        });
        eventCenter.emit(TOOLTIP_SYNC_EVENT, syncId, syncAction, eventEmitterSymbol);
      }, [isReceivingSynchronisation, activeCoordinate, activeDataKey, activeIndex, activeLabel, eventEmitterSymbol, syncId, syncMethod, isTooltipActive, viewBox]);
    }
    function ownKeys$j(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$j(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$j(Object(t2), true).forEach(function(r3) {
          _defineProperty$l(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$j(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$l(e, r2, t2) {
      return (r2 = _toPropertyKey$l(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$l(t2) {
      var i = _toPrimitive$l(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$l(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function defaultUniqBy(entry) {
      return entry.dataKey;
    }
    function renderContent(content, props) {
      if (/* @__PURE__ */ reactExports.isValidElement(content)) {
        return /* @__PURE__ */ reactExports.cloneElement(content, props);
      }
      if (typeof content === "function") {
        return /* @__PURE__ */ reactExports.createElement(content, props);
      }
      return /* @__PURE__ */ reactExports.createElement(DefaultTooltipContent, props);
    }
    var emptyPayload = [];
    var defaultTooltipProps = {
      allowEscapeViewBox: {
        x: false,
        y: false
      },
      animationDuration: 400,
      animationEasing: "ease",
      axisId: 0,
      contentStyle: {},
      cursor: true,
      filterNull: true,
      isAnimationActive: "auto",
      itemSorter: "name",
      itemStyle: {},
      labelStyle: {},
      offset: 10,
      reverseDirection: {
        x: false,
        y: false
      },
      separator: " : ",
      trigger: "hover",
      useTranslate3d: false,
      wrapperStyle: {}
    };
    function Tooltip(outsideProps) {
      var _useAppSelector, _ref2;
      var props = resolveDefaultProps(outsideProps, defaultTooltipProps);
      var {
        active: activeFromProps,
        allowEscapeViewBox,
        animationDuration,
        animationEasing,
        content,
        filterNull,
        isAnimationActive,
        offset,
        payloadUniqBy,
        position,
        reverseDirection,
        useTranslate3d,
        wrapperStyle,
        cursor,
        shared,
        trigger,
        defaultIndex,
        portal: portalFromProps,
        axisId
      } = props;
      var dispatch = useAppDispatch();
      var defaultIndexAsString = typeof defaultIndex === "number" ? String(defaultIndex) : defaultIndex;
      reactExports.useEffect(() => {
        dispatch(setTooltipSettingsState({
          shared,
          trigger,
          axisId,
          active: activeFromProps,
          defaultIndex: defaultIndexAsString
        }));
      }, [dispatch, shared, trigger, axisId, activeFromProps, defaultIndexAsString]);
      var viewBox = useViewBox();
      var accessibilityLayer = useAccessibilityLayer();
      var tooltipEventType = useTooltipEventType(shared);
      var {
        activeIndex,
        isActive
      } = (_useAppSelector = useAppSelector((state) => selectIsTooltipActive(state, tooltipEventType, trigger, defaultIndexAsString))) !== null && _useAppSelector !== void 0 ? _useAppSelector : {};
      var payloadFromRedux = useAppSelector((state) => selectTooltipPayload(state, tooltipEventType, trigger, defaultIndexAsString));
      var labelFromRedux = useAppSelector((state) => selectActiveLabel(state, tooltipEventType, trigger, defaultIndexAsString));
      var coordinate = useAppSelector((state) => selectActiveCoordinate(state, tooltipEventType, trigger, defaultIndexAsString));
      var payload = payloadFromRedux;
      var tooltipPortalFromContext = useTooltipPortal();
      var finalIsActive = (_ref2 = activeFromProps !== null && activeFromProps !== void 0 ? activeFromProps : isActive) !== null && _ref2 !== void 0 ? _ref2 : false;
      var [lastBoundingBox, updateBoundingBox] = useElementOffset([payload, finalIsActive]);
      var finalLabel = tooltipEventType === "axis" ? labelFromRedux : void 0;
      useTooltipChartSynchronisation(tooltipEventType, trigger, coordinate, finalLabel, activeIndex, finalIsActive);
      var tooltipPortal = portalFromProps !== null && portalFromProps !== void 0 ? portalFromProps : tooltipPortalFromContext;
      if (tooltipPortal == null || viewBox == null || tooltipEventType == null) {
        return null;
      }
      var finalPayload = payload !== null && payload !== void 0 ? payload : emptyPayload;
      if (!finalIsActive) {
        finalPayload = emptyPayload;
      }
      if (filterNull && finalPayload.length) {
        finalPayload = getUniqPayload(finalPayload.filter((entry) => entry.value != null && (entry.hide !== true || props.includeHidden)), payloadUniqBy, defaultUniqBy);
      }
      var hasPayload = finalPayload.length > 0;
      var tooltipElement = /* @__PURE__ */ reactExports.createElement(TooltipBoundingBox, {
        allowEscapeViewBox,
        animationDuration,
        animationEasing,
        isAnimationActive,
        active: finalIsActive,
        coordinate,
        hasPayload,
        offset,
        position,
        reverseDirection,
        useTranslate3d,
        viewBox,
        wrapperStyle,
        lastBoundingBox,
        innerRef: updateBoundingBox,
        hasPortalFromProps: Boolean(portalFromProps)
      }, renderContent(content, _objectSpread$j(_objectSpread$j({}, props), {}, {
        payload: finalPayload,
        label: finalLabel,
        active: finalIsActive,
        activeIndex,
        coordinate,
        accessibilityLayer
      })));
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactDomExports.createPortal(tooltipElement, tooltipPortal), finalIsActive && /* @__PURE__ */ reactExports.createElement(Cursor, {
        cursor,
        tooltipEventType,
        coordinate,
        payload: finalPayload,
        index: activeIndex
      }));
    }
    var Cell = (_props) => null;
    Cell.displayName = "Cell";
    function _defineProperty$k(e, r2, t2) {
      return (r2 = _toPropertyKey$k(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$k(t2) {
      var i = _toPrimitive$k(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$k(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    class LRUCache {
      constructor(maxSize) {
        _defineProperty$k(this, "cache", /* @__PURE__ */ new Map());
        this.maxSize = maxSize;
      }
      get(key) {
        var value = this.cache.get(key);
        if (value !== void 0) {
          this.cache.delete(key);
          this.cache.set(key, value);
        }
        return value;
      }
      set(key, value) {
        if (this.cache.has(key)) {
          this.cache.delete(key);
        } else if (this.cache.size >= this.maxSize) {
          var firstKey = this.cache.keys().next().value;
          if (firstKey != null) {
            this.cache.delete(firstKey);
          }
        }
        this.cache.set(key, value);
      }
      clear() {
        this.cache.clear();
      }
      size() {
        return this.cache.size;
      }
    }
    function ownKeys$i(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$i(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$i(Object(t2), true).forEach(function(r3) {
          _defineProperty$j(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$i(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$j(e, r2, t2) {
      return (r2 = _toPropertyKey$j(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$j(t2) {
      var i = _toPrimitive$j(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$j(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    var defaultConfig = {
      cacheSize: 2e3,
      enableCache: true
    };
    var currentConfig = _objectSpread$i({}, defaultConfig);
    var stringCache = new LRUCache(currentConfig.cacheSize);
    var SPAN_STYLE = {
      position: "absolute",
      top: "-20000px",
      left: 0,
      padding: 0,
      margin: 0,
      border: "none",
      whiteSpace: "pre"
    };
    var MEASUREMENT_SPAN_ID = "recharts_measurement_span";
    function createCacheKey(text, style) {
      var fontSize = style.fontSize || "";
      var fontFamily = style.fontFamily || "";
      var fontWeight = style.fontWeight || "";
      var fontStyle = style.fontStyle || "";
      var letterSpacing = style.letterSpacing || "";
      var textTransform = style.textTransform || "";
      return "".concat(text, "|").concat(fontSize, "|").concat(fontFamily, "|").concat(fontWeight, "|").concat(fontStyle, "|").concat(letterSpacing, "|").concat(textTransform);
    }
    var measureTextWithDOM = (text, style) => {
      try {
        var measurementSpan = document.getElementById(MEASUREMENT_SPAN_ID);
        if (!measurementSpan) {
          measurementSpan = document.createElement("span");
          measurementSpan.setAttribute("id", MEASUREMENT_SPAN_ID);
          measurementSpan.setAttribute("aria-hidden", "true");
          document.body.appendChild(measurementSpan);
        }
        Object.assign(measurementSpan.style, SPAN_STYLE, style);
        measurementSpan.textContent = "".concat(text);
        var rect = measurementSpan.getBoundingClientRect();
        return {
          width: rect.width,
          height: rect.height
        };
      } catch (_unused) {
        return {
          width: 0,
          height: 0
        };
      }
    };
    var getStringSize = function getStringSize2(text) {
      var style = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (text === void 0 || text === null || Global.isSsr) {
        return {
          width: 0,
          height: 0
        };
      }
      if (!currentConfig.enableCache) {
        return measureTextWithDOM(text, style);
      }
      var cacheKey = createCacheKey(text, style);
      var cachedResult = stringCache.get(cacheKey);
      if (cachedResult) {
        return cachedResult;
      }
      var result = measureTextWithDOM(text, style);
      stringCache.set(cacheKey, result);
      return result;
    };
    var MULTIPLY_OR_DIVIDE_REGEX = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([*/])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/;
    var ADD_OR_SUBTRACT_REGEX = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([+-])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/;
    var CSS_LENGTH_UNIT_REGEX = /^px|cm|vh|vw|em|rem|%|mm|in|pt|pc|ex|ch|vmin|vmax|Q$/;
    var NUM_SPLIT_REGEX = /(-?\d+(?:\.\d+)?)([a-zA-Z%]+)?/;
    var CONVERSION_RATES = {
      cm: 96 / 2.54,
      mm: 96 / 25.4,
      pt: 96 / 72,
      pc: 96 / 6,
      in: 96,
      Q: 96 / (2.54 * 40),
      px: 1
    };
    var FIXED_CSS_LENGTH_UNITS = Object.keys(CONVERSION_RATES);
    var STR_NAN = "NaN";
    function convertToPx(value, unit2) {
      return value * CONVERSION_RATES[unit2];
    }
    class DecimalCSS {
      static parse(str) {
        var _NUM_SPLIT_REGEX$exec;
        var [, numStr, unit2] = (_NUM_SPLIT_REGEX$exec = NUM_SPLIT_REGEX.exec(str)) !== null && _NUM_SPLIT_REGEX$exec !== void 0 ? _NUM_SPLIT_REGEX$exec : [];
        return new DecimalCSS(parseFloat(numStr), unit2 !== null && unit2 !== void 0 ? unit2 : "");
      }
      constructor(num, unit2) {
        this.num = num;
        this.unit = unit2;
        this.num = num;
        this.unit = unit2;
        if (isNan(num)) {
          this.unit = "";
        }
        if (unit2 !== "" && !CSS_LENGTH_UNIT_REGEX.test(unit2)) {
          this.num = NaN;
          this.unit = "";
        }
        if (FIXED_CSS_LENGTH_UNITS.includes(unit2)) {
          this.num = convertToPx(num, unit2);
          this.unit = "px";
        }
      }
      add(other) {
        if (this.unit !== other.unit) {
          return new DecimalCSS(NaN, "");
        }
        return new DecimalCSS(this.num + other.num, this.unit);
      }
      subtract(other) {
        if (this.unit !== other.unit) {
          return new DecimalCSS(NaN, "");
        }
        return new DecimalCSS(this.num - other.num, this.unit);
      }
      multiply(other) {
        if (this.unit !== "" && other.unit !== "" && this.unit !== other.unit) {
          return new DecimalCSS(NaN, "");
        }
        return new DecimalCSS(this.num * other.num, this.unit || other.unit);
      }
      divide(other) {
        if (this.unit !== "" && other.unit !== "" && this.unit !== other.unit) {
          return new DecimalCSS(NaN, "");
        }
        return new DecimalCSS(this.num / other.num, this.unit || other.unit);
      }
      toString() {
        return "".concat(this.num).concat(this.unit);
      }
      isNaN() {
        return isNan(this.num);
      }
    }
    function calculateArithmetic(expr) {
      if (expr.includes(STR_NAN)) {
        return STR_NAN;
      }
      var newExpr = expr;
      while (newExpr.includes("*") || newExpr.includes("/")) {
        var _MULTIPLY_OR_DIVIDE_R;
        var [, leftOperand, operator, rightOperand] = (_MULTIPLY_OR_DIVIDE_R = MULTIPLY_OR_DIVIDE_REGEX.exec(newExpr)) !== null && _MULTIPLY_OR_DIVIDE_R !== void 0 ? _MULTIPLY_OR_DIVIDE_R : [];
        var lTs = DecimalCSS.parse(leftOperand !== null && leftOperand !== void 0 ? leftOperand : "");
        var rTs = DecimalCSS.parse(rightOperand !== null && rightOperand !== void 0 ? rightOperand : "");
        var result = operator === "*" ? lTs.multiply(rTs) : lTs.divide(rTs);
        if (result.isNaN()) {
          return STR_NAN;
        }
        newExpr = newExpr.replace(MULTIPLY_OR_DIVIDE_REGEX, result.toString());
      }
      while (newExpr.includes("+") || /.-\d+(?:\.\d+)?/.test(newExpr)) {
        var _ADD_OR_SUBTRACT_REGE;
        var [, _leftOperand, _operator, _rightOperand] = (_ADD_OR_SUBTRACT_REGE = ADD_OR_SUBTRACT_REGEX.exec(newExpr)) !== null && _ADD_OR_SUBTRACT_REGE !== void 0 ? _ADD_OR_SUBTRACT_REGE : [];
        var _lTs = DecimalCSS.parse(_leftOperand !== null && _leftOperand !== void 0 ? _leftOperand : "");
        var _rTs = DecimalCSS.parse(_rightOperand !== null && _rightOperand !== void 0 ? _rightOperand : "");
        var _result = _operator === "+" ? _lTs.add(_rTs) : _lTs.subtract(_rTs);
        if (_result.isNaN()) {
          return STR_NAN;
        }
        newExpr = newExpr.replace(ADD_OR_SUBTRACT_REGEX, _result.toString());
      }
      return newExpr;
    }
    var PARENTHESES_REGEX = /\(([^()]*)\)/;
    function calculateParentheses(expr) {
      var newExpr = expr;
      var match;
      while ((match = PARENTHESES_REGEX.exec(newExpr)) != null) {
        var [, parentheticalExpression] = match;
        newExpr = newExpr.replace(PARENTHESES_REGEX, calculateArithmetic(parentheticalExpression));
      }
      return newExpr;
    }
    function evaluateExpression(expression) {
      var newExpr = expression.replace(/\s+/g, "");
      newExpr = calculateParentheses(newExpr);
      newExpr = calculateArithmetic(newExpr);
      return newExpr;
    }
    function safeEvaluateExpression(expression) {
      try {
        return evaluateExpression(expression);
      } catch (_unused) {
        return STR_NAN;
      }
    }
    function reduceCSSCalc(expression) {
      var result = safeEvaluateExpression(expression.slice(5, -1));
      if (result === STR_NAN) {
        return "";
      }
      return result;
    }
    var _excluded$i = ["x", "y", "lineHeight", "capHeight", "fill", "scaleToFit", "textAnchor", "verticalAnchor"], _excluded2$9 = ["dx", "dy", "angle", "className", "breakAll"];
    function _extends$i() {
      return _extends$i = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$i.apply(null, arguments);
    }
    function _objectWithoutProperties$i(e, t2) {
      if (null == e) return {};
      var o, r2, i = _objectWithoutPropertiesLoose$i(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e);
        for (r2 = 0; r2 < n2.length; r2++) o = n2[r2], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose$i(r2, e) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    var BREAKING_SPACES = /[ \f\n\r\t\v\u2028\u2029]+/;
    var calculateWordWidths = (_ref2) => {
      var {
        children,
        breakAll,
        style
      } = _ref2;
      try {
        var words = [];
        if (!isNullish(children)) {
          if (breakAll) {
            words = children.toString().split("");
          } else {
            words = children.toString().split(BREAKING_SPACES);
          }
        }
        var wordsWithComputedWidth = words.map((word) => ({
          word,
          width: getStringSize(word, style).width
        }));
        var spaceWidth = breakAll ? 0 : getStringSize("", style).width;
        return {
          wordsWithComputedWidth,
          spaceWidth
        };
      } catch (_unused) {
        return null;
      }
    };
    function isValidTextAnchor(value) {
      return value === "start" || value === "middle" || value === "end" || value === "inherit";
    }
    var calculate = (words, lineWidth, spaceWidth, scaleToFit) => words.reduce((result, _ref2) => {
      var {
        word,
        width
      } = _ref2;
      var currentLine = result[result.length - 1];
      if (currentLine && width != null && (lineWidth == null || scaleToFit || currentLine.width + width + spaceWidth < Number(lineWidth))) {
        currentLine.words.push(word);
        currentLine.width += width + spaceWidth;
      } else {
        var newLine = {
          words: [word],
          width
        };
        result.push(newLine);
      }
      return result;
    }, []);
    var findLongestLine = (words) => words.reduce((a2, b) => a2.width > b.width ? a2 : b);
    var suffix = "";
    var checkOverflow = (text, index, breakAll, style, maxLines, lineWidth, spaceWidth, scaleToFit) => {
      var tempText = text.slice(0, index);
      var words = calculateWordWidths({
        breakAll,
        style,
        children: tempText + suffix
      });
      if (!words) {
        return [false, []];
      }
      var result = calculate(words.wordsWithComputedWidth, lineWidth, spaceWidth, scaleToFit);
      var doesOverflow = result.length > maxLines || findLongestLine(result).width > Number(lineWidth);
      return [doesOverflow, result];
    };
    var calculateWordsByLines = (_ref3, initialWordsWithComputedWith, spaceWidth, lineWidth, scaleToFit) => {
      var {
        maxLines,
        children,
        style,
        breakAll
      } = _ref3;
      var shouldLimitLines = isNumber(maxLines);
      var text = String(children);
      var originalResult = calculate(initialWordsWithComputedWith, lineWidth, spaceWidth, scaleToFit);
      if (!shouldLimitLines || scaleToFit) {
        return originalResult;
      }
      var overflows = originalResult.length > maxLines || findLongestLine(originalResult).width > Number(lineWidth);
      if (!overflows) {
        return originalResult;
      }
      var start = 0;
      var end = text.length - 1;
      var iterations = 0;
      var trimmedResult;
      while (start <= end && iterations <= text.length - 1) {
        var middle = Math.floor((start + end) / 2);
        var prev = middle - 1;
        var [doesPrevOverflow, result] = checkOverflow(text, prev, breakAll, style, maxLines, lineWidth, spaceWidth, scaleToFit);
        var [doesMiddleOverflow] = checkOverflow(text, middle, breakAll, style, maxLines, lineWidth, spaceWidth, scaleToFit);
        if (!doesPrevOverflow && !doesMiddleOverflow) {
          start = middle + 1;
        }
        if (doesPrevOverflow && doesMiddleOverflow) {
          end = middle - 1;
        }
        if (!doesPrevOverflow && doesMiddleOverflow) {
          trimmedResult = result;
          break;
        }
        iterations++;
      }
      return trimmedResult || originalResult;
    };
    var getWordsWithoutCalculate = (children) => {
      var words = !isNullish(children) ? children.toString().split(BREAKING_SPACES) : [];
      return [{
        words,
        width: void 0
      }];
    };
    var getWordsByLines = (_ref4) => {
      var {
        width,
        scaleToFit,
        children,
        style,
        breakAll,
        maxLines
      } = _ref4;
      if ((width || scaleToFit) && !Global.isSsr) {
        var wordsWithComputedWidth, spaceWidth;
        var wordWidths = calculateWordWidths({
          breakAll,
          children,
          style
        });
        if (wordWidths) {
          var {
            wordsWithComputedWidth: wcw,
            spaceWidth: sw
          } = wordWidths;
          wordsWithComputedWidth = wcw;
          spaceWidth = sw;
        } else {
          return getWordsWithoutCalculate(children);
        }
        return calculateWordsByLines({
          breakAll,
          children,
          maxLines,
          style
        }, wordsWithComputedWidth, spaceWidth, width, Boolean(scaleToFit));
      }
      return getWordsWithoutCalculate(children);
    };
    var DEFAULT_FILL = "#808080";
    var textDefaultProps = {
      angle: 0,
      breakAll: false,
      // Magic number from d3
      capHeight: "0.71em",
      fill: DEFAULT_FILL,
      lineHeight: "1em",
      scaleToFit: false,
      textAnchor: "start",
      // Maintain compat with existing charts / default SVG behavior
      verticalAnchor: "end",
      x: 0,
      y: 0
    };
    var Text = /* @__PURE__ */ reactExports.forwardRef((outsideProps, ref) => {
      var _resolveDefaultProps = resolveDefaultProps(outsideProps, textDefaultProps), {
        x: propsX,
        y: propsY,
        lineHeight,
        capHeight,
        fill,
        scaleToFit,
        textAnchor,
        verticalAnchor
      } = _resolveDefaultProps, props = _objectWithoutProperties$i(_resolveDefaultProps, _excluded$i);
      var wordsByLines = reactExports.useMemo(() => {
        return getWordsByLines({
          breakAll: props.breakAll,
          children: props.children,
          maxLines: props.maxLines,
          scaleToFit,
          style: props.style,
          width: props.width
        });
      }, [props.breakAll, props.children, props.maxLines, scaleToFit, props.style, props.width]);
      var {
        dx,
        dy,
        angle,
        className,
        breakAll
      } = props, textProps = _objectWithoutProperties$i(props, _excluded2$9);
      if (!isNumOrStr(propsX) || !isNumOrStr(propsY) || wordsByLines.length === 0) {
        return null;
      }
      var x2 = Number(propsX) + (isNumber(dx) ? dx : 0);
      var y2 = Number(propsY) + (isNumber(dy) ? dy : 0);
      if (!isWellBehavedNumber(x2) || !isWellBehavedNumber(y2)) {
        return null;
      }
      var startDy;
      switch (verticalAnchor) {
        case "start":
          startDy = reduceCSSCalc("calc(".concat(capHeight, ")"));
          break;
        case "middle":
          startDy = reduceCSSCalc("calc(".concat((wordsByLines.length - 1) / 2, " * -").concat(lineHeight, " + (").concat(capHeight, " / 2))"));
          break;
        default:
          startDy = reduceCSSCalc("calc(".concat(wordsByLines.length - 1, " * -").concat(lineHeight, ")"));
          break;
      }
      var transforms = [];
      if (scaleToFit) {
        var lineWidth = wordsByLines[0].width;
        var {
          width
        } = props;
        transforms.push("scale(".concat(isNumber(width) && isNumber(lineWidth) ? width / lineWidth : 1, ")"));
      }
      if (angle) {
        transforms.push("rotate(".concat(angle, ", ").concat(x2, ", ").concat(y2, ")"));
      }
      if (transforms.length) {
        textProps.transform = transforms.join(" ");
      }
      return /* @__PURE__ */ reactExports.createElement("text", _extends$i({}, svgPropertiesAndEvents(textProps), {
        ref,
        x: x2,
        y: y2,
        className: clsx("recharts-text", className),
        textAnchor,
        fill: fill.includes("url") ? DEFAULT_FILL : fill
      }), wordsByLines.map((line, index) => {
        var words = line.words.join(breakAll ? "" : " ");
        return (
          // duplicate words will cause duplicate keys which is why we add the array index here
          /* @__PURE__ */ reactExports.createElement("tspan", {
            x: x2,
            dy: index === 0 ? startDy : lineHeight,
            key: "".concat(words, "-").concat(index)
          }, words)
        );
      }));
    });
    Text.displayName = "Text";
    var _excluded$h = ["labelRef"];
    function _objectWithoutProperties$h(e, t2) {
      if (null == e) return {};
      var o, r2, i = _objectWithoutPropertiesLoose$h(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e);
        for (r2 = 0; r2 < n2.length; r2++) o = n2[r2], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose$h(r2, e) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    function ownKeys$h(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$h(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$h(Object(t2), true).forEach(function(r3) {
          _defineProperty$i(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$h(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$i(e, r2, t2) {
      return (r2 = _toPropertyKey$i(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$i(t2) {
      var i = _toPrimitive$i(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$i(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function _extends$h() {
      return _extends$h = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$h.apply(null, arguments);
    }
    var CartesianLabelContext = /* @__PURE__ */ reactExports.createContext(null);
    var CartesianLabelContextProvider = (_ref2) => {
      var {
        x: x2,
        y: y2,
        upperWidth,
        lowerWidth,
        width,
        height,
        children
      } = _ref2;
      var viewBox = reactExports.useMemo(() => ({
        x: x2,
        y: y2,
        upperWidth,
        lowerWidth,
        width,
        height
      }), [x2, y2, upperWidth, lowerWidth, width, height]);
      return /* @__PURE__ */ reactExports.createElement(CartesianLabelContext.Provider, {
        value: viewBox
      }, children);
    };
    var useCartesianLabelContext = () => {
      var labelChildContext = reactExports.useContext(CartesianLabelContext);
      var chartContext = useViewBox();
      return labelChildContext || cartesianViewBoxToTrapezoid(chartContext);
    };
    var PolarLabelContext = /* @__PURE__ */ reactExports.createContext(null);
    var usePolarLabelContext = () => {
      var labelChildContext = reactExports.useContext(PolarLabelContext);
      var chartContext = useAppSelector(selectPolarViewBox);
      return labelChildContext || chartContext;
    };
    var getLabel = (props) => {
      var {
        value,
        formatter
      } = props;
      var label = isNullish(props.children) ? value : props.children;
      if (typeof formatter === "function") {
        return formatter(label);
      }
      return label;
    };
    var isLabelContentAFunction = (content) => {
      return content != null && typeof content === "function";
    };
    var getDeltaAngle = (startAngle, endAngle) => {
      var sign2 = mathSign(endAngle - startAngle);
      var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);
      return sign2 * deltaAngle;
    };
    var renderRadialLabel = (labelProps, position, label, attrs, viewBox) => {
      var {
        offset,
        className
      } = labelProps;
      var {
        cx,
        cy,
        innerRadius,
        outerRadius,
        startAngle,
        endAngle,
        clockWise
      } = viewBox;
      var radius = (innerRadius + outerRadius) / 2;
      var deltaAngle = getDeltaAngle(startAngle, endAngle);
      var sign2 = deltaAngle >= 0 ? 1 : -1;
      var labelAngle, direction;
      switch (position) {
        case "insideStart":
          labelAngle = startAngle + sign2 * offset;
          direction = clockWise;
          break;
        case "insideEnd":
          labelAngle = endAngle - sign2 * offset;
          direction = !clockWise;
          break;
        case "end":
          labelAngle = endAngle + sign2 * offset;
          direction = clockWise;
          break;
        default:
          throw new Error("Unsupported position ".concat(position));
      }
      direction = deltaAngle <= 0 ? direction : !direction;
      var startPoint = polarToCartesian(cx, cy, radius, labelAngle);
      var endPoint = polarToCartesian(cx, cy, radius, labelAngle + (direction ? 1 : -1) * 359);
      var path = "M".concat(startPoint.x, ",").concat(startPoint.y, "\n    A").concat(radius, ",").concat(radius, ",0,1,").concat(direction ? 0 : 1, ",\n    ").concat(endPoint.x, ",").concat(endPoint.y);
      var id2 = isNullish(labelProps.id) ? uniqueId("recharts-radial-line-") : labelProps.id;
      return /* @__PURE__ */ reactExports.createElement("text", _extends$h({}, attrs, {
        dominantBaseline: "central",
        className: clsx("recharts-radial-bar-label", className)
      }), /* @__PURE__ */ reactExports.createElement("defs", null, /* @__PURE__ */ reactExports.createElement("path", {
        id: id2,
        d: path
      })), /* @__PURE__ */ reactExports.createElement("textPath", {
        xlinkHref: "#".concat(id2)
      }, label));
    };
    var getAttrsOfPolarLabel = (viewBox, offset, position) => {
      var {
        cx,
        cy,
        innerRadius,
        outerRadius,
        startAngle,
        endAngle
      } = viewBox;
      var midAngle = (startAngle + endAngle) / 2;
      if (position === "outside") {
        var {
          x: _x,
          y: _y
        } = polarToCartesian(cx, cy, outerRadius + offset, midAngle);
        return {
          x: _x,
          y: _y,
          textAnchor: _x >= cx ? "start" : "end",
          verticalAnchor: "middle"
        };
      }
      if (position === "center") {
        return {
          x: cx,
          y: cy,
          textAnchor: "middle",
          verticalAnchor: "middle"
        };
      }
      if (position === "centerTop") {
        return {
          x: cx,
          y: cy,
          textAnchor: "middle",
          verticalAnchor: "start"
        };
      }
      if (position === "centerBottom") {
        return {
          x: cx,
          y: cy,
          textAnchor: "middle",
          verticalAnchor: "end"
        };
      }
      var r2 = (innerRadius + outerRadius) / 2;
      var {
        x: x2,
        y: y2
      } = polarToCartesian(cx, cy, r2, midAngle);
      return {
        x: x2,
        y: y2,
        textAnchor: "middle",
        verticalAnchor: "middle"
      };
    };
    var isPolar = (viewBox) => "cx" in viewBox && isNumber(viewBox.cx);
    var getAttrsOfCartesianLabel = (props, viewBox) => {
      var {
        parentViewBox: parentViewBoxFromProps,
        offset,
        position
      } = props;
      var parentViewBox;
      if (parentViewBoxFromProps != null && !isPolar(parentViewBoxFromProps)) {
        parentViewBox = parentViewBoxFromProps;
      }
      var {
        x: x2,
        y: y2,
        upperWidth,
        lowerWidth,
        height
      } = viewBox;
      var upperX = x2;
      var lowerX = x2 + (upperWidth - lowerWidth) / 2;
      var middleX = (upperX + lowerX) / 2;
      var midHeightWidth = (upperWidth + lowerWidth) / 2;
      var centerX = upperX + upperWidth / 2;
      var verticalSign = height >= 0 ? 1 : -1;
      var verticalOffset = verticalSign * offset;
      var verticalEnd = verticalSign > 0 ? "end" : "start";
      var verticalStart = verticalSign > 0 ? "start" : "end";
      var horizontalSign = upperWidth >= 0 ? 1 : -1;
      var horizontalOffset = horizontalSign * offset;
      var horizontalEnd = horizontalSign > 0 ? "end" : "start";
      var horizontalStart = horizontalSign > 0 ? "start" : "end";
      if (position === "top") {
        var attrs = {
          x: upperX + upperWidth / 2,
          y: y2 - verticalOffset,
          textAnchor: "middle",
          verticalAnchor: verticalEnd
        };
        return _objectSpread$h(_objectSpread$h({}, attrs), parentViewBox ? {
          height: Math.max(y2 - parentViewBox.y, 0),
          width: upperWidth
        } : {});
      }
      if (position === "bottom") {
        var _attrs = {
          x: lowerX + lowerWidth / 2,
          y: y2 + height + verticalOffset,
          textAnchor: "middle",
          verticalAnchor: verticalStart
        };
        return _objectSpread$h(_objectSpread$h({}, _attrs), parentViewBox ? {
          height: Math.max(parentViewBox.y + parentViewBox.height - (y2 + height), 0),
          width: lowerWidth
        } : {});
      }
      if (position === "left") {
        var _attrs2 = {
          x: middleX - horizontalOffset,
          y: y2 + height / 2,
          textAnchor: horizontalEnd,
          verticalAnchor: "middle"
        };
        return _objectSpread$h(_objectSpread$h({}, _attrs2), parentViewBox ? {
          width: Math.max(_attrs2.x - parentViewBox.x, 0),
          height
        } : {});
      }
      if (position === "right") {
        var _attrs3 = {
          x: middleX + midHeightWidth + horizontalOffset,
          y: y2 + height / 2,
          textAnchor: horizontalStart,
          verticalAnchor: "middle"
        };
        return _objectSpread$h(_objectSpread$h({}, _attrs3), parentViewBox ? {
          width: Math.max(parentViewBox.x + parentViewBox.width - _attrs3.x, 0),
          height
        } : {});
      }
      var sizeAttrs = parentViewBox ? {
        width: midHeightWidth,
        height
      } : {};
      if (position === "insideLeft") {
        return _objectSpread$h({
          x: middleX + horizontalOffset,
          y: y2 + height / 2,
          textAnchor: horizontalStart,
          verticalAnchor: "middle"
        }, sizeAttrs);
      }
      if (position === "insideRight") {
        return _objectSpread$h({
          x: middleX + midHeightWidth - horizontalOffset,
          y: y2 + height / 2,
          textAnchor: horizontalEnd,
          verticalAnchor: "middle"
        }, sizeAttrs);
      }
      if (position === "insideTop") {
        return _objectSpread$h({
          x: upperX + upperWidth / 2,
          y: y2 + verticalOffset,
          textAnchor: "middle",
          verticalAnchor: verticalStart
        }, sizeAttrs);
      }
      if (position === "insideBottom") {
        return _objectSpread$h({
          x: lowerX + lowerWidth / 2,
          y: y2 + height - verticalOffset,
          textAnchor: "middle",
          verticalAnchor: verticalEnd
        }, sizeAttrs);
      }
      if (position === "insideTopLeft") {
        return _objectSpread$h({
          x: upperX + horizontalOffset,
          y: y2 + verticalOffset,
          textAnchor: horizontalStart,
          verticalAnchor: verticalStart
        }, sizeAttrs);
      }
      if (position === "insideTopRight") {
        return _objectSpread$h({
          x: upperX + upperWidth - horizontalOffset,
          y: y2 + verticalOffset,
          textAnchor: horizontalEnd,
          verticalAnchor: verticalStart
        }, sizeAttrs);
      }
      if (position === "insideBottomLeft") {
        return _objectSpread$h({
          x: lowerX + horizontalOffset,
          y: y2 + height - verticalOffset,
          textAnchor: horizontalStart,
          verticalAnchor: verticalEnd
        }, sizeAttrs);
      }
      if (position === "insideBottomRight") {
        return _objectSpread$h({
          x: lowerX + lowerWidth - horizontalOffset,
          y: y2 + height - verticalOffset,
          textAnchor: horizontalEnd,
          verticalAnchor: verticalEnd
        }, sizeAttrs);
      }
      if (!!position && typeof position === "object" && (isNumber(position.x) || isPercent(position.x)) && (isNumber(position.y) || isPercent(position.y))) {
        return _objectSpread$h({
          x: x2 + getPercentValue(position.x, midHeightWidth),
          y: y2 + getPercentValue(position.y, height),
          textAnchor: "end",
          verticalAnchor: "end"
        }, sizeAttrs);
      }
      return _objectSpread$h({
        x: centerX,
        y: y2 + height / 2,
        textAnchor: "middle",
        verticalAnchor: "middle"
      }, sizeAttrs);
    };
    var defaultLabelProps = {
      angle: 0,
      offset: 5,
      zIndex: DefaultZIndexes.label,
      position: "middle",
      textBreakAll: false
    };
    function Label(outerProps) {
      var props = resolveDefaultProps(outerProps, defaultLabelProps);
      var {
        viewBox: viewBoxFromProps,
        position,
        value,
        children,
        content,
        className = "",
        textBreakAll,
        labelRef
      } = props;
      var polarViewBox = usePolarLabelContext();
      var cartesianViewBox = useCartesianLabelContext();
      var resolvedViewBox = position === "center" ? cartesianViewBox : polarViewBox !== null && polarViewBox !== void 0 ? polarViewBox : cartesianViewBox;
      var viewBox, label, positionAttrs;
      if (viewBoxFromProps == null) {
        viewBox = resolvedViewBox;
      } else if (isPolar(viewBoxFromProps)) {
        viewBox = viewBoxFromProps;
      } else {
        viewBox = cartesianViewBoxToTrapezoid(viewBoxFromProps);
      }
      if (!viewBox || isNullish(value) && isNullish(children) && !/* @__PURE__ */ reactExports.isValidElement(content) && typeof content !== "function") {
        return null;
      }
      var propsWithViewBox = _objectSpread$h(_objectSpread$h({}, props), {}, {
        viewBox
      });
      if (/* @__PURE__ */ reactExports.isValidElement(content)) {
        var {
          labelRef: _
        } = propsWithViewBox, propsWithoutLabelRef = _objectWithoutProperties$h(propsWithViewBox, _excluded$h);
        return /* @__PURE__ */ reactExports.cloneElement(content, propsWithoutLabelRef);
      }
      if (typeof content === "function") {
        label = /* @__PURE__ */ reactExports.createElement(content, propsWithViewBox);
        if (/* @__PURE__ */ reactExports.isValidElement(label)) {
          return label;
        }
      } else {
        label = getLabel(props);
      }
      var attrs = svgPropertiesAndEvents(props);
      if (isPolar(viewBox)) {
        if (position === "insideStart" || position === "insideEnd" || position === "end") {
          return renderRadialLabel(props, position, label, attrs, viewBox);
        }
        positionAttrs = getAttrsOfPolarLabel(viewBox, props.offset, props.position);
      } else {
        positionAttrs = getAttrsOfCartesianLabel(props, viewBox);
      }
      return /* @__PURE__ */ reactExports.createElement(ZIndexLayer, {
        zIndex: props.zIndex
      }, /* @__PURE__ */ reactExports.createElement(Text, _extends$h({
        ref: labelRef,
        className: clsx("recharts-label", className)
      }, attrs, positionAttrs, {
        /*
         * textAnchor is decided by default based on the `position`
         * but we allow overriding via props for precise control.
         */
        textAnchor: isValidTextAnchor(attrs.textAnchor) ? attrs.textAnchor : positionAttrs.textAnchor,
        breakAll: textBreakAll
      }), label));
    }
    Label.displayName = "Label";
    var parseLabel = (label, viewBox, labelRef) => {
      if (!label) {
        return null;
      }
      var commonProps = {
        viewBox,
        labelRef
      };
      if (label === true) {
        return /* @__PURE__ */ reactExports.createElement(Label, _extends$h({
          key: "label-implicit"
        }, commonProps));
      }
      if (isNumOrStr(label)) {
        return /* @__PURE__ */ reactExports.createElement(Label, _extends$h({
          key: "label-implicit",
          value: label
        }, commonProps));
      }
      if (/* @__PURE__ */ reactExports.isValidElement(label)) {
        if (label.type === Label) {
          return /* @__PURE__ */ reactExports.cloneElement(label, _objectSpread$h({
            key: "label-implicit"
          }, commonProps));
        }
        return /* @__PURE__ */ reactExports.createElement(Label, _extends$h({
          key: "label-implicit",
          content: label
        }, commonProps));
      }
      if (isLabelContentAFunction(label)) {
        return /* @__PURE__ */ reactExports.createElement(Label, _extends$h({
          key: "label-implicit",
          content: label
        }, commonProps));
      }
      if (label && typeof label === "object") {
        return /* @__PURE__ */ reactExports.createElement(Label, _extends$h({}, label, {
          key: "label-implicit"
        }, commonProps));
      }
      return null;
    };
    function CartesianLabelFromLabelProp(_ref3) {
      var {
        label,
        labelRef
      } = _ref3;
      var viewBox = useCartesianLabelContext();
      return parseLabel(label, viewBox, labelRef) || null;
    }
    var last$3 = {};
    var last$2 = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      function last2(arr) {
        return arr[arr.length - 1];
      }
      exports$1.last = last2;
    })(last$2);
    var toArray$1 = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      function toArray2(value) {
        return Array.isArray(value) ? value : Array.from(value);
      }
      exports$1.toArray = toArray2;
    })(toArray$1);
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      const last$12 = last$2;
      const toArray2 = toArray$1;
      const isArrayLike$1 = isArrayLike;
      function last2(array2) {
        if (!isArrayLike$1.isArrayLike(array2)) {
          return void 0;
        }
        return last$12.last(toArray2.toArray(array2));
      }
      exports$1.last = last2;
    })(last$3);
    var last = last$3.last;
    const last$1 = /* @__PURE__ */ getDefaultExportFromCjs(last);
    var _excluded$g = ["valueAccessor"], _excluded2$8 = ["dataKey", "clockWise", "id", "textBreakAll", "zIndex"];
    function _extends$g() {
      return _extends$g = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$g.apply(null, arguments);
    }
    function _objectWithoutProperties$g(e, t2) {
      if (null == e) return {};
      var o, r2, i = _objectWithoutPropertiesLoose$g(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e);
        for (r2 = 0; r2 < n2.length; r2++) o = n2[r2], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose$g(r2, e) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    var defaultAccessor = (entry) => Array.isArray(entry.value) ? last$1(entry.value) : entry.value;
    var CartesianLabelListContext = /* @__PURE__ */ reactExports.createContext(void 0);
    var CartesianLabelListContextProvider = CartesianLabelListContext.Provider;
    var PolarLabelListContext = /* @__PURE__ */ reactExports.createContext(void 0);
    var PolarLabelListContextProvider = PolarLabelListContext.Provider;
    function useCartesianLabelListContext() {
      return reactExports.useContext(CartesianLabelListContext);
    }
    function usePolarLabelListContext() {
      return reactExports.useContext(PolarLabelListContext);
    }
    function LabelList(_ref2) {
      var {
        valueAccessor = defaultAccessor
      } = _ref2, restProps = _objectWithoutProperties$g(_ref2, _excluded$g);
      var {
        dataKey,
        clockWise,
        id: id2,
        textBreakAll,
        zIndex
      } = restProps, others = _objectWithoutProperties$g(restProps, _excluded2$8);
      var cartesianData = useCartesianLabelListContext();
      var polarData = usePolarLabelListContext();
      var data = cartesianData || polarData;
      if (!data || !data.length) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(ZIndexLayer, {
        zIndex: zIndex !== null && zIndex !== void 0 ? zIndex : DefaultZIndexes.label
      }, /* @__PURE__ */ reactExports.createElement(Layer, {
        className: "recharts-label-list"
      }, data.map((entry, index) => {
        var _restProps$fill;
        var value = isNullish(dataKey) ? valueAccessor(entry, index) : getValueByDataKey(entry && entry.payload, dataKey);
        var idProps = isNullish(id2) ? {} : {
          id: "".concat(id2, "-").concat(index)
        };
        return /* @__PURE__ */ reactExports.createElement(Label, _extends$g({
          key: "label-".concat(index)
        }, svgPropertiesAndEvents(entry), others, idProps, {
          /*
           * Prefer to use the explicit fill from LabelList props.
           * Only in an absence of that, fall back to the fill of the entry.
           * The entry fill can be quite difficult to see especially in Bar, Pie, RadialBar in inside positions.
           * On the other hand it's quite convenient in Scatter, Line, or when the position is outside the Bar, Pie filled shapes.
           */
          fill: (_restProps$fill = restProps.fill) !== null && _restProps$fill !== void 0 ? _restProps$fill : entry.fill,
          parentViewBox: entry.parentViewBox,
          value,
          textBreakAll,
          viewBox: entry.viewBox,
          index,
          zIndex: 0
        }));
      })));
    }
    LabelList.displayName = "LabelList";
    function LabelListFromLabelProp(_ref2) {
      var {
        label
      } = _ref2;
      if (!label) {
        return null;
      }
      if (label === true) {
        return /* @__PURE__ */ reactExports.createElement(LabelList, {
          key: "labelList-implicit"
        });
      }
      if (/* @__PURE__ */ reactExports.isValidElement(label) || isLabelContentAFunction(label)) {
        return /* @__PURE__ */ reactExports.createElement(LabelList, {
          key: "labelList-implicit",
          content: label
        });
      }
      if (typeof label === "object") {
        return /* @__PURE__ */ reactExports.createElement(LabelList, _extends$g({
          key: "labelList-implicit"
        }, label, {
          type: String(label.type)
        }));
      }
      return null;
    }
    function _extends$f() {
      return _extends$f = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$f.apply(null, arguments);
    }
    var Dot = (props) => {
      var {
        cx,
        cy,
        r: r2,
        className
      } = props;
      var layerClass = clsx("recharts-dot", className);
      if (isNumber(cx) && isNumber(cy) && isNumber(r2)) {
        return /* @__PURE__ */ reactExports.createElement("circle", _extends$f({}, svgPropertiesNoEvents(props), adaptEventHandlers(props), {
          className: layerClass,
          cx,
          cy,
          r: r2
        }));
      }
      return null;
    };
    var selectUnfilteredPolarItems = (state) => state.graphicalItems.polarItems;
    var selectAxisPredicate = createSelector([pickAxisType, pickAxisId], itemAxisPredicate);
    var selectPolarItemsSettings = createSelector([selectUnfilteredPolarItems, selectBaseAxis, selectAxisPredicate], combineGraphicalItemsSettings);
    var selectPolarGraphicalItemsData = createSelector([selectPolarItemsSettings], combineGraphicalItemsData);
    var selectPolarDisplayedData = createSelector([selectPolarGraphicalItemsData, selectChartDataAndAlwaysIgnoreIndexes], combineDisplayedData);
    var selectPolarAppliedValues = createSelector([selectPolarDisplayedData, selectBaseAxis, selectPolarItemsSettings], combineAppliedValues);
    createSelector([selectPolarDisplayedData, selectBaseAxis, selectPolarItemsSettings], (data, axisSettings, items) => {
      if (items.length > 0) {
        return data.flatMap((entry) => {
          return items.flatMap((item) => {
            var _axisSettings$dataKey;
            var valueByDataKey = getValueByDataKey(entry, (_axisSettings$dataKey = axisSettings.dataKey) !== null && _axisSettings$dataKey !== void 0 ? _axisSettings$dataKey : item.dataKey);
            return {
              value: valueByDataKey,
              errorDomain: []
              // polar charts do not have error bars
            };
          });
        }).filter(Boolean);
      }
      if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) {
        return data.map((item) => ({
          value: getValueByDataKey(item, axisSettings.dataKey),
          errorDomain: []
        }));
      }
      return data.map((entry) => ({
        value: entry,
        errorDomain: []
      }));
    });
    var unsupportedInPolarChart = () => void 0;
    var selectDomainOfAllPolarAppliedNumericalValues = createSelector([selectPolarDisplayedData, selectBaseAxis, selectPolarItemsSettings, selectAllErrorBarSettings, pickAxisType], combineDomainOfAllAppliedNumericalValuesIncludingErrorValues);
    var selectPolarNumericalDomain = createSelector([selectBaseAxis, selectDomainDefinition, selectDomainFromUserPreference, unsupportedInPolarChart, selectDomainOfAllPolarAppliedNumericalValues, unsupportedInPolarChart, selectChartLayout, pickAxisType], combineNumericalDomain);
    var selectPolarAxisDomain = createSelector([selectBaseAxis, selectChartLayout, selectPolarDisplayedData, selectPolarAppliedValues, selectStackOffsetType, pickAxisType, selectPolarNumericalDomain], combineAxisDomain);
    var selectPolarNiceTicks = createSelector([selectPolarAxisDomain, selectBaseAxis, selectRealScaleType], combineNiceTicks);
    createSelector([selectBaseAxis, selectPolarAxisDomain, selectPolarNiceTicks, pickAxisType], combineAxisDomainWithNiceTicks);
    var initialState$6 = {
      radiusAxis: {},
      angleAxis: {}
    };
    var polarAxisSlice = createSlice({
      name: "polarAxis",
      initialState: initialState$6,
      reducers: {
        addRadiusAxis(state, action) {
          state.radiusAxis[action.payload.id] = castDraft(action.payload);
        },
        removeRadiusAxis(state, action) {
          delete state.radiusAxis[action.payload.id];
        },
        addAngleAxis(state, action) {
          state.angleAxis[action.payload.id] = castDraft(action.payload);
        },
        removeAngleAxis(state, action) {
          delete state.angleAxis[action.payload.id];
        }
      }
    });
    var {
      addRadiusAxis,
      removeRadiusAxis,
      addAngleAxis,
      removeAngleAxis
    } = polarAxisSlice.actions;
    var polarAxisReducer = polarAxisSlice.reducer;
    function ownKeys$g(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$g(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$g(Object(t2), true).forEach(function(r3) {
          _defineProperty$h(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$g(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$h(e, r2, t2) {
      return (r2 = _toPropertyKey$h(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$h(t2) {
      var i = _toPrimitive$h(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$h(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    var pickId = (_state, id2) => id2;
    var selectSynchronisedPieSettings = createSelector([selectUnfilteredPolarItems, pickId], (graphicalItems, id2) => graphicalItems.filter((item) => item.type === "pie").find((item) => item.id === id2));
    var emptyArray = [];
    var pickCells$1 = (_state, _id, cells) => {
      if ((cells === null || cells === void 0 ? void 0 : cells.length) === 0) {
        return emptyArray;
      }
      return cells;
    };
    var selectDisplayedData = createSelector([selectChartDataAndAlwaysIgnoreIndexes, selectSynchronisedPieSettings, pickCells$1], (_ref2, pieSettings, cells) => {
      var {
        chartData
      } = _ref2;
      if (pieSettings == null) {
        return void 0;
      }
      var displayedData;
      if ((pieSettings === null || pieSettings === void 0 ? void 0 : pieSettings.data) != null && pieSettings.data.length > 0) {
        displayedData = pieSettings.data;
      } else {
        displayedData = chartData;
      }
      if ((!displayedData || !displayedData.length) && cells != null) {
        displayedData = cells.map((cell) => _objectSpread$g(_objectSpread$g({}, pieSettings.presentationProps), cell.props));
      }
      if (displayedData == null) {
        return void 0;
      }
      return displayedData;
    });
    var selectPieLegend = createSelector([selectDisplayedData, selectSynchronisedPieSettings, pickCells$1], (displayedData, pieSettings, cells) => {
      if (displayedData == null || pieSettings == null) {
        return void 0;
      }
      return displayedData.map((entry, i) => {
        var _cells$i;
        var name = getValueByDataKey(entry, pieSettings.nameKey, pieSettings.name);
        var color2;
        if (cells !== null && cells !== void 0 && (_cells$i = cells[i]) !== null && _cells$i !== void 0 && (_cells$i = _cells$i.props) !== null && _cells$i !== void 0 && _cells$i.fill) {
          color2 = cells[i].props.fill;
        } else if (typeof entry === "object" && entry != null && "fill" in entry) {
          color2 = entry.fill;
        } else {
          color2 = pieSettings.fill;
        }
        return {
          value: getTooltipNameProp(name, pieSettings.dataKey),
          color: color2,
          // @ts-expect-error we need a better typing for our data inputs
          payload: entry,
          type: pieSettings.legendType
        };
      });
    });
    var selectPieSectors = createSelector([selectDisplayedData, selectSynchronisedPieSettings, pickCells$1, selectChartOffsetInternal], (displayedData, pieSettings, cells, offset) => {
      if (pieSettings == null || displayedData == null) {
        return void 0;
      }
      return computePieSectors({
        offset,
        pieSettings,
        displayedData,
        cells
      });
    });
    var reactIs = { exports: {} };
    var reactIs_production = {};
    /**
     * @license React
     * react-is.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
    function typeOf(object2) {
      if ("object" === typeof object2 && null !== object2) {
        var $$typeof = object2.$$typeof;
        switch ($$typeof) {
          case REACT_ELEMENT_TYPE:
            switch (object2 = object2.type, object2) {
              case REACT_FRAGMENT_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_SUSPENSE_TYPE:
              case REACT_SUSPENSE_LIST_TYPE:
              case REACT_VIEW_TRANSITION_TYPE:
                return object2;
              default:
                switch (object2 = object2 && object2.$$typeof, object2) {
                  case REACT_CONTEXT_TYPE:
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_LAZY_TYPE:
                  case REACT_MEMO_TYPE:
                    return object2;
                  case REACT_CONSUMER_TYPE:
                    return object2;
                  default:
                    return $$typeof;
                }
            }
          case REACT_PORTAL_TYPE:
            return $$typeof;
        }
      }
    }
    reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE;
    reactIs_production.ContextProvider = REACT_CONTEXT_TYPE;
    reactIs_production.Element = REACT_ELEMENT_TYPE;
    reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE;
    reactIs_production.Fragment = REACT_FRAGMENT_TYPE;
    reactIs_production.Lazy = REACT_LAZY_TYPE;
    reactIs_production.Memo = REACT_MEMO_TYPE;
    reactIs_production.Portal = REACT_PORTAL_TYPE;
    reactIs_production.Profiler = REACT_PROFILER_TYPE;
    reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE;
    reactIs_production.Suspense = REACT_SUSPENSE_TYPE;
    reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
    reactIs_production.isContextConsumer = function(object2) {
      return typeOf(object2) === REACT_CONSUMER_TYPE;
    };
    reactIs_production.isContextProvider = function(object2) {
      return typeOf(object2) === REACT_CONTEXT_TYPE;
    };
    reactIs_production.isElement = function(object2) {
      return "object" === typeof object2 && null !== object2 && object2.$$typeof === REACT_ELEMENT_TYPE;
    };
    reactIs_production.isForwardRef = function(object2) {
      return typeOf(object2) === REACT_FORWARD_REF_TYPE;
    };
    reactIs_production.isFragment = function(object2) {
      return typeOf(object2) === REACT_FRAGMENT_TYPE;
    };
    reactIs_production.isLazy = function(object2) {
      return typeOf(object2) === REACT_LAZY_TYPE;
    };
    reactIs_production.isMemo = function(object2) {
      return typeOf(object2) === REACT_MEMO_TYPE;
    };
    reactIs_production.isPortal = function(object2) {
      return typeOf(object2) === REACT_PORTAL_TYPE;
    };
    reactIs_production.isProfiler = function(object2) {
      return typeOf(object2) === REACT_PROFILER_TYPE;
    };
    reactIs_production.isStrictMode = function(object2) {
      return typeOf(object2) === REACT_STRICT_MODE_TYPE;
    };
    reactIs_production.isSuspense = function(object2) {
      return typeOf(object2) === REACT_SUSPENSE_TYPE;
    };
    reactIs_production.isSuspenseList = function(object2) {
      return typeOf(object2) === REACT_SUSPENSE_LIST_TYPE;
    };
    reactIs_production.isValidElementType = function(type) {
      return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? true : false;
    };
    reactIs_production.typeOf = typeOf;
    {
      reactIs.exports = reactIs_production;
    }
    var reactIsExports = reactIs.exports;
    var getDisplayName = (Comp) => {
      if (typeof Comp === "string") {
        return Comp;
      }
      if (!Comp) {
        return "";
      }
      return Comp.displayName || Comp.name || "Component";
    };
    var lastChildren = null;
    var lastResult = null;
    var toArray = (children) => {
      if (children === lastChildren && Array.isArray(lastResult)) {
        return lastResult;
      }
      var result = [];
      reactExports.Children.forEach(children, (child) => {
        if (isNullish(child)) return;
        if (reactIsExports.isFragment(child)) {
          result = result.concat(toArray(child.props.children));
        } else {
          result.push(child);
        }
      });
      lastResult = result;
      lastChildren = children;
      return result;
    };
    function findAllByType(children, type) {
      var result = [];
      var types = [];
      if (Array.isArray(type)) {
        types = type.map((t2) => getDisplayName(t2));
      } else {
        types = [getDisplayName(type)];
      }
      toArray(children).forEach((child) => {
        var childType = get$2(child, "type.displayName") || get$2(child, "type.name");
        if (childType && types.indexOf(childType) !== -1) {
          result.push(child);
        }
      });
      return result;
    }
    var isClipDot = (dot) => {
      if (dot && typeof dot === "object" && "clipDot" in dot) {
        return Boolean(dot.clipDot);
      }
      return true;
    };
    var isPlainObject$2 = {};
    (function(exports$1) {
      Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
      function isPlainObject2(object2) {
        var _a;
        if (typeof object2 !== "object") {
          return false;
        }
        if (object2 == null) {
          return false;
        }
        if (Object.getPrototypeOf(object2) === null) {
          return true;
        }
        if (Object.prototype.toString.call(object2) !== "[object Object]") {
          const tag = object2[Symbol.toStringTag];
          if (tag == null) {
            return false;
          }
          const isTagReadonly = !((_a = Object.getOwnPropertyDescriptor(object2, Symbol.toStringTag)) == null ? void 0 : _a.writable);
          if (isTagReadonly) {
            return false;
          }
          return object2.toString() === `[object ${tag}]`;
        }
        let proto = object2;
        while (Object.getPrototypeOf(proto) !== null) {
          proto = Object.getPrototypeOf(proto);
        }
        return Object.getPrototypeOf(object2) === proto;
      }
      exports$1.isPlainObject = isPlainObject2;
    })(isPlainObject$2);
    var isPlainObject = isPlainObject$2.isPlainObject;
    const isPlainObject$1 = /* @__PURE__ */ getDefaultExportFromCjs(isPlainObject);
    function ownKeys$f(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$f(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$f(Object(t2), true).forEach(function(r3) {
          _defineProperty$g(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$f(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$g(e, r2, t2) {
      return (r2 = _toPropertyKey$g(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$g(t2) {
      var i = _toPrimitive$g(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$g(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function _extends$e() {
      return _extends$e = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$e.apply(null, arguments);
    }
    var getTrapezoidPath = (x2, y2, upperWidth, lowerWidth, height) => {
      var widthGap = upperWidth - lowerWidth;
      var path;
      path = "M ".concat(x2, ",").concat(y2);
      path += "L ".concat(x2 + upperWidth, ",").concat(y2);
      path += "L ".concat(x2 + upperWidth - widthGap / 2, ",").concat(y2 + height);
      path += "L ".concat(x2 + upperWidth - widthGap / 2 - lowerWidth, ",").concat(y2 + height);
      path += "L ".concat(x2, ",").concat(y2, " Z");
      return path;
    };
    var defaultTrapezoidProps = {
      x: 0,
      y: 0,
      upperWidth: 0,
      lowerWidth: 0,
      height: 0,
      isUpdateAnimationActive: false,
      animationBegin: 0,
      animationDuration: 1500,
      animationEasing: "ease"
    };
    var Trapezoid = (outsideProps) => {
      var trapezoidProps = resolveDefaultProps(outsideProps, defaultTrapezoidProps);
      var {
        x: x2,
        y: y2,
        upperWidth,
        lowerWidth,
        height,
        className
      } = trapezoidProps;
      var {
        animationEasing,
        animationDuration,
        animationBegin,
        isUpdateAnimationActive
      } = trapezoidProps;
      var pathRef = reactExports.useRef(null);
      var [totalLength, setTotalLength] = reactExports.useState(-1);
      var prevUpperWidthRef = reactExports.useRef(upperWidth);
      var prevLowerWidthRef = reactExports.useRef(lowerWidth);
      var prevHeightRef = reactExports.useRef(height);
      var prevXRef = reactExports.useRef(x2);
      var prevYRef = reactExports.useRef(y2);
      var animationId = useAnimationId(outsideProps, "trapezoid-");
      reactExports.useEffect(() => {
        if (pathRef.current && pathRef.current.getTotalLength) {
          try {
            var pathTotalLength = pathRef.current.getTotalLength();
            if (pathTotalLength) {
              setTotalLength(pathTotalLength);
            }
          } catch (_unused) {
          }
        }
      }, []);
      if (x2 !== +x2 || y2 !== +y2 || upperWidth !== +upperWidth || lowerWidth !== +lowerWidth || height !== +height || upperWidth === 0 && lowerWidth === 0 || height === 0) {
        return null;
      }
      var layerClass = clsx("recharts-trapezoid", className);
      if (!isUpdateAnimationActive) {
        return /* @__PURE__ */ reactExports.createElement("g", null, /* @__PURE__ */ reactExports.createElement("path", _extends$e({}, svgPropertiesAndEvents(trapezoidProps), {
          className: layerClass,
          d: getTrapezoidPath(x2, y2, upperWidth, lowerWidth, height)
        })));
      }
      var prevUpperWidth = prevUpperWidthRef.current;
      var prevLowerWidth = prevLowerWidthRef.current;
      var prevHeight = prevHeightRef.current;
      var prevX = prevXRef.current;
      var prevY = prevYRef.current;
      var from2 = "0px ".concat(totalLength === -1 ? 1 : totalLength, "px");
      var to2 = "".concat(totalLength, "px 0px");
      var transition = getTransitionVal(["strokeDasharray"], animationDuration, animationEasing);
      return /* @__PURE__ */ reactExports.createElement(JavascriptAnimate, {
        animationId,
        key: animationId,
        canBegin: totalLength > 0,
        duration: animationDuration,
        easing: animationEasing,
        isActive: isUpdateAnimationActive,
        begin: animationBegin
      }, (t2) => {
        var currUpperWidth = interpolate$1(prevUpperWidth, upperWidth, t2);
        var currLowerWidth = interpolate$1(prevLowerWidth, lowerWidth, t2);
        var currHeight = interpolate$1(prevHeight, height, t2);
        var currX = interpolate$1(prevX, x2, t2);
        var currY = interpolate$1(prevY, y2, t2);
        if (pathRef.current) {
          prevUpperWidthRef.current = currUpperWidth;
          prevLowerWidthRef.current = currLowerWidth;
          prevHeightRef.current = currHeight;
          prevXRef.current = currX;
          prevYRef.current = currY;
        }
        var animationStyle = t2 > 0 ? {
          transition,
          strokeDasharray: to2
        } : {
          strokeDasharray: from2
        };
        return /* @__PURE__ */ reactExports.createElement("path", _extends$e({}, svgPropertiesAndEvents(trapezoidProps), {
          className: layerClass,
          d: getTrapezoidPath(currX, currY, currUpperWidth, currLowerWidth, currHeight),
          ref: pathRef,
          style: _objectSpread$f(_objectSpread$f({}, animationStyle), trapezoidProps.style)
        }));
      });
    };
    var _excluded$f = ["option", "shapeType", "propTransformer", "activeClassName"];
    function _objectWithoutProperties$f(e, t2) {
      if (null == e) return {};
      var o, r2, i = _objectWithoutPropertiesLoose$f(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e);
        for (r2 = 0; r2 < n2.length; r2++) o = n2[r2], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose$f(r2, e) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    function ownKeys$e(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$e(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$e(Object(t2), true).forEach(function(r3) {
          _defineProperty$f(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$e(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$f(e, r2, t2) {
      return (r2 = _toPropertyKey$f(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$f(t2) {
      var i = _toPrimitive$f(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$f(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function defaultPropTransformer(option, props) {
      return _objectSpread$e(_objectSpread$e({}, props), option);
    }
    function isSymbolsProps(shapeType, _elementProps) {
      return shapeType === "symbols";
    }
    function ShapeSelector(_ref2) {
      var {
        shapeType,
        elementProps
      } = _ref2;
      switch (shapeType) {
        case "rectangle":
          return /* @__PURE__ */ reactExports.createElement(Rectangle, elementProps);
        case "trapezoid":
          return /* @__PURE__ */ reactExports.createElement(Trapezoid, elementProps);
        case "sector":
          return /* @__PURE__ */ reactExports.createElement(Sector, elementProps);
        case "symbols":
          if (isSymbolsProps(shapeType)) {
            return /* @__PURE__ */ reactExports.createElement(Symbols, elementProps);
          }
          break;
        case "curve":
          return /* @__PURE__ */ reactExports.createElement(Curve, elementProps);
        default:
          return null;
      }
    }
    function getPropsFromShapeOption(option) {
      if (/* @__PURE__ */ reactExports.isValidElement(option)) {
        return option.props;
      }
      return option;
    }
    function Shape(_ref2) {
      var {
        option,
        shapeType,
        propTransformer = defaultPropTransformer,
        activeClassName = "recharts-active-shape"
      } = _ref2, props = _objectWithoutProperties$f(_ref2, _excluded$f);
      var shape;
      if (/* @__PURE__ */ reactExports.isValidElement(option)) {
        shape = /* @__PURE__ */ reactExports.cloneElement(option, _objectSpread$e(_objectSpread$e({}, props), getPropsFromShapeOption(option)));
      } else if (typeof option === "function") {
        shape = option(props, props.index);
      } else if (isPlainObject$1(option) && typeof option !== "boolean") {
        var nextProps = propTransformer(option, props);
        shape = /* @__PURE__ */ reactExports.createElement(ShapeSelector, {
          shapeType,
          elementProps: nextProps
        });
      } else {
        var elementProps = props;
        shape = /* @__PURE__ */ reactExports.createElement(ShapeSelector, {
          shapeType,
          elementProps
        });
      }
      if (props.isActive) {
        return /* @__PURE__ */ reactExports.createElement(Layer, {
          className: activeClassName
        }, shape);
      }
      return shape;
    }
    var useMouseEnterItemDispatch = (onMouseEnterFromProps, dataKey, graphicalItemId) => {
      var dispatch = useAppDispatch();
      return (data, index) => (event) => {
        onMouseEnterFromProps === null || onMouseEnterFromProps === void 0 || onMouseEnterFromProps(data, index, event);
        dispatch(setActiveMouseOverItemIndex({
          activeIndex: String(index),
          activeDataKey: dataKey,
          activeCoordinate: data.tooltipPosition,
          activeGraphicalItemId: graphicalItemId
        }));
      };
    };
    var useMouseLeaveItemDispatch = (onMouseLeaveFromProps) => {
      var dispatch = useAppDispatch();
      return (data, index) => (event) => {
        onMouseLeaveFromProps === null || onMouseLeaveFromProps === void 0 || onMouseLeaveFromProps(data, index, event);
        dispatch(mouseLeaveItem());
      };
    };
    var useMouseClickItemDispatch = (onMouseClickFromProps, dataKey, graphicalItemId) => {
      var dispatch = useAppDispatch();
      return (data, index) => (event) => {
        onMouseClickFromProps === null || onMouseClickFromProps === void 0 || onMouseClickFromProps(data, index, event);
        dispatch(setActiveClickItemIndex({
          activeIndex: String(index),
          activeDataKey: dataKey,
          activeCoordinate: data.tooltipPosition,
          activeGraphicalItemId: graphicalItemId
        }));
      };
    };
    function SetTooltipEntrySettings(_ref2) {
      var {
        tooltipEntrySettings
      } = _ref2;
      var dispatch = useAppDispatch();
      var isPanorama = useIsPanorama();
      var prevSettingsRef = reactExports.useRef(null);
      reactExports.useLayoutEffect(() => {
        if (isPanorama) {
          return;
        }
        if (prevSettingsRef.current === null) {
          dispatch(addTooltipEntrySettings(tooltipEntrySettings));
        } else if (prevSettingsRef.current !== tooltipEntrySettings) {
          dispatch(replaceTooltipEntrySettings({
            prev: prevSettingsRef.current,
            next: tooltipEntrySettings
          }));
        }
        prevSettingsRef.current = tooltipEntrySettings;
      }, [tooltipEntrySettings, dispatch, isPanorama]);
      reactExports.useLayoutEffect(() => {
        return () => {
          if (prevSettingsRef.current) {
            dispatch(removeTooltipEntrySettings(prevSettingsRef.current));
            prevSettingsRef.current = null;
          }
        };
      }, [dispatch]);
      return null;
    }
    function SetLegendPayload(_ref2) {
      var {
        legendPayload
      } = _ref2;
      var dispatch = useAppDispatch();
      var isPanorama = useIsPanorama();
      var prevPayloadRef = reactExports.useRef(null);
      reactExports.useLayoutEffect(() => {
        if (isPanorama) {
          return;
        }
        if (prevPayloadRef.current === null) {
          dispatch(addLegendPayload(legendPayload));
        } else if (prevPayloadRef.current !== legendPayload) {
          dispatch(replaceLegendPayload({
            prev: prevPayloadRef.current,
            next: legendPayload
          }));
        }
        prevPayloadRef.current = legendPayload;
      }, [dispatch, isPanorama, legendPayload]);
      reactExports.useLayoutEffect(() => {
        return () => {
          if (prevPayloadRef.current) {
            dispatch(removeLegendPayload(prevPayloadRef.current));
            prevPayloadRef.current = null;
          }
        };
      }, [dispatch]);
      return null;
    }
    function SetPolarLegendPayload(_ref2) {
      var {
        legendPayload
      } = _ref2;
      var dispatch = useAppDispatch();
      var layout = useAppSelector(selectChartLayout);
      var prevPayloadRef = reactExports.useRef(null);
      reactExports.useLayoutEffect(() => {
        if (layout !== "centric" && layout !== "radial") {
          return;
        }
        if (prevPayloadRef.current === null) {
          dispatch(addLegendPayload(legendPayload));
        } else if (prevPayloadRef.current !== legendPayload) {
          dispatch(replaceLegendPayload({
            prev: prevPayloadRef.current,
            next: legendPayload
          }));
        }
        prevPayloadRef.current = legendPayload;
      }, [dispatch, layout, legendPayload]);
      reactExports.useLayoutEffect(() => {
        return () => {
          if (prevPayloadRef.current) {
            dispatch(removeLegendPayload(prevPayloadRef.current));
            prevPayloadRef.current = null;
          }
        };
      }, [dispatch]);
      return null;
    }
    var _ref;
    var useIdFallback = () => {
      var [id2] = reactExports.useState(() => uniqueId("uid-"));
      return id2;
    };
    var useId = (_ref = React$4["useId".toString()]) !== null && _ref !== void 0 ? _ref : useIdFallback;
    function useUniqueId(prefix2, customId) {
      var generatedId = useId();
      if (customId) {
        return customId;
      }
      return prefix2 ? "".concat(prefix2, "-").concat(generatedId) : generatedId;
    }
    var GraphicalItemIdContext = /* @__PURE__ */ reactExports.createContext(void 0);
    var RegisterGraphicalItemId = (_ref2) => {
      var {
        id: id2,
        type,
        children
      } = _ref2;
      var resolvedId = useUniqueId("recharts-".concat(type), id2);
      return /* @__PURE__ */ reactExports.createElement(GraphicalItemIdContext.Provider, {
        value: resolvedId
      }, children(resolvedId));
    };
    var initialState$5 = {
      cartesianItems: [],
      polarItems: []
    };
    var graphicalItemsSlice = createSlice({
      name: "graphicalItems",
      initialState: initialState$5,
      reducers: {
        addCartesianGraphicalItem: {
          reducer(state, action) {
            state.cartesianItems.push(castDraft(action.payload));
          },
          prepare: prepareAutoBatched()
        },
        replaceCartesianGraphicalItem: {
          reducer(state, action) {
            var {
              prev,
              next
            } = action.payload;
            var index = current$1(state).cartesianItems.indexOf(castDraft(prev));
            if (index > -1) {
              state.cartesianItems[index] = castDraft(next);
            }
          },
          prepare: prepareAutoBatched()
        },
        removeCartesianGraphicalItem: {
          reducer(state, action) {
            var index = current$1(state).cartesianItems.indexOf(castDraft(action.payload));
            if (index > -1) {
              state.cartesianItems.splice(index, 1);
            }
          },
          prepare: prepareAutoBatched()
        },
        addPolarGraphicalItem: {
          reducer(state, action) {
            state.polarItems.push(castDraft(action.payload));
          },
          prepare: prepareAutoBatched()
        },
        removePolarGraphicalItem: {
          reducer(state, action) {
            var index = current$1(state).polarItems.indexOf(castDraft(action.payload));
            if (index > -1) {
              state.polarItems.splice(index, 1);
            }
          },
          prepare: prepareAutoBatched()
        }
      }
    });
    var {
      addCartesianGraphicalItem,
      replaceCartesianGraphicalItem,
      removeCartesianGraphicalItem,
      addPolarGraphicalItem,
      removePolarGraphicalItem
    } = graphicalItemsSlice.actions;
    var graphicalItemsReducer = graphicalItemsSlice.reducer;
    var SetCartesianGraphicalItemImpl = (props) => {
      var dispatch = useAppDispatch();
      var prevPropsRef = reactExports.useRef(null);
      reactExports.useLayoutEffect(() => {
        if (prevPropsRef.current === null) {
          dispatch(addCartesianGraphicalItem(props));
        } else if (prevPropsRef.current !== props) {
          dispatch(replaceCartesianGraphicalItem({
            prev: prevPropsRef.current,
            next: props
          }));
        }
        prevPropsRef.current = props;
      }, [dispatch, props]);
      reactExports.useLayoutEffect(() => {
        return () => {
          if (prevPropsRef.current) {
            dispatch(removeCartesianGraphicalItem(prevPropsRef.current));
            prevPropsRef.current = null;
          }
        };
      }, [dispatch]);
      return null;
    };
    var SetCartesianGraphicalItem = /* @__PURE__ */ reactExports.memo(SetCartesianGraphicalItemImpl);
    function SetPolarGraphicalItem(props) {
      var dispatch = useAppDispatch();
      reactExports.useLayoutEffect(() => {
        dispatch(addPolarGraphicalItem(props));
        return () => {
          dispatch(removePolarGraphicalItem(props));
        };
      }, [dispatch, props]);
      return null;
    }
    var _excluded$e = ["key"], _excluded2$7 = ["onMouseEnter", "onClick", "onMouseLeave"], _excluded3$3 = ["id"], _excluded4$2 = ["id"];
    function ownKeys$d(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$d(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$d(Object(t2), true).forEach(function(r3) {
          _defineProperty$e(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$d(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$e(e, r2, t2) {
      return (r2 = _toPropertyKey$e(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$e(t2) {
      var i = _toPrimitive$e(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$e(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function _extends$d() {
      return _extends$d = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$d.apply(null, arguments);
    }
    function _objectWithoutProperties$e(e, t2) {
      if (null == e) return {};
      var o, r2, i = _objectWithoutPropertiesLoose$e(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e);
        for (r2 = 0; r2 < n2.length; r2++) o = n2[r2], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose$e(r2, e) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    function SetPiePayloadLegend(props) {
      var cells = reactExports.useMemo(() => findAllByType(props.children, Cell), [props.children]);
      var legendPayload = useAppSelector((state) => selectPieLegend(state, props.id, cells));
      if (legendPayload == null) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(SetPolarLegendPayload, {
        legendPayload
      });
    }
    var SetPieTooltipEntrySettings = /* @__PURE__ */ reactExports.memo((_ref2) => {
      var {
        dataKey,
        nameKey,
        sectors,
        stroke,
        strokeWidth,
        fill,
        name,
        hide,
        tooltipType
      } = _ref2;
      var tooltipEntrySettings = {
        dataDefinedOnItem: sectors.map((p2) => p2.tooltipPayload),
        positions: sectors.map((p2) => p2.tooltipPosition),
        settings: {
          stroke,
          strokeWidth,
          fill,
          dataKey,
          nameKey,
          name: getTooltipNameProp(name, dataKey),
          hide,
          type: tooltipType,
          color: fill,
          unit: ""
          // why doesn't Pie support unit?
        }
      };
      return /* @__PURE__ */ reactExports.createElement(SetTooltipEntrySettings, {
        tooltipEntrySettings
      });
    });
    var getTextAnchor = (x2, cx) => {
      if (x2 > cx) {
        return "start";
      }
      if (x2 < cx) {
        return "end";
      }
      return "middle";
    };
    var getOuterRadius = (dataPoint, outerRadius, maxPieRadius) => {
      if (typeof outerRadius === "function") {
        return getPercentValue(outerRadius(dataPoint), maxPieRadius, maxPieRadius * 0.8);
      }
      return getPercentValue(outerRadius, maxPieRadius, maxPieRadius * 0.8);
    };
    var parseCoordinateOfPie = (pieSettings, offset, dataPoint) => {
      var {
        top,
        left,
        width,
        height
      } = offset;
      var maxPieRadius = getMaxRadius(width, height);
      var cx = left + getPercentValue(pieSettings.cx, width, width / 2);
      var cy = top + getPercentValue(pieSettings.cy, height, height / 2);
      var innerRadius = getPercentValue(pieSettings.innerRadius, maxPieRadius, 0);
      var outerRadius = getOuterRadius(dataPoint, pieSettings.outerRadius, maxPieRadius);
      var maxRadius = pieSettings.maxRadius || Math.sqrt(width * width + height * height) / 2;
      return {
        cx,
        cy,
        innerRadius,
        outerRadius,
        maxRadius
      };
    };
    var parseDeltaAngle = (startAngle, endAngle) => {
      var sign2 = mathSign(endAngle - startAngle);
      var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);
      return sign2 * deltaAngle;
    };
    function getClassNamePropertyIfExists(u2) {
      if (u2 && typeof u2 === "object" && "className" in u2 && typeof u2.className === "string") {
        return u2.className;
      }
      return "";
    }
    var renderLabelLineItem = (option, props) => {
      if (/* @__PURE__ */ reactExports.isValidElement(option)) {
        return /* @__PURE__ */ reactExports.cloneElement(option, props);
      }
      if (typeof option === "function") {
        return option(props);
      }
      var className = clsx("recharts-pie-label-line", typeof option !== "boolean" ? option.className : "");
      var {
        key
      } = props, otherProps = _objectWithoutProperties$e(props, _excluded$e);
      return /* @__PURE__ */ reactExports.createElement(Curve, _extends$d({}, otherProps, {
        type: "linear",
        className
      }));
    };
    var renderLabelItem = (option, props, value) => {
      if (/* @__PURE__ */ reactExports.isValidElement(option)) {
        return /* @__PURE__ */ reactExports.cloneElement(option, props);
      }
      var label = value;
      if (typeof option === "function") {
        label = option(props);
        if (/* @__PURE__ */ reactExports.isValidElement(label)) {
          return label;
        }
      }
      var className = clsx("recharts-pie-label-text", getClassNamePropertyIfExists(option));
      return /* @__PURE__ */ reactExports.createElement(Text, _extends$d({}, props, {
        alignmentBaseline: "middle",
        className
      }), label);
    };
    function PieLabels(_ref2) {
      var {
        sectors,
        props,
        showLabels
      } = _ref2;
      var {
        label,
        labelLine,
        dataKey
      } = props;
      if (!showLabels || !label || !sectors) {
        return null;
      }
      var pieProps = svgPropertiesNoEvents(props);
      var customLabelProps = svgPropertiesNoEventsFromUnknown(label);
      var customLabelLineProps = svgPropertiesNoEventsFromUnknown(labelLine);
      var offsetRadius = typeof label === "object" && "offsetRadius" in label && typeof label.offsetRadius === "number" && label.offsetRadius || 20;
      var labels = sectors.map((entry, i) => {
        var midAngle = (entry.startAngle + entry.endAngle) / 2;
        var endPoint = polarToCartesian(entry.cx, entry.cy, entry.outerRadius + offsetRadius, midAngle);
        var labelProps = _objectSpread$d(_objectSpread$d(_objectSpread$d(_objectSpread$d({}, pieProps), entry), {}, {
          // @ts-expect-error customLabelProps is contributing unknown props
          stroke: "none"
        }, customLabelProps), {}, {
          index: i,
          textAnchor: getTextAnchor(endPoint.x, entry.cx)
        }, endPoint);
        var lineProps = _objectSpread$d(_objectSpread$d(_objectSpread$d(_objectSpread$d({}, pieProps), entry), {}, {
          // @ts-expect-error customLabelLineProps is contributing unknown props
          fill: "none",
          // @ts-expect-error customLabelLineProps is contributing unknown props
          stroke: entry.fill
        }, customLabelLineProps), {}, {
          index: i,
          points: [polarToCartesian(entry.cx, entry.cy, entry.outerRadius, midAngle), endPoint],
          key: "line"
        });
        return /* @__PURE__ */ reactExports.createElement(ZIndexLayer, {
          zIndex: DefaultZIndexes.label,
          key: "label-".concat(entry.startAngle, "-").concat(entry.endAngle, "-").concat(entry.midAngle, "-").concat(i)
        }, /* @__PURE__ */ reactExports.createElement(Layer, null, labelLine && renderLabelLineItem(labelLine, lineProps), renderLabelItem(label, labelProps, getValueByDataKey(entry, dataKey))));
      });
      return /* @__PURE__ */ reactExports.createElement(Layer, {
        className: "recharts-pie-labels"
      }, labels);
    }
    function PieLabelList(_ref3) {
      var {
        sectors,
        props,
        showLabels
      } = _ref3;
      var {
        label
      } = props;
      if (typeof label === "object" && label != null && "position" in label) {
        return /* @__PURE__ */ reactExports.createElement(LabelListFromLabelProp, {
          label
        });
      }
      return /* @__PURE__ */ reactExports.createElement(PieLabels, {
        sectors,
        props,
        showLabels
      });
    }
    function PieSectors(props) {
      var {
        sectors,
        activeShape,
        inactiveShape: inactiveShapeProp,
        allOtherPieProps,
        shape,
        id: id2
      } = props;
      var activeIndex = useAppSelector(selectActiveTooltipIndex);
      var activeDataKey = useAppSelector(selectActiveTooltipDataKey);
      var activeGraphicalItemId = useAppSelector(selectActiveTooltipGraphicalItemId);
      var {
        onMouseEnter: onMouseEnterFromProps,
        onClick: onItemClickFromProps,
        onMouseLeave: onMouseLeaveFromProps
      } = allOtherPieProps, restOfAllOtherProps = _objectWithoutProperties$e(allOtherPieProps, _excluded2$7);
      var onMouseEnterFromContext = useMouseEnterItemDispatch(onMouseEnterFromProps, allOtherPieProps.dataKey, id2);
      var onMouseLeaveFromContext = useMouseLeaveItemDispatch(onMouseLeaveFromProps);
      var onClickFromContext = useMouseClickItemDispatch(onItemClickFromProps, allOtherPieProps.dataKey, id2);
      if (sectors == null || sectors.length === 0) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, sectors.map((entry, i) => {
        if ((entry === null || entry === void 0 ? void 0 : entry.startAngle) === 0 && (entry === null || entry === void 0 ? void 0 : entry.endAngle) === 0 && sectors.length !== 1) return null;
        var graphicalItemMatches = activeGraphicalItemId == null || activeGraphicalItemId === id2;
        var isActive = String(i) === activeIndex && (activeDataKey == null || allOtherPieProps.dataKey === activeDataKey) && graphicalItemMatches;
        var inactiveShape = activeIndex ? inactiveShapeProp : null;
        var sectorOptions = activeShape && isActive ? activeShape : inactiveShape;
        var sectorProps = _objectSpread$d(_objectSpread$d({}, entry), {}, {
          stroke: entry.stroke,
          tabIndex: -1,
          [DATA_ITEM_INDEX_ATTRIBUTE_NAME]: i,
          [DATA_ITEM_DATAKEY_ATTRIBUTE_NAME]: allOtherPieProps.dataKey
        });
        return /* @__PURE__ */ reactExports.createElement(Layer, _extends$d({
          key: "sector-".concat(entry === null || entry === void 0 ? void 0 : entry.startAngle, "-").concat(entry === null || entry === void 0 ? void 0 : entry.endAngle, "-").concat(entry.midAngle, "-").concat(i),
          tabIndex: -1,
          className: "recharts-pie-sector"
        }, adaptEventsOfChild(restOfAllOtherProps, entry, i), {
          // @ts-expect-error the types need a bit of attention
          onMouseEnter: onMouseEnterFromContext(entry, i),
          onMouseLeave: onMouseLeaveFromContext(entry, i),
          onClick: onClickFromContext(entry, i)
        }), /* @__PURE__ */ reactExports.createElement(Shape, _extends$d({
          option: shape !== null && shape !== void 0 ? shape : sectorOptions,
          index: i,
          shapeType: "sector",
          isActive
        }, sectorProps)));
      }));
    }
    function computePieSectors(_ref4) {
      var _pieSettings$paddingA;
      var {
        pieSettings,
        displayedData,
        cells,
        offset
      } = _ref4;
      var {
        cornerRadius,
        startAngle,
        endAngle,
        dataKey,
        nameKey,
        tooltipType
      } = pieSettings;
      var minAngle = Math.abs(pieSettings.minAngle);
      var deltaAngle = parseDeltaAngle(startAngle, endAngle);
      var absDeltaAngle = Math.abs(deltaAngle);
      var paddingAngle = displayedData.length <= 1 ? 0 : (_pieSettings$paddingA = pieSettings.paddingAngle) !== null && _pieSettings$paddingA !== void 0 ? _pieSettings$paddingA : 0;
      var notZeroItemCount = displayedData.filter((entry) => getValueByDataKey(entry, dataKey, 0) !== 0).length;
      var totalPaddingAngle = (absDeltaAngle >= 360 ? notZeroItemCount : notZeroItemCount - 1) * paddingAngle;
      var realTotalAngle = absDeltaAngle - notZeroItemCount * minAngle - totalPaddingAngle;
      var sum = displayedData.reduce((result, entry) => {
        var val = getValueByDataKey(entry, dataKey, 0);
        return result + (isNumber(val) ? val : 0);
      }, 0);
      var sectors;
      if (sum > 0) {
        var prev;
        sectors = displayedData.map((entry, i) => {
          var val = getValueByDataKey(entry, dataKey, 0);
          var name = getValueByDataKey(entry, nameKey, i);
          var coordinate = parseCoordinateOfPie(pieSettings, offset, entry);
          var percent = (isNumber(val) ? val : 0) / sum;
          var tempStartAngle;
          var entryWithCellInfo = _objectSpread$d(_objectSpread$d({}, entry), cells && cells[i] && cells[i].props);
          if (i) {
            tempStartAngle = prev.endAngle + mathSign(deltaAngle) * paddingAngle * (val !== 0 ? 1 : 0);
          } else {
            tempStartAngle = startAngle;
          }
          var tempEndAngle = tempStartAngle + mathSign(deltaAngle) * ((val !== 0 ? minAngle : 0) + percent * realTotalAngle);
          var midAngle = (tempStartAngle + tempEndAngle) / 2;
          var middleRadius = (coordinate.innerRadius + coordinate.outerRadius) / 2;
          var tooltipPayload = [{
            name,
            value: val,
            payload: entryWithCellInfo,
            dataKey,
            type: tooltipType
          }];
          var tooltipPosition = polarToCartesian(coordinate.cx, coordinate.cy, middleRadius, midAngle);
          prev = _objectSpread$d(_objectSpread$d(_objectSpread$d(_objectSpread$d({}, pieSettings.presentationProps), {}, {
            percent,
            cornerRadius: typeof cornerRadius === "string" ? parseFloat(cornerRadius) : cornerRadius,
            name,
            tooltipPayload,
            midAngle,
            middleRadius,
            tooltipPosition
          }, entryWithCellInfo), coordinate), {}, {
            value: val,
            dataKey,
            startAngle: tempStartAngle,
            endAngle: tempEndAngle,
            payload: entryWithCellInfo,
            paddingAngle: mathSign(deltaAngle) * paddingAngle
          });
          return prev;
        });
      }
      return sectors;
    }
    function PieLabelListProvider(_ref5) {
      var {
        showLabels,
        sectors,
        children
      } = _ref5;
      var labelListEntries = reactExports.useMemo(() => {
        if (!showLabels || !sectors) {
          return [];
        }
        return sectors.map((entry) => ({
          value: entry.value,
          payload: entry.payload,
          clockWise: false,
          parentViewBox: void 0,
          viewBox: {
            cx: entry.cx,
            cy: entry.cy,
            innerRadius: entry.innerRadius,
            outerRadius: entry.outerRadius,
            startAngle: entry.startAngle,
            endAngle: entry.endAngle,
            clockWise: false
          },
          fill: entry.fill
        }));
      }, [sectors, showLabels]);
      return /* @__PURE__ */ reactExports.createElement(PolarLabelListContextProvider, {
        value: showLabels ? labelListEntries : void 0
      }, children);
    }
    function SectorsWithAnimation(_ref6) {
      var {
        props,
        previousSectorsRef,
        id: id2
      } = _ref6;
      var {
        sectors,
        isAnimationActive,
        animationBegin,
        animationDuration,
        animationEasing,
        activeShape,
        inactiveShape,
        onAnimationStart,
        onAnimationEnd
      } = props;
      var animationId = useAnimationId(props, "recharts-pie-");
      var prevSectors = previousSectorsRef.current;
      var [isAnimating, setIsAnimating] = reactExports.useState(false);
      var handleAnimationEnd = reactExports.useCallback(() => {
        if (typeof onAnimationEnd === "function") {
          onAnimationEnd();
        }
        setIsAnimating(false);
      }, [onAnimationEnd]);
      var handleAnimationStart = reactExports.useCallback(() => {
        if (typeof onAnimationStart === "function") {
          onAnimationStart();
        }
        setIsAnimating(true);
      }, [onAnimationStart]);
      return /* @__PURE__ */ reactExports.createElement(PieLabelListProvider, {
        showLabels: !isAnimating,
        sectors
      }, /* @__PURE__ */ reactExports.createElement(JavascriptAnimate, {
        animationId,
        begin: animationBegin,
        duration: animationDuration,
        isActive: isAnimationActive,
        easing: animationEasing,
        onAnimationStart: handleAnimationStart,
        onAnimationEnd: handleAnimationEnd,
        key: animationId
      }, (t2) => {
        var stepData = [];
        var first = sectors && sectors[0];
        var curAngle = first === null || first === void 0 ? void 0 : first.startAngle;
        sectors === null || sectors === void 0 || sectors.forEach((entry, index) => {
          var prev = prevSectors && prevSectors[index];
          var paddingAngle = index > 0 ? get$2(entry, "paddingAngle", 0) : 0;
          if (prev) {
            var angle = interpolate$1(prev.endAngle - prev.startAngle, entry.endAngle - entry.startAngle, t2);
            var latest2 = _objectSpread$d(_objectSpread$d({}, entry), {}, {
              startAngle: curAngle + paddingAngle,
              endAngle: curAngle + angle + paddingAngle
            });
            stepData.push(latest2);
            curAngle = latest2.endAngle;
          } else {
            var {
              endAngle,
              startAngle
            } = entry;
            var deltaAngle = interpolate$1(0, endAngle - startAngle, t2);
            var _latest = _objectSpread$d(_objectSpread$d({}, entry), {}, {
              startAngle: curAngle + paddingAngle,
              endAngle: curAngle + deltaAngle + paddingAngle
            });
            stepData.push(_latest);
            curAngle = _latest.endAngle;
          }
        });
        previousSectorsRef.current = stepData;
        return /* @__PURE__ */ reactExports.createElement(Layer, null, /* @__PURE__ */ reactExports.createElement(PieSectors, {
          sectors: stepData,
          activeShape,
          inactiveShape,
          allOtherPieProps: props,
          shape: props.shape,
          id: id2
        }));
      }), /* @__PURE__ */ reactExports.createElement(PieLabelList, {
        showLabels: !isAnimating,
        sectors,
        props
      }), props.children);
    }
    var defaultPieProps = {
      animationBegin: 400,
      animationDuration: 1500,
      animationEasing: "ease",
      cx: "50%",
      cy: "50%",
      dataKey: "value",
      endAngle: 360,
      fill: "#808080",
      hide: false,
      innerRadius: 0,
      isAnimationActive: "auto",
      label: false,
      labelLine: true,
      legendType: "rect",
      minAngle: 0,
      nameKey: "name",
      outerRadius: "80%",
      paddingAngle: 0,
      rootTabIndex: 0,
      startAngle: 0,
      stroke: "#fff",
      zIndex: DefaultZIndexes.area
    };
    function PieImpl(props) {
      var {
        id: id2
      } = props, propsWithoutId = _objectWithoutProperties$e(props, _excluded3$3);
      var {
        hide,
        className,
        rootTabIndex
      } = props;
      var cells = reactExports.useMemo(() => findAllByType(props.children, Cell), [props.children]);
      var sectors = useAppSelector((state) => selectPieSectors(state, id2, cells));
      var previousSectorsRef = reactExports.useRef(null);
      var layerClass = clsx("recharts-pie", className);
      if (hide || sectors == null) {
        previousSectorsRef.current = null;
        return /* @__PURE__ */ reactExports.createElement(Layer, {
          tabIndex: rootTabIndex,
          className: layerClass
        });
      }
      return /* @__PURE__ */ reactExports.createElement(ZIndexLayer, {
        zIndex: props.zIndex
      }, /* @__PURE__ */ reactExports.createElement(SetPieTooltipEntrySettings, {
        dataKey: props.dataKey,
        nameKey: props.nameKey,
        sectors,
        stroke: props.stroke,
        strokeWidth: props.strokeWidth,
        fill: props.fill,
        name: props.name,
        hide: props.hide,
        tooltipType: props.tooltipType
      }), /* @__PURE__ */ reactExports.createElement(Layer, {
        tabIndex: rootTabIndex,
        className: layerClass
      }, /* @__PURE__ */ reactExports.createElement(SectorsWithAnimation, {
        props: _objectSpread$d(_objectSpread$d({}, propsWithoutId), {}, {
          sectors
        }),
        previousSectorsRef,
        id: id2
      })));
    }
    function Pie(outsideProps) {
      var props = resolveDefaultProps(outsideProps, defaultPieProps);
      var {
        id: externalId
      } = props, propsWithoutId = _objectWithoutProperties$e(props, _excluded4$2);
      var presentationProps = svgPropertiesNoEvents(propsWithoutId);
      return /* @__PURE__ */ reactExports.createElement(RegisterGraphicalItemId, {
        id: externalId,
        type: "pie"
      }, (id2) => /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(SetPolarGraphicalItem, {
        type: "pie",
        id: id2,
        data: propsWithoutId.data,
        dataKey: propsWithoutId.dataKey,
        hide: propsWithoutId.hide,
        angleAxisId: 0,
        radiusAxisId: 0,
        name: propsWithoutId.name,
        nameKey: propsWithoutId.nameKey,
        tooltipType: propsWithoutId.tooltipType,
        legendType: propsWithoutId.legendType,
        fill: propsWithoutId.fill,
        cx: propsWithoutId.cx,
        cy: propsWithoutId.cy,
        startAngle: propsWithoutId.startAngle,
        endAngle: propsWithoutId.endAngle,
        paddingAngle: propsWithoutId.paddingAngle,
        minAngle: propsWithoutId.minAngle,
        innerRadius: propsWithoutId.innerRadius,
        outerRadius: propsWithoutId.outerRadius,
        cornerRadius: propsWithoutId.cornerRadius,
        presentationProps,
        maxRadius: props.maxRadius
      }), /* @__PURE__ */ reactExports.createElement(SetPiePayloadLegend, _extends$d({}, propsWithoutId, {
        id: id2
      })), /* @__PURE__ */ reactExports.createElement(PieImpl, _extends$d({}, propsWithoutId, {
        id: id2
      }))));
    }
    Pie.displayName = "Pie";
    var _excluded$d = ["points"];
    function ownKeys$c(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$c(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$c(Object(t2), true).forEach(function(r3) {
          _defineProperty$d(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$c(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$d(e, r2, t2) {
      return (r2 = _toPropertyKey$d(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$d(t2) {
      var i = _toPrimitive$d(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$d(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function _extends$c() {
      return _extends$c = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$c.apply(null, arguments);
    }
    function _objectWithoutProperties$d(e, t2) {
      if (null == e) return {};
      var o, r2, i = _objectWithoutPropertiesLoose$d(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e);
        for (r2 = 0; r2 < n2.length; r2++) o = n2[r2], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose$d(r2, e) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    function DotItem(_ref2) {
      var {
        option,
        dotProps,
        className
      } = _ref2;
      if (/* @__PURE__ */ reactExports.isValidElement(option)) {
        return /* @__PURE__ */ reactExports.cloneElement(option, dotProps);
      }
      if (typeof option === "function") {
        return option(dotProps);
      }
      var finalClassName = clsx(className, typeof option !== "boolean" ? option.className : "");
      var _ref22 = dotProps !== null && dotProps !== void 0 ? dotProps : {}, {
        points
      } = _ref22, props = _objectWithoutProperties$d(_ref22, _excluded$d);
      return /* @__PURE__ */ reactExports.createElement(Dot, _extends$c({}, props, {
        className: finalClassName
      }));
    }
    function shouldRenderDots(points, dot) {
      if (points == null) {
        return false;
      }
      if (dot) {
        return true;
      }
      return points.length === 1;
    }
    function Dots(_ref3) {
      var {
        points,
        dot,
        className,
        dotClassName,
        dataKey,
        baseProps,
        needClip,
        clipPathId,
        zIndex = DefaultZIndexes.scatter
      } = _ref3;
      if (!shouldRenderDots(points, dot)) {
        return null;
      }
      var clipDot = isClipDot(dot);
      var customDotProps = svgPropertiesAndEventsFromUnknown(dot);
      var dots = points.map((entry, i) => {
        var _entry$x, _entry$y;
        var dotProps = _objectSpread$c(_objectSpread$c(_objectSpread$c({
          r: 3
        }, baseProps), customDotProps), {}, {
          index: i,
          cx: (_entry$x = entry.x) !== null && _entry$x !== void 0 ? _entry$x : void 0,
          cy: (_entry$y = entry.y) !== null && _entry$y !== void 0 ? _entry$y : void 0,
          dataKey,
          value: entry.value,
          payload: entry.payload,
          points
        });
        return /* @__PURE__ */ reactExports.createElement(DotItem, {
          key: "dot-".concat(i),
          option: dot,
          dotProps,
          className: dotClassName
        });
      });
      var layerProps = {};
      if (needClip && clipPathId != null) {
        layerProps.clipPath = "url(#clipPath-".concat(clipDot ? "" : "dots-").concat(clipPathId, ")");
      }
      return /* @__PURE__ */ reactExports.createElement(ZIndexLayer, {
        zIndex
      }, /* @__PURE__ */ reactExports.createElement(Layer, _extends$c({
        className
      }, layerProps), dots));
    }
    function ownKeys$b(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$b(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$b(Object(t2), true).forEach(function(r3) {
          _defineProperty$c(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$b(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$c(e, r2, t2) {
      return (r2 = _toPropertyKey$c(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$c(t2) {
      var i = _toPrimitive$c(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$c(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    var initialState$4 = {
      xAxis: {},
      yAxis: {},
      zAxis: {}
    };
    var cartesianAxisSlice = createSlice({
      name: "cartesianAxis",
      initialState: initialState$4,
      reducers: {
        addXAxis: {
          reducer(state, action) {
            state.xAxis[action.payload.id] = castDraft(action.payload);
          },
          prepare: prepareAutoBatched()
        },
        replaceXAxis: {
          reducer(state, action) {
            var {
              prev,
              next
            } = action.payload;
            if (state.xAxis[prev.id] !== void 0) {
              if (prev.id !== next.id) {
                delete state.xAxis[prev.id];
              }
              state.xAxis[next.id] = castDraft(next);
            }
          },
          prepare: prepareAutoBatched()
        },
        removeXAxis: {
          reducer(state, action) {
            delete state.xAxis[action.payload.id];
          },
          prepare: prepareAutoBatched()
        },
        addYAxis: {
          reducer(state, action) {
            state.yAxis[action.payload.id] = castDraft(action.payload);
          },
          prepare: prepareAutoBatched()
        },
        replaceYAxis: {
          reducer(state, action) {
            var {
              prev,
              next
            } = action.payload;
            if (state.yAxis[prev.id] !== void 0) {
              if (prev.id !== next.id) {
                delete state.yAxis[prev.id];
              }
              state.yAxis[next.id] = castDraft(next);
            }
          },
          prepare: prepareAutoBatched()
        },
        removeYAxis: {
          reducer(state, action) {
            delete state.yAxis[action.payload.id];
          },
          prepare: prepareAutoBatched()
        },
        addZAxis: {
          reducer(state, action) {
            state.zAxis[action.payload.id] = castDraft(action.payload);
          },
          prepare: prepareAutoBatched()
        },
        replaceZAxis: {
          reducer(state, action) {
            var {
              prev,
              next
            } = action.payload;
            if (state.zAxis[prev.id] !== void 0) {
              if (prev.id !== next.id) {
                delete state.zAxis[prev.id];
              }
              state.zAxis[next.id] = castDraft(next);
            }
          },
          prepare: prepareAutoBatched()
        },
        removeZAxis: {
          reducer(state, action) {
            delete state.zAxis[action.payload.id];
          },
          prepare: prepareAutoBatched()
        },
        updateYAxisWidth(state, action) {
          var {
            id: id2,
            width
          } = action.payload;
          var axis = state.yAxis[id2];
          if (axis) {
            var history = axis.widthHistory || [];
            if (history.length === 3 && history[0] === history[2] && width === history[1] && width !== axis.width && Math.abs(width - history[0]) <= 1) {
              return;
            }
            var newHistory = [...history, width].slice(-3);
            state.yAxis[id2] = _objectSpread$b(_objectSpread$b({}, state.yAxis[id2]), {}, {
              width,
              widthHistory: newHistory
            });
          }
        }
      }
    });
    var {
      addXAxis,
      replaceXAxis,
      removeXAxis,
      addYAxis,
      replaceYAxis,
      removeYAxis,
      addZAxis,
      replaceZAxis,
      removeZAxis,
      updateYAxisWidth
    } = cartesianAxisSlice.actions;
    var cartesianAxisReducer = cartesianAxisSlice.reducer;
    var selectChartOffset = createSelector([selectChartOffsetInternal], (offsetInternal) => {
      return {
        top: offsetInternal.top,
        bottom: offsetInternal.bottom,
        left: offsetInternal.left,
        right: offsetInternal.right
      };
    });
    var selectPlotArea = createSelector([selectChartOffset, selectChartWidth, selectChartHeight], (offset, chartWidth, chartHeight) => {
      if (!offset || chartWidth == null || chartHeight == null) {
        return void 0;
      }
      return {
        x: offset.left,
        y: offset.top,
        width: Math.max(0, chartWidth - offset.left - offset.right),
        height: Math.max(0, chartHeight - offset.top - offset.bottom)
      };
    });
    var usePlotArea = () => {
      return useAppSelector(selectPlotArea);
    };
    var useActiveTooltipDataPoints = () => {
      return useAppSelector(selectActiveTooltipDataPoints);
    };
    function ownKeys$a(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$a(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$a(Object(t2), true).forEach(function(r3) {
          _defineProperty$b(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$a(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$b(e, r2, t2) {
      return (r2 = _toPropertyKey$b(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$b(t2) {
      var i = _toPrimitive$b(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$b(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    var ActivePoint = (_ref2) => {
      var {
        point: point2,
        childIndex,
        mainColor,
        activeDot,
        dataKey,
        clipPath
      } = _ref2;
      if (activeDot === false || point2.x == null || point2.y == null) {
        return null;
      }
      var dotPropsTyped = {
        index: childIndex,
        dataKey,
        cx: point2.x,
        cy: point2.y,
        r: 4,
        fill: mainColor !== null && mainColor !== void 0 ? mainColor : "none",
        strokeWidth: 2,
        stroke: "#fff",
        payload: point2.payload,
        value: point2.value
      };
      var dotProps = _objectSpread$a(_objectSpread$a(_objectSpread$a({}, dotPropsTyped), svgPropertiesNoEventsFromUnknown(activeDot)), adaptEventHandlers(activeDot));
      var dot;
      if (/* @__PURE__ */ reactExports.isValidElement(activeDot)) {
        dot = /* @__PURE__ */ reactExports.cloneElement(activeDot, dotProps);
      } else if (typeof activeDot === "function") {
        dot = activeDot(dotProps);
      } else {
        dot = /* @__PURE__ */ reactExports.createElement(Dot, dotProps);
      }
      return /* @__PURE__ */ reactExports.createElement(Layer, {
        className: "recharts-active-dot",
        clipPath
      }, dot);
    };
    function ActivePoints(_ref2) {
      var {
        points,
        mainColor,
        activeDot,
        itemDataKey,
        clipPath,
        zIndex = DefaultZIndexes.activeDot
      } = _ref2;
      var activeTooltipIndex = useAppSelector(selectActiveTooltipIndex);
      var activeDataPoints = useActiveTooltipDataPoints();
      if (points == null || activeDataPoints == null) {
        return null;
      }
      var activePoint = points.find((p2) => activeDataPoints.includes(p2.payload));
      if (isNullish(activePoint)) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(ZIndexLayer, {
        zIndex
      }, /* @__PURE__ */ reactExports.createElement(ActivePoint, {
        point: activePoint,
        childIndex: Number(activeTooltipIndex),
        mainColor,
        dataKey: itemDataKey,
        activeDot,
        clipPath
      }));
    }
    var prefix = "Invariant failed";
    function invariant(condition, message) {
      {
        throw new Error(prefix);
      }
    }
    var _excluded$c = ["x", "y"];
    function _extends$b() {
      return _extends$b = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$b.apply(null, arguments);
    }
    function ownKeys$9(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$9(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$9(Object(t2), true).forEach(function(r3) {
          _defineProperty$a(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$9(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$a(e, r2, t2) {
      return (r2 = _toPropertyKey$a(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$a(t2) {
      var i = _toPrimitive$a(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$a(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function _objectWithoutProperties$c(e, t2) {
      if (null == e) return {};
      var o, r2, i = _objectWithoutPropertiesLoose$c(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e);
        for (r2 = 0; r2 < n2.length; r2++) o = n2[r2], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose$c(r2, e) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    function typeguardBarRectangleProps(_ref2, props) {
      var {
        x: xProp,
        y: yProp
      } = _ref2, option = _objectWithoutProperties$c(_ref2, _excluded$c);
      var xValue = "".concat(xProp);
      var x2 = parseInt(xValue, 10);
      var yValue = "".concat(yProp);
      var y2 = parseInt(yValue, 10);
      var heightValue = "".concat(props.height || option.height);
      var height = parseInt(heightValue, 10);
      var widthValue = "".concat(props.width || option.width);
      var width = parseInt(widthValue, 10);
      return _objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9({}, props), option), x2 ? {
        x: x2
      } : {}), y2 ? {
        y: y2
      } : {}), {}, {
        height,
        width,
        name: props.name,
        radius: props.radius
      });
    }
    function BarRectangle(props) {
      return /* @__PURE__ */ reactExports.createElement(Shape, _extends$b({
        shapeType: "rectangle",
        propTransformer: typeguardBarRectangleProps,
        activeClassName: "recharts-active-bar"
      }, props));
    }
    var minPointSizeCallback = function minPointSizeCallback2(minPointSize) {
      var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      return (value, index) => {
        if (isNumber(minPointSize)) return minPointSize;
        var isValueNumberOrNil = isNumber(value) || isNullish(value);
        if (isValueNumberOrNil) {
          return minPointSize(value, index);
        }
        !isValueNumberOrNil ? invariant() : void 0;
        return defaultValue;
      };
    };
    var initialState$3 = {};
    var errorBarSlice = createSlice({
      name: "errorBars",
      initialState: initialState$3,
      reducers: {
        addErrorBar: (state, action) => {
          var {
            itemId,
            errorBar
          } = action.payload;
          if (!state[itemId]) {
            state[itemId] = [];
          }
          state[itemId].push(errorBar);
        },
        replaceErrorBar: (state, action) => {
          var {
            itemId,
            prev,
            next
          } = action.payload;
          if (state[itemId]) {
            state[itemId] = state[itemId].map((e) => e.dataKey === prev.dataKey && e.direction === prev.direction ? next : e);
          }
        },
        removeErrorBar: (state, action) => {
          var {
            itemId,
            errorBar
          } = action.payload;
          if (state[itemId]) {
            state[itemId] = state[itemId].filter((e) => e.dataKey !== errorBar.dataKey || e.direction !== errorBar.direction);
          }
        }
      }
    });
    var {
      addErrorBar,
      replaceErrorBar,
      removeErrorBar
    } = errorBarSlice.actions;
    var errorBarReducer = errorBarSlice.reducer;
    var _excluded$b = ["children"];
    function _objectWithoutProperties$b(e, t2) {
      if (null == e) return {};
      var o, r2, i = _objectWithoutPropertiesLoose$b(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e);
        for (r2 = 0; r2 < n2.length; r2++) o = n2[r2], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose$b(r2, e) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    var initialContextState = {
      data: [],
      xAxisId: "xAxis-0",
      yAxisId: "yAxis-0",
      dataPointFormatter: () => ({
        x: 0,
        y: 0,
        value: 0
      }),
      errorBarOffset: 0
    };
    var ErrorBarContext = /* @__PURE__ */ reactExports.createContext(initialContextState);
    function SetErrorBarContext(props) {
      var {
        children
      } = props, rest = _objectWithoutProperties$b(props, _excluded$b);
      return /* @__PURE__ */ reactExports.createElement(ErrorBarContext.Provider, {
        value: rest
      }, children);
    }
    function useNeedsClip(xAxisId, yAxisId) {
      var _xAxis$allowDataOverf, _yAxis$allowDataOverf;
      var xAxis = useAppSelector((state) => selectXAxisSettings(state, xAxisId));
      var yAxis = useAppSelector((state) => selectYAxisSettings(state, yAxisId));
      var needClipX = (_xAxis$allowDataOverf = xAxis === null || xAxis === void 0 ? void 0 : xAxis.allowDataOverflow) !== null && _xAxis$allowDataOverf !== void 0 ? _xAxis$allowDataOverf : implicitXAxis.allowDataOverflow;
      var needClipY = (_yAxis$allowDataOverf = yAxis === null || yAxis === void 0 ? void 0 : yAxis.allowDataOverflow) !== null && _yAxis$allowDataOverf !== void 0 ? _yAxis$allowDataOverf : implicitYAxis.allowDataOverflow;
      var needClip = needClipX || needClipY;
      return {
        needClip,
        needClipX,
        needClipY
      };
    }
    function GraphicalItemClipPath(_ref2) {
      var {
        xAxisId,
        yAxisId,
        clipPathId
      } = _ref2;
      var plotArea = usePlotArea();
      var {
        needClipX,
        needClipY,
        needClip
      } = useNeedsClip(xAxisId, yAxisId);
      if (!needClip || !plotArea) {
        return null;
      }
      var {
        x: x2,
        y: y2,
        width,
        height
      } = plotArea;
      return /* @__PURE__ */ reactExports.createElement("clipPath", {
        id: "clipPath-".concat(clipPathId)
      }, /* @__PURE__ */ reactExports.createElement("rect", {
        x: needClipX ? x2 : x2 - width / 2,
        y: needClipY ? y2 : y2 - height / 2,
        width: needClipX ? width : width * 2,
        height: needClipY ? height : height * 2
      }));
    }
    function getZIndexFromUnknown(input, defaultZIndex) {
      if (input && typeof input === "object" && "zIndex" in input && typeof input.zIndex === "number" && isWellBehavedNumber(input.zIndex)) {
        return input.zIndex;
      }
      return defaultZIndex;
    }
    var useSyncExternalStoreWithSelector_production = {};
    /**
     * @license React
     * use-sync-external-store-with-selector.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var React = reactExports;
    function is$1(x2, y2) {
      return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
    }
    var objectIs = "function" === typeof Object.is ? Object.is : is$1, useSyncExternalStore = React.useSyncExternalStore, useRef = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue = React.useDebugValue;
    useSyncExternalStoreWithSelector_production.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
      var instRef = useRef(null);
      if (null === instRef.current) {
        var inst = { hasValue: false, value: null };
        instRef.current = inst;
      } else inst = instRef.current;
      instRef = useMemo(
        function() {
          function memoizedSelector(nextSnapshot) {
            if (!hasMemo) {
              hasMemo = true;
              memoizedSnapshot = nextSnapshot;
              nextSnapshot = selector(nextSnapshot);
              if (void 0 !== isEqual && inst.hasValue) {
                var currentSelection = inst.value;
                if (isEqual(currentSelection, nextSnapshot))
                  return memoizedSelection = currentSelection;
              }
              return memoizedSelection = nextSnapshot;
            }
            currentSelection = memoizedSelection;
            if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
            var nextSelection = selector(nextSnapshot);
            if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
              return memoizedSnapshot = nextSnapshot, currentSelection;
            memoizedSnapshot = nextSnapshot;
            return memoizedSelection = nextSelection;
          }
          var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
          return [
            function() {
              return memoizedSelector(getSnapshot());
            },
            null === maybeGetServerSnapshot ? void 0 : function() {
              return memoizedSelector(maybeGetServerSnapshot());
            }
          ];
        },
        [getSnapshot, getServerSnapshot, selector, isEqual]
      );
      var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
      useEffect(
        function() {
          inst.hasValue = true;
          inst.value = value;
        },
        [value]
      );
      useDebugValue(value);
      return value;
    };
    function defaultNoopBatch(callback) {
      callback();
    }
    function createListenerCollection() {
      let first = null;
      let last2 = null;
      return {
        clear() {
          first = null;
          last2 = null;
        },
        notify() {
          defaultNoopBatch(() => {
            let listener2 = first;
            while (listener2) {
              listener2.callback();
              listener2 = listener2.next;
            }
          });
        },
        get() {
          const listeners = [];
          let listener2 = first;
          while (listener2) {
            listeners.push(listener2);
            listener2 = listener2.next;
          }
          return listeners;
        },
        subscribe(callback) {
          let isSubscribed = true;
          const listener2 = last2 = {
            callback,
            next: null,
            prev: last2
          };
          if (listener2.prev) {
            listener2.prev.next = listener2;
          } else {
            first = listener2;
          }
          return function unsubscribe() {
            if (!isSubscribed || first === null) return;
            isSubscribed = false;
            if (listener2.next) {
              listener2.next.prev = listener2.prev;
            } else {
              last2 = listener2.prev;
            }
            if (listener2.prev) {
              listener2.prev.next = listener2.next;
            } else {
              first = listener2.next;
            }
          };
        }
      };
    }
    var nullListeners = {
      notify() {
      },
      get: () => []
    };
    function createSubscription(store, parentSub) {
      let unsubscribe;
      let listeners = nullListeners;
      let subscriptionsAmount = 0;
      let selfSubscribed = false;
      function addNestedSub(listener2) {
        trySubscribe();
        const cleanupListener = listeners.subscribe(listener2);
        let removed = false;
        return () => {
          if (!removed) {
            removed = true;
            cleanupListener();
            tryUnsubscribe();
          }
        };
      }
      function notifyNestedSubs() {
        listeners.notify();
      }
      function handleChangeWrapper() {
        if (subscription.onStateChange) {
          subscription.onStateChange();
        }
      }
      function isSubscribed() {
        return selfSubscribed;
      }
      function trySubscribe() {
        subscriptionsAmount++;
        if (!unsubscribe) {
          unsubscribe = store.subscribe(handleChangeWrapper);
          listeners = createListenerCollection();
        }
      }
      function tryUnsubscribe() {
        subscriptionsAmount--;
        if (unsubscribe && subscriptionsAmount === 0) {
          unsubscribe();
          unsubscribe = void 0;
          listeners.clear();
          listeners = nullListeners;
        }
      }
      function trySubscribeSelf() {
        if (!selfSubscribed) {
          selfSubscribed = true;
          trySubscribe();
        }
      }
      function tryUnsubscribeSelf() {
        if (selfSubscribed) {
          selfSubscribed = false;
          tryUnsubscribe();
        }
      }
      const subscription = {
        addNestedSub,
        notifyNestedSubs,
        handleChangeWrapper,
        isSubscribed,
        trySubscribe: trySubscribeSelf,
        tryUnsubscribe: tryUnsubscribeSelf,
        getListeners: () => listeners
      };
      return subscription;
    }
    var canUseDOM = () => !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
    var isDOM = /* @__PURE__ */ canUseDOM();
    var isRunningInReactNative = () => typeof navigator !== "undefined" && navigator.product === "ReactNative";
    var isReactNative = /* @__PURE__ */ isRunningInReactNative();
    var getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? reactExports.useLayoutEffect : reactExports.useEffect;
    var useIsomorphicLayoutEffect = /* @__PURE__ */ getUseIsomorphicLayoutEffect();
    function is(x2, y2) {
      if (x2 === y2) {
        return x2 !== 0 || y2 !== 0 || 1 / x2 === 1 / y2;
      } else {
        return x2 !== x2 && y2 !== y2;
      }
    }
    function shallowEqual(objA, objB) {
      if (is(objA, objB)) return true;
      if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
        return false;
      }
      const keysA = Object.keys(objA);
      const keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) return false;
      for (let i = 0; i < keysA.length; i++) {
        if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
          return false;
        }
      }
      return true;
    }
    var ContextKey = /* @__PURE__ */ Symbol.for(`react-redux-context`);
    var gT = typeof globalThis !== "undefined" ? globalThis : (
      /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
      {}
    );
    function getContext() {
      var _a;
      if (!reactExports.createContext) return {};
      const contextMap = (_a = gT[ContextKey]) != null ? _a : gT[ContextKey] = /* @__PURE__ */ new Map();
      let realContext = contextMap.get(reactExports.createContext);
      if (!realContext) {
        realContext = reactExports.createContext(
          null
        );
        contextMap.set(reactExports.createContext, realContext);
      }
      return realContext;
    }
    var ReactReduxContext = /* @__PURE__ */ getContext();
    function Provider(providerProps) {
      const { children, context, serverState, store } = providerProps;
      const contextValue = reactExports.useMemo(() => {
        const subscription = createSubscription(store);
        const baseContextValue = {
          store,
          subscription,
          getServerState: serverState ? () => serverState : void 0
        };
        {
          return baseContextValue;
        }
      }, [store, serverState]);
      const previousState = reactExports.useMemo(() => store.getState(), [store]);
      useIsomorphicLayoutEffect(() => {
        const { subscription } = contextValue;
        subscription.onStateChange = subscription.notifyNestedSubs;
        subscription.trySubscribe();
        if (previousState !== store.getState()) {
          subscription.notifyNestedSubs();
        }
        return () => {
          subscription.tryUnsubscribe();
          subscription.onStateChange = void 0;
        };
      }, [contextValue, previousState]);
      const Context = context || ReactReduxContext;
      return /* @__PURE__ */ reactExports.createElement(Context.Provider, { value: contextValue }, children);
    }
    var Provider_default = Provider;
    var propsToShallowCompare = /* @__PURE__ */ new Set(["axisLine", "tickLine", "activeBar", "activeDot", "activeLabel", "activeShape", "allowEscapeViewBox", "background", "cursor", "dot", "label", "line", "margin", "padding", "position", "shape", "style", "tick", "wrapperStyle"]);
    function sameValueZero(x2, y2) {
      if (x2 == null && y2 == null) {
        return true;
      }
      if (typeof x2 === "number" && typeof y2 === "number") {
        return x2 === y2 || x2 !== x2 && y2 !== y2;
      }
      return x2 === y2;
    }
    function propsAreEqual(prevProps, nextProps) {
      var allKeys = /* @__PURE__ */ new Set([...Object.keys(prevProps), ...Object.keys(nextProps)]);
      for (var key of allKeys) {
        if (propsToShallowCompare.has(key)) {
          if (prevProps[key] == null && nextProps[key] == null) {
            continue;
          }
          if (!shallowEqual(prevProps[key], nextProps[key])) {
            return false;
          }
        } else if (!sameValueZero(prevProps[key], nextProps[key])) {
          return false;
        }
      }
      return true;
    }
    var _excluded$a = ["onMouseEnter", "onMouseLeave", "onClick"], _excluded2$6 = ["value", "background", "tooltipPosition"], _excluded3$2 = ["id"], _excluded4$1 = ["onMouseEnter", "onClick", "onMouseLeave"];
    function _extends$a() {
      return _extends$a = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$a.apply(null, arguments);
    }
    function ownKeys$8(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$8(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$8(Object(t2), true).forEach(function(r3) {
          _defineProperty$9(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$8(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$9(e, r2, t2) {
      return (r2 = _toPropertyKey$9(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$9(t2) {
      var i = _toPrimitive$9(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$9(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function _objectWithoutProperties$a(e, t2) {
      if (null == e) return {};
      var o, r2, i = _objectWithoutPropertiesLoose$a(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e);
        for (r2 = 0; r2 < n2.length; r2++) o = n2[r2], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose$a(r2, e) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    var computeLegendPayloadFromBarData = (props) => {
      var {
        dataKey,
        name,
        fill,
        legendType,
        hide
      } = props;
      return [{
        inactive: hide,
        dataKey,
        type: legendType,
        color: fill,
        value: getTooltipNameProp(name, dataKey),
        payload: props
      }];
    };
    var SetBarTooltipEntrySettings = /* @__PURE__ */ reactExports.memo((_ref2) => {
      var {
        dataKey,
        stroke,
        strokeWidth,
        fill,
        name,
        hide,
        unit: unit2,
        tooltipType
      } = _ref2;
      var tooltipEntrySettings = {
        dataDefinedOnItem: void 0,
        positions: void 0,
        settings: {
          stroke,
          strokeWidth,
          fill,
          dataKey,
          nameKey: void 0,
          name: getTooltipNameProp(name, dataKey),
          hide,
          type: tooltipType,
          color: fill,
          unit: unit2
        }
      };
      return /* @__PURE__ */ reactExports.createElement(SetTooltipEntrySettings, {
        tooltipEntrySettings
      });
    });
    function BarBackground(props) {
      var activeIndex = useAppSelector(selectActiveTooltipIndex);
      var {
        data,
        dataKey,
        background: backgroundFromProps,
        allOtherBarProps
      } = props;
      var {
        onMouseEnter: onMouseEnterFromProps,
        onMouseLeave: onMouseLeaveFromProps,
        onClick: onItemClickFromProps
      } = allOtherBarProps, restOfAllOtherProps = _objectWithoutProperties$a(allOtherBarProps, _excluded$a);
      var onMouseEnterFromContext = useMouseEnterItemDispatch(onMouseEnterFromProps, dataKey);
      var onMouseLeaveFromContext = useMouseLeaveItemDispatch(onMouseLeaveFromProps);
      var onClickFromContext = useMouseClickItemDispatch(onItemClickFromProps, dataKey);
      if (!backgroundFromProps || data == null) {
        return null;
      }
      var backgroundProps = svgPropertiesNoEventsFromUnknown(backgroundFromProps);
      return /* @__PURE__ */ reactExports.createElement(ZIndexLayer, {
        zIndex: getZIndexFromUnknown(backgroundFromProps, DefaultZIndexes.barBackground)
      }, data.map((entry, i) => {
        var {
          value,
          background: backgroundFromDataEntry,
          tooltipPosition
        } = entry, rest = _objectWithoutProperties$a(entry, _excluded2$6);
        if (!backgroundFromDataEntry) {
          return null;
        }
        var onMouseEnter = onMouseEnterFromContext(entry, i);
        var onMouseLeave = onMouseLeaveFromContext(entry, i);
        var onClick = onClickFromContext(entry, i);
        var barRectangleProps = _objectSpread$8(_objectSpread$8(_objectSpread$8(_objectSpread$8(_objectSpread$8({
          option: backgroundFromProps,
          isActive: String(i) === activeIndex
        }, rest), {}, {
          // @ts-expect-error backgroundProps is contributing unknown props
          fill: "#eee"
        }, backgroundFromDataEntry), backgroundProps), adaptEventsOfChild(restOfAllOtherProps, entry, i)), {}, {
          onMouseEnter,
          onMouseLeave,
          onClick,
          dataKey,
          index: i,
          className: "recharts-bar-background-rectangle"
        });
        return /* @__PURE__ */ reactExports.createElement(BarRectangle, _extends$a({
          key: "background-bar-".concat(i)
        }, barRectangleProps));
      }));
    }
    function BarLabelListProvider(_ref2) {
      var {
        showLabels,
        children,
        rects
      } = _ref2;
      var labelListEntries = rects === null || rects === void 0 ? void 0 : rects.map((entry) => {
        var viewBox = {
          x: entry.x,
          y: entry.y,
          width: entry.width,
          lowerWidth: entry.width,
          upperWidth: entry.width,
          height: entry.height
        };
        return _objectSpread$8(_objectSpread$8({}, viewBox), {}, {
          value: entry.value,
          payload: entry.payload,
          parentViewBox: entry.parentViewBox,
          viewBox,
          fill: entry.fill
        });
      });
      return /* @__PURE__ */ reactExports.createElement(CartesianLabelListContextProvider, {
        value: showLabels ? labelListEntries : void 0
      }, children);
    }
    function BarRectangleWithActiveState(props) {
      var {
        shape,
        activeBar,
        baseProps,
        entry,
        index,
        dataKey
      } = props;
      var activeIndex = useAppSelector(selectActiveTooltipIndex);
      var activeDataKey = useAppSelector(selectActiveTooltipDataKey);
      var isActive = activeBar && String(index) === activeIndex && (activeDataKey == null || dataKey === activeDataKey);
      var option = isActive ? activeBar : shape;
      if (isActive) {
        return /* @__PURE__ */ reactExports.createElement(ZIndexLayer, {
          zIndex: DefaultZIndexes.activeBar
        }, /* @__PURE__ */ reactExports.createElement(BarRectangle, _extends$a({}, baseProps, {
          name: String(baseProps.name)
        }, entry, {
          isActive,
          option,
          index,
          dataKey
        })));
      }
      return /* @__PURE__ */ reactExports.createElement(BarRectangle, _extends$a({}, baseProps, {
        name: String(baseProps.name)
      }, entry, {
        isActive,
        option,
        index,
        dataKey
      }));
    }
    function BarRectangleNeverActive(props) {
      var {
        shape,
        baseProps,
        entry,
        index,
        dataKey
      } = props;
      return /* @__PURE__ */ reactExports.createElement(BarRectangle, _extends$a({}, baseProps, {
        name: String(baseProps.name)
      }, entry, {
        isActive: false,
        option: shape,
        index,
        dataKey
      }));
    }
    function BarRectangles(_ref3) {
      var _svgPropertiesNoEvent;
      var {
        data,
        props
      } = _ref3;
      var _ref4 = (_svgPropertiesNoEvent = svgPropertiesNoEvents(props)) !== null && _svgPropertiesNoEvent !== void 0 ? _svgPropertiesNoEvent : {}, {
        id: id2
      } = _ref4, baseProps = _objectWithoutProperties$a(_ref4, _excluded3$2);
      var {
        shape,
        dataKey,
        activeBar
      } = props;
      var {
        onMouseEnter: onMouseEnterFromProps,
        onClick: onItemClickFromProps,
        onMouseLeave: onMouseLeaveFromProps
      } = props, restOfAllOtherProps = _objectWithoutProperties$a(props, _excluded4$1);
      var onMouseEnterFromContext = useMouseEnterItemDispatch(onMouseEnterFromProps, dataKey);
      var onMouseLeaveFromContext = useMouseLeaveItemDispatch(onMouseLeaveFromProps);
      var onClickFromContext = useMouseClickItemDispatch(onItemClickFromProps, dataKey);
      if (!data) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, data.map((entry, i) => {
        return /* @__PURE__ */ reactExports.createElement(
          Layer,
          _extends$a({
            key: "rectangle-".concat(entry === null || entry === void 0 ? void 0 : entry.x, "-").concat(entry === null || entry === void 0 ? void 0 : entry.y, "-").concat(entry === null || entry === void 0 ? void 0 : entry.value, "-").concat(i),
            className: "recharts-bar-rectangle"
          }, adaptEventsOfChild(restOfAllOtherProps, entry, i), {
            // @ts-expect-error BarRectangleItem type definition says it's missing properties, but I can see them present in debugger!
            onMouseEnter: onMouseEnterFromContext(entry, i),
            onMouseLeave: onMouseLeaveFromContext(entry, i),
            onClick: onClickFromContext(entry, i)
          }),
          activeBar ? /* @__PURE__ */ reactExports.createElement(BarRectangleWithActiveState, {
            shape,
            activeBar,
            baseProps,
            entry,
            index: i,
            dataKey
          }) : (
            /*
             * If the `activeBar` prop is falsy, then let's call the variant without hooks.
             * Using the `selectActiveTooltipIndex` selector is usually fast
             * but in charts with large-ish amount of data even the few nanoseconds add up to a noticeable jank.
             * If the activeBar is false then we don't need to know which index is active - because we won't use it anyway.
             * So let's just skip the hooks altogether. That way, React can skip rendering the component,
             * and can skip the tree reconciliation for its children too.
             * Because we can't call hooks conditionally, we need to have a separate component for that.
             */
            /* @__PURE__ */ reactExports.createElement(BarRectangleNeverActive, {
              shape,
              baseProps,
              entry,
              index: i,
              dataKey
            })
          )
        );
      }));
    }
    function RectanglesWithAnimation(_ref5) {
      var {
        props,
        previousRectanglesRef
      } = _ref5;
      var {
        data,
        layout,
        isAnimationActive,
        animationBegin,
        animationDuration,
        animationEasing,
        onAnimationEnd,
        onAnimationStart
      } = props;
      var prevData = previousRectanglesRef.current;
      var animationId = useAnimationId(props, "recharts-bar-");
      var [isAnimating, setIsAnimating] = reactExports.useState(false);
      var showLabels = !isAnimating;
      var handleAnimationEnd = reactExports.useCallback(() => {
        if (typeof onAnimationEnd === "function") {
          onAnimationEnd();
        }
        setIsAnimating(false);
      }, [onAnimationEnd]);
      var handleAnimationStart = reactExports.useCallback(() => {
        if (typeof onAnimationStart === "function") {
          onAnimationStart();
        }
        setIsAnimating(true);
      }, [onAnimationStart]);
      return /* @__PURE__ */ reactExports.createElement(BarLabelListProvider, {
        showLabels,
        rects: data
      }, /* @__PURE__ */ reactExports.createElement(JavascriptAnimate, {
        animationId,
        begin: animationBegin,
        duration: animationDuration,
        isActive: isAnimationActive,
        easing: animationEasing,
        onAnimationEnd: handleAnimationEnd,
        onAnimationStart: handleAnimationStart,
        key: animationId
      }, (t2) => {
        var stepData = t2 === 1 ? data : data === null || data === void 0 ? void 0 : data.map((entry, index) => {
          var prev = prevData && prevData[index];
          if (prev) {
            return _objectSpread$8(_objectSpread$8({}, entry), {}, {
              x: interpolate$1(prev.x, entry.x, t2),
              y: interpolate$1(prev.y, entry.y, t2),
              width: interpolate$1(prev.width, entry.width, t2),
              height: interpolate$1(prev.height, entry.height, t2)
            });
          }
          if (layout === "horizontal") {
            var height = interpolate$1(0, entry.height, t2);
            var y2 = interpolate$1(entry.stackedBarStart, entry.y, t2);
            return _objectSpread$8(_objectSpread$8({}, entry), {}, {
              y: y2,
              height
            });
          }
          var w2 = interpolate$1(0, entry.width, t2);
          var x2 = interpolate$1(entry.stackedBarStart, entry.x, t2);
          return _objectSpread$8(_objectSpread$8({}, entry), {}, {
            width: w2,
            x: x2
          });
        });
        if (t2 > 0) {
          previousRectanglesRef.current = stepData !== null && stepData !== void 0 ? stepData : null;
        }
        if (stepData == null) {
          return null;
        }
        return /* @__PURE__ */ reactExports.createElement(Layer, null, /* @__PURE__ */ reactExports.createElement(BarRectangles, {
          props,
          data: stepData
        }));
      }), /* @__PURE__ */ reactExports.createElement(LabelListFromLabelProp, {
        label: props.label
      }), props.children);
    }
    function RenderRectangles(props) {
      var previousRectanglesRef = reactExports.useRef(null);
      return /* @__PURE__ */ reactExports.createElement(RectanglesWithAnimation, {
        previousRectanglesRef,
        props
      });
    }
    var defaultMinPointSize = 0;
    var errorBarDataPointFormatter$1 = (dataPoint, dataKey) => {
      var value = Array.isArray(dataPoint.value) ? dataPoint.value[1] : dataPoint.value;
      return {
        x: dataPoint.x,
        y: dataPoint.y,
        value,
        // @ts-expect-error getValueByDataKey does not validate the output type
        errorVal: getValueByDataKey(dataPoint, dataKey)
      };
    };
    class BarWithState extends reactExports.PureComponent {
      render() {
        var {
          hide,
          data,
          dataKey,
          className,
          xAxisId,
          yAxisId,
          needClip,
          background,
          id: id2
        } = this.props;
        if (hide || data == null) {
          return null;
        }
        var layerClass = clsx("recharts-bar", className);
        var clipPathId = id2;
        return /* @__PURE__ */ reactExports.createElement(Layer, {
          className: layerClass,
          id: id2
        }, needClip && /* @__PURE__ */ reactExports.createElement("defs", null, /* @__PURE__ */ reactExports.createElement(GraphicalItemClipPath, {
          clipPathId,
          xAxisId,
          yAxisId
        })), /* @__PURE__ */ reactExports.createElement(Layer, {
          className: "recharts-bar-rectangles",
          clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : void 0
        }, /* @__PURE__ */ reactExports.createElement(BarBackground, {
          data,
          dataKey,
          background,
          allOtherBarProps: this.props
        }), /* @__PURE__ */ reactExports.createElement(RenderRectangles, this.props)));
      }
    }
    var defaultBarProps = {
      activeBar: false,
      animationBegin: 0,
      animationDuration: 400,
      animationEasing: "ease",
      background: false,
      hide: false,
      isAnimationActive: "auto",
      label: false,
      legendType: "rect",
      minPointSize: defaultMinPointSize,
      xAxisId: 0,
      yAxisId: 0,
      zIndex: DefaultZIndexes.bar
    };
    function BarImpl(props) {
      var {
        xAxisId,
        yAxisId,
        hide,
        legendType,
        minPointSize,
        activeBar,
        animationBegin,
        animationDuration,
        animationEasing,
        isAnimationActive
      } = props;
      var {
        needClip
      } = useNeedsClip(xAxisId, yAxisId);
      var layout = useChartLayout();
      var isPanorama = useIsPanorama();
      var cells = findAllByType(props.children, Cell);
      var rects = useAppSelector((state) => selectBarRectangles(state, xAxisId, yAxisId, isPanorama, props.id, cells));
      if (layout !== "vertical" && layout !== "horizontal") {
        return null;
      }
      var errorBarOffset;
      var firstDataPoint = rects === null || rects === void 0 ? void 0 : rects[0];
      if (firstDataPoint == null || firstDataPoint.height == null || firstDataPoint.width == null) {
        errorBarOffset = 0;
      } else {
        errorBarOffset = layout === "vertical" ? firstDataPoint.height / 2 : firstDataPoint.width / 2;
      }
      return /* @__PURE__ */ reactExports.createElement(SetErrorBarContext, {
        xAxisId,
        yAxisId,
        data: rects,
        dataPointFormatter: errorBarDataPointFormatter$1,
        errorBarOffset
      }, /* @__PURE__ */ reactExports.createElement(BarWithState, _extends$a({}, props, {
        layout,
        needClip,
        data: rects,
        xAxisId,
        yAxisId,
        hide,
        legendType,
        minPointSize,
        activeBar,
        animationBegin,
        animationDuration,
        animationEasing,
        isAnimationActive
      })));
    }
    function computeBarRectangles(_ref6) {
      var {
        layout,
        barSettings: {
          dataKey,
          minPointSize: minPointSizeProp
        },
        pos,
        bandSize,
        xAxis,
        yAxis,
        xAxisTicks,
        yAxisTicks,
        stackedData,
        displayedData,
        offset,
        cells,
        parentViewBox,
        dataStartIndex
      } = _ref6;
      var numericAxis = layout === "horizontal" ? yAxis : xAxis;
      var stackedDomain = stackedData ? numericAxis.scale.domain() : null;
      var baseValue = getBaseValueOfBar({
        numericAxis
      });
      var stackedBarStart = numericAxis.scale(baseValue);
      return displayedData.map((entry, index) => {
        var value, x2, y2, width, height, background;
        if (stackedData) {
          value = truncateByDomain(stackedData[index + dataStartIndex], stackedDomain);
        } else {
          value = getValueByDataKey(entry, dataKey);
          if (!Array.isArray(value)) {
            value = [baseValue, value];
          }
        }
        var minPointSize = minPointSizeCallback(minPointSizeProp, defaultMinPointSize)(value[1], index);
        if (layout === "horizontal") {
          var _ref7;
          var [baseValueScale, currentValueScale] = [yAxis.scale(value[0]), yAxis.scale(value[1])];
          x2 = getCateCoordinateOfBar({
            axis: xAxis,
            ticks: xAxisTicks,
            bandSize,
            offset: pos.offset,
            entry,
            index
          });
          y2 = (_ref7 = currentValueScale !== null && currentValueScale !== void 0 ? currentValueScale : baseValueScale) !== null && _ref7 !== void 0 ? _ref7 : void 0;
          width = pos.size;
          var computedHeight = baseValueScale - currentValueScale;
          height = isNan(computedHeight) ? 0 : computedHeight;
          background = {
            x: x2,
            y: offset.top,
            width,
            height: offset.height
          };
          if (Math.abs(minPointSize) > 0 && Math.abs(height) < Math.abs(minPointSize)) {
            var delta = mathSign(height || minPointSize) * (Math.abs(minPointSize) - Math.abs(height));
            y2 -= delta;
            height += delta;
          }
        } else {
          var [_baseValueScale, _currentValueScale] = [xAxis.scale(value[0]), xAxis.scale(value[1])];
          x2 = _baseValueScale;
          y2 = getCateCoordinateOfBar({
            axis: yAxis,
            ticks: yAxisTicks,
            bandSize,
            offset: pos.offset,
            entry,
            index
          });
          width = _currentValueScale - _baseValueScale;
          height = pos.size;
          background = {
            x: offset.left,
            y: y2,
            width: offset.width,
            height
          };
          if (Math.abs(minPointSize) > 0 && Math.abs(width) < Math.abs(minPointSize)) {
            var _delta = mathSign(width || minPointSize) * (Math.abs(minPointSize) - Math.abs(width));
            width += _delta;
          }
        }
        if (x2 == null || y2 == null || width == null || height == null) {
          return null;
        }
        var barRectangleItem = _objectSpread$8(_objectSpread$8({}, entry), {}, {
          stackedBarStart,
          x: x2,
          y: y2,
          width,
          height,
          value: stackedData ? value : value[1],
          payload: entry,
          background,
          tooltipPosition: {
            x: x2 + width / 2,
            y: y2 + height / 2
          },
          parentViewBox
        }, cells && cells[index] && cells[index].props);
        return barRectangleItem;
      }).filter(Boolean);
    }
    function BarFn(outsideProps) {
      var props = resolveDefaultProps(outsideProps, defaultBarProps);
      var isPanorama = useIsPanorama();
      return /* @__PURE__ */ reactExports.createElement(RegisterGraphicalItemId, {
        id: props.id,
        type: "bar"
      }, (id2) => /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(SetLegendPayload, {
        legendPayload: computeLegendPayloadFromBarData(props)
      }), /* @__PURE__ */ reactExports.createElement(SetBarTooltipEntrySettings, {
        dataKey: props.dataKey,
        stroke: props.stroke,
        strokeWidth: props.strokeWidth,
        fill: props.fill,
        name: props.name,
        hide: props.hide,
        unit: props.unit,
        tooltipType: props.tooltipType
      }), /* @__PURE__ */ reactExports.createElement(SetCartesianGraphicalItem, {
        type: "bar",
        id: id2,
        data: void 0,
        xAxisId: props.xAxisId,
        yAxisId: props.yAxisId,
        zAxisId: 0,
        dataKey: props.dataKey,
        stackId: getNormalizedStackId(props.stackId),
        hide: props.hide,
        barSize: props.barSize,
        minPointSize: props.minPointSize,
        maxBarSize: props.maxBarSize,
        isPanorama
      }), /* @__PURE__ */ reactExports.createElement(ZIndexLayer, {
        zIndex: props.zIndex
      }, /* @__PURE__ */ reactExports.createElement(BarImpl, _extends$a({}, props, {
        id: id2
      })))));
    }
    var Bar = /* @__PURE__ */ reactExports.memo(BarFn, propsAreEqual);
    Bar.displayName = "Bar";
    function ownKeys$7(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$7(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$7(Object(t2), true).forEach(function(r3) {
          _defineProperty$8(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$7(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$8(e, r2, t2) {
      return (r2 = _toPropertyKey$8(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$8(t2) {
      var i = _toPrimitive$8(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$8(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    var pickXAxisId = (_state, xAxisId) => xAxisId;
    var pickYAxisId = (_state, _xAxisId, yAxisId) => yAxisId;
    var pickIsPanorama = (_state, _xAxisId, _yAxisId, isPanorama) => isPanorama;
    var pickBarId = (_state, _xAxisId, _yAxisId, _isPanorama, id2) => id2;
    var selectSynchronisedBarSettings = createSelector([selectUnfilteredCartesianItems, pickBarId], (graphicalItems, id2) => graphicalItems.filter((item) => item.type === "bar").find((item) => item.id === id2));
    var selectMaxBarSize = createSelector([selectSynchronisedBarSettings], (barSettings) => barSettings === null || barSettings === void 0 ? void 0 : barSettings.maxBarSize);
    var pickCells = (_state, _xAxisId, _yAxisId, _isPanorama, _id, cells) => cells;
    var getBarSize = (globalSize, totalSize, selfSize) => {
      var barSize = selfSize !== null && selfSize !== void 0 ? selfSize : globalSize;
      if (isNullish(barSize)) {
        return void 0;
      }
      return getPercentValue(barSize, totalSize, 0);
    };
    var selectAllVisibleBars = createSelector([selectChartLayout, selectUnfilteredCartesianItems, pickXAxisId, pickYAxisId, pickIsPanorama], (layout, allItems, xAxisId, yAxisId, isPanorama) => allItems.filter((i) => {
      if (layout === "horizontal") {
        return i.xAxisId === xAxisId;
      }
      return i.yAxisId === yAxisId;
    }).filter((i) => i.isPanorama === isPanorama).filter((i) => i.hide === false).filter((i) => i.type === "bar"));
    var selectBarStackGroups = (state, xAxisId, yAxisId, isPanorama) => {
      var layout = selectChartLayout(state);
      if (layout === "horizontal") {
        return selectStackGroups(state, "yAxis", yAxisId, isPanorama);
      }
      return selectStackGroups(state, "xAxis", xAxisId, isPanorama);
    };
    var selectBarCartesianAxisSize = (state, xAxisId, yAxisId) => {
      var layout = selectChartLayout(state);
      if (layout === "horizontal") {
        return selectCartesianAxisSize(state, "xAxis", xAxisId);
      }
      return selectCartesianAxisSize(state, "yAxis", yAxisId);
    };
    var combineBarSizeList = (allBars, globalSize, totalSize) => {
      var initialValue = {};
      var stackedBars = allBars.filter(isStacked);
      var unstackedBars = allBars.filter((b) => b.stackId == null);
      var groupByStack = stackedBars.reduce((acc, bar) => {
        if (!acc[bar.stackId]) {
          acc[bar.stackId] = [];
        }
        acc[bar.stackId].push(bar);
        return acc;
      }, initialValue);
      var stackedSizeList = Object.entries(groupByStack).map((_ref2) => {
        var [stackId, bars] = _ref2;
        var dataKeys = bars.map((b) => b.dataKey);
        var barSize = getBarSize(globalSize, totalSize, bars[0].barSize);
        return {
          stackId,
          dataKeys,
          barSize
        };
      });
      var unstackedSizeList = unstackedBars.map((b) => {
        var dataKeys = [b.dataKey].filter((dk2) => dk2 != null);
        var barSize = getBarSize(globalSize, totalSize, b.barSize);
        return {
          stackId: void 0,
          dataKeys,
          barSize
        };
      });
      return [...stackedSizeList, ...unstackedSizeList];
    };
    var selectBarSizeList = createSelector([selectAllVisibleBars, selectRootBarSize, selectBarCartesianAxisSize], combineBarSizeList);
    var selectBarBandSize = (state, xAxisId, yAxisId, isPanorama, id2) => {
      var _ref2, _getBandSizeOfAxis;
      var barSettings = selectSynchronisedBarSettings(state, xAxisId, yAxisId, isPanorama, id2);
      if (barSettings == null) {
        return void 0;
      }
      var layout = selectChartLayout(state);
      var globalMaxBarSize = selectRootMaxBarSize(state);
      var {
        maxBarSize: childMaxBarSize
      } = barSettings;
      var maxBarSize = isNullish(childMaxBarSize) ? globalMaxBarSize : childMaxBarSize;
      var axis, ticks2;
      if (layout === "horizontal") {
        axis = selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
        ticks2 = selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
      } else {
        axis = selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
        ticks2 = selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
      }
      return (_ref2 = (_getBandSizeOfAxis = getBandSizeOfAxis(axis, ticks2, true)) !== null && _getBandSizeOfAxis !== void 0 ? _getBandSizeOfAxis : maxBarSize) !== null && _ref2 !== void 0 ? _ref2 : 0;
    };
    var selectAxisBandSize = (state, xAxisId, yAxisId, isPanorama) => {
      var layout = selectChartLayout(state);
      var axis, ticks2;
      if (layout === "horizontal") {
        axis = selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
        ticks2 = selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
      } else {
        axis = selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
        ticks2 = selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
      }
      return getBandSizeOfAxis(axis, ticks2);
    };
    function getBarPositions(barGap, barCategoryGap, bandSize, sizeList, maxBarSize) {
      var len = sizeList.length;
      if (len < 1) {
        return void 0;
      }
      var realBarGap = getPercentValue(barGap, bandSize, 0, true);
      var result;
      var initialValue = [];
      if (isWellBehavedNumber(sizeList[0].barSize)) {
        var useFull = false;
        var fullBarSize = bandSize / len;
        var sum = sizeList.reduce((res, entry) => res + (entry.barSize || 0), 0);
        sum += (len - 1) * realBarGap;
        if (sum >= bandSize) {
          sum -= (len - 1) * realBarGap;
          realBarGap = 0;
        }
        if (sum >= bandSize && fullBarSize > 0) {
          useFull = true;
          fullBarSize *= 0.9;
          sum = len * fullBarSize;
        }
        var offset = (bandSize - sum) / 2 >> 0;
        var prev = {
          offset: offset - realBarGap,
          size: 0
        };
        result = sizeList.reduce((res, entry) => {
          var _entry$barSize;
          var newPosition = {
            stackId: entry.stackId,
            dataKeys: entry.dataKeys,
            position: {
              offset: prev.offset + prev.size + realBarGap,
              size: useFull ? fullBarSize : (_entry$barSize = entry.barSize) !== null && _entry$barSize !== void 0 ? _entry$barSize : 0
            }
          };
          var newRes = [...res, newPosition];
          prev = newRes[newRes.length - 1].position;
          return newRes;
        }, initialValue);
      } else {
        var _offset = getPercentValue(barCategoryGap, bandSize, 0, true);
        if (bandSize - 2 * _offset - (len - 1) * realBarGap <= 0) {
          realBarGap = 0;
        }
        var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;
        if (originalSize > 1) {
          originalSize >>= 0;
        }
        var size = isWellBehavedNumber(maxBarSize) ? Math.min(originalSize, maxBarSize) : originalSize;
        result = sizeList.reduce((res, entry, i) => [...res, {
          stackId: entry.stackId,
          dataKeys: entry.dataKeys,
          position: {
            offset: _offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,
            size
          }
        }], initialValue);
      }
      return result;
    }
    var combineAllBarPositions = (sizeList, globalMaxBarSize, barGap, barCategoryGap, barBandSize, bandSize, childMaxBarSize) => {
      var maxBarSize = isNullish(childMaxBarSize) ? globalMaxBarSize : childMaxBarSize;
      var allBarPositions = getBarPositions(barGap, barCategoryGap, barBandSize !== bandSize ? barBandSize : bandSize, sizeList, maxBarSize);
      if (barBandSize !== bandSize && allBarPositions != null) {
        allBarPositions = allBarPositions.map((pos) => _objectSpread$7(_objectSpread$7({}, pos), {}, {
          position: _objectSpread$7(_objectSpread$7({}, pos.position), {}, {
            offset: pos.position.offset - barBandSize / 2
          })
        }));
      }
      return allBarPositions;
    };
    var selectAllBarPositions = createSelector([selectBarSizeList, selectRootMaxBarSize, selectBarGap, selectBarCategoryGap, selectBarBandSize, selectAxisBandSize, selectMaxBarSize], combineAllBarPositions);
    var selectXAxisWithScale$2 = (state, xAxisId, _yAxisId, isPanorama) => selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
    var selectYAxisWithScale$2 = (state, _xAxisId, yAxisId, isPanorama) => selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
    var selectXAxisTicks$2 = (state, xAxisId, _yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
    var selectYAxisTicks$2 = (state, _xAxisId, yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
    var selectBarPosition = createSelector([selectAllBarPositions, selectSynchronisedBarSettings], (allBarPositions, barSettings) => {
      if (allBarPositions == null || barSettings == null) {
        return void 0;
      }
      var position = allBarPositions.find((p2) => p2.stackId === barSettings.stackId && barSettings.dataKey != null && p2.dataKeys.includes(barSettings.dataKey));
      if (position == null) {
        return void 0;
      }
      return position.position;
    });
    var combineStackedData = (stackGroups, barSettings) => {
      var stackSeriesIdentifier = getStackSeriesIdentifier(barSettings);
      if (!stackGroups || stackSeriesIdentifier == null || barSettings == null) {
        return void 0;
      }
      var {
        stackId
      } = barSettings;
      if (stackId == null) {
        return void 0;
      }
      var stackGroup = stackGroups[stackId];
      if (!stackGroup) {
        return void 0;
      }
      var {
        stackedData
      } = stackGroup;
      if (!stackedData) {
        return void 0;
      }
      return stackedData.find((sd2) => sd2.key === stackSeriesIdentifier);
    };
    var selectStackedDataOfItem = createSelector([selectBarStackGroups, selectSynchronisedBarSettings], combineStackedData);
    var selectBarRectangles = createSelector([selectChartOffsetInternal, selectAxisViewBox, selectXAxisWithScale$2, selectYAxisWithScale$2, selectXAxisTicks$2, selectYAxisTicks$2, selectBarPosition, selectChartLayout, selectChartDataWithIndexesIfNotInPanorama, selectAxisBandSize, selectStackedDataOfItem, selectSynchronisedBarSettings, pickCells], (offset, axisViewBox, xAxis, yAxis, xAxisTicks, yAxisTicks, pos, layout, _ref3, bandSize, stackedData, barSettings, cells) => {
      var {
        chartData,
        dataStartIndex,
        dataEndIndex
      } = _ref3;
      if (barSettings == null || pos == null || axisViewBox == null || layout !== "horizontal" && layout !== "vertical" || xAxis == null || yAxis == null || xAxisTicks == null || yAxisTicks == null || bandSize == null) {
        return void 0;
      }
      var {
        data
      } = barSettings;
      var displayedData;
      if (data != null && data.length > 0) {
        displayedData = data;
      } else {
        displayedData = chartData === null || chartData === void 0 ? void 0 : chartData.slice(dataStartIndex, dataEndIndex + 1);
      }
      if (displayedData == null) {
        return void 0;
      }
      return computeBarRectangles({
        layout,
        barSettings,
        pos,
        parentViewBox: axisViewBox,
        bandSize,
        xAxis,
        yAxis,
        xAxisTicks,
        yAxisTicks,
        stackedData,
        displayedData,
        offset,
        cells,
        dataStartIndex
      });
    });
    var ChartDataContextProvider = (props) => {
      var {
        chartData
      } = props;
      var dispatch = useAppDispatch();
      var isPanorama = useIsPanorama();
      reactExports.useEffect(() => {
        if (isPanorama) {
          return () => {
          };
        }
        dispatch(setChartData(chartData));
        return () => {
          dispatch(setChartData(void 0));
        };
      }, [chartData, dispatch, isPanorama]);
      return null;
    };
    var initialState$2 = {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      padding: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }
    };
    var brushSlice = createSlice({
      name: "brush",
      initialState: initialState$2,
      reducers: {
        setBrushSettings(_state, action) {
          if (action.payload == null) {
            return initialState$2;
          }
          return action.payload;
        }
      }
    });
    var {
      setBrushSettings
    } = brushSlice.actions;
    var brushReducer = brushSlice.reducer;
    function _defineProperty$7(e, r2, t2) {
      return (r2 = _toPropertyKey$7(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$7(t2) {
      var i = _toPrimitive$7(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$7(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    class ScaleHelper {
      static create(obj) {
        return new ScaleHelper(obj);
      }
      constructor(scale) {
        this.scale = scale;
      }
      get domain() {
        return this.scale.domain;
      }
      get range() {
        return this.scale.range;
      }
      get rangeMin() {
        return this.range()[0];
      }
      get rangeMax() {
        return this.range()[1];
      }
      get bandwidth() {
        return this.scale.bandwidth;
      }
      apply(value) {
        var {
          bandAware,
          position
        } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (value === void 0) {
          return void 0;
        }
        if (position) {
          switch (position) {
            case "start": {
              return this.scale(value);
            }
            case "middle": {
              var offset = this.bandwidth ? this.bandwidth() / 2 : 0;
              return this.scale(value) + offset;
            }
            case "end": {
              var _offset = this.bandwidth ? this.bandwidth() : 0;
              return this.scale(value) + _offset;
            }
            default: {
              return this.scale(value);
            }
          }
        }
        if (bandAware) {
          var _offset2 = this.bandwidth ? this.bandwidth() / 2 : 0;
          return this.scale(value) + _offset2;
        }
        return this.scale(value);
      }
      isInRange(value) {
        var range2 = this.range();
        var first = range2[0];
        var last2 = range2[range2.length - 1];
        return first <= last2 ? value >= first && value <= last2 : value >= last2 && value <= first;
      }
    }
    _defineProperty$7(ScaleHelper, "EPS", 1e-4);
    function normalizeAngle(angle) {
      return (angle % 180 + 180) % 180;
    }
    var getAngledRectangleWidth = function getAngledRectangleWidth2(_ref5) {
      var {
        width,
        height
      } = _ref5;
      var angle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var normalizedAngle = normalizeAngle(angle);
      var angleRadians = normalizedAngle * Math.PI / 180;
      var angleThreshold = Math.atan(height / width);
      var angledWidth = angleRadians > angleThreshold && angleRadians < Math.PI - angleThreshold ? height / Math.sin(angleRadians) : width / Math.cos(angleRadians);
      return Math.abs(angledWidth);
    };
    var initialState$1 = {
      dots: [],
      areas: [],
      lines: []
    };
    var referenceElementsSlice = createSlice({
      name: "referenceElements",
      initialState: initialState$1,
      reducers: {
        addDot: (state, action) => {
          state.dots.push(action.payload);
        },
        removeDot: (state, action) => {
          var index = current$1(state).dots.findIndex((dot) => dot === action.payload);
          if (index !== -1) {
            state.dots.splice(index, 1);
          }
        },
        addArea: (state, action) => {
          state.areas.push(action.payload);
        },
        removeArea: (state, action) => {
          var index = current$1(state).areas.findIndex((area) => area === action.payload);
          if (index !== -1) {
            state.areas.splice(index, 1);
          }
        },
        addLine: (state, action) => {
          state.lines.push(castDraft(action.payload));
        },
        removeLine: (state, action) => {
          var index = current$1(state).lines.findIndex((line) => line === action.payload);
          if (index !== -1) {
            state.lines.splice(index, 1);
          }
        }
      }
    });
    var {
      addDot,
      removeDot,
      addArea,
      removeArea,
      addLine,
      removeLine
    } = referenceElementsSlice.actions;
    var referenceElementsReducer = referenceElementsSlice.reducer;
    var ClipPathIdContext = /* @__PURE__ */ reactExports.createContext(void 0);
    var ClipPathProvider = (_ref2) => {
      var {
        children
      } = _ref2;
      var [clipPathId] = reactExports.useState("".concat(uniqueId("recharts"), "-clip"));
      var plotArea = usePlotArea();
      if (plotArea == null) {
        return null;
      }
      var {
        x: x2,
        y: y2,
        width,
        height
      } = plotArea;
      return /* @__PURE__ */ reactExports.createElement(ClipPathIdContext.Provider, {
        value: clipPathId
      }, /* @__PURE__ */ reactExports.createElement("defs", null, /* @__PURE__ */ reactExports.createElement("clipPath", {
        id: clipPathId
      }, /* @__PURE__ */ reactExports.createElement("rect", {
        x: x2,
        y: y2,
        height,
        width
      }))), children);
    };
    function getEveryNthWithCondition(array2, n2) {
      if (n2 < 1) {
        return [];
      }
      if (n2 === 1) {
        return array2;
      }
      var result = [];
      for (var i = 0; i < array2.length; i += n2) {
        result.push(array2[i]);
      }
      return result;
    }
    function getAngledTickWidth(contentSize, unitSize, angle) {
      var size = {
        width: contentSize.width + unitSize.width,
        height: contentSize.height + unitSize.height
      };
      return getAngledRectangleWidth(size, angle);
    }
    function getTickBoundaries(viewBox, sign2, sizeKey) {
      var isWidth = sizeKey === "width";
      var {
        x: x2,
        y: y2,
        width,
        height
      } = viewBox;
      if (sign2 === 1) {
        return {
          start: isWidth ? x2 : y2,
          end: isWidth ? x2 + width : y2 + height
        };
      }
      return {
        start: isWidth ? x2 + width : y2 + height,
        end: isWidth ? x2 : y2
      };
    }
    function isVisible(sign2, tickPosition, getSize, start, end) {
      if (sign2 * tickPosition < sign2 * start || sign2 * tickPosition > sign2 * end) {
        return false;
      }
      var size = getSize();
      return sign2 * (tickPosition - sign2 * size / 2 - start) >= 0 && sign2 * (tickPosition + sign2 * size / 2 - end) <= 0;
    }
    function getNumberIntervalTicks(ticks2, interval) {
      return getEveryNthWithCondition(ticks2, interval + 1);
    }
    function getEquidistantTicks(sign2, boundaries, getTickSize, ticks2, minTickGap) {
      var result = (ticks2 || []).slice();
      var {
        start: initialStart,
        end
      } = boundaries;
      var index = 0;
      var stepsize = 1;
      var start = initialStart;
      var _loop = function _loop2() {
        var entry = ticks2 === null || ticks2 === void 0 ? void 0 : ticks2[index];
        if (entry === void 0) {
          return {
            v: getEveryNthWithCondition(ticks2, stepsize)
          };
        }
        var i = index;
        var size;
        var getSize = () => {
          if (size === void 0) {
            size = getTickSize(entry, i);
          }
          return size;
        };
        var tickCoord = entry.coordinate;
        var isShow = index === 0 || isVisible(sign2, tickCoord, getSize, start, end);
        if (!isShow) {
          index = 0;
          start = initialStart;
          stepsize += 1;
        }
        if (isShow) {
          start = tickCoord + sign2 * (getSize() / 2 + minTickGap);
          index += stepsize;
        }
      }, _ret;
      while (stepsize <= result.length) {
        _ret = _loop();
        if (_ret) return _ret.v;
      }
      return [];
    }
    function ownKeys$6(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$6(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$6(Object(t2), true).forEach(function(r3) {
          _defineProperty$6(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$6(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$6(e, r2, t2) {
      return (r2 = _toPropertyKey$6(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$6(t2) {
      var i = _toPrimitive$6(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$6(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function getTicksEnd(sign2, boundaries, getTickSize, ticks2, minTickGap) {
      var result = (ticks2 || []).slice();
      var len = result.length;
      var {
        start
      } = boundaries;
      var {
        end
      } = boundaries;
      var _loop = function _loop2(i2) {
        var entry = result[i2];
        var size;
        var getSize = () => {
          if (size === void 0) {
            size = getTickSize(entry, i2);
          }
          return size;
        };
        if (i2 === len - 1) {
          var gap = sign2 * (entry.coordinate + sign2 * getSize() / 2 - end);
          result[i2] = entry = _objectSpread$6(_objectSpread$6({}, entry), {}, {
            tickCoord: gap > 0 ? entry.coordinate - gap * sign2 : entry.coordinate
          });
        } else {
          result[i2] = entry = _objectSpread$6(_objectSpread$6({}, entry), {}, {
            tickCoord: entry.coordinate
          });
        }
        if (entry.tickCoord != null) {
          var isShow = isVisible(sign2, entry.tickCoord, getSize, start, end);
          if (isShow) {
            end = entry.tickCoord - sign2 * (getSize() / 2 + minTickGap);
            result[i2] = _objectSpread$6(_objectSpread$6({}, entry), {}, {
              isShow: true
            });
          }
        }
      };
      for (var i = len - 1; i >= 0; i--) {
        _loop(i);
      }
      return result;
    }
    function getTicksStart(sign2, boundaries, getTickSize, ticks2, minTickGap, preserveEnd) {
      var result = (ticks2 || []).slice();
      var len = result.length;
      var {
        start,
        end
      } = boundaries;
      if (preserveEnd) {
        var tail = ticks2[len - 1];
        var tailSize = getTickSize(tail, len - 1);
        var tailGap = sign2 * (tail.coordinate + sign2 * tailSize / 2 - end);
        result[len - 1] = tail = _objectSpread$6(_objectSpread$6({}, tail), {}, {
          tickCoord: tailGap > 0 ? tail.coordinate - tailGap * sign2 : tail.coordinate
        });
        if (tail.tickCoord != null) {
          var isTailShow = isVisible(sign2, tail.tickCoord, () => tailSize, start, end);
          if (isTailShow) {
            end = tail.tickCoord - sign2 * (tailSize / 2 + minTickGap);
            result[len - 1] = _objectSpread$6(_objectSpread$6({}, tail), {}, {
              isShow: true
            });
          }
        }
      }
      var count = preserveEnd ? len - 1 : len;
      var _loop2 = function _loop22(i2) {
        var entry = result[i2];
        var size;
        var getSize = () => {
          if (size === void 0) {
            size = getTickSize(entry, i2);
          }
          return size;
        };
        if (i2 === 0) {
          var gap = sign2 * (entry.coordinate - sign2 * getSize() / 2 - start);
          result[i2] = entry = _objectSpread$6(_objectSpread$6({}, entry), {}, {
            tickCoord: gap < 0 ? entry.coordinate - gap * sign2 : entry.coordinate
          });
        } else {
          result[i2] = entry = _objectSpread$6(_objectSpread$6({}, entry), {}, {
            tickCoord: entry.coordinate
          });
        }
        if (entry.tickCoord != null) {
          var isShow = isVisible(sign2, entry.tickCoord, getSize, start, end);
          if (isShow) {
            start = entry.tickCoord + sign2 * (getSize() / 2 + minTickGap);
            result[i2] = _objectSpread$6(_objectSpread$6({}, entry), {}, {
              isShow: true
            });
          }
        }
      };
      for (var i = 0; i < count; i++) {
        _loop2(i);
      }
      return result;
    }
    function getTicks(props, fontSize, letterSpacing) {
      var {
        tick,
        ticks: ticks2,
        viewBox,
        minTickGap,
        orientation: orientation2,
        interval,
        tickFormatter,
        unit: unit2,
        angle
      } = props;
      if (!ticks2 || !ticks2.length || !tick) {
        return [];
      }
      if (isNumber(interval) || Global.isSsr) {
        var _getNumberIntervalTic;
        return (_getNumberIntervalTic = getNumberIntervalTicks(ticks2, isNumber(interval) ? interval : 0)) !== null && _getNumberIntervalTic !== void 0 ? _getNumberIntervalTic : [];
      }
      var candidates = [];
      var sizeKey = orientation2 === "top" || orientation2 === "bottom" ? "width" : "height";
      var unitSize = unit2 && sizeKey === "width" ? getStringSize(unit2, {
        fontSize,
        letterSpacing
      }) : {
        width: 0,
        height: 0
      };
      var getTickSize = (content, index) => {
        var value = typeof tickFormatter === "function" ? tickFormatter(content.value, index) : content.value;
        return sizeKey === "width" ? getAngledTickWidth(getStringSize(value, {
          fontSize,
          letterSpacing
        }), unitSize, angle) : getStringSize(value, {
          fontSize,
          letterSpacing
        })[sizeKey];
      };
      var sign2 = ticks2.length >= 2 ? mathSign(ticks2[1].coordinate - ticks2[0].coordinate) : 1;
      var boundaries = getTickBoundaries(viewBox, sign2, sizeKey);
      if (interval === "equidistantPreserveStart") {
        return getEquidistantTicks(sign2, boundaries, getTickSize, ticks2, minTickGap);
      }
      if (interval === "preserveStart" || interval === "preserveStartEnd") {
        candidates = getTicksStart(sign2, boundaries, getTickSize, ticks2, minTickGap, interval === "preserveStartEnd");
      } else {
        candidates = getTicksEnd(sign2, boundaries, getTickSize, ticks2, minTickGap);
      }
      return candidates.filter((entry) => entry.isShow);
    }
    var getCalculatedYAxisWidth = (_ref2) => {
      var {
        ticks: ticks2,
        label,
        labelGapWithTick = 5,
        // Default gap between label and tick
        tickSize = 0,
        tickMargin = 0
      } = _ref2;
      var maxTickWidth = 0;
      if (ticks2) {
        Array.from(ticks2).forEach((tickNode) => {
          if (tickNode) {
            var bbox = tickNode.getBoundingClientRect();
            if (bbox.width > maxTickWidth) {
              maxTickWidth = bbox.width;
            }
          }
        });
        var labelWidth = label ? label.getBoundingClientRect().width : 0;
        var tickWidth = tickSize + tickMargin;
        var updatedYAxisWidth = maxTickWidth + tickWidth + labelWidth + (label ? labelGapWithTick : 0);
        return Math.round(updatedYAxisWidth);
      }
      return 0;
    };
    var _excluded$9 = ["axisLine", "width", "height", "className", "hide", "ticks", "axisType"];
    function _objectWithoutProperties$9(e, t2) {
      if (null == e) return {};
      var o, r2, i = _objectWithoutPropertiesLoose$9(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e);
        for (r2 = 0; r2 < n2.length; r2++) o = n2[r2], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose$9(r2, e) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    function _extends$9() {
      return _extends$9 = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$9.apply(null, arguments);
    }
    function ownKeys$5(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$5(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$5(Object(t2), true).forEach(function(r3) {
          _defineProperty$5(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$5(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$5(e, r2, t2) {
      return (r2 = _toPropertyKey$5(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$5(t2) {
      var i = _toPrimitive$5(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$5(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    var defaultCartesianAxisProps = {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      viewBox: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      },
      // The orientation of axis
      orientation: "bottom",
      // The ticks
      ticks: [],
      stroke: "#666",
      tickLine: true,
      axisLine: true,
      tick: true,
      mirror: false,
      minTickGap: 5,
      // The width or height of tick
      tickSize: 6,
      tickMargin: 2,
      interval: "preserveEnd",
      zIndex: DefaultZIndexes.axis
    };
    function AxisLine(axisLineProps) {
      var {
        x: x2,
        y: y2,
        width,
        height,
        orientation: orientation2,
        mirror,
        axisLine,
        otherSvgProps
      } = axisLineProps;
      if (!axisLine) {
        return null;
      }
      var props = _objectSpread$5(_objectSpread$5(_objectSpread$5({}, otherSvgProps), svgPropertiesNoEvents(axisLine)), {}, {
        fill: "none"
      });
      if (orientation2 === "top" || orientation2 === "bottom") {
        var needHeight = +(orientation2 === "top" && !mirror || orientation2 === "bottom" && mirror);
        props = _objectSpread$5(_objectSpread$5({}, props), {}, {
          x1: x2,
          y1: y2 + needHeight * height,
          x2: x2 + width,
          y2: y2 + needHeight * height
        });
      } else {
        var needWidth = +(orientation2 === "left" && !mirror || orientation2 === "right" && mirror);
        props = _objectSpread$5(_objectSpread$5({}, props), {}, {
          x1: x2 + needWidth * width,
          y1: y2,
          x2: x2 + needWidth * width,
          y2: y2 + height
        });
      }
      return /* @__PURE__ */ reactExports.createElement("line", _extends$9({}, props, {
        className: clsx("recharts-cartesian-axis-line", get$2(axisLine, "className"))
      }));
    }
    function getTickLineCoord(data, x2, y2, width, height, orientation2, tickSize, mirror, tickMargin) {
      var x1, x22, y1, y22, tx, ty;
      var sign2 = mirror ? -1 : 1;
      var finalTickSize = data.tickSize || tickSize;
      var tickCoord = isNumber(data.tickCoord) ? data.tickCoord : data.coordinate;
      switch (orientation2) {
        case "top":
          x1 = x22 = data.coordinate;
          y22 = y2 + +!mirror * height;
          y1 = y22 - sign2 * finalTickSize;
          ty = y1 - sign2 * tickMargin;
          tx = tickCoord;
          break;
        case "left":
          y1 = y22 = data.coordinate;
          x22 = x2 + +!mirror * width;
          x1 = x22 - sign2 * finalTickSize;
          tx = x1 - sign2 * tickMargin;
          ty = tickCoord;
          break;
        case "right":
          y1 = y22 = data.coordinate;
          x22 = x2 + +mirror * width;
          x1 = x22 + sign2 * finalTickSize;
          tx = x1 + sign2 * tickMargin;
          ty = tickCoord;
          break;
        default:
          x1 = x22 = data.coordinate;
          y22 = y2 + +mirror * height;
          y1 = y22 + sign2 * finalTickSize;
          ty = y1 + sign2 * tickMargin;
          tx = tickCoord;
          break;
      }
      return {
        line: {
          x1,
          y1,
          x2: x22,
          y2: y22
        },
        tick: {
          x: tx,
          y: ty
        }
      };
    }
    function getTickTextAnchor(orientation2, mirror) {
      switch (orientation2) {
        case "left":
          return mirror ? "start" : "end";
        case "right":
          return mirror ? "end" : "start";
        default:
          return "middle";
      }
    }
    function getTickVerticalAnchor(orientation2, mirror) {
      switch (orientation2) {
        case "left":
        case "right":
          return "middle";
        case "top":
          return mirror ? "start" : "end";
        default:
          return mirror ? "end" : "start";
      }
    }
    function TickItem(props) {
      var {
        option,
        tickProps,
        value
      } = props;
      var tickItem;
      var combinedClassName = clsx(tickProps.className, "recharts-cartesian-axis-tick-value");
      if (/* @__PURE__ */ reactExports.isValidElement(option)) {
        tickItem = /* @__PURE__ */ reactExports.cloneElement(option, _objectSpread$5(_objectSpread$5({}, tickProps), {}, {
          className: combinedClassName
        }));
      } else if (typeof option === "function") {
        tickItem = option(_objectSpread$5(_objectSpread$5({}, tickProps), {}, {
          className: combinedClassName
        }));
      } else {
        var className = "recharts-cartesian-axis-tick-value";
        if (typeof option !== "boolean") {
          className = clsx(className, option === null || option === void 0 ? void 0 : option.className);
        }
        tickItem = /* @__PURE__ */ reactExports.createElement(Text, _extends$9({}, tickProps, {
          className
        }), value);
      }
      return tickItem;
    }
    var Ticks = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var {
        ticks: ticks2 = [],
        tick,
        tickLine,
        stroke,
        tickFormatter,
        unit: unit2,
        padding,
        tickTextProps,
        orientation: orientation2,
        mirror,
        x: x2,
        y: y2,
        width,
        height,
        tickSize,
        tickMargin,
        fontSize,
        letterSpacing,
        getTicksConfig,
        events,
        axisType
      } = props;
      var finalTicks = getTicks(_objectSpread$5(_objectSpread$5({}, getTicksConfig), {}, {
        ticks: ticks2
      }), fontSize, letterSpacing);
      var textAnchor = getTickTextAnchor(orientation2, mirror);
      var verticalAnchor = getTickVerticalAnchor(orientation2, mirror);
      var axisProps = svgPropertiesNoEvents(getTicksConfig);
      var customTickProps = svgPropertiesNoEventsFromUnknown(tick);
      var tickLinePropsObject = {};
      if (typeof tickLine === "object") {
        tickLinePropsObject = tickLine;
      }
      var tickLineProps = _objectSpread$5(_objectSpread$5({}, axisProps), {}, {
        fill: "none"
      }, tickLinePropsObject);
      var tickLineCoords = finalTicks.map((entry) => _objectSpread$5({
        entry
      }, getTickLineCoord(entry, x2, y2, width, height, orientation2, tickSize, mirror, tickMargin)));
      var tickLines = tickLineCoords.map((_ref2) => {
        var {
          entry,
          line: lineCoord
        } = _ref2;
        return /* @__PURE__ */ reactExports.createElement(Layer, {
          className: "recharts-cartesian-axis-tick",
          key: "tick-".concat(entry.value, "-").concat(entry.coordinate, "-").concat(entry.tickCoord)
        }, tickLine && /* @__PURE__ */ reactExports.createElement("line", _extends$9({}, tickLineProps, lineCoord, {
          className: clsx("recharts-cartesian-axis-tick-line", get$2(tickLine, "className"))
        })));
      });
      var tickLabels = tickLineCoords.map((_ref2, i) => {
        var {
          entry,
          tick: tickCoord
        } = _ref2;
        var tickProps = _objectSpread$5(_objectSpread$5(_objectSpread$5(_objectSpread$5({
          // @ts-expect-error textAnchor from axisProps is typed as `string` but Text wants type `TextAnchor`
          textAnchor,
          verticalAnchor
        }, axisProps), {}, {
          // @ts-expect-error customTickProps is contributing unknown props
          stroke: "none",
          // @ts-expect-error customTickProps is contributing unknown props
          fill: stroke
        }, customTickProps), tickCoord), {}, {
          index: i,
          payload: entry,
          visibleTicksCount: finalTicks.length,
          tickFormatter,
          padding
        }, tickTextProps);
        return /* @__PURE__ */ reactExports.createElement(Layer, _extends$9({
          className: "recharts-cartesian-axis-tick-label",
          key: "tick-label-".concat(entry.value, "-").concat(entry.coordinate, "-").concat(entry.tickCoord)
        }, adaptEventsOfChild(events, entry, i)), tick && /* @__PURE__ */ reactExports.createElement(TickItem, {
          option: tick,
          tickProps,
          value: "".concat(typeof tickFormatter === "function" ? tickFormatter(entry.value, i) : entry.value).concat(unit2 || "")
        }));
      });
      return /* @__PURE__ */ reactExports.createElement("g", {
        className: "recharts-cartesian-axis-ticks recharts-".concat(axisType, "-ticks")
      }, tickLabels.length > 0 && /* @__PURE__ */ reactExports.createElement(ZIndexLayer, {
        zIndex: DefaultZIndexes.label
      }, /* @__PURE__ */ reactExports.createElement("g", {
        className: "recharts-cartesian-axis-tick-labels recharts-".concat(axisType, "-tick-labels"),
        ref
      }, tickLabels)), tickLines.length > 0 && /* @__PURE__ */ reactExports.createElement("g", {
        className: "recharts-cartesian-axis-tick-lines recharts-".concat(axisType, "-tick-lines")
      }, tickLines));
    });
    var CartesianAxisComponent = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var {
        axisLine,
        width,
        height,
        className,
        hide,
        ticks: ticks2,
        axisType
      } = props, rest = _objectWithoutProperties$9(props, _excluded$9);
      var [fontSize, setFontSize] = reactExports.useState("");
      var [letterSpacing, setLetterSpacing] = reactExports.useState("");
      var tickRefs = reactExports.useRef(null);
      reactExports.useImperativeHandle(ref, () => ({
        getCalculatedWidth: () => {
          var _props$labelRef;
          return getCalculatedYAxisWidth({
            ticks: tickRefs.current,
            label: (_props$labelRef = props.labelRef) === null || _props$labelRef === void 0 ? void 0 : _props$labelRef.current,
            labelGapWithTick: 5,
            tickSize: props.tickSize,
            tickMargin: props.tickMargin
          });
        }
      }));
      var layerRef = reactExports.useCallback((el2) => {
        if (el2) {
          var tickNodes = el2.getElementsByClassName("recharts-cartesian-axis-tick-value");
          tickRefs.current = tickNodes;
          var tick = tickNodes[0];
          if (tick) {
            var computedStyle = window.getComputedStyle(tick);
            var calculatedFontSize = computedStyle.fontSize;
            var calculatedLetterSpacing = computedStyle.letterSpacing;
            if (calculatedFontSize !== fontSize || calculatedLetterSpacing !== letterSpacing) {
              setFontSize(calculatedFontSize);
              setLetterSpacing(calculatedLetterSpacing);
            }
          }
        }
      }, [fontSize, letterSpacing]);
      if (hide) {
        return null;
      }
      if (width != null && width <= 0 || height != null && height <= 0) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(ZIndexLayer, {
        zIndex: props.zIndex
      }, /* @__PURE__ */ reactExports.createElement(Layer, {
        className: clsx("recharts-cartesian-axis", className)
      }, /* @__PURE__ */ reactExports.createElement(AxisLine, {
        x: props.x,
        y: props.y,
        width,
        height,
        orientation: props.orientation,
        mirror: props.mirror,
        axisLine,
        otherSvgProps: svgPropertiesNoEvents(props)
      }), /* @__PURE__ */ reactExports.createElement(Ticks, {
        ref: layerRef,
        axisType,
        events: rest,
        fontSize,
        getTicksConfig: props,
        height: props.height,
        letterSpacing,
        mirror: props.mirror,
        orientation: props.orientation,
        padding: props.padding,
        stroke: props.stroke,
        tick: props.tick,
        tickFormatter: props.tickFormatter,
        tickLine: props.tickLine,
        tickMargin: props.tickMargin,
        tickSize: props.tickSize,
        tickTextProps: props.tickTextProps,
        ticks: ticks2,
        unit: props.unit,
        width: props.width,
        x: props.x,
        y: props.y
      }), /* @__PURE__ */ reactExports.createElement(CartesianLabelContextProvider, {
        x: props.x,
        y: props.y,
        width: props.width,
        height: props.height,
        lowerWidth: props.width,
        upperWidth: props.width
      }, /* @__PURE__ */ reactExports.createElement(CartesianLabelFromLabelProp, {
        label: props.label,
        labelRef: props.labelRef
      }), props.children)));
    });
    var CartesianAxis = /* @__PURE__ */ reactExports.forwardRef((outsideProps, ref) => {
      var props = resolveDefaultProps(outsideProps, defaultCartesianAxisProps);
      return /* @__PURE__ */ reactExports.createElement(CartesianAxisComponent, _extends$9({}, props, {
        ref
      }));
    });
    CartesianAxis.displayName = "CartesianAxis";
    var _excluded$8 = ["x1", "y1", "x2", "y2", "key"], _excluded2$5 = ["offset"], _excluded3$1 = ["xAxisId", "yAxisId"], _excluded4 = ["xAxisId", "yAxisId"];
    function ownKeys$4(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$4(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$4(Object(t2), true).forEach(function(r3) {
          _defineProperty$4(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$4(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$4(e, r2, t2) {
      return (r2 = _toPropertyKey$4(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$4(t2) {
      var i = _toPrimitive$4(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$4(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function _extends$8() {
      return _extends$8 = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$8.apply(null, arguments);
    }
    function _objectWithoutProperties$8(e, t2) {
      if (null == e) return {};
      var o, r2, i = _objectWithoutPropertiesLoose$8(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e);
        for (r2 = 0; r2 < n2.length; r2++) o = n2[r2], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose$8(r2, e) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    var Background = (props) => {
      var {
        fill
      } = props;
      if (!fill || fill === "none") {
        return null;
      }
      var {
        fillOpacity,
        x: x2,
        y: y2,
        width,
        height,
        ry
      } = props;
      return /* @__PURE__ */ reactExports.createElement("rect", {
        x: x2,
        y: y2,
        ry,
        width,
        height,
        stroke: "none",
        fill,
        fillOpacity,
        className: "recharts-cartesian-grid-bg"
      });
    };
    function LineItem(_ref2) {
      var {
        option,
        lineItemProps
      } = _ref2;
      var lineItem;
      if (/* @__PURE__ */ reactExports.isValidElement(option)) {
        lineItem = /* @__PURE__ */ reactExports.cloneElement(option, lineItemProps);
      } else if (typeof option === "function") {
        lineItem = option(lineItemProps);
      } else {
        var _svgPropertiesNoEvent;
        var {
          x1,
          y1,
          x2,
          y2,
          key
        } = lineItemProps, others = _objectWithoutProperties$8(lineItemProps, _excluded$8);
        var _ref22 = (_svgPropertiesNoEvent = svgPropertiesNoEvents(others)) !== null && _svgPropertiesNoEvent !== void 0 ? _svgPropertiesNoEvent : {}, {
          offset: __
        } = _ref22, restOfFilteredProps = _objectWithoutProperties$8(_ref22, _excluded2$5);
        lineItem = /* @__PURE__ */ reactExports.createElement("line", _extends$8({}, restOfFilteredProps, {
          x1,
          y1,
          x2,
          y2,
          fill: "none",
          key
        }));
      }
      return lineItem;
    }
    function HorizontalGridLines(props) {
      var {
        x: x2,
        width,
        horizontal = true,
        horizontalPoints
      } = props;
      if (!horizontal || !horizontalPoints || !horizontalPoints.length) {
        return null;
      }
      var {
        xAxisId,
        yAxisId
      } = props, otherLineItemProps = _objectWithoutProperties$8(props, _excluded3$1);
      var items = horizontalPoints.map((entry, i) => {
        var lineItemProps = _objectSpread$4(_objectSpread$4({}, otherLineItemProps), {}, {
          x1: x2,
          y1: entry,
          x2: x2 + width,
          y2: entry,
          key: "line-".concat(i),
          index: i
        });
        return /* @__PURE__ */ reactExports.createElement(LineItem, {
          key: "line-".concat(i),
          option: horizontal,
          lineItemProps
        });
      });
      return /* @__PURE__ */ reactExports.createElement("g", {
        className: "recharts-cartesian-grid-horizontal"
      }, items);
    }
    function VerticalGridLines(props) {
      var {
        y: y2,
        height,
        vertical = true,
        verticalPoints
      } = props;
      if (!vertical || !verticalPoints || !verticalPoints.length) {
        return null;
      }
      var {
        xAxisId,
        yAxisId
      } = props, otherLineItemProps = _objectWithoutProperties$8(props, _excluded4);
      var items = verticalPoints.map((entry, i) => {
        var lineItemProps = _objectSpread$4(_objectSpread$4({}, otherLineItemProps), {}, {
          x1: entry,
          y1: y2,
          x2: entry,
          y2: y2 + height,
          key: "line-".concat(i),
          index: i
        });
        return /* @__PURE__ */ reactExports.createElement(LineItem, {
          option: vertical,
          lineItemProps,
          key: "line-".concat(i)
        });
      });
      return /* @__PURE__ */ reactExports.createElement("g", {
        className: "recharts-cartesian-grid-vertical"
      }, items);
    }
    function HorizontalStripes(props) {
      var {
        horizontalFill,
        fillOpacity,
        x: x2,
        y: y2,
        width,
        height,
        horizontalPoints,
        horizontal = true
      } = props;
      if (!horizontal || !horizontalFill || !horizontalFill.length || horizontalPoints == null) {
        return null;
      }
      var roundedSortedHorizontalPoints = horizontalPoints.map((e) => Math.round(e + y2 - y2)).sort((a2, b) => a2 - b);
      if (y2 !== roundedSortedHorizontalPoints[0]) {
        roundedSortedHorizontalPoints.unshift(0);
      }
      var items = roundedSortedHorizontalPoints.map((entry, i) => {
        var lastStripe = !roundedSortedHorizontalPoints[i + 1];
        var lineHeight = lastStripe ? y2 + height - entry : roundedSortedHorizontalPoints[i + 1] - entry;
        if (lineHeight <= 0) {
          return null;
        }
        var colorIndex = i % horizontalFill.length;
        return /* @__PURE__ */ reactExports.createElement("rect", {
          key: "react-".concat(i),
          y: entry,
          x: x2,
          height: lineHeight,
          width,
          stroke: "none",
          fill: horizontalFill[colorIndex],
          fillOpacity,
          className: "recharts-cartesian-grid-bg"
        });
      });
      return /* @__PURE__ */ reactExports.createElement("g", {
        className: "recharts-cartesian-gridstripes-horizontal"
      }, items);
    }
    function VerticalStripes(props) {
      var {
        vertical = true,
        verticalFill,
        fillOpacity,
        x: x2,
        y: y2,
        width,
        height,
        verticalPoints
      } = props;
      if (!vertical || !verticalFill || !verticalFill.length) {
        return null;
      }
      var roundedSortedVerticalPoints = verticalPoints.map((e) => Math.round(e + x2 - x2)).sort((a2, b) => a2 - b);
      if (x2 !== roundedSortedVerticalPoints[0]) {
        roundedSortedVerticalPoints.unshift(0);
      }
      var items = roundedSortedVerticalPoints.map((entry, i) => {
        var lastStripe = !roundedSortedVerticalPoints[i + 1];
        var lineWidth = lastStripe ? x2 + width - entry : roundedSortedVerticalPoints[i + 1] - entry;
        if (lineWidth <= 0) {
          return null;
        }
        var colorIndex = i % verticalFill.length;
        return /* @__PURE__ */ reactExports.createElement("rect", {
          key: "react-".concat(i),
          x: entry,
          y: y2,
          width: lineWidth,
          height,
          stroke: "none",
          fill: verticalFill[colorIndex],
          fillOpacity,
          className: "recharts-cartesian-grid-bg"
        });
      });
      return /* @__PURE__ */ reactExports.createElement("g", {
        className: "recharts-cartesian-gridstripes-vertical"
      }, items);
    }
    var defaultVerticalCoordinatesGenerator = (_ref3, syncWithTicks) => {
      var {
        xAxis,
        width,
        height,
        offset
      } = _ref3;
      return getCoordinatesOfGrid(getTicks(_objectSpread$4(_objectSpread$4(_objectSpread$4({}, defaultCartesianAxisProps), xAxis), {}, {
        ticks: getTicksOfAxis(xAxis),
        viewBox: {
          x: 0,
          y: 0,
          width,
          height
        }
      })), offset.left, offset.left + offset.width, syncWithTicks);
    };
    var defaultHorizontalCoordinatesGenerator = (_ref4, syncWithTicks) => {
      var {
        yAxis,
        width,
        height,
        offset
      } = _ref4;
      return getCoordinatesOfGrid(getTicks(_objectSpread$4(_objectSpread$4(_objectSpread$4({}, defaultCartesianAxisProps), yAxis), {}, {
        ticks: getTicksOfAxis(yAxis),
        viewBox: {
          x: 0,
          y: 0,
          width,
          height
        }
      })), offset.top, offset.top + offset.height, syncWithTicks);
    };
    var defaultCartesianGridProps = {
      horizontal: true,
      vertical: true,
      // The ordinates of horizontal grid lines
      horizontalPoints: [],
      // The abscissas of vertical grid lines
      verticalPoints: [],
      stroke: "#ccc",
      fill: "none",
      // The fill of colors of grid lines
      verticalFill: [],
      horizontalFill: [],
      xAxisId: 0,
      yAxisId: 0,
      syncWithTicks: false,
      zIndex: DefaultZIndexes.grid
    };
    function CartesianGrid(props) {
      var chartWidth = useChartWidth();
      var chartHeight = useChartHeight();
      var offset = useOffsetInternal();
      var propsIncludingDefaults = _objectSpread$4(_objectSpread$4({}, resolveDefaultProps(props, defaultCartesianGridProps)), {}, {
        x: isNumber(props.x) ? props.x : offset.left,
        y: isNumber(props.y) ? props.y : offset.top,
        width: isNumber(props.width) ? props.width : offset.width,
        height: isNumber(props.height) ? props.height : offset.height
      });
      var {
        xAxisId,
        yAxisId,
        x: x2,
        y: y2,
        width,
        height,
        syncWithTicks,
        horizontalValues,
        verticalValues
      } = propsIncludingDefaults;
      var isPanorama = useIsPanorama();
      var xAxis = useAppSelector((state) => selectAxisPropsNeededForCartesianGridTicksGenerator(state, "xAxis", xAxisId, isPanorama));
      var yAxis = useAppSelector((state) => selectAxisPropsNeededForCartesianGridTicksGenerator(state, "yAxis", yAxisId, isPanorama));
      if (!isPositiveNumber(width) || !isPositiveNumber(height) || !isNumber(x2) || !isNumber(y2)) {
        return null;
      }
      var verticalCoordinatesGenerator = propsIncludingDefaults.verticalCoordinatesGenerator || defaultVerticalCoordinatesGenerator;
      var horizontalCoordinatesGenerator = propsIncludingDefaults.horizontalCoordinatesGenerator || defaultHorizontalCoordinatesGenerator;
      var {
        horizontalPoints,
        verticalPoints
      } = propsIncludingDefaults;
      if ((!horizontalPoints || !horizontalPoints.length) && typeof horizontalCoordinatesGenerator === "function") {
        var isHorizontalValues = horizontalValues && horizontalValues.length;
        var generatorResult = horizontalCoordinatesGenerator({
          yAxis: yAxis ? _objectSpread$4(_objectSpread$4({}, yAxis), {}, {
            ticks: isHorizontalValues ? horizontalValues : yAxis.ticks
          }) : void 0,
          width: chartWidth !== null && chartWidth !== void 0 ? chartWidth : width,
          height: chartHeight !== null && chartHeight !== void 0 ? chartHeight : height,
          offset
        }, isHorizontalValues ? true : syncWithTicks);
        warn(Array.isArray(generatorResult), "horizontalCoordinatesGenerator should return Array but instead it returned [".concat(typeof generatorResult, "]"));
        if (Array.isArray(generatorResult)) {
          horizontalPoints = generatorResult;
        }
      }
      if ((!verticalPoints || !verticalPoints.length) && typeof verticalCoordinatesGenerator === "function") {
        var isVerticalValues = verticalValues && verticalValues.length;
        var _generatorResult = verticalCoordinatesGenerator({
          xAxis: xAxis ? _objectSpread$4(_objectSpread$4({}, xAxis), {}, {
            ticks: isVerticalValues ? verticalValues : xAxis.ticks
          }) : void 0,
          width: chartWidth !== null && chartWidth !== void 0 ? chartWidth : width,
          height: chartHeight !== null && chartHeight !== void 0 ? chartHeight : height,
          offset
        }, isVerticalValues ? true : syncWithTicks);
        warn(Array.isArray(_generatorResult), "verticalCoordinatesGenerator should return Array but instead it returned [".concat(typeof _generatorResult, "]"));
        if (Array.isArray(_generatorResult)) {
          verticalPoints = _generatorResult;
        }
      }
      return /* @__PURE__ */ reactExports.createElement(ZIndexLayer, {
        zIndex: propsIncludingDefaults.zIndex
      }, /* @__PURE__ */ reactExports.createElement("g", {
        className: "recharts-cartesian-grid"
      }, /* @__PURE__ */ reactExports.createElement(Background, {
        fill: propsIncludingDefaults.fill,
        fillOpacity: propsIncludingDefaults.fillOpacity,
        x: propsIncludingDefaults.x,
        y: propsIncludingDefaults.y,
        width: propsIncludingDefaults.width,
        height: propsIncludingDefaults.height,
        ry: propsIncludingDefaults.ry
      }), /* @__PURE__ */ reactExports.createElement(HorizontalStripes, _extends$8({}, propsIncludingDefaults, {
        horizontalPoints
      })), /* @__PURE__ */ reactExports.createElement(VerticalStripes, _extends$8({}, propsIncludingDefaults, {
        verticalPoints
      })), /* @__PURE__ */ reactExports.createElement(HorizontalGridLines, _extends$8({}, propsIncludingDefaults, {
        offset,
        horizontalPoints,
        xAxis,
        yAxis
      })), /* @__PURE__ */ reactExports.createElement(VerticalGridLines, _extends$8({}, propsIncludingDefaults, {
        offset,
        verticalPoints,
        xAxis,
        yAxis
      }))));
    }
    CartesianGrid.displayName = "CartesianGrid";
    var selectXAxisWithScale$1 = (state, xAxisId, _yAxisId, isPanorama) => selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
    var selectXAxisTicks$1 = (state, xAxisId, _yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
    var selectYAxisWithScale$1 = (state, _xAxisId, yAxisId, isPanorama) => selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
    var selectYAxisTicks$1 = (state, _xAxisId, yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
    var selectBandSize$1 = createSelector([selectChartLayout, selectXAxisWithScale$1, selectYAxisWithScale$1, selectXAxisTicks$1, selectYAxisTicks$1], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks) => {
      if (isCategoricalAxis(layout, "xAxis")) {
        return getBandSizeOfAxis(xAxis, xAxisTicks, false);
      }
      return getBandSizeOfAxis(yAxis, yAxisTicks, false);
    });
    var pickLineId = (_state, _xAxisId, _yAxisId, _isPanorama, id2) => id2;
    function isLineSettings(item) {
      return item.type === "line";
    }
    var selectSynchronisedLineSettings = createSelector([selectUnfilteredCartesianItems, pickLineId], (graphicalItems, id2) => graphicalItems.filter(isLineSettings).find((x2) => x2.id === id2));
    var selectLinePoints = createSelector([selectChartLayout, selectXAxisWithScale$1, selectYAxisWithScale$1, selectXAxisTicks$1, selectYAxisTicks$1, selectSynchronisedLineSettings, selectBandSize$1, selectChartDataWithIndexesIfNotInPanorama], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks, lineSettings, bandSize, _ref2) => {
      var {
        chartData,
        dataStartIndex,
        dataEndIndex
      } = _ref2;
      if (lineSettings == null || xAxis == null || yAxis == null || xAxisTicks == null || yAxisTicks == null || xAxisTicks.length === 0 || yAxisTicks.length === 0 || bandSize == null || layout !== "horizontal" && layout !== "vertical") {
        return void 0;
      }
      var {
        dataKey,
        data
      } = lineSettings;
      var displayedData;
      if (data != null && data.length > 0) {
        displayedData = data;
      } else {
        displayedData = chartData === null || chartData === void 0 ? void 0 : chartData.slice(dataStartIndex, dataEndIndex + 1);
      }
      if (displayedData == null) {
        return void 0;
      }
      return computeLinePoints({
        layout,
        xAxis,
        yAxis,
        xAxisTicks,
        yAxisTicks,
        dataKey,
        bandSize,
        displayedData
      });
    });
    function getRadiusAndStrokeWidthFromDot(dot) {
      var props = svgPropertiesNoEventsFromUnknown(dot);
      var defaultR = 3;
      var defaultStrokeWidth = 2;
      if (props != null) {
        var {
          r: r2,
          strokeWidth
        } = props;
        var realR = Number(r2);
        var realStrokeWidth = Number(strokeWidth);
        if (Number.isNaN(realR) || realR < 0) {
          realR = defaultR;
        }
        if (Number.isNaN(realStrokeWidth) || realStrokeWidth < 0) {
          realStrokeWidth = defaultStrokeWidth;
        }
        return {
          r: realR,
          strokeWidth: realStrokeWidth
        };
      }
      return {
        r: defaultR,
        strokeWidth: defaultStrokeWidth
      };
    }
    var _excluded$7 = ["id"], _excluded2$4 = ["type", "layout", "connectNulls", "needClip", "shape"], _excluded3 = ["activeDot", "animateNewValues", "animationBegin", "animationDuration", "animationEasing", "connectNulls", "dot", "hide", "isAnimationActive", "label", "legendType", "xAxisId", "yAxisId", "id"];
    function _extends$7() {
      return _extends$7 = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$7.apply(null, arguments);
    }
    function ownKeys$3(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$3(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$3(Object(t2), true).forEach(function(r3) {
          _defineProperty$3(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$3(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$3(e, r2, t2) {
      return (r2 = _toPropertyKey$3(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$3(t2) {
      var i = _toPrimitive$3(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$3(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function _objectWithoutProperties$7(e, t2) {
      if (null == e) return {};
      var o, r2, i = _objectWithoutPropertiesLoose$7(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e);
        for (r2 = 0; r2 < n2.length; r2++) o = n2[r2], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose$7(r2, e) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    var computeLegendPayloadFromAreaData$1 = (props) => {
      var {
        dataKey,
        name,
        stroke,
        legendType,
        hide
      } = props;
      return [{
        inactive: hide,
        dataKey,
        type: legendType,
        color: stroke,
        value: getTooltipNameProp(name, dataKey),
        payload: props
      }];
    };
    var SetLineTooltipEntrySettings = /* @__PURE__ */ reactExports.memo((_ref2) => {
      var {
        dataKey,
        data,
        stroke,
        strokeWidth,
        fill,
        name,
        hide,
        unit: unit2,
        tooltipType
      } = _ref2;
      var tooltipEntrySettings = {
        dataDefinedOnItem: data,
        positions: void 0,
        settings: {
          stroke,
          strokeWidth,
          fill,
          dataKey,
          nameKey: void 0,
          name: getTooltipNameProp(name, dataKey),
          hide,
          type: tooltipType,
          color: stroke,
          unit: unit2
        }
      };
      return /* @__PURE__ */ reactExports.createElement(SetTooltipEntrySettings, {
        tooltipEntrySettings
      });
    });
    var generateSimpleStrokeDasharray = (totalLength, length) => {
      return "".concat(length, "px ").concat(totalLength - length, "px");
    };
    function repeat(lines, count) {
      var linesUnit = lines.length % 2 !== 0 ? [...lines, 0] : lines;
      var result = [];
      for (var i = 0; i < count; ++i) {
        result = [...result, ...linesUnit];
      }
      return result;
    }
    var getStrokeDasharray = (length, totalLength, lines) => {
      var lineLength = lines.reduce((pre, next) => pre + next);
      if (!lineLength) {
        return generateSimpleStrokeDasharray(totalLength, length);
      }
      var count = Math.floor(length / lineLength);
      var remainLength = length % lineLength;
      var restLength = totalLength - length;
      var remainLines = [];
      for (var i = 0, sum = 0; i < lines.length; sum += lines[i], ++i) {
        if (sum + lines[i] > remainLength) {
          remainLines = [...lines.slice(0, i), remainLength - sum];
          break;
        }
      }
      var emptyLines = remainLines.length % 2 === 0 ? [0, restLength] : [restLength];
      return [...repeat(lines, count), ...remainLines, ...emptyLines].map((line) => "".concat(line, "px")).join(", ");
    };
    function LineDotsWrapper(_ref2) {
      var {
        clipPathId,
        points,
        props
      } = _ref2;
      var {
        dot,
        dataKey,
        needClip
      } = props;
      var {
        id: id2
      } = props, propsWithoutId = _objectWithoutProperties$7(props, _excluded$7);
      var lineProps = svgPropertiesNoEvents(propsWithoutId);
      return /* @__PURE__ */ reactExports.createElement(Dots, {
        points,
        dot,
        className: "recharts-line-dots",
        dotClassName: "recharts-line-dot",
        dataKey,
        baseProps: lineProps,
        needClip,
        clipPathId
      });
    }
    function LineLabelListProvider(_ref3) {
      var {
        showLabels,
        children,
        points
      } = _ref3;
      var labelListEntries = reactExports.useMemo(() => {
        return points === null || points === void 0 ? void 0 : points.map((point2) => {
          var _point$x, _point$y;
          var viewBox = {
            x: (_point$x = point2.x) !== null && _point$x !== void 0 ? _point$x : 0,
            y: (_point$y = point2.y) !== null && _point$y !== void 0 ? _point$y : 0,
            width: 0,
            lowerWidth: 0,
            upperWidth: 0,
            height: 0
          };
          return _objectSpread$3(_objectSpread$3({}, viewBox), {}, {
            value: point2.value,
            payload: point2.payload,
            viewBox,
            /*
             * Line is not passing parentViewBox to the LabelList so the labels can escape - looks like a bug, should we pass parentViewBox?
             * Or should this just be the root chart viewBox?
             */
            parentViewBox: void 0,
            fill: void 0
          });
        });
      }, [points]);
      return /* @__PURE__ */ reactExports.createElement(CartesianLabelListContextProvider, {
        value: showLabels ? labelListEntries : void 0
      }, children);
    }
    function StaticCurve(_ref4) {
      var {
        clipPathId,
        pathRef,
        points,
        strokeDasharray,
        props
      } = _ref4;
      var {
        type,
        layout,
        connectNulls,
        needClip,
        shape
      } = props, others = _objectWithoutProperties$7(props, _excluded2$4);
      var curveProps = _objectSpread$3(_objectSpread$3({}, svgPropertiesAndEvents(others)), {}, {
        fill: "none",
        className: "recharts-line-curve",
        clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : void 0,
        points,
        type,
        layout,
        connectNulls,
        strokeDasharray: strokeDasharray !== null && strokeDasharray !== void 0 ? strokeDasharray : props.strokeDasharray
      });
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, (points === null || points === void 0 ? void 0 : points.length) > 1 && /* @__PURE__ */ reactExports.createElement(Shape, _extends$7({
        shapeType: "curve",
        option: shape
      }, curveProps, {
        pathRef
      })), /* @__PURE__ */ reactExports.createElement(LineDotsWrapper, {
        points,
        clipPathId,
        props
      }));
    }
    function getTotalLength(mainCurve) {
      try {
        return mainCurve && mainCurve.getTotalLength && mainCurve.getTotalLength() || 0;
      } catch (_unused) {
        return 0;
      }
    }
    function CurveWithAnimation(_ref5) {
      var {
        clipPathId,
        props,
        pathRef,
        previousPointsRef,
        longestAnimatedLengthRef
      } = _ref5;
      var {
        points,
        strokeDasharray,
        isAnimationActive,
        animationBegin,
        animationDuration,
        animationEasing,
        animateNewValues,
        width,
        height,
        onAnimationEnd,
        onAnimationStart
      } = props;
      var prevPoints = previousPointsRef.current;
      var animationId = useAnimationId(points, "recharts-line-");
      var animationIdRef = reactExports.useRef(animationId);
      var [isAnimating, setIsAnimating] = reactExports.useState(false);
      var showLabels = !isAnimating;
      var handleAnimationEnd = reactExports.useCallback(() => {
        if (typeof onAnimationEnd === "function") {
          onAnimationEnd();
        }
        setIsAnimating(false);
      }, [onAnimationEnd]);
      var handleAnimationStart = reactExports.useCallback(() => {
        if (typeof onAnimationStart === "function") {
          onAnimationStart();
        }
        setIsAnimating(true);
      }, [onAnimationStart]);
      var totalLength = getTotalLength(pathRef.current);
      var startingPointRef = reactExports.useRef(0);
      if (animationIdRef.current !== animationId) {
        startingPointRef.current = longestAnimatedLengthRef.current;
        animationIdRef.current = animationId;
      }
      var startingPoint = startingPointRef.current;
      return /* @__PURE__ */ reactExports.createElement(LineLabelListProvider, {
        points,
        showLabels
      }, props.children, /* @__PURE__ */ reactExports.createElement(JavascriptAnimate, {
        animationId,
        begin: animationBegin,
        duration: animationDuration,
        isActive: isAnimationActive,
        easing: animationEasing,
        onAnimationEnd: handleAnimationEnd,
        onAnimationStart: handleAnimationStart,
        key: animationId
      }, (t2) => {
        var lengthInterpolated = interpolate$1(startingPoint, totalLength + startingPoint, t2);
        var curLength = Math.min(lengthInterpolated, totalLength);
        var currentStrokeDasharray;
        if (isAnimationActive) {
          if (strokeDasharray) {
            var lines = "".concat(strokeDasharray).split(/[,\s]+/gim).map((num) => parseFloat(num));
            currentStrokeDasharray = getStrokeDasharray(curLength, totalLength, lines);
          } else {
            currentStrokeDasharray = generateSimpleStrokeDasharray(totalLength, curLength);
          }
        } else {
          currentStrokeDasharray = strokeDasharray == null ? void 0 : String(strokeDasharray);
        }
        if (t2 > 0 && totalLength > 0) {
          previousPointsRef.current = points;
          longestAnimatedLengthRef.current = Math.max(longestAnimatedLengthRef.current, curLength);
        }
        if (prevPoints) {
          var prevPointsDiffFactor = prevPoints.length / points.length;
          var stepData = t2 === 1 ? points : points.map((entry, index) => {
            var prevPointIndex = Math.floor(index * prevPointsDiffFactor);
            if (prevPoints[prevPointIndex]) {
              var prev = prevPoints[prevPointIndex];
              return _objectSpread$3(_objectSpread$3({}, entry), {}, {
                x: interpolate$1(prev.x, entry.x, t2),
                y: interpolate$1(prev.y, entry.y, t2)
              });
            }
            if (animateNewValues) {
              return _objectSpread$3(_objectSpread$3({}, entry), {}, {
                x: interpolate$1(width * 2, entry.x, t2),
                y: interpolate$1(height / 2, entry.y, t2)
              });
            }
            return _objectSpread$3(_objectSpread$3({}, entry), {}, {
              x: entry.x,
              y: entry.y
            });
          });
          previousPointsRef.current = stepData;
          return /* @__PURE__ */ reactExports.createElement(StaticCurve, {
            props,
            points: stepData,
            clipPathId,
            pathRef,
            strokeDasharray: currentStrokeDasharray
          });
        }
        return /* @__PURE__ */ reactExports.createElement(StaticCurve, {
          props,
          points,
          clipPathId,
          pathRef,
          strokeDasharray: currentStrokeDasharray
        });
      }), /* @__PURE__ */ reactExports.createElement(LabelListFromLabelProp, {
        label: props.label
      }));
    }
    function RenderCurve(_ref6) {
      var {
        clipPathId,
        props
      } = _ref6;
      var previousPointsRef = reactExports.useRef(null);
      var longestAnimatedLengthRef = reactExports.useRef(0);
      var pathRef = reactExports.useRef(null);
      return /* @__PURE__ */ reactExports.createElement(CurveWithAnimation, {
        props,
        clipPathId,
        previousPointsRef,
        longestAnimatedLengthRef,
        pathRef
      });
    }
    var errorBarDataPointFormatter = (dataPoint, dataKey) => {
      var _dataPoint$x, _dataPoint$y;
      return {
        x: (_dataPoint$x = dataPoint.x) !== null && _dataPoint$x !== void 0 ? _dataPoint$x : void 0,
        y: (_dataPoint$y = dataPoint.y) !== null && _dataPoint$y !== void 0 ? _dataPoint$y : void 0,
        value: dataPoint.value,
        // @ts-expect-error getValueByDataKey does not validate the output type
        errorVal: getValueByDataKey(dataPoint.payload, dataKey)
      };
    };
    class LineWithState extends reactExports.Component {
      render() {
        var {
          hide,
          dot,
          points,
          className,
          xAxisId,
          yAxisId,
          top,
          left,
          width,
          height,
          id: id2,
          needClip,
          zIndex
        } = this.props;
        if (hide) {
          return null;
        }
        var layerClass = clsx("recharts-line", className);
        var clipPathId = id2;
        var {
          r: r2,
          strokeWidth
        } = getRadiusAndStrokeWidthFromDot(dot);
        var clipDot = isClipDot(dot);
        var dotSize = r2 * 2 + strokeWidth;
        var activePointsClipPath = needClip ? "url(#clipPath-".concat(clipDot ? "" : "dots-").concat(clipPathId, ")") : void 0;
        return /* @__PURE__ */ reactExports.createElement(ZIndexLayer, {
          zIndex
        }, /* @__PURE__ */ reactExports.createElement(Layer, {
          className: layerClass
        }, needClip && /* @__PURE__ */ reactExports.createElement("defs", null, /* @__PURE__ */ reactExports.createElement(GraphicalItemClipPath, {
          clipPathId,
          xAxisId,
          yAxisId
        }), !clipDot && /* @__PURE__ */ reactExports.createElement("clipPath", {
          id: "clipPath-dots-".concat(clipPathId)
        }, /* @__PURE__ */ reactExports.createElement("rect", {
          x: left - dotSize / 2,
          y: top - dotSize / 2,
          width: width + dotSize,
          height: height + dotSize
        }))), /* @__PURE__ */ reactExports.createElement(SetErrorBarContext, {
          xAxisId,
          yAxisId,
          data: points,
          dataPointFormatter: errorBarDataPointFormatter,
          errorBarOffset: 0
        }, /* @__PURE__ */ reactExports.createElement(RenderCurve, {
          props: this.props,
          clipPathId
        }))), /* @__PURE__ */ reactExports.createElement(ActivePoints, {
          activeDot: this.props.activeDot,
          points,
          mainColor: this.props.stroke,
          itemDataKey: this.props.dataKey,
          clipPath: activePointsClipPath
        }));
      }
    }
    var defaultLineProps = {
      activeDot: true,
      animateNewValues: true,
      animationBegin: 0,
      animationDuration: 1500,
      animationEasing: "ease",
      connectNulls: false,
      dot: true,
      fill: "#fff",
      hide: false,
      isAnimationActive: "auto",
      label: false,
      legendType: "line",
      stroke: "#3182bd",
      strokeWidth: 1,
      xAxisId: 0,
      yAxisId: 0,
      zIndex: DefaultZIndexes.line,
      type: "linear"
    };
    function LineImpl(props) {
      var _resolveDefaultProps = resolveDefaultProps(props, defaultLineProps), {
        activeDot,
        animateNewValues,
        animationBegin,
        animationDuration,
        animationEasing,
        connectNulls,
        dot,
        hide,
        isAnimationActive,
        label,
        legendType,
        xAxisId,
        yAxisId,
        id: id2
      } = _resolveDefaultProps, everythingElse = _objectWithoutProperties$7(_resolveDefaultProps, _excluded3);
      var {
        needClip
      } = useNeedsClip(xAxisId, yAxisId);
      var plotArea = usePlotArea();
      var layout = useChartLayout();
      var isPanorama = useIsPanorama();
      var points = useAppSelector((state) => selectLinePoints(state, xAxisId, yAxisId, isPanorama, id2));
      if (layout !== "horizontal" && layout !== "vertical" || points == null || plotArea == null) {
        return null;
      }
      var {
        height,
        width,
        x: left,
        y: top
      } = plotArea;
      return /* @__PURE__ */ reactExports.createElement(LineWithState, _extends$7({}, everythingElse, {
        id: id2,
        connectNulls,
        dot,
        activeDot,
        animateNewValues,
        animationBegin,
        animationDuration,
        animationEasing,
        isAnimationActive,
        hide,
        label,
        legendType,
        xAxisId,
        yAxisId,
        points,
        layout,
        height,
        width,
        left,
        top,
        needClip
      }));
    }
    function computeLinePoints(_ref7) {
      var {
        layout,
        xAxis,
        yAxis,
        xAxisTicks,
        yAxisTicks,
        dataKey,
        bandSize,
        displayedData
      } = _ref7;
      return displayedData.map((entry, index) => {
        var value = getValueByDataKey(entry, dataKey);
        if (layout === "horizontal") {
          var _x = getCateCoordinateOfLine({
            axis: xAxis,
            ticks: xAxisTicks,
            bandSize,
            entry,
            index
          });
          var _y = isNullish(value) ? null : yAxis.scale(value);
          return {
            x: _x,
            y: _y,
            value,
            payload: entry
          };
        }
        var x2 = isNullish(value) ? null : xAxis.scale(value);
        var y2 = getCateCoordinateOfLine({
          axis: yAxis,
          ticks: yAxisTicks,
          bandSize,
          entry,
          index
        });
        if (x2 == null || y2 == null) {
          return null;
        }
        return {
          x: x2,
          y: y2,
          value,
          payload: entry
        };
      }).filter(Boolean);
    }
    function LineFn(outsideProps) {
      var props = resolveDefaultProps(outsideProps, defaultLineProps);
      var isPanorama = useIsPanorama();
      return /* @__PURE__ */ reactExports.createElement(RegisterGraphicalItemId, {
        id: props.id,
        type: "line"
      }, (id2) => /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(SetLegendPayload, {
        legendPayload: computeLegendPayloadFromAreaData$1(props)
      }), /* @__PURE__ */ reactExports.createElement(SetLineTooltipEntrySettings, {
        dataKey: props.dataKey,
        data: props.data,
        stroke: props.stroke,
        strokeWidth: props.strokeWidth,
        fill: props.fill,
        name: props.name,
        hide: props.hide,
        unit: props.unit,
        tooltipType: props.tooltipType
      }), /* @__PURE__ */ reactExports.createElement(SetCartesianGraphicalItem, {
        type: "line",
        id: id2,
        data: props.data,
        xAxisId: props.xAxisId,
        yAxisId: props.yAxisId,
        zAxisId: 0,
        dataKey: props.dataKey,
        hide: props.hide,
        isPanorama
      }), /* @__PURE__ */ reactExports.createElement(LineImpl, _extends$7({}, props, {
        id: id2
      }))));
    }
    var Line = /* @__PURE__ */ reactExports.memo(LineFn, propsAreEqual);
    Line.displayName = "Line";
    var selectXAxisWithScale = (state, xAxisId, _yAxisId, isPanorama) => selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
    var selectXAxisTicks = (state, xAxisId, _yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
    var selectYAxisWithScale = (state, _xAxisId, yAxisId, isPanorama) => selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
    var selectYAxisTicks = (state, _xAxisId, yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
    var selectBandSize = createSelector([selectChartLayout, selectXAxisWithScale, selectYAxisWithScale, selectXAxisTicks, selectYAxisTicks], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks) => {
      if (isCategoricalAxis(layout, "xAxis")) {
        return getBandSizeOfAxis(xAxis, xAxisTicks, false);
      }
      return getBandSizeOfAxis(yAxis, yAxisTicks, false);
    });
    var pickAreaId = (_state, _xAxisId, _yAxisId, _isPanorama, id2) => id2;
    var selectSynchronisedAreaSettings = createSelector([selectUnfilteredCartesianItems, pickAreaId], (graphicalItems, id2) => graphicalItems.filter((item) => item.type === "area").find((item) => item.id === id2));
    var selectGraphicalItemStackedData = (state, xAxisId, yAxisId, isPanorama, id2) => {
      var _stackGroups$stackId;
      var areaSettings = selectSynchronisedAreaSettings(state, xAxisId, yAxisId, isPanorama, id2);
      if (areaSettings == null) {
        return void 0;
      }
      var layout = selectChartLayout(state);
      var isXAxisCategorical = isCategoricalAxis(layout, "xAxis");
      var stackGroups;
      if (isXAxisCategorical) {
        stackGroups = selectStackGroups(state, "yAxis", yAxisId, isPanorama);
      } else {
        stackGroups = selectStackGroups(state, "xAxis", xAxisId, isPanorama);
      }
      if (stackGroups == null) {
        return void 0;
      }
      var {
        stackId
      } = areaSettings;
      var stackSeriesIdentifier = getStackSeriesIdentifier(areaSettings);
      if (stackId == null || stackSeriesIdentifier == null) {
        return void 0;
      }
      var groups = (_stackGroups$stackId = stackGroups[stackId]) === null || _stackGroups$stackId === void 0 ? void 0 : _stackGroups$stackId.stackedData;
      return groups === null || groups === void 0 ? void 0 : groups.find((v2) => v2.key === stackSeriesIdentifier);
    };
    var selectArea = createSelector([selectChartLayout, selectXAxisWithScale, selectYAxisWithScale, selectXAxisTicks, selectYAxisTicks, selectGraphicalItemStackedData, selectChartDataWithIndexesIfNotInPanorama, selectBandSize, selectSynchronisedAreaSettings, selectChartBaseValue], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks, stackedData, _ref2, bandSize, areaSettings, chartBaseValue) => {
      var {
        chartData,
        dataStartIndex,
        dataEndIndex
      } = _ref2;
      if (areaSettings == null || layout !== "horizontal" && layout !== "vertical" || xAxis == null || yAxis == null || xAxisTicks == null || yAxisTicks == null || xAxisTicks.length === 0 || yAxisTicks.length === 0 || bandSize == null) {
        return void 0;
      }
      var {
        data
      } = areaSettings;
      var displayedData;
      if (data && data.length > 0) {
        displayedData = data;
      } else {
        displayedData = chartData === null || chartData === void 0 ? void 0 : chartData.slice(dataStartIndex, dataEndIndex + 1);
      }
      if (displayedData == null) {
        return void 0;
      }
      return computeArea({
        layout,
        xAxis,
        yAxis,
        xAxisTicks,
        yAxisTicks,
        dataStartIndex,
        areaSettings,
        stackedData,
        displayedData,
        chartBaseValue,
        bandSize
      });
    });
    var _excluded$6 = ["id"], _excluded2$3 = ["activeDot", "animationBegin", "animationDuration", "animationEasing", "connectNulls", "dot", "fill", "fillOpacity", "hide", "isAnimationActive", "legendType", "stroke", "xAxisId", "yAxisId"];
    function _extends$6() {
      return _extends$6 = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$6.apply(null, arguments);
    }
    function _objectWithoutProperties$6(e, t2) {
      if (null == e) return {};
      var o, r2, i = _objectWithoutPropertiesLoose$6(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e);
        for (r2 = 0; r2 < n2.length; r2++) o = n2[r2], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose$6(r2, e) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    function ownKeys$2(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$2(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$2(Object(t2), true).forEach(function(r3) {
          _defineProperty$2(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$2(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$2(e, r2, t2) {
      return (r2 = _toPropertyKey$2(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$2(t2) {
      var i = _toPrimitive$2(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$2(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function getLegendItemColor(stroke, fill) {
      return stroke && stroke !== "none" ? stroke : fill;
    }
    var computeLegendPayloadFromAreaData = (props) => {
      var {
        dataKey,
        name,
        stroke,
        fill,
        legendType,
        hide
      } = props;
      return [{
        inactive: hide,
        dataKey,
        type: legendType,
        color: getLegendItemColor(stroke, fill),
        value: getTooltipNameProp(name, dataKey),
        payload: props
      }];
    };
    var SetAreaTooltipEntrySettings = /* @__PURE__ */ reactExports.memo((_ref2) => {
      var {
        dataKey,
        data,
        stroke,
        strokeWidth,
        fill,
        name,
        hide,
        unit: unit2,
        tooltipType
      } = _ref2;
      var tooltipEntrySettings = {
        dataDefinedOnItem: data,
        positions: void 0,
        settings: {
          stroke,
          strokeWidth,
          fill,
          dataKey,
          nameKey: void 0,
          name: getTooltipNameProp(name, dataKey),
          hide,
          type: tooltipType,
          color: getLegendItemColor(stroke, fill),
          unit: unit2
        }
      };
      return /* @__PURE__ */ reactExports.createElement(SetTooltipEntrySettings, {
        tooltipEntrySettings
      });
    });
    function AreaDotsWrapper(_ref2) {
      var {
        clipPathId,
        points,
        props
      } = _ref2;
      var {
        needClip,
        dot,
        dataKey
      } = props;
      var areaProps = svgPropertiesNoEvents(props);
      return /* @__PURE__ */ reactExports.createElement(Dots, {
        points,
        dot,
        className: "recharts-area-dots",
        dotClassName: "recharts-area-dot",
        dataKey,
        baseProps: areaProps,
        needClip,
        clipPathId
      });
    }
    function AreaLabelListProvider(_ref3) {
      var {
        showLabels,
        children,
        points
      } = _ref3;
      var labelListEntries = points.map((point2) => {
        var _point$x, _point$y;
        var viewBox = {
          x: (_point$x = point2.x) !== null && _point$x !== void 0 ? _point$x : 0,
          y: (_point$y = point2.y) !== null && _point$y !== void 0 ? _point$y : 0,
          width: 0,
          lowerWidth: 0,
          upperWidth: 0,
          height: 0
        };
        return _objectSpread$2(_objectSpread$2({}, viewBox), {}, {
          value: point2.value,
          payload: point2.payload,
          parentViewBox: void 0,
          viewBox,
          fill: void 0
        });
      });
      return /* @__PURE__ */ reactExports.createElement(CartesianLabelListContextProvider, {
        value: showLabels ? labelListEntries : void 0
      }, children);
    }
    function StaticArea(_ref4) {
      var {
        points,
        baseLine,
        needClip,
        clipPathId,
        props
      } = _ref4;
      var {
        layout,
        type,
        stroke,
        connectNulls,
        isRange
      } = props;
      var {
        id: id2
      } = props, propsWithoutId = _objectWithoutProperties$6(props, _excluded$6);
      var allOtherProps = svgPropertiesNoEvents(propsWithoutId);
      var propsWithEvents = svgPropertiesAndEvents(propsWithoutId);
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, (points === null || points === void 0 ? void 0 : points.length) > 1 && /* @__PURE__ */ reactExports.createElement(Layer, {
        clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : void 0
      }, /* @__PURE__ */ reactExports.createElement(Curve, _extends$6({}, propsWithEvents, {
        id: id2,
        points,
        connectNulls,
        type,
        baseLine,
        layout,
        stroke: "none",
        className: "recharts-area-area"
      })), stroke !== "none" && /* @__PURE__ */ reactExports.createElement(Curve, _extends$6({}, allOtherProps, {
        className: "recharts-area-curve",
        layout,
        type,
        connectNulls,
        fill: "none",
        points
      })), stroke !== "none" && isRange && /* @__PURE__ */ reactExports.createElement(Curve, _extends$6({}, allOtherProps, {
        className: "recharts-area-curve",
        layout,
        type,
        connectNulls,
        fill: "none",
        points: baseLine
      }))), /* @__PURE__ */ reactExports.createElement(AreaDotsWrapper, {
        points,
        props: propsWithoutId,
        clipPathId
      }));
    }
    function VerticalRect(_ref5) {
      var {
        alpha: alpha2,
        baseLine,
        points,
        strokeWidth
      } = _ref5;
      var startY = points[0].y;
      var endY = points[points.length - 1].y;
      if (!isWellBehavedNumber(startY) || !isWellBehavedNumber(endY)) {
        return null;
      }
      var height = alpha2 * Math.abs(startY - endY);
      var maxX = Math.max(...points.map((entry) => entry.x || 0));
      if (isNumber(baseLine)) {
        maxX = Math.max(baseLine, maxX);
      } else if (baseLine && Array.isArray(baseLine) && baseLine.length) {
        maxX = Math.max(...baseLine.map((entry) => entry.x || 0), maxX);
      }
      if (isNumber(maxX)) {
        return /* @__PURE__ */ reactExports.createElement("rect", {
          x: 0,
          y: startY < endY ? startY : startY - height,
          width: maxX + (strokeWidth ? parseInt("".concat(strokeWidth), 10) : 1),
          height: Math.floor(height)
        });
      }
      return null;
    }
    function HorizontalRect(_ref6) {
      var {
        alpha: alpha2,
        baseLine,
        points,
        strokeWidth
      } = _ref6;
      var startX = points[0].x;
      var endX = points[points.length - 1].x;
      if (!isWellBehavedNumber(startX) || !isWellBehavedNumber(endX)) {
        return null;
      }
      var width = alpha2 * Math.abs(startX - endX);
      var maxY = Math.max(...points.map((entry) => entry.y || 0));
      if (isNumber(baseLine)) {
        maxY = Math.max(baseLine, maxY);
      } else if (baseLine && Array.isArray(baseLine) && baseLine.length) {
        maxY = Math.max(...baseLine.map((entry) => entry.y || 0), maxY);
      }
      if (isNumber(maxY)) {
        return /* @__PURE__ */ reactExports.createElement("rect", {
          x: startX < endX ? startX : startX - width,
          y: 0,
          width,
          height: Math.floor(maxY + (strokeWidth ? parseInt("".concat(strokeWidth), 10) : 1))
        });
      }
      return null;
    }
    function ClipRect(_ref7) {
      var {
        alpha: alpha2,
        layout,
        points,
        baseLine,
        strokeWidth
      } = _ref7;
      if (layout === "vertical") {
        return /* @__PURE__ */ reactExports.createElement(VerticalRect, {
          alpha: alpha2,
          points,
          baseLine,
          strokeWidth
        });
      }
      return /* @__PURE__ */ reactExports.createElement(HorizontalRect, {
        alpha: alpha2,
        points,
        baseLine,
        strokeWidth
      });
    }
    function AreaWithAnimation(_ref8) {
      var {
        needClip,
        clipPathId,
        props,
        previousPointsRef,
        previousBaselineRef
      } = _ref8;
      var {
        points,
        baseLine,
        isAnimationActive,
        animationBegin,
        animationDuration,
        animationEasing,
        onAnimationStart,
        onAnimationEnd
      } = props;
      var animationInput = reactExports.useMemo(() => ({
        points,
        baseLine
      }), [points, baseLine]);
      var animationId = useAnimationId(animationInput, "recharts-area-");
      var layout = useCartesianChartLayout();
      var [isAnimating, setIsAnimating] = reactExports.useState(false);
      var showLabels = !isAnimating;
      var handleAnimationEnd = reactExports.useCallback(() => {
        if (typeof onAnimationEnd === "function") {
          onAnimationEnd();
        }
        setIsAnimating(false);
      }, [onAnimationEnd]);
      var handleAnimationStart = reactExports.useCallback(() => {
        if (typeof onAnimationStart === "function") {
          onAnimationStart();
        }
        setIsAnimating(true);
      }, [onAnimationStart]);
      if (layout == null) {
        return null;
      }
      var prevPoints = previousPointsRef.current;
      var prevBaseLine = previousBaselineRef.current;
      return /* @__PURE__ */ reactExports.createElement(AreaLabelListProvider, {
        showLabels,
        points
      }, props.children, /* @__PURE__ */ reactExports.createElement(JavascriptAnimate, {
        animationId,
        begin: animationBegin,
        duration: animationDuration,
        isActive: isAnimationActive,
        easing: animationEasing,
        onAnimationEnd: handleAnimationEnd,
        onAnimationStart: handleAnimationStart,
        key: animationId
      }, (t2) => {
        if (prevPoints) {
          var prevPointsDiffFactor = prevPoints.length / points.length;
          var stepPoints = (
            /*
             * Here it is important that at the very end of the animation, on the last frame,
             * we render the original points without any interpolation.
             * This is needed because the code above is checking for reference equality to decide if the animation should run
             * and if we create a new array instance (even if the numbers were the same)
             * then we would break animations.
             */
            t2 === 1 ? points : points.map((entry, index) => {
              var prevPointIndex = Math.floor(index * prevPointsDiffFactor);
              if (prevPoints[prevPointIndex]) {
                var prev = prevPoints[prevPointIndex];
                return _objectSpread$2(_objectSpread$2({}, entry), {}, {
                  x: interpolate$1(prev.x, entry.x, t2),
                  y: interpolate$1(prev.y, entry.y, t2)
                });
              }
              return entry;
            })
          );
          var stepBaseLine;
          if (isNumber(baseLine)) {
            stepBaseLine = interpolate$1(prevBaseLine, baseLine, t2);
          } else if (isNullish(baseLine) || isNan(baseLine)) {
            stepBaseLine = interpolate$1(prevBaseLine, 0, t2);
          } else {
            stepBaseLine = baseLine.map((entry, index) => {
              var prevPointIndex = Math.floor(index * prevPointsDiffFactor);
              if (Array.isArray(prevBaseLine) && prevBaseLine[prevPointIndex]) {
                var prev = prevBaseLine[prevPointIndex];
                return _objectSpread$2(_objectSpread$2({}, entry), {}, {
                  x: interpolate$1(prev.x, entry.x, t2),
                  y: interpolate$1(prev.y, entry.y, t2)
                });
              }
              return entry;
            });
          }
          if (t2 > 0) {
            previousPointsRef.current = stepPoints;
            previousBaselineRef.current = stepBaseLine;
          }
          return /* @__PURE__ */ reactExports.createElement(StaticArea, {
            points: stepPoints,
            baseLine: stepBaseLine,
            needClip,
            clipPathId,
            props
          });
        }
        if (t2 > 0) {
          previousPointsRef.current = points;
          previousBaselineRef.current = baseLine;
        }
        return /* @__PURE__ */ reactExports.createElement(Layer, null, isAnimationActive && /* @__PURE__ */ reactExports.createElement("defs", null, /* @__PURE__ */ reactExports.createElement("clipPath", {
          id: "animationClipPath-".concat(clipPathId)
        }, /* @__PURE__ */ reactExports.createElement(ClipRect, {
          alpha: t2,
          points,
          baseLine,
          layout,
          strokeWidth: props.strokeWidth
        }))), /* @__PURE__ */ reactExports.createElement(Layer, {
          clipPath: "url(#animationClipPath-".concat(clipPathId, ")")
        }, /* @__PURE__ */ reactExports.createElement(StaticArea, {
          points,
          baseLine,
          needClip,
          clipPathId,
          props
        })));
      }), /* @__PURE__ */ reactExports.createElement(LabelListFromLabelProp, {
        label: props.label
      }));
    }
    function RenderArea(_ref9) {
      var {
        needClip,
        clipPathId,
        props
      } = _ref9;
      var previousPointsRef = reactExports.useRef(null);
      var previousBaselineRef = reactExports.useRef();
      return /* @__PURE__ */ reactExports.createElement(AreaWithAnimation, {
        needClip,
        clipPathId,
        props,
        previousPointsRef,
        previousBaselineRef
      });
    }
    class AreaWithState extends reactExports.PureComponent {
      render() {
        var {
          hide,
          dot,
          points,
          className,
          top,
          left,
          needClip,
          xAxisId,
          yAxisId,
          width,
          height,
          id: id2,
          baseLine,
          zIndex
        } = this.props;
        if (hide) {
          return null;
        }
        var layerClass = clsx("recharts-area", className);
        var clipPathId = id2;
        var {
          r: r2,
          strokeWidth
        } = getRadiusAndStrokeWidthFromDot(dot);
        var clipDot = isClipDot(dot);
        var dotSize = r2 * 2 + strokeWidth;
        var activePointsClipPath = needClip ? "url(#clipPath-".concat(clipDot ? "" : "dots-").concat(clipPathId, ")") : void 0;
        return /* @__PURE__ */ reactExports.createElement(ZIndexLayer, {
          zIndex
        }, /* @__PURE__ */ reactExports.createElement(Layer, {
          className: layerClass
        }, needClip && /* @__PURE__ */ reactExports.createElement("defs", null, /* @__PURE__ */ reactExports.createElement(GraphicalItemClipPath, {
          clipPathId,
          xAxisId,
          yAxisId
        }), !clipDot && /* @__PURE__ */ reactExports.createElement("clipPath", {
          id: "clipPath-dots-".concat(clipPathId)
        }, /* @__PURE__ */ reactExports.createElement("rect", {
          x: left - dotSize / 2,
          y: top - dotSize / 2,
          width: width + dotSize,
          height: height + dotSize
        }))), /* @__PURE__ */ reactExports.createElement(RenderArea, {
          needClip,
          clipPathId,
          props: this.props
        })), /* @__PURE__ */ reactExports.createElement(ActivePoints, {
          points,
          mainColor: getLegendItemColor(this.props.stroke, this.props.fill),
          itemDataKey: this.props.dataKey,
          activeDot: this.props.activeDot,
          clipPath: activePointsClipPath
        }), this.props.isRange && Array.isArray(baseLine) && /* @__PURE__ */ reactExports.createElement(ActivePoints, {
          points: baseLine,
          mainColor: getLegendItemColor(this.props.stroke, this.props.fill),
          itemDataKey: this.props.dataKey,
          activeDot: this.props.activeDot,
          clipPath: activePointsClipPath
        }));
      }
    }
    var defaultAreaProps = {
      activeDot: true,
      animationBegin: 0,
      animationDuration: 1500,
      animationEasing: "ease",
      connectNulls: false,
      dot: false,
      fill: "#3182bd",
      fillOpacity: 0.6,
      hide: false,
      isAnimationActive: "auto",
      legendType: "line",
      stroke: "#3182bd",
      strokeWidth: 1,
      type: "linear",
      label: false,
      xAxisId: 0,
      yAxisId: 0,
      zIndex: DefaultZIndexes.area
    };
    function AreaImpl(props) {
      var _useAppSelector;
      var _resolveDefaultProps = resolveDefaultProps(props, defaultAreaProps), {
        activeDot,
        animationBegin,
        animationDuration,
        animationEasing,
        connectNulls,
        dot,
        fill,
        fillOpacity,
        hide,
        isAnimationActive,
        legendType,
        stroke,
        xAxisId,
        yAxisId
      } = _resolveDefaultProps, everythingElse = _objectWithoutProperties$6(_resolveDefaultProps, _excluded2$3);
      var layout = useChartLayout();
      var chartName = useChartName();
      var {
        needClip
      } = useNeedsClip(xAxisId, yAxisId);
      var isPanorama = useIsPanorama();
      var {
        points,
        isRange,
        baseLine
      } = (_useAppSelector = useAppSelector((state) => selectArea(state, xAxisId, yAxisId, isPanorama, props.id))) !== null && _useAppSelector !== void 0 ? _useAppSelector : {};
      var plotArea = usePlotArea();
      if (layout !== "horizontal" && layout !== "vertical" || plotArea == null) {
        return null;
      }
      if (chartName !== "AreaChart" && chartName !== "ComposedChart") {
        return null;
      }
      var {
        height,
        width,
        x: left,
        y: top
      } = plotArea;
      if (!points || !points.length) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(AreaWithState, _extends$6({}, everythingElse, {
        activeDot,
        animationBegin,
        animationDuration,
        animationEasing,
        baseLine,
        connectNulls,
        dot,
        fill,
        fillOpacity,
        height,
        hide,
        layout,
        isAnimationActive: isAnimationActive === "auto" ? !Global.isSsr : isAnimationActive,
        isRange,
        legendType,
        needClip,
        points,
        stroke,
        width,
        left,
        top,
        xAxisId,
        yAxisId
      }));
    }
    var getBaseValue = (layout, chartBaseValue, itemBaseValue, xAxis, yAxis) => {
      var baseValue = itemBaseValue !== null && itemBaseValue !== void 0 ? itemBaseValue : chartBaseValue;
      if (isNumber(baseValue)) {
        return baseValue;
      }
      var numericAxis = layout === "horizontal" ? yAxis : xAxis;
      var domain = numericAxis.scale.domain();
      if (numericAxis.type === "number") {
        var domainMax = Math.max(domain[0], domain[1]);
        var domainMin = Math.min(domain[0], domain[1]);
        if (baseValue === "dataMin") {
          return domainMin;
        }
        if (baseValue === "dataMax") {
          return domainMax;
        }
        return domainMax < 0 ? domainMax : Math.max(Math.min(domain[0], domain[1]), 0);
      }
      if (baseValue === "dataMin") {
        return domain[0];
      }
      if (baseValue === "dataMax") {
        return domain[1];
      }
      return domain[0];
    };
    function computeArea(_ref0) {
      var {
        areaSettings: {
          connectNulls,
          baseValue: itemBaseValue,
          dataKey
        },
        stackedData,
        layout,
        chartBaseValue,
        xAxis,
        yAxis,
        displayedData,
        dataStartIndex,
        xAxisTicks,
        yAxisTicks,
        bandSize
      } = _ref0;
      var hasStack = stackedData && stackedData.length;
      var baseValue = getBaseValue(layout, chartBaseValue, itemBaseValue, xAxis, yAxis);
      var isHorizontalLayout = layout === "horizontal";
      var isRange = false;
      var points = displayedData.map((entry, index) => {
        var value;
        if (hasStack) {
          value = stackedData[dataStartIndex + index];
        } else {
          value = getValueByDataKey(entry, dataKey);
          if (!Array.isArray(value)) {
            value = [baseValue, value];
          } else {
            isRange = true;
          }
        }
        var isBreakPoint = value[1] == null || hasStack && !connectNulls && getValueByDataKey(entry, dataKey) == null;
        if (isHorizontalLayout) {
          return {
            x: getCateCoordinateOfLine({
              axis: xAxis,
              ticks: xAxisTicks,
              bandSize,
              entry,
              index
            }),
            y: isBreakPoint ? null : yAxis.scale(value[1]),
            value,
            payload: entry
          };
        }
        return {
          x: isBreakPoint ? null : xAxis.scale(value[1]),
          y: getCateCoordinateOfLine({
            axis: yAxis,
            ticks: yAxisTicks,
            bandSize,
            entry,
            index
          }),
          value,
          payload: entry
        };
      });
      var baseLine;
      if (hasStack || isRange) {
        baseLine = points.map((entry) => {
          var x2 = Array.isArray(entry.value) ? entry.value[0] : null;
          if (isHorizontalLayout) {
            return {
              x: entry.x,
              y: x2 != null && entry.y != null ? yAxis.scale(x2) : null,
              payload: entry.payload
            };
          }
          return {
            x: x2 != null ? xAxis.scale(x2) : null,
            y: entry.y,
            payload: entry.payload
          };
        });
      } else {
        baseLine = isHorizontalLayout ? yAxis.scale(baseValue) : xAxis.scale(baseValue);
      }
      return {
        points,
        baseLine,
        isRange
      };
    }
    function AreaFn(outsideProps) {
      var props = resolveDefaultProps(outsideProps, defaultAreaProps);
      var isPanorama = useIsPanorama();
      return /* @__PURE__ */ reactExports.createElement(RegisterGraphicalItemId, {
        id: props.id,
        type: "area"
      }, (id2) => /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(SetLegendPayload, {
        legendPayload: computeLegendPayloadFromAreaData(props)
      }), /* @__PURE__ */ reactExports.createElement(SetAreaTooltipEntrySettings, {
        dataKey: props.dataKey,
        data: props.data,
        stroke: props.stroke,
        strokeWidth: props.strokeWidth,
        fill: props.fill,
        name: props.name,
        hide: props.hide,
        unit: props.unit,
        tooltipType: props.tooltipType
      }), /* @__PURE__ */ reactExports.createElement(SetCartesianGraphicalItem, {
        type: "area",
        id: id2,
        data: props.data,
        dataKey: props.dataKey,
        xAxisId: props.xAxisId,
        yAxisId: props.yAxisId,
        zAxisId: 0,
        stackId: getNormalizedStackId(props.stackId),
        hide: props.hide,
        barSize: void 0,
        baseValue: props.baseValue,
        isPanorama,
        connectNulls: props.connectNulls
      }), /* @__PURE__ */ reactExports.createElement(AreaImpl, _extends$6({}, props, {
        id: id2
      }))));
    }
    var Area = /* @__PURE__ */ reactExports.memo(AreaFn, propsAreEqual);
    Area.displayName = "Area";
    var _excluded$5 = ["domain", "range"], _excluded2$2 = ["domain", "range"];
    function _objectWithoutProperties$5(e, t2) {
      if (null == e) return {};
      var o, r2, i = _objectWithoutPropertiesLoose$5(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e);
        for (r2 = 0; r2 < n2.length; r2++) o = n2[r2], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose$5(r2, e) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    function shortArraysAreEqual(arr1, arr2) {
      if (arr1 === arr2) {
        return true;
      }
      if (Array.isArray(arr1) && arr1.length === 2 && Array.isArray(arr2) && arr2.length === 2) {
        return arr1[0] === arr2[0] && arr1[1] === arr2[1];
      }
      return false;
    }
    function axisPropsAreEqual(prevProps, nextProps) {
      if (prevProps === nextProps) {
        return true;
      }
      var {
        domain: prevDomain,
        range: prevRange
      } = prevProps, prevRest = _objectWithoutProperties$5(prevProps, _excluded$5);
      var {
        domain: nextDomain,
        range: nextRange
      } = nextProps, nextRest = _objectWithoutProperties$5(nextProps, _excluded2$2);
      if (!shortArraysAreEqual(prevDomain, nextDomain)) {
        return false;
      }
      if (!shortArraysAreEqual(prevRange, nextRange)) {
        return false;
      }
      return propsAreEqual(prevRest, nextRest);
    }
    var _excluded$4 = ["dangerouslySetInnerHTML", "ticks"], _excluded2$1 = ["id"];
    function _extends$5() {
      return _extends$5 = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$5.apply(null, arguments);
    }
    function _objectWithoutProperties$4(e, t2) {
      if (null == e) return {};
      var o, r2, i = _objectWithoutPropertiesLoose$4(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e);
        for (r2 = 0; r2 < n2.length; r2++) o = n2[r2], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose$4(r2, e) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    function SetXAxisSettings(settings) {
      var dispatch = useAppDispatch();
      var prevSettingsRef = reactExports.useRef(null);
      reactExports.useLayoutEffect(() => {
        if (prevSettingsRef.current === null) {
          dispatch(addXAxis(settings));
        } else if (prevSettingsRef.current !== settings) {
          dispatch(replaceXAxis({
            prev: prevSettingsRef.current,
            next: settings
          }));
        }
        prevSettingsRef.current = settings;
      }, [settings, dispatch]);
      reactExports.useLayoutEffect(() => {
        return () => {
          if (prevSettingsRef.current) {
            dispatch(removeXAxis(prevSettingsRef.current));
            prevSettingsRef.current = null;
          }
        };
      }, [dispatch]);
      return null;
    }
    var XAxisImpl = (props) => {
      var {
        xAxisId,
        className
      } = props;
      var viewBox = useAppSelector(selectAxisViewBox);
      var isPanorama = useIsPanorama();
      var axisType = "xAxis";
      var scale = useAppSelector((state) => selectAxisScale(state, axisType, xAxisId, isPanorama));
      var cartesianTickItems = useAppSelector((state) => selectTicksOfAxis(state, axisType, xAxisId, isPanorama));
      var axisSize = useAppSelector((state) => selectXAxisSize(state, xAxisId));
      var position = useAppSelector((state) => selectXAxisPosition(state, xAxisId));
      var synchronizedSettings = useAppSelector((state) => selectXAxisSettingsNoDefaults(state, xAxisId));
      if (axisSize == null || position == null || synchronizedSettings == null) {
        return null;
      }
      var {
        dangerouslySetInnerHTML,
        ticks: ticks2
      } = props, allOtherProps = _objectWithoutProperties$4(props, _excluded$4);
      var {
        id: id2
      } = synchronizedSettings, restSynchronizedSettings = _objectWithoutProperties$4(synchronizedSettings, _excluded2$1);
      return /* @__PURE__ */ reactExports.createElement(CartesianAxis, _extends$5({}, allOtherProps, restSynchronizedSettings, {
        scale,
        x: position.x,
        y: position.y,
        width: axisSize.width,
        height: axisSize.height,
        className: clsx("recharts-".concat(axisType, " ").concat(axisType), className),
        viewBox,
        ticks: cartesianTickItems,
        axisType
      }));
    };
    var xAxisDefaultProps = {
      allowDataOverflow: implicitXAxis.allowDataOverflow,
      allowDecimals: implicitXAxis.allowDecimals,
      allowDuplicatedCategory: implicitXAxis.allowDuplicatedCategory,
      angle: implicitXAxis.angle,
      axisLine: defaultCartesianAxisProps.axisLine,
      height: implicitXAxis.height,
      hide: false,
      includeHidden: implicitXAxis.includeHidden,
      interval: implicitXAxis.interval,
      minTickGap: implicitXAxis.minTickGap,
      mirror: implicitXAxis.mirror,
      orientation: implicitXAxis.orientation,
      padding: implicitXAxis.padding,
      reversed: implicitXAxis.reversed,
      scale: implicitXAxis.scale,
      tick: implicitXAxis.tick,
      tickCount: implicitXAxis.tickCount,
      tickLine: defaultCartesianAxisProps.tickLine,
      tickSize: defaultCartesianAxisProps.tickSize,
      type: implicitXAxis.type,
      xAxisId: 0
    };
    var XAxisSettingsDispatcher = (outsideProps) => {
      var props = resolveDefaultProps(outsideProps, xAxisDefaultProps);
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(SetXAxisSettings, {
        allowDataOverflow: props.allowDataOverflow,
        allowDecimals: props.allowDecimals,
        allowDuplicatedCategory: props.allowDuplicatedCategory,
        angle: props.angle,
        dataKey: props.dataKey,
        domain: props.domain,
        height: props.height,
        hide: props.hide,
        id: props.xAxisId,
        includeHidden: props.includeHidden,
        interval: props.interval,
        minTickGap: props.minTickGap,
        mirror: props.mirror,
        name: props.name,
        orientation: props.orientation,
        padding: props.padding,
        reversed: props.reversed,
        scale: props.scale,
        tick: props.tick,
        tickCount: props.tickCount,
        tickFormatter: props.tickFormatter,
        ticks: props.ticks,
        type: props.type,
        unit: props.unit
      }), /* @__PURE__ */ reactExports.createElement(XAxisImpl, props));
    };
    var XAxis = /* @__PURE__ */ reactExports.memo(XAxisSettingsDispatcher, axisPropsAreEqual);
    XAxis.displayName = "XAxis";
    var _excluded$3 = ["dangerouslySetInnerHTML", "ticks"], _excluded2 = ["id"];
    function _extends$4() {
      return _extends$4 = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$4.apply(null, arguments);
    }
    function _objectWithoutProperties$3(e, t2) {
      if (null == e) return {};
      var o, r2, i = _objectWithoutPropertiesLoose$3(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e);
        for (r2 = 0; r2 < n2.length; r2++) o = n2[r2], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose$3(r2, e) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    function SetYAxisSettings(settings) {
      var dispatch = useAppDispatch();
      var prevSettingsRef = reactExports.useRef(null);
      reactExports.useLayoutEffect(() => {
        if (prevSettingsRef.current === null) {
          dispatch(addYAxis(settings));
        } else if (prevSettingsRef.current !== settings) {
          dispatch(replaceYAxis({
            prev: prevSettingsRef.current,
            next: settings
          }));
        }
        prevSettingsRef.current = settings;
      }, [settings, dispatch]);
      reactExports.useLayoutEffect(() => {
        return () => {
          if (prevSettingsRef.current) {
            dispatch(removeYAxis(prevSettingsRef.current));
            prevSettingsRef.current = null;
          }
        };
      }, [dispatch]);
      return null;
    }
    var YAxisImpl = (props) => {
      var {
        yAxisId,
        className,
        width,
        label
      } = props;
      var cartesianAxisRef = reactExports.useRef(null);
      var labelRef = reactExports.useRef(null);
      var viewBox = useAppSelector(selectAxisViewBox);
      var isPanorama = useIsPanorama();
      var dispatch = useAppDispatch();
      var axisType = "yAxis";
      var scale = useAppSelector((state) => selectAxisScale(state, axisType, yAxisId, isPanorama));
      var axisSize = useAppSelector((state) => selectYAxisSize(state, yAxisId));
      var position = useAppSelector((state) => selectYAxisPosition(state, yAxisId));
      var cartesianTickItems = useAppSelector((state) => selectTicksOfAxis(state, axisType, yAxisId, isPanorama));
      var synchronizedSettings = useAppSelector((state) => selectYAxisSettingsNoDefaults(state, yAxisId));
      reactExports.useLayoutEffect(() => {
        if (width !== "auto" || !axisSize || isLabelContentAFunction(label) || /* @__PURE__ */ reactExports.isValidElement(label) || synchronizedSettings == null) {
          return;
        }
        var axisComponent = cartesianAxisRef.current;
        if (!axisComponent) {
          return;
        }
        var updatedYAxisWidth = axisComponent.getCalculatedWidth();
        if (Math.round(axisSize.width) !== Math.round(updatedYAxisWidth)) {
          dispatch(updateYAxisWidth({
            id: yAxisId,
            width: updatedYAxisWidth
          }));
        }
      }, [
        // The dependency on cartesianAxisRef.current is not needed because useLayoutEffect will run after every render.
        // The ref will be populated by then.
        // To re-run this effect when ticks change, we can depend on the ticks array from the store.
        cartesianTickItems,
        axisSize,
        dispatch,
        label,
        yAxisId,
        width,
        synchronizedSettings
      ]);
      if (axisSize == null || position == null || synchronizedSettings == null) {
        return null;
      }
      var {
        dangerouslySetInnerHTML,
        ticks: ticks2
      } = props, allOtherProps = _objectWithoutProperties$3(props, _excluded$3);
      var {
        id: id2
      } = synchronizedSettings, restSynchronizedSettings = _objectWithoutProperties$3(synchronizedSettings, _excluded2);
      return /* @__PURE__ */ reactExports.createElement(CartesianAxis, _extends$4({}, allOtherProps, restSynchronizedSettings, {
        ref: cartesianAxisRef,
        labelRef,
        scale,
        x: position.x,
        y: position.y,
        tickTextProps: width === "auto" ? {
          width: void 0
        } : {
          width
        },
        width: axisSize.width,
        height: axisSize.height,
        className: clsx("recharts-".concat(axisType, " ").concat(axisType), className),
        viewBox,
        ticks: cartesianTickItems,
        axisType
      }));
    };
    var yAxisDefaultProps = {
      allowDataOverflow: implicitYAxis.allowDataOverflow,
      allowDecimals: implicitYAxis.allowDecimals,
      allowDuplicatedCategory: implicitYAxis.allowDuplicatedCategory,
      angle: implicitYAxis.angle,
      axisLine: defaultCartesianAxisProps.axisLine,
      hide: false,
      includeHidden: implicitYAxis.includeHidden,
      interval: implicitYAxis.interval,
      minTickGap: implicitYAxis.minTickGap,
      mirror: implicitYAxis.mirror,
      orientation: implicitYAxis.orientation,
      padding: implicitYAxis.padding,
      reversed: implicitYAxis.reversed,
      scale: implicitYAxis.scale,
      tick: implicitYAxis.tick,
      tickCount: implicitYAxis.tickCount,
      tickLine: defaultCartesianAxisProps.tickLine,
      tickSize: defaultCartesianAxisProps.tickSize,
      type: implicitYAxis.type,
      width: implicitYAxis.width,
      yAxisId: 0
    };
    var YAxisSettingsDispatcher = (outsideProps) => {
      var props = resolveDefaultProps(outsideProps, yAxisDefaultProps);
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(SetYAxisSettings, {
        interval: props.interval,
        id: props.yAxisId,
        scale: props.scale,
        type: props.type,
        domain: props.domain,
        allowDataOverflow: props.allowDataOverflow,
        dataKey: props.dataKey,
        allowDuplicatedCategory: props.allowDuplicatedCategory,
        allowDecimals: props.allowDecimals,
        tickCount: props.tickCount,
        padding: props.padding,
        includeHidden: props.includeHidden,
        reversed: props.reversed,
        ticks: props.ticks,
        width: props.width,
        orientation: props.orientation,
        mirror: props.mirror,
        hide: props.hide,
        unit: props.unit,
        name: props.name,
        angle: props.angle,
        minTickGap: props.minTickGap,
        tick: props.tick,
        tickFormatter: props.tickFormatter
      }), /* @__PURE__ */ reactExports.createElement(YAxisImpl, props));
    };
    var YAxis = /* @__PURE__ */ reactExports.memo(YAxisSettingsDispatcher, axisPropsAreEqual);
    YAxis.displayName = "YAxis";
    var pickChartPointer = (_state, chartPointer) => chartPointer;
    var selectActivePropsFromChartPointer = createSelector([pickChartPointer, selectChartLayout, selectPolarViewBox, selectTooltipAxisType, selectTooltipAxisRangeWithReverse, selectTooltipAxisTicks, selectOrderedTooltipTicks, selectChartOffsetInternal], combineActiveProps);
    var getChartPointer = (event) => {
      var rect = event.currentTarget.getBoundingClientRect();
      var scaleX = rect.width / event.currentTarget.offsetWidth;
      var scaleY = rect.height / event.currentTarget.offsetHeight;
      return {
        /*
         * Here it's important to use:
         * - event.clientX and event.clientY to get the mouse position relative to the viewport, including scroll.
         * - pageX and pageY are not used because they are relative to the whole document, and ignore scroll.
         * - rect.left and rect.top are used to get the position of the chart relative to the viewport.
         * - offsetX and offsetY are not used because they are relative to the offset parent
         *  which may or may not be the same as the clientX and clientY, depending on the position of the chart in the DOM
         *  and surrounding element styles. CSS position: relative, absolute, fixed, will change the offset parent.
         * - scaleX and scaleY are necessary for when the chart element is scaled using CSS `transform: scale(N)`.
         */
        chartX: Math.round((event.clientX - rect.left) / scaleX),
        chartY: Math.round((event.clientY - rect.top) / scaleY)
      };
    };
    var mouseClickAction = createAction("mouseClick");
    var mouseClickMiddleware = createListenerMiddleware();
    mouseClickMiddleware.startListening({
      actionCreator: mouseClickAction,
      effect: (action, listenerApi) => {
        var mousePointer = action.payload;
        var activeProps = selectActivePropsFromChartPointer(listenerApi.getState(), getChartPointer(mousePointer));
        if ((activeProps === null || activeProps === void 0 ? void 0 : activeProps.activeIndex) != null) {
          listenerApi.dispatch(setMouseClickAxisIndex({
            activeIndex: activeProps.activeIndex,
            activeDataKey: void 0,
            activeCoordinate: activeProps.activeCoordinate
          }));
        }
      }
    });
    var mouseMoveAction = createAction("mouseMove");
    var mouseMoveMiddleware = createListenerMiddleware();
    var rafId = null;
    mouseMoveMiddleware.startListening({
      actionCreator: mouseMoveAction,
      effect: (action, listenerApi) => {
        var mousePointer = action.payload;
        if (rafId !== null) {
          cancelAnimationFrame(rafId);
        }
        var chartPointer = getChartPointer(mousePointer);
        rafId = requestAnimationFrame(() => {
          var state = listenerApi.getState();
          var tooltipEventType = selectTooltipEventType$1(state, state.tooltip.settings.shared);
          if (tooltipEventType === "axis") {
            var activeProps = selectActivePropsFromChartPointer(state, chartPointer);
            if ((activeProps === null || activeProps === void 0 ? void 0 : activeProps.activeIndex) != null) {
              listenerApi.dispatch(setMouseOverAxisIndex({
                activeIndex: activeProps.activeIndex,
                activeDataKey: void 0,
                activeCoordinate: activeProps.activeCoordinate
              }));
            } else {
              listenerApi.dispatch(mouseLeaveChart());
            }
          }
          rafId = null;
        });
      }
    });
    var initialState = {
      accessibilityLayer: true,
      barCategoryGap: "10%",
      barGap: 4,
      barSize: void 0,
      className: void 0,
      maxBarSize: void 0,
      stackOffset: "none",
      syncId: void 0,
      syncMethod: "index",
      baseValue: void 0,
      reverseStackOrder: false
    };
    var rootPropsSlice = createSlice({
      name: "rootProps",
      initialState,
      reducers: {
        updateOptions: (state, action) => {
          var _action$payload$barGa;
          state.accessibilityLayer = action.payload.accessibilityLayer;
          state.barCategoryGap = action.payload.barCategoryGap;
          state.barGap = (_action$payload$barGa = action.payload.barGap) !== null && _action$payload$barGa !== void 0 ? _action$payload$barGa : initialState.barGap;
          state.barSize = action.payload.barSize;
          state.maxBarSize = action.payload.maxBarSize;
          state.stackOffset = action.payload.stackOffset;
          state.syncId = action.payload.syncId;
          state.syncMethod = action.payload.syncMethod;
          state.className = action.payload.className;
          state.baseValue = action.payload.baseValue;
          state.reverseStackOrder = action.payload.reverseStackOrder;
        }
      }
    });
    var rootPropsReducer = rootPropsSlice.reducer;
    var {
      updateOptions
    } = rootPropsSlice.actions;
    var polarOptionsSlice = createSlice({
      name: "polarOptions",
      initialState: null,
      reducers: {
        updatePolarOptions: (_state, action) => {
          return action.payload;
        }
      }
    });
    var {
      updatePolarOptions
    } = polarOptionsSlice.actions;
    var polarOptionsReducer = polarOptionsSlice.reducer;
    var keyDownAction = createAction("keyDown");
    var focusAction = createAction("focus");
    var keyboardEventsMiddleware = createListenerMiddleware();
    keyboardEventsMiddleware.startListening({
      actionCreator: keyDownAction,
      effect: (action, listenerApi) => {
        var state = listenerApi.getState();
        var accessibilityLayerIsActive = state.rootProps.accessibilityLayer !== false;
        if (!accessibilityLayerIsActive) {
          return;
        }
        var {
          keyboardInteraction
        } = state.tooltip;
        var key = action.payload;
        if (key !== "ArrowRight" && key !== "ArrowLeft" && key !== "Enter") {
          return;
        }
        var resolvedIndex = combineActiveTooltipIndex(keyboardInteraction, selectTooltipDisplayedData(state), selectTooltipAxisDataKey(state), selectTooltipAxisDomain(state));
        var currentIndex = resolvedIndex == null ? -1 : Number(resolvedIndex);
        if (!Number.isFinite(currentIndex) || currentIndex < 0) {
          return;
        }
        var tooltipTicks = selectTooltipAxisTicks(state);
        if (key === "Enter") {
          var _coordinate = selectCoordinateForDefaultIndex(state, "axis", "hover", String(keyboardInteraction.index));
          listenerApi.dispatch(setKeyboardInteraction({
            active: !keyboardInteraction.active,
            activeIndex: keyboardInteraction.index,
            activeDataKey: keyboardInteraction.dataKey,
            activeCoordinate: _coordinate
          }));
          return;
        }
        var direction = selectChartDirection(state);
        var directionMultiplier = direction === "left-to-right" ? 1 : -1;
        var movement = key === "ArrowRight" ? 1 : -1;
        var nextIndex = currentIndex + movement * directionMultiplier;
        if (tooltipTicks == null || nextIndex >= tooltipTicks.length || nextIndex < 0) {
          return;
        }
        var coordinate = selectCoordinateForDefaultIndex(state, "axis", "hover", String(nextIndex));
        listenerApi.dispatch(setKeyboardInteraction({
          active: true,
          activeIndex: nextIndex.toString(),
          activeDataKey: void 0,
          activeCoordinate: coordinate
        }));
      }
    });
    keyboardEventsMiddleware.startListening({
      actionCreator: focusAction,
      effect: (_action, listenerApi) => {
        var state = listenerApi.getState();
        var accessibilityLayerIsActive = state.rootProps.accessibilityLayer !== false;
        if (!accessibilityLayerIsActive) {
          return;
        }
        var {
          keyboardInteraction
        } = state.tooltip;
        if (keyboardInteraction.active) {
          return;
        }
        if (keyboardInteraction.index == null) {
          var nextIndex = "0";
          var coordinate = selectCoordinateForDefaultIndex(state, "axis", "hover", String(nextIndex));
          listenerApi.dispatch(setKeyboardInteraction({
            activeDataKey: void 0,
            active: true,
            activeIndex: nextIndex,
            activeCoordinate: coordinate
          }));
        }
      }
    });
    var externalEventAction = createAction("externalEvent");
    var externalEventsMiddleware = createListenerMiddleware();
    var rafIdMap = /* @__PURE__ */ new Map();
    externalEventsMiddleware.startListening({
      actionCreator: externalEventAction,
      effect: (action, listenerApi) => {
        var {
          handler,
          reactEvent
        } = action.payload;
        if (handler == null) {
          return;
        }
        reactEvent.persist();
        var eventType = reactEvent.type;
        var existingRafId = rafIdMap.get(eventType);
        if (existingRafId !== void 0) {
          cancelAnimationFrame(existingRafId);
        }
        var rafId2 = requestAnimationFrame(() => {
          try {
            var state = listenerApi.getState();
            var nextState = {
              activeCoordinate: selectActiveTooltipCoordinate(state),
              activeDataKey: selectActiveTooltipDataKey(state),
              activeIndex: selectActiveTooltipIndex(state),
              activeLabel: selectActiveLabel$1(state),
              activeTooltipIndex: selectActiveTooltipIndex(state),
              isTooltipActive: selectIsTooltipActive$1(state)
            };
            handler(nextState, reactEvent);
          } finally {
            rafIdMap.delete(eventType);
          }
        });
        rafIdMap.set(eventType, rafId2);
      }
    });
    var selectAllTooltipPayloadConfiguration = createSelector([selectTooltipState], (tooltipState) => tooltipState.tooltipItemPayloads);
    var selectTooltipCoordinate = createSelector([selectAllTooltipPayloadConfiguration, selectTooltipPayloadSearcher, (_state, tooltipIndex, _dataKey) => tooltipIndex, (_state, _tooltipIndex, dataKey) => dataKey], (allTooltipConfigurations, tooltipPayloadSearcher, tooltipIndex, dataKey) => {
      var mostRelevantTooltipConfiguration = allTooltipConfigurations.find((tooltipConfiguration) => {
        return tooltipConfiguration.settings.dataKey === dataKey;
      });
      if (mostRelevantTooltipConfiguration == null) {
        return void 0;
      }
      var {
        positions
      } = mostRelevantTooltipConfiguration;
      if (positions == null) {
        return void 0;
      }
      var maybePosition = tooltipPayloadSearcher(positions, tooltipIndex);
      return maybePosition;
    });
    var touchEventAction = createAction("touchMove");
    var touchEventMiddleware = createListenerMiddleware();
    touchEventMiddleware.startListening({
      actionCreator: touchEventAction,
      effect: (action, listenerApi) => {
        var touchEvent = action.payload;
        if (touchEvent.touches == null || touchEvent.touches.length === 0) {
          return;
        }
        var state = listenerApi.getState();
        var tooltipEventType = selectTooltipEventType$1(state, state.tooltip.settings.shared);
        if (tooltipEventType === "axis") {
          var activeProps = selectActivePropsFromChartPointer(state, getChartPointer({
            clientX: touchEvent.touches[0].clientX,
            clientY: touchEvent.touches[0].clientY,
            currentTarget: touchEvent.currentTarget
          }));
          if ((activeProps === null || activeProps === void 0 ? void 0 : activeProps.activeIndex) != null) {
            listenerApi.dispatch(setMouseOverAxisIndex({
              activeIndex: activeProps.activeIndex,
              activeDataKey: void 0,
              activeCoordinate: activeProps.activeCoordinate
            }));
          }
        } else if (tooltipEventType === "item") {
          var _target$getAttribute;
          var touch = touchEvent.touches[0];
          if (document.elementFromPoint == null) {
            return;
          }
          var target = document.elementFromPoint(touch.clientX, touch.clientY);
          if (!target || !target.getAttribute) {
            return;
          }
          var itemIndex = target.getAttribute(DATA_ITEM_INDEX_ATTRIBUTE_NAME);
          var dataKey = (_target$getAttribute = target.getAttribute(DATA_ITEM_DATAKEY_ATTRIBUTE_NAME)) !== null && _target$getAttribute !== void 0 ? _target$getAttribute : void 0;
          var coordinate = selectTooltipCoordinate(listenerApi.getState(), itemIndex, dataKey);
          listenerApi.dispatch(setActiveMouseOverItemIndex({
            activeDataKey: dataKey,
            activeIndex: itemIndex,
            activeCoordinate: coordinate
          }));
        }
      }
    });
    var rootReducer = combineReducers({
      brush: brushReducer,
      cartesianAxis: cartesianAxisReducer,
      chartData: chartDataReducer,
      errorBars: errorBarReducer,
      graphicalItems: graphicalItemsReducer,
      layout: chartLayoutReducer,
      legend: legendReducer,
      options: optionsReducer,
      polarAxis: polarAxisReducer,
      polarOptions: polarOptionsReducer,
      referenceElements: referenceElementsReducer,
      rootProps: rootPropsReducer,
      tooltip: tooltipReducer,
      zIndex: zIndexReducer
    });
    var createRechartsStore = function createRechartsStore2(preloadedState) {
      return configureStore({
        reducer: rootReducer,
        // redux-toolkit v1 types are unhappy with the preloadedState type. Remove the `as any` when bumping to v2
        preloadedState,
        // @ts-expect-error redux-toolkit v1 types are unhappy with the middleware array. Remove this comment when bumping to v2
        middleware: (getDefaultMiddleware) => {
          var _process$env$NODE_ENV;
          return getDefaultMiddleware({
            serializableCheck: false,
            immutableCheck: !["commonjs", "es6", "production"].includes((_process$env$NODE_ENV = "es6") !== null && _process$env$NODE_ENV !== void 0 ? _process$env$NODE_ENV : "")
          }).concat([mouseClickMiddleware.middleware, mouseMoveMiddleware.middleware, keyboardEventsMiddleware.middleware, externalEventsMiddleware.middleware, touchEventMiddleware.middleware]);
        },
        /*
         * I can't find out how to satisfy typescript here.
         * We return `EnhancerArray<[StoreEnhancer<{}, {}>, StoreEnhancer]>` from this function,
         * but the types say we should return `EnhancerArray<StoreEnhancer<{}, {}>`.
         * Looks like it's badly inferred generics, but it won't allow me to provide the correct type manually either.
         * So let's just ignore the error for now.
         */
        // @ts-expect-error mismatched generics
        enhancers: (getDefaultEnhancers) => {
          var enhancers = getDefaultEnhancers;
          if (typeof getDefaultEnhancers === "function") {
            enhancers = getDefaultEnhancers();
          }
          return enhancers.concat(autoBatchEnhancer({
            type: "raf"
          }));
        },
        devTools: Global.devToolsEnabled
      });
    };
    function RechartsStoreProvider(_ref2) {
      var {
        preloadedState,
        children,
        reduxStoreName
      } = _ref2;
      var isPanorama = useIsPanorama();
      var storeRef = reactExports.useRef(null);
      if (isPanorama) {
        return children;
      }
      if (storeRef.current == null) {
        storeRef.current = createRechartsStore(preloadedState);
      }
      var nonNullContext = RechartsReduxContext;
      return /* @__PURE__ */ reactExports.createElement(Provider_default, {
        context: nonNullContext,
        store: storeRef.current
      }, children);
    }
    function ReportMainChartPropsImpl(_ref2) {
      var {
        layout,
        margin
      } = _ref2;
      var dispatch = useAppDispatch();
      var isPanorama = useIsPanorama();
      reactExports.useEffect(() => {
        if (!isPanorama) {
          dispatch(setLayout(layout));
          dispatch(setMargin(margin));
        }
      }, [dispatch, isPanorama, layout, margin]);
      return null;
    }
    var ReportMainChartProps = /* @__PURE__ */ reactExports.memo(ReportMainChartPropsImpl, propsAreEqual);
    function ReportChartProps(props) {
      var dispatch = useAppDispatch();
      reactExports.useEffect(() => {
        dispatch(updateOptions(props));
      }, [dispatch, props]);
      return null;
    }
    function ZIndexSvgPortal(_ref2) {
      var {
        zIndex,
        isPanorama
      } = _ref2;
      var prefix2 = isPanorama ? "recharts-zindex-panorama-" : "recharts-zindex-";
      var portalId = useUniqueId("".concat(prefix2).concat(zIndex));
      var dispatch = useAppDispatch();
      reactExports.useLayoutEffect(() => {
        dispatch(registerZIndexPortalId({
          zIndex,
          elementId: portalId,
          isPanorama
        }));
        return () => {
          dispatch(unregisterZIndexPortalId({
            zIndex,
            isPanorama
          }));
        };
      }, [dispatch, zIndex, portalId, isPanorama]);
      return /* @__PURE__ */ reactExports.createElement("g", {
        tabIndex: -1,
        id: portalId
      });
    }
    function AllZIndexPortals(_ref2) {
      var {
        children,
        isPanorama
      } = _ref2;
      var allRegisteredZIndexes = useAppSelector(selectAllRegisteredZIndexes);
      if (!allRegisteredZIndexes || allRegisteredZIndexes.length === 0) {
        return children;
      }
      var allNegativeZIndexes = allRegisteredZIndexes.filter((zIndex) => zIndex < 0);
      var allPositiveZIndexes = allRegisteredZIndexes.filter((zIndex) => zIndex > 0);
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, allNegativeZIndexes.map((zIndex) => /* @__PURE__ */ reactExports.createElement(ZIndexSvgPortal, {
        key: zIndex,
        zIndex,
        isPanorama
      })), children, allPositiveZIndexes.map((zIndex) => /* @__PURE__ */ reactExports.createElement(ZIndexSvgPortal, {
        key: zIndex,
        zIndex,
        isPanorama
      })));
    }
    var _excluded$2 = ["children"];
    function _objectWithoutProperties$2(e, t2) {
      if (null == e) return {};
      var o, r2, i = _objectWithoutPropertiesLoose$2(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e);
        for (r2 = 0; r2 < n2.length; r2++) o = n2[r2], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose$2(r2, e) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    function _extends$3() {
      return _extends$3 = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$3.apply(null, arguments);
    }
    var FULL_WIDTH_AND_HEIGHT = {
      width: "100%",
      height: "100%",
      /*
       * display: block is necessary here because the default for an SVG is display: inline,
       * which in some browsers (Chrome) adds a little bit of extra space above and below the SVG
       * to make space for the descender of letters like "g" and "y". This throws off the height calculation
       * and causes the container to grow indefinitely on each render with responsive=true.
       * Display: block removes that extra space.
       *
       * Interestingly, Firefox does not have this problem, but it doesn't hurt to add the style anyway.
       */
      display: "block"
    };
    var MainChartSurface = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var width = useChartWidth();
      var height = useChartHeight();
      var hasAccessibilityLayer = useAccessibilityLayer();
      if (!isPositiveNumber(width) || !isPositiveNumber(height)) {
        return null;
      }
      var {
        children,
        otherAttributes,
        title,
        desc
      } = props;
      var tabIndex, role;
      if (otherAttributes != null) {
        if (typeof otherAttributes.tabIndex === "number") {
          tabIndex = otherAttributes.tabIndex;
        } else {
          tabIndex = hasAccessibilityLayer ? 0 : void 0;
        }
        if (typeof otherAttributes.role === "string") {
          role = otherAttributes.role;
        } else {
          role = hasAccessibilityLayer ? "application" : void 0;
        }
      }
      return /* @__PURE__ */ reactExports.createElement(Surface, _extends$3({}, otherAttributes, {
        title,
        desc,
        role,
        tabIndex,
        width,
        height,
        style: FULL_WIDTH_AND_HEIGHT,
        ref
      }), children);
    });
    var BrushPanoramaSurface = (_ref2) => {
      var {
        children
      } = _ref2;
      var brushDimensions = useAppSelector(selectBrushDimensions);
      if (!brushDimensions) {
        return null;
      }
      var {
        width,
        height,
        y: y2,
        x: x2
      } = brushDimensions;
      return /* @__PURE__ */ reactExports.createElement(Surface, {
        width,
        height,
        x: x2,
        y: y2
      }, children);
    };
    var RootSurface = /* @__PURE__ */ reactExports.forwardRef((_ref2, ref) => {
      var {
        children
      } = _ref2, rest = _objectWithoutProperties$2(_ref2, _excluded$2);
      var isPanorama = useIsPanorama();
      if (isPanorama) {
        return /* @__PURE__ */ reactExports.createElement(BrushPanoramaSurface, null, /* @__PURE__ */ reactExports.createElement(AllZIndexPortals, {
          isPanorama: true
        }, children));
      }
      return /* @__PURE__ */ reactExports.createElement(MainChartSurface, _extends$3({
        ref
      }, rest), /* @__PURE__ */ reactExports.createElement(AllZIndexPortals, {
        isPanorama: false
      }, children));
    });
    function useReportScale() {
      var dispatch = useAppDispatch();
      var [ref, setRef] = reactExports.useState(null);
      var scale = useAppSelector(selectContainerScale);
      reactExports.useEffect(() => {
        if (ref == null) {
          return;
        }
        var rect = ref.getBoundingClientRect();
        var newScale = rect.width / ref.offsetWidth;
        if (isWellBehavedNumber(newScale) && newScale !== scale) {
          dispatch(setScale(newScale));
        }
      }, [ref, dispatch, scale]);
      return setRef;
    }
    function ownKeys$1(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread$1(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$1(Object(t2), true).forEach(function(r3) {
          _defineProperty$1(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty$1(e, r2, t2) {
      return (r2 = _toPropertyKey$1(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey$1(t2) {
      var i = _toPrimitive$1(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive$1(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function _extends$2() {
      return _extends$2 = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$2.apply(null, arguments);
    }
    var EventSynchronizer = () => {
      useSynchronisedEventsFromOtherCharts();
      return null;
    };
    function getNumberOrZero(value) {
      if (typeof value === "number") {
        return value;
      }
      if (typeof value === "string") {
        var parsed = parseFloat(value);
        if (!Number.isNaN(parsed)) {
          return parsed;
        }
      }
      return 0;
    }
    var ResponsiveDiv = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var _props$style, _props$style2;
      var observerRef = reactExports.useRef(null);
      var [sizes, setSizes] = reactExports.useState({
        containerWidth: getNumberOrZero((_props$style = props.style) === null || _props$style === void 0 ? void 0 : _props$style.width),
        containerHeight: getNumberOrZero((_props$style2 = props.style) === null || _props$style2 === void 0 ? void 0 : _props$style2.height)
      });
      var setContainerSize = reactExports.useCallback((newWidth, newHeight) => {
        setSizes((prevState) => {
          var roundedWidth = Math.round(newWidth);
          var roundedHeight = Math.round(newHeight);
          if (prevState.containerWidth === roundedWidth && prevState.containerHeight === roundedHeight) {
            return prevState;
          }
          return {
            containerWidth: roundedWidth,
            containerHeight: roundedHeight
          };
        });
      }, []);
      var innerRef = reactExports.useCallback((node) => {
        if (typeof ref === "function") {
          ref(node);
        }
        if (node != null && typeof ResizeObserver !== "undefined") {
          var {
            width: containerWidth,
            height: containerHeight
          } = node.getBoundingClientRect();
          setContainerSize(containerWidth, containerHeight);
          var callback = (entries) => {
            var {
              width,
              height
            } = entries[0].contentRect;
            setContainerSize(width, height);
          };
          var observer = new ResizeObserver(callback);
          observer.observe(node);
          observerRef.current = observer;
        }
      }, [ref, setContainerSize]);
      reactExports.useEffect(() => {
        return () => {
          var observer = observerRef.current;
          if (observer != null) {
            observer.disconnect();
          }
        };
      }, [setContainerSize]);
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(ReportChartSize, {
        width: sizes.containerWidth,
        height: sizes.containerHeight
      }), /* @__PURE__ */ reactExports.createElement("div", _extends$2({
        ref: innerRef
      }, props)));
    });
    var ReadSizeOnceDiv = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var {
        width,
        height
      } = props;
      var [sizes, setSizes] = reactExports.useState({
        containerWidth: getNumberOrZero(width),
        containerHeight: getNumberOrZero(height)
      });
      var setContainerSize = reactExports.useCallback((newWidth, newHeight) => {
        setSizes((prevState) => {
          var roundedWidth = Math.round(newWidth);
          var roundedHeight = Math.round(newHeight);
          if (prevState.containerWidth === roundedWidth && prevState.containerHeight === roundedHeight) {
            return prevState;
          }
          return {
            containerWidth: roundedWidth,
            containerHeight: roundedHeight
          };
        });
      }, []);
      var innerRef = reactExports.useCallback((node) => {
        if (typeof ref === "function") {
          ref(node);
        }
        if (node != null) {
          var {
            width: containerWidth,
            height: containerHeight
          } = node.getBoundingClientRect();
          setContainerSize(containerWidth, containerHeight);
        }
      }, [ref, setContainerSize]);
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(ReportChartSize, {
        width: sizes.containerWidth,
        height: sizes.containerHeight
      }), /* @__PURE__ */ reactExports.createElement("div", _extends$2({
        ref: innerRef
      }, props)));
    });
    var StaticDiv = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var {
        width,
        height
      } = props;
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(ReportChartSize, {
        width,
        height
      }), /* @__PURE__ */ reactExports.createElement("div", _extends$2({
        ref
      }, props)));
    });
    var NonResponsiveDiv = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var {
        width,
        height
      } = props;
      if (isPercent(width) || isPercent(height)) {
        return /* @__PURE__ */ reactExports.createElement(ReadSizeOnceDiv, _extends$2({}, props, {
          ref
        }));
      }
      return /* @__PURE__ */ reactExports.createElement(StaticDiv, _extends$2({}, props, {
        ref
      }));
    });
    function getWrapperDivComponent(responsive) {
      return responsive === true ? ResponsiveDiv : NonResponsiveDiv;
    }
    var RechartsWrapper = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var {
        children,
        className,
        height: heightFromProps,
        onClick,
        onContextMenu,
        onDoubleClick,
        onMouseDown,
        onMouseEnter,
        onMouseLeave,
        onMouseMove,
        onMouseUp,
        onTouchEnd,
        onTouchMove,
        onTouchStart,
        style,
        width: widthFromProps,
        responsive,
        dispatchTouchEvents = true
      } = props;
      var containerRef = reactExports.useRef(null);
      var dispatch = useAppDispatch();
      var [tooltipPortal, setTooltipPortal] = reactExports.useState(null);
      var [legendPortal, setLegendPortal] = reactExports.useState(null);
      var setScaleRef = useReportScale();
      var responsiveContainerCalculations = useResponsiveContainerContext();
      var width = (responsiveContainerCalculations === null || responsiveContainerCalculations === void 0 ? void 0 : responsiveContainerCalculations.width) > 0 ? responsiveContainerCalculations.width : widthFromProps;
      var height = (responsiveContainerCalculations === null || responsiveContainerCalculations === void 0 ? void 0 : responsiveContainerCalculations.height) > 0 ? responsiveContainerCalculations.height : heightFromProps;
      var innerRef = reactExports.useCallback((node) => {
        setScaleRef(node);
        if (typeof ref === "function") {
          ref(node);
        }
        setTooltipPortal(node);
        setLegendPortal(node);
        if (node != null) {
          containerRef.current = node;
        }
      }, [setScaleRef, ref, setTooltipPortal, setLegendPortal]);
      var myOnClick = reactExports.useCallback((e) => {
        dispatch(mouseClickAction(e));
        dispatch(externalEventAction({
          handler: onClick,
          reactEvent: e
        }));
      }, [dispatch, onClick]);
      var myOnMouseEnter = reactExports.useCallback((e) => {
        dispatch(mouseMoveAction(e));
        dispatch(externalEventAction({
          handler: onMouseEnter,
          reactEvent: e
        }));
      }, [dispatch, onMouseEnter]);
      var myOnMouseLeave = reactExports.useCallback((e) => {
        dispatch(mouseLeaveChart());
        dispatch(externalEventAction({
          handler: onMouseLeave,
          reactEvent: e
        }));
      }, [dispatch, onMouseLeave]);
      var myOnMouseMove = reactExports.useCallback((e) => {
        dispatch(mouseMoveAction(e));
        dispatch(externalEventAction({
          handler: onMouseMove,
          reactEvent: e
        }));
      }, [dispatch, onMouseMove]);
      var onFocus = reactExports.useCallback(() => {
        dispatch(focusAction());
      }, [dispatch]);
      var onKeyDown = reactExports.useCallback((e) => {
        dispatch(keyDownAction(e.key));
      }, [dispatch]);
      var myOnContextMenu = reactExports.useCallback((e) => {
        dispatch(externalEventAction({
          handler: onContextMenu,
          reactEvent: e
        }));
      }, [dispatch, onContextMenu]);
      var myOnDoubleClick = reactExports.useCallback((e) => {
        dispatch(externalEventAction({
          handler: onDoubleClick,
          reactEvent: e
        }));
      }, [dispatch, onDoubleClick]);
      var myOnMouseDown = reactExports.useCallback((e) => {
        dispatch(externalEventAction({
          handler: onMouseDown,
          reactEvent: e
        }));
      }, [dispatch, onMouseDown]);
      var myOnMouseUp = reactExports.useCallback((e) => {
        dispatch(externalEventAction({
          handler: onMouseUp,
          reactEvent: e
        }));
      }, [dispatch, onMouseUp]);
      var myOnTouchStart = reactExports.useCallback((e) => {
        dispatch(externalEventAction({
          handler: onTouchStart,
          reactEvent: e
        }));
      }, [dispatch, onTouchStart]);
      var myOnTouchMove = reactExports.useCallback((e) => {
        if (dispatchTouchEvents) {
          dispatch(touchEventAction(e));
        }
        dispatch(externalEventAction({
          handler: onTouchMove,
          reactEvent: e
        }));
      }, [dispatch, dispatchTouchEvents, onTouchMove]);
      var myOnTouchEnd = reactExports.useCallback((e) => {
        dispatch(externalEventAction({
          handler: onTouchEnd,
          reactEvent: e
        }));
      }, [dispatch, onTouchEnd]);
      var WrapperDiv = getWrapperDivComponent(responsive);
      return /* @__PURE__ */ reactExports.createElement(TooltipPortalContext.Provider, {
        value: tooltipPortal
      }, /* @__PURE__ */ reactExports.createElement(LegendPortalContext.Provider, {
        value: legendPortal
      }, /* @__PURE__ */ reactExports.createElement(WrapperDiv, {
        width: width !== null && width !== void 0 ? width : style === null || style === void 0 ? void 0 : style.width,
        height: height !== null && height !== void 0 ? height : style === null || style === void 0 ? void 0 : style.height,
        className: clsx("recharts-wrapper", className),
        style: _objectSpread$1({
          position: "relative",
          cursor: "default",
          width,
          height
        }, style),
        onClick: myOnClick,
        onContextMenu: myOnContextMenu,
        onDoubleClick: myOnDoubleClick,
        onFocus,
        onKeyDown,
        onMouseDown: myOnMouseDown,
        onMouseEnter: myOnMouseEnter,
        onMouseLeave: myOnMouseLeave,
        onMouseMove: myOnMouseMove,
        onMouseUp: myOnMouseUp,
        onTouchEnd: myOnTouchEnd,
        onTouchMove: myOnTouchMove,
        onTouchStart: myOnTouchStart,
        ref: innerRef
      }, /* @__PURE__ */ reactExports.createElement(EventSynchronizer, null), children)));
    });
    var _excluded$1 = ["width", "height", "responsive", "children", "className", "style", "compact", "title", "desc"];
    function _objectWithoutProperties$1(e, t2) {
      if (null == e) return {};
      var o, r2, i = _objectWithoutPropertiesLoose$1(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e);
        for (r2 = 0; r2 < n2.length; r2++) o = n2[r2], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose$1(r2, e) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    var CategoricalChart = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var {
        width,
        height,
        responsive,
        children,
        className,
        style,
        compact,
        title,
        desc
      } = props, others = _objectWithoutProperties$1(props, _excluded$1);
      var attrs = svgPropertiesNoEvents(others);
      if (compact) {
        return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(ReportChartSize, {
          width,
          height
        }), /* @__PURE__ */ reactExports.createElement(RootSurface, {
          otherAttributes: attrs,
          title,
          desc
        }, children));
      }
      return /* @__PURE__ */ reactExports.createElement(RechartsWrapper, {
        className,
        style,
        width,
        height,
        responsive: responsive !== null && responsive !== void 0 ? responsive : false,
        onClick: props.onClick,
        onMouseLeave: props.onMouseLeave,
        onMouseEnter: props.onMouseEnter,
        onMouseMove: props.onMouseMove,
        onMouseDown: props.onMouseDown,
        onMouseUp: props.onMouseUp,
        onContextMenu: props.onContextMenu,
        onDoubleClick: props.onDoubleClick,
        onTouchStart: props.onTouchStart,
        onTouchMove: props.onTouchMove,
        onTouchEnd: props.onTouchEnd
      }, /* @__PURE__ */ reactExports.createElement(RootSurface, {
        otherAttributes: attrs,
        title,
        desc,
        ref
      }, /* @__PURE__ */ reactExports.createElement(ClipPathProvider, null, children)));
    });
    function _extends$1() {
      return _extends$1 = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$1.apply(null, arguments);
    }
    var defaultMargin$1 = {
      top: 5,
      right: 5,
      bottom: 5,
      left: 5
    };
    var defaultCartesianChartProps = {
      accessibilityLayer: true,
      barCategoryGap: "10%",
      barGap: 4,
      layout: "horizontal",
      margin: defaultMargin$1,
      responsive: false,
      reverseStackOrder: false,
      stackOffset: "none",
      syncMethod: "index"
    };
    var CartesianChart = /* @__PURE__ */ reactExports.forwardRef(function CartesianChart2(props, ref) {
      var _categoricalChartProp;
      var rootChartProps = resolveDefaultProps(props.categoricalChartProps, defaultCartesianChartProps);
      var {
        chartName,
        defaultTooltipEventType,
        validateTooltipEventTypes,
        tooltipPayloadSearcher,
        categoricalChartProps
      } = props;
      var options = {
        chartName,
        defaultTooltipEventType,
        validateTooltipEventTypes,
        tooltipPayloadSearcher,
        eventEmitter: void 0
      };
      return /* @__PURE__ */ reactExports.createElement(RechartsStoreProvider, {
        preloadedState: {
          options
        },
        reduxStoreName: (_categoricalChartProp = categoricalChartProps.id) !== null && _categoricalChartProp !== void 0 ? _categoricalChartProp : chartName
      }, /* @__PURE__ */ reactExports.createElement(ChartDataContextProvider, {
        chartData: categoricalChartProps.data
      }), /* @__PURE__ */ reactExports.createElement(ReportMainChartProps, {
        layout: rootChartProps.layout,
        margin: rootChartProps.margin
      }), /* @__PURE__ */ reactExports.createElement(ReportChartProps, {
        baseValue: rootChartProps.baseValue,
        accessibilityLayer: rootChartProps.accessibilityLayer,
        barCategoryGap: rootChartProps.barCategoryGap,
        maxBarSize: rootChartProps.maxBarSize,
        stackOffset: rootChartProps.stackOffset,
        barGap: rootChartProps.barGap,
        barSize: rootChartProps.barSize,
        syncId: rootChartProps.syncId,
        syncMethod: rootChartProps.syncMethod,
        className: rootChartProps.className,
        reverseStackOrder: rootChartProps.reverseStackOrder
      }), /* @__PURE__ */ reactExports.createElement(CategoricalChart, _extends$1({}, rootChartProps, {
        ref
      })));
    });
    var allowedTooltipTypes$4 = ["axis"];
    var LineChart = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      return /* @__PURE__ */ reactExports.createElement(CartesianChart, {
        chartName: "LineChart",
        defaultTooltipEventType: "axis",
        validateTooltipEventTypes: allowedTooltipTypes$4,
        tooltipPayloadSearcher: arrayTooltipSearcher,
        categoricalChartProps: props,
        ref
      });
    });
    var allowedTooltipTypes$3 = ["axis", "item"];
    var BarChart = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      return /* @__PURE__ */ reactExports.createElement(CartesianChart, {
        chartName: "BarChart",
        defaultTooltipEventType: "axis",
        validateTooltipEventTypes: allowedTooltipTypes$3,
        tooltipPayloadSearcher: arrayTooltipSearcher,
        categoricalChartProps: props,
        ref
      });
    });
    function ReportPolarOptions(props) {
      var dispatch = useAppDispatch();
      reactExports.useEffect(() => {
        dispatch(updatePolarOptions(props));
      }, [dispatch, props]);
      return null;
    }
    var _excluded = ["layout"];
    function _extends() {
      return _extends = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends.apply(null, arguments);
    }
    function _objectWithoutProperties(e, t2) {
      if (null == e) return {};
      var o, r2, i = _objectWithoutPropertiesLoose(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e);
        for (r2 = 0; r2 < n2.length; r2++) o = n2[r2], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose(r2, e) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    var defaultMargin = {
      top: 5,
      right: 5,
      bottom: 5,
      left: 5
    };
    var defaultPolarChartProps = {
      accessibilityLayer: true,
      stackOffset: "none",
      barCategoryGap: "10%",
      barGap: 4,
      margin: defaultMargin,
      reverseStackOrder: false,
      syncMethod: "index",
      layout: "radial",
      responsive: false,
      cx: "50%",
      cy: "50%",
      innerRadius: 0,
      outerRadius: "80%"
    };
    var PolarChart = /* @__PURE__ */ reactExports.forwardRef(function PolarChart2(props, ref) {
      var _polarChartProps$id;
      var polarChartProps = resolveDefaultProps(props.categoricalChartProps, defaultPolarChartProps);
      var {
        layout
      } = polarChartProps, otherCategoricalProps = _objectWithoutProperties(polarChartProps, _excluded);
      var {
        chartName,
        defaultTooltipEventType,
        validateTooltipEventTypes,
        tooltipPayloadSearcher
      } = props;
      var options = {
        chartName,
        defaultTooltipEventType,
        validateTooltipEventTypes,
        tooltipPayloadSearcher,
        eventEmitter: void 0
      };
      return /* @__PURE__ */ reactExports.createElement(RechartsStoreProvider, {
        preloadedState: {
          options
        },
        reduxStoreName: (_polarChartProps$id = polarChartProps.id) !== null && _polarChartProps$id !== void 0 ? _polarChartProps$id : chartName
      }, /* @__PURE__ */ reactExports.createElement(ChartDataContextProvider, {
        chartData: polarChartProps.data
      }), /* @__PURE__ */ reactExports.createElement(ReportMainChartProps, {
        layout,
        margin: polarChartProps.margin
      }), /* @__PURE__ */ reactExports.createElement(ReportChartProps, {
        baseValue: void 0,
        accessibilityLayer: polarChartProps.accessibilityLayer,
        barCategoryGap: polarChartProps.barCategoryGap,
        maxBarSize: polarChartProps.maxBarSize,
        stackOffset: polarChartProps.stackOffset,
        barGap: polarChartProps.barGap,
        barSize: polarChartProps.barSize,
        syncId: polarChartProps.syncId,
        syncMethod: polarChartProps.syncMethod,
        className: polarChartProps.className,
        reverseStackOrder: polarChartProps.reverseStackOrder
      }), /* @__PURE__ */ reactExports.createElement(ReportPolarOptions, {
        cx: polarChartProps.cx,
        cy: polarChartProps.cy,
        startAngle: polarChartProps.startAngle,
        endAngle: polarChartProps.endAngle,
        innerRadius: polarChartProps.innerRadius,
        outerRadius: polarChartProps.outerRadius
      }), /* @__PURE__ */ reactExports.createElement(CategoricalChart, _extends({}, otherCategoricalProps, {
        ref
      })));
    });
    function ownKeys(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
          _defineProperty(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty(e, r2, t2) {
      return (r2 = _toPropertyKey(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
    }
    function _toPropertyKey(t2) {
      var i = _toPrimitive(t2, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _toPrimitive(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r2);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    var allowedTooltipTypes$2 = ["item"];
    var defaultPieChartProps = _objectSpread(_objectSpread({}, defaultPolarChartProps), {}, {
      layout: "centric",
      startAngle: 0,
      endAngle: 360
    });
    var PieChart = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var propsWithDefaults = resolveDefaultProps(props, defaultPieChartProps);
      return /* @__PURE__ */ reactExports.createElement(PolarChart, {
        chartName: "PieChart",
        defaultTooltipEventType: "item",
        validateTooltipEventTypes: allowedTooltipTypes$2,
        tooltipPayloadSearcher: arrayTooltipSearcher,
        categoricalChartProps: propsWithDefaults,
        ref
      });
    });
    var allowedTooltipTypes$1 = ["axis"];
    var AreaChart = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      return /* @__PURE__ */ reactExports.createElement(CartesianChart, {
        chartName: "AreaChart",
        defaultTooltipEventType: "axis",
        validateTooltipEventTypes: allowedTooltipTypes$1,
        tooltipPayloadSearcher: arrayTooltipSearcher,
        categoricalChartProps: props,
        ref
      });
    });
    var allowedTooltipTypes = ["axis"];
    var ComposedChart = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      return /* @__PURE__ */ reactExports.createElement(CartesianChart, {
        chartName: "ComposedChart",
        defaultTooltipEventType: "axis",
        validateTooltipEventTypes: allowedTooltipTypes,
        tooltipPayloadSearcher: arrayTooltipSearcher,
        categoricalChartProps: props,
        ref
      });
    });
    const KPICard = ({ title, value, subtext, trend, trendValue, color: color2 }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-6 rounded-xl border border-slate-200 shadow-sm", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-start mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `p-3 rounded-lg ${color2}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-white", children: "" }) }),
        trend && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-center space-x-1 text-sm ${trend === "up" ? "text-green-600" : "text-red-600"}`, children: [
          trend === "up" ? /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingUp, { size: 16 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingDown, { size: 16 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: trendValue })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-slate-500 text-sm font-medium mb-1", children: title }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-2xl font-bold text-slate-900 mb-1", children: value }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-slate-400", children: subtext })
    ] });
    const RiskTable = () => {
      const [data, setData] = reactExports.useState([]);
      reactExports.useEffect(() => {
        const fetchRisks = () => __async(exports, null, function* () {
          try {
            const response = yield api.get("/godowns");
            if (response.success && Array.isArray(response.data)) {
              const sorted = response.data.map((g) => ({
                id: g.id,
                name: g.name,
                district: g.district,
                commodity: "Paddy",
                score: g.riskScore || 0,
                days: 45,
                status: (g.riskScore || 0) > 75 ? "High Risk" : "Normal"
              })).sort((a2, b) => b.score - a2.score).slice(0, 5);
              setData(sorted);
            }
          } catch (e) {
            console.error(e);
          }
        });
        fetchRisks();
      }, []);
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "w-full text-sm text-left", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { className: "text-xs text-slate-500 uppercase bg-slate-50 border-b", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 font-medium", children: "Godown Name" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 font-medium", children: "District" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 font-medium", children: "Commodity" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 font-medium", children: "Risk Score" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 font-medium", children: "Days" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 font-medium", children: "Status" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 font-medium text-right", children: "Action" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: data.map((row) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: "bg-white border-b hover:bg-slate-50 transition-colors", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 font-medium text-slate-900", children: row.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 text-slate-600", children: row.district }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 text-slate-600", children: row.commodity }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `font-bold ${row.score > 75 ? "text-red-600" : row.score > 50 ? "text-amber-600" : "text-green-600"}`, children: row.score }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-2 w-16 h-1.5 bg-slate-200 rounded-full overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: `h-full rounded-full ${row.score > 75 ? "bg-red-500" : row.score > 50 ? "bg-amber-500" : "bg-green-500"}`,
                style: { width: `${row.score}%` }
              }
            ) })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 text-slate-600", children: row.days }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `px-2.5 py-1 rounded-full text-xs font-medium border ${row.status === "High Risk" ? "bg-red-50 text-red-700 border-red-200" : row.status === "Medium" || row.status === "Guide" ? "bg-amber-50 text-amber-700 border-amber-200" : "bg-green-50 text-green-700 border-green-200"}`, children: row.status }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 text-right", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "text-slate-400 hover:text-slate-600 p-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MoreVertical, { size: 16 }) }) })
        ] }, row.id)) })
      ] }) });
    };
    const SpoilageChart = () => {
      const data = [
        { month: "Jan", spoilage: 120, saved: 450 },
        { month: "Feb", spoilage: 98, saved: 520 },
        { month: "Mar", spoilage: 86, saved: 600 },
        { month: "Apr", spoilage: 150, saved: 580 },
        { month: "May", spoilage: 180, saved: 620 },
        { month: "Jun", spoilage: 140, saved: 550 }
      ];
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-80 w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: "100%", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(AreaChart, { data, margin: { top: 10, right: 10, left: 0, bottom: 0 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "colorSaved", x1: "0", y1: "0", x2: "0", y2: "1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "5%", stopColor: "#10b981", stopOpacity: 0.1 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "95%", stopColor: "#10b981", stopOpacity: 0 })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "colorSpoilage", x1: "0", y1: "0", x2: "0", y2: "1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "5%", stopColor: "#ef4444", stopOpacity: 0.1 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "95%", stopColor: "#ef4444", stopOpacity: 0 })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CartesianGrid, { strokeDasharray: "3 3", vertical: false, stroke: "#f1f5f9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(XAxis, { dataKey: "month", axisLine: false, tickLine: false, tick: { fill: "#64748b", fontSize: 12 }, dy: 10 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(YAxis, { axisLine: false, tickLine: false, tick: { fill: "#64748b", fontSize: 12 } }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Tooltip,
          {
            contentStyle: { backgroundColor: "#fff", borderRadius: "8px", border: "1px solid #e2e8f0", boxShadow: "0 4px 6px -1px rgb(0 0 0 / 0.1)" },
            itemStyle: { fontSize: "12px" }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Area,
          {
            type: "monotone",
            dataKey: "saved",
            name: "Est. Saved (MT)",
            stroke: "#10b981",
            strokeWidth: 2,
            fillOpacity: 1,
            fill: "url(#colorSaved)"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Area,
          {
            type: "monotone",
            dataKey: "spoilage",
            name: "Spoilage (MT)",
            stroke: "#ef4444",
            strokeWidth: 2,
            fillOpacity: 1,
            fill: "url(#colorSpoilage)"
          }
        )
      ] }) }) });
    };
    const PredictiveAlerts = ({ alerts }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gradient-to-br from-indigo-900 to-slate-900 text-white p-6 rounded-xl shadow-lg border border-indigo-700 relative overflow-hidden", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-0 right-0 w-32 h-32 bg-indigo-500 rounded-full mix-blend-overlay filter blur-3xl opacity-20 -mr-16 -mt-16" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative z-10", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "font-bold text-lg flex items-center gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-2xl", children: "" }),
            " Predictive Risk (48h)"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bg-indigo-500/30 border border-indigo-400/30 px-2 py-1 rounded text-xs font-bold animate-pulse", children: "AI Forecast Active" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: alerts.map((alert2, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-3 items-start p-3 rounded-lg bg-white/5 border border-white/10 hover:bg-white/10 transition-colors cursor-pointer", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `mt-1 p-1.5 rounded-full ${alert2.severity === "High" ? "bg-red-500" : "bg-orange-500"}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlertTriangle, { size: 12, className: "text-white" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-bold text-sm text-indigo-100", children: alert2.title }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-indigo-300 mt-1", children: alert2.desc }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 mt-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-[10px] bg-indigo-950/50 px-2 py-0.5 rounded text-indigo-200 border border-indigo-800", children: [
                "Confidence: ",
                alert2.confidence,
                "%"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-[10px] bg-indigo-950/50 px-2 py-0.5 rounded text-indigo-200 border border-indigo-800", children: [
                "Impact: ",
                alert2.impact
              ] })
            ] })
          ] })
        ] }, i)) })
      ] })
    ] });
    const RiskMitigationWidget = ({ data }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl border border-slate-200 shadow-sm overflow-hidden", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6 border-b border-slate-100 flex justify-between items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "text-lg font-bold text-slate-800 flex items-center gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-emerald-500", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CheckCircle, { size: 20 }) }),
          "Ranked Mitigations & Resolutions"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs font-bold text-slate-500 uppercase", children: "Live Updates" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "divide-y divide-slate-100", children: data.map((item, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 flex items-start gap-4 hover:bg-slate-50 transition-colors", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-1", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-8 h-8 rounded-full bg-slate-100 flex items-center justify-center text-slate-500 font-bold text-xs", children: [
          "#",
          index + 1
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-start", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-bold text-slate-800 text-sm", children: item.issue }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-[10px] font-bold bg-emerald-100 text-emerald-700 px-2 py-0.5 rounded-full", children: "Resolved" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-slate-500 mt-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-slate-700", children: "Solution:" }),
            " ",
            item.solution
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4 mt-2 text-[10px] text-slate-400 font-medium", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              " ",
              item.time
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              " ",
              item.location
            ] })
          ] })
        ] })
      ] }, index)) })
    ] });
    const Overview = () => {
      const { t: t2 } = useLanguage();
      const [metrics, setMetrics] = reactExports.useState(null);
      const predictions = [
        { title: "Heavy Rain in Delta Region", desc: "Moisture spike expected in Thanjavur & Tiruvarur godowns. Check tarpaulins.", severity: "High", confidence: 92, impact: "25 Godowns" },
        { title: "Truck Strike Probability", desc: "Transport union talks stalling. Potential logistics delay > 24h on NH-45.", severity: "Medium", confidence: 75, impact: "Supply Chain" }
      ];
      const mitigations = [
        { issue: "High Moisture Alarm (14.2%)", solution: "Aeration Fans Activated Automatically", time: "2 hrs ago", location: "Tiruvarur G-04" },
        { issue: "Pest Infestation Risk", solution: "Fumigation Schedule Accelerated", time: "5 hrs ago", location: "Nagapattinam" },
        { title: "Stock Discrepancy", solution: "Audit Team Dispatched", time: "Yesterday", location: "Mannargudi" }
      ];
      reactExports.useEffect(() => {
        const fetchData = () => __async(exports, null, function* () {
          try {
            const response = yield api.get("/reports/dashboard");
            if (response.success) {
              setMetrics(response.data);
            }
          } catch (error) {
            console.error("Failed to fetch dashboard data", error);
          }
        });
        fetchData();
      }, []);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            KPICard,
            {
              title: t2("totalGodowns"),
              value: (metrics == null ? void 0 : metrics.totalGodowns) || "0",
              subtext: t2("operationalDistrict"),
              color: "bg-blue-600"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            KPICard,
            {
              title: t2("atRiskGodowns"),
              value: (metrics == null ? void 0 : metrics.highRiskGodowns) || "0",
              subtext: "High Risk Status",
              trend: "down",
              trendValue: "15%",
              color: "bg-red-500"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            KPICard,
            {
              title: t2("estSpoilageSaved"),
              value: (metrics == null ? void 0 : metrics.spoilagePreventedValue) || "0",
              subtext: "Current Financial Year",
              trend: "up",
              trendValue: "8%",
              color: "bg-emerald-600"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            KPICard,
            {
              title: t2("seasonProcurement"),
              value: "1,240 MT",
              subtext: "Kharif Marketing Season",
              color: "bg-indigo-600"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-3 gap-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lg:col-span-2 space-y-6", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-6 rounded-xl border border-slate-200 shadow-sm", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-lg font-bold text-slate-800", children: t2("spoilageTrends") }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("select", { className: "text-sm bg-slate-50 border border-slate-200 text-slate-700 font-bold rounded-lg pl-3 pr-8 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 appearance-none cursor-pointer hover:bg-slate-100 transition-colors", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { children: "Last 6 Months" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { children: "Last Year" })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-slate-500", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingDown, { size: 14 }) })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(SpoilageChart, {})
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 gap-6" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-6", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(PredictiveAlerts, { alerts: predictions }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-6 rounded-xl border border-slate-200 shadow-sm flex flex-col h-[500px]", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "text-lg font-bold text-slate-800 mb-4 flex items-center gap-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(MapPin, { className: "text-blue-600", size: 20 }),
                t2("riskHeatmap")
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 bg-slate-50 rounded-lg overflow-hidden border border-slate-200 relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(RiskMap, {}) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(RiskMitigationWidget, { data: mitigations })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl border border-slate-200 shadow-sm overflow-hidden", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6 border-b border-slate-100 flex justify-between items-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-lg font-bold text-slate-800", children: t2("topRiskGodowns") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "text-blue-600 text-sm font-medium hover:underline", children: t2("viewAll") })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(RiskTable, {})
        ] })
      ] });
    };
    const GodownNetwork = () => {
      const [searchTerm, setSearchTerm] = reactExports.useState("");
      const [godowns, setGodowns] = reactExports.useState([]);
      const [loading, setLoading] = reactExports.useState(true);
      React$3.useEffect(() => {
        const fetchGodowns = () => __async(exports, null, function* () {
          try {
            const response = yield api.get("/godowns");
            if (response.success && Array.isArray(response.data)) {
              const transformed = response.data.map((g) => ({
                id: g.id,
                name: g.name,
                district: g.district,
                capacity: g.capacity || 0,
                stock: g.capacity ? g.capacity * 0.8 : 0,
                // Mock stock if missing
                util: g.capacity ? Math.round(g.capacity * 0.8 / g.capacity * 100) : 0,
                risk: g.riskScore || 0,
                status: (g.riskScore || 0) > 75 ? "Critical" : "Normal",
                lastInsp: "2023-12-10"
              }));
              setGodowns(transformed);
            }
          } catch (error) {
            console.error(error);
          } finally {
            setLoading(false);
          }
        });
        fetchGodowns();
      }, []);
      if (loading) return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-8 text-center", children: "Loading Network..." });
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col md:flex-row md:items-center justify-between gap-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-2xl font-bold text-slate-800", children: "Godown Network" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-500", children: "Monitor storage capacity and risk levels across 248 godowns." })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "bg-white border text-slate-700 px-4 py-2 rounded-lg text-sm font-medium hover:bg-slate-50 flex items-center space-x-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hidden sm:inline", children: "Export Data" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "bg-blue-600 text-white px-4 py-2 rounded-lg text-sm font-medium hover:bg-blue-700", children: "+ Add Godown" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-4 rounded-xl border border-slate-200 shadow-sm flex flex-col md:flex-row gap-4 items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative flex-1 w-full", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Search, { className: "absolute left-3 top-1/2 transform -translate-y-1/2 text-slate-400", size: 20 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                placeholder: "Search by Godown Name, ID, or District...",
                className: "w-full pl-10 pr-4 py-2 border border-slate-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm",
                value: searchTerm,
                onChange: (e) => setSearchTerm(e.target.value)
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 w-full md:w-auto overflow-x-auto pb-2 md:pb-0", children: [
            ["District", "Commodity", "Risk Level", "Utilization"].map((filter) => /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "flex items-center space-x-1 px-3 py-2 border border-slate-200 rounded-lg text-sm text-slate-600 hover:bg-slate-50 whitespace-nowrap bg-white", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: filter }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { size: 14 })
            ] }, filter)),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "flex items-center space-x-1 px-3 py-2 border border-slate-200 rounded-lg text-sm text-slate-600 hover:bg-slate-50 whitespace-nowrap bg-slate-50", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Filter, { size: 14 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "More" })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl border border-slate-200 shadow-sm overflow-hidden", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "w-full text-sm text-left", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { className: "bg-slate-50 text-slate-500 font-medium", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-4 border-b", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-1 cursor-pointer hover:text-slate-700", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Godown ID" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowUpDown, { size: 14 })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-4 border-b", children: "Name & District" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-4 border-b text-right", children: "Capacity (MT)" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-4 border-b text-right", children: "Stock (MT)" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-4 border-b text-right", children: "Util %" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-4 border-b", children: "Risk Score" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-4 border-b", children: "Status" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-4 border-b", children: "Last Insp." }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-4 border-b text-center", children: "Actions" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { className: "divide-y divide-slate-100", children: godowns.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: "hover:bg-slate-50 transition-colors", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 text-slate-600 font-mono", children: item.id }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: "px-6 py-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-medium text-slate-900", children: item.name }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-slate-500", children: item.district })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 text-right text-slate-600", children: item.capacity.toLocaleString() }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 text-right text-slate-600", children: item.stock.toLocaleString() }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 text-right", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-end space-x-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-slate-700 font-medium", children: [
                  item.util,
                  "%"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-16 h-1.5 bg-slate-200 rounded-full overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: `h-full rounded-full ${item.util > 90 ? "bg-red-500" : "bg-blue-500"}`,
                    style: { width: `${item.util}%` }
                  }
                ) })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `font-bold ${item.risk > 75 ? "text-red-600" : item.risk > 50 ? "text-amber-600" : "text-green-600"}`, children: item.risk }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `px-2.5 py-1 rounded-full text-xs font-medium border ${item.status === "Critical" || item.status === "High Risk" ? "bg-red-50 text-red-700 border-red-200" : item.status === "Watch" ? "bg-amber-50 text-amber-700 border-amber-200" : "bg-green-50 text-green-700 border-green-200"}`, children: item.status }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 text-slate-500 text-xs", children: item.lastInsp }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center space-x-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: `/godown/${item.id}`, className: "p-1.5 text-blue-600 hover:bg-blue-50 rounded transition-colors", title: "View Details", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Eye, { size: 16 }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "p-1.5 text-slate-400 hover:bg-slate-100 hover:text-slate-600 rounded transition-colors", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MoreHorizontal, { size: 16 }) })
              ] }) })
            ] }, item.id)) })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "px-6 py-4 border-t border-slate-100 flex items-center justify-between text-sm text-slate-500", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Showing 6 of 248 godowns" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "px-3 py-1 border rounded hover:bg-slate-50 disabled:opacity-50", children: "Previous" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "px-3 py-1 border rounded hover:bg-slate-50", children: "Next" })
            ] })
          ] })
        ] })
      ] });
    };
    const CommodityCard = ({ name, totalStock, oldStock, days, color: color2 }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-5 rounded-xl border border-slate-200 shadow-sm relative overflow-hidden", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `absolute top-0 right-0 p-2 opacity-10 ${color2}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-16 h-16 rounded-full bg-current" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-slate-500 text-sm font-medium mb-2", children: name }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-end space-x-2 mb-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-2xl font-bold text-slate-800", children: totalStock }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-slate-500 mb-1", children: "MT" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between text-xs", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-slate-500", children: "Avg. Aging" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-medium text-slate-700", children: [
            days,
            " days"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between text-xs", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-slate-500", children: "Above Threshold" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium text-red-600", children: oldStock })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full bg-slate-100 h-1.5 rounded-full mt-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `h-full rounded-full ${color2.replace("text", "bg").replace("500", "600")}`, style: { width: "70%" } }) })
      ] })
    ] });
    const InventoryAging = () => {
      const agingData = [
        { range: "0-3 Months", rice: 4500, wheat: 2400, paddy: 6700 },
        { range: "3-6 Months", rice: 3200, wheat: 1800, paddy: 4100 },
        { range: "6-9 Months", rice: 1800, wheat: 900, paddy: 2200 },
        { range: "9-12 Months", rice: 800, wheat: 400, paddy: 1100 },
        { range: "> 1 Year", rice: 200, wheat: 150, paddy: 600 }
      ];
      const pieData = [
        { name: "Fresh Stock", value: 65, color: "#10b981" },
        // Green
        { name: "Aging", value: 25, color: "#f59e0b" },
        // Amber
        { name: "Critical", value: 10, color: "#ef4444" }
        // Red
      ];
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col md:flex-row justify-between items-start md:items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-2xl font-bold text-slate-800", children: "Inventory & Aging Analysis" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-500", children: "Track commodity lifespan and identify spoilage risks." })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 mt-4 md:mt-0", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "flex items-center space-x-2 bg-white border border-slate-200 px-3 py-2 rounded-lg text-sm font-medium hover:bg-slate-50", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Calendar, { size: 16 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "KMS 2023-24" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "flex items-center space-x-2 bg-white border border-slate-200 px-3 py-2 rounded-lg text-sm font-medium hover:bg-slate-50", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Filter, { size: 16 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Filter" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "flex items-center space-x-2 bg-blue-50 text-blue-700 px-3 py-2 rounded-lg text-sm font-medium hover:bg-blue-100", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Download, { size: 16 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Report" })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CommodityCard, { name: "Paddy", totalStock: "12,500", oldStock: "12%", days: "145", color: "text-yellow-500" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CommodityCard, { name: "Rice (Boiled)", totalStock: "8,400", oldStock: "5%", days: "85", color: "text-teal-500" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CommodityCard, { name: "Wheat", totalStock: "4,200", oldStock: "2%", days: "45", color: "text-amber-700" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CommodityCard, { name: "Sugar", totalStock: "1,800", oldStock: "0.5%", days: "20", color: "text-blue-500" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-3 gap-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lg:col-span-2 bg-white p-6 rounded-xl border border-slate-200 shadow-sm", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-lg font-bold text-slate-800 mb-6", children: "Aging Distribution by Commodity" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-80", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: "100%", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(BarChart, { data: agingData, margin: { top: 20, right: 30, left: 20, bottom: 5 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(CartesianGrid, { strokeDasharray: "3 3", vertical: false }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(XAxis, { dataKey: "range", tick: { fontSize: 12, fill: "#64748b" }, axisLine: false, tickLine: false }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(YAxis, { tick: { fontSize: 12, fill: "#64748b" }, axisLine: false, tickLine: false }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { cursor: { fill: "#f8fafc" }, contentStyle: { borderRadius: "8px", border: "none", boxShadow: "0 4px 6px -1px rgb(0 0 0 / 0.1)" } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Legend, { wrapperStyle: { paddingTop: "20px" } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Bar, { dataKey: "paddy", name: "Paddy", fill: "#eab308", radius: [4, 4, 0, 0] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Bar, { dataKey: "rice", name: "Rice", fill: "#14b8a6", radius: [4, 4, 0, 0] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Bar, { dataKey: "wheat", name: "Wheat", fill: "#b45309", radius: [4, 4, 0, 0] })
            ] }) }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-6 rounded-xl border border-slate-200 shadow-sm flex flex-col items-center justify-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-lg font-bold text-slate-800 w-full mb-4", children: "Stock Health Index" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "h-64 w-full relative", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: "100%", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(PieChart, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Pie,
                  {
                    data: pieData,
                    cx: "50%",
                    cy: "50%",
                    innerRadius: 60,
                    outerRadius: 80,
                    paddingAngle: 5,
                    dataKey: "value",
                    children: pieData.map((entry, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(Cell, { fill: entry.color }, `cell-${index}`))
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, {}),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Legend, { verticalAlign: "bottom", height: 36 })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 flex items-center justify-center pointer-events-none mb-8", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-3xl font-bold text-slate-800", children: "89%" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-slate-500", children: "Healthy" })
              ] }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full mt-4 p-4 bg-slate-50 rounded-lg text-sm text-slate-600", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "mb-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold text-slate-900", children: "Recommendation:" }),
              " Prioritize dispatch of 200 MT Rice from Thanjavur Godown A due to aging > 1 year."
            ] }) })
          ] })
        ] })
      ] });
    };
    const AlertItem = ({ title, location, date: date2, priority, onClick, isActive }) => {
      const priorityColors = {
        Critical: "bg-red-50 text-red-700 border-red-100",
        High: "bg-orange-50 text-orange-700 border-orange-100",
        Medium: "bg-yellow-50 text-yellow-700 border-yellow-100"
      };
      const iconColors = {
        Critical: "text-red-600",
        High: "text-orange-600",
        Medium: "text-yellow-600"
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          onClick,
          className: `p-4 border-b border-slate-100 cursor-pointer hover:bg-slate-50 transition-colors ${isActive ? "bg-blue-50/50" : ""}`,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-start mb-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `px-2 py-0.5 rounded text-xs font-medium border ${priorityColors[priority]}`, children: priority }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-slate-400", children: date2 })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start gap-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(AlertTriangle, { size: 18, className: `mt-0.5 ${iconColors[priority]}` }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-sm font-semibold text-slate-900 mb-1", children: title }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center text-xs text-slate-500 gap-1 mb-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(MapPin, { size: 12 }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: location })
                ] })
              ] })
            ] })
          ]
        }
      );
    };
    const TaskItem = ({ title, assignee, status }) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-3 bg-white border border-slate-200 rounded-lg", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3", children: [
          status === "Resolved" ? /* @__PURE__ */ jsxRuntimeExports.jsx(CheckCircle2, { className: "text-green-500", size: 20 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Circle, { className: "text-slate-300", size: 20 }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `text-sm font-medium ${status === "Resolved" ? "text-slate-400 line-through" : "text-slate-800"}`, children: title }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-slate-500", children: [
              "Assigned to: ",
              assignee
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-right", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `text-xs px-2 py-1 rounded-full ${status === "Resolved" ? "bg-green-100 text-green-700" : "bg-blue-100 text-blue-700"}`, children: status }) })
      ] });
    };
    const AlertsTasks = () => {
      const [activeAlert, setActiveAlert] = reactExports.useState(1);
      const alerts = [
        { id: 1, priority: "Critical", title: "Excess Moisture Detected", location: "Thanjavur Main Godown", date: "2 hrs ago", status: "Open" },
        { id: 2, priority: "High", title: "Aging Threshold Breached", location: "Mannargudi G1", date: "5 hrs ago", status: "In Progress" },
        { id: 3, priority: "Medium", title: "Pest Control Overdue", location: "Madurai North", date: "1 day ago", status: "Open" },
        { id: 4, priority: "Medium", title: "Stock Discrepancy", location: "Trichy Buffer", date: "2 days ago", status: "Resolved" }
      ];
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-3 gap-6 h-[calc(100vh-140px)]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl border border-slate-200 shadow-sm flex flex-col h-full overflow-hidden", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 border-b border-slate-100 flex justify-between items-center bg-slate-50", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "font-bold text-slate-800", children: "Alerts" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "text-slate-400 hover:text-slate-600", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Filter, { size: 18 }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-y-auto flex-1", children: alerts.map((alert2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            AlertItem,
            __spreadProps(__spreadValues({}, alert2), {
              isActive: activeAlert === alert2.id,
              onClick: () => setActiveAlert(alert2.id)
            }),
            alert2.id
          )) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lg:col-span-2 flex flex-col gap-6 h-full overflow-y-auto", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-6 rounded-xl border border-slate-200 shadow-sm", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-start mb-6", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 mb-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bg-red-100 text-red-700 text-xs font-bold px-2 py-1 rounded uppercase tracking-wide", children: "Critical Alert" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-slate-400 text-sm", children: "#ALT-2023-892" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-xl font-bold text-slate-900", children: "Excess Moisture Detected in Silo 4" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-slate-500 mt-1 flex items-center gap-1", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(MapPin, { size: 14 }),
                  " Thanjavur Main Godown  Reported by IoT Sensor System"
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "p-2 hover:bg-slate-100 rounded-full text-slate-400", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MoreVertical, { size: 20 }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-slate-50 p-4 rounded-lg mb-6 text-sm text-slate-700 leading-relaxed border border-slate-100", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Moisture levels in Silo 4 have exceeded 14% for the last 6 hours. Immediate aeration required to prevent fungal growth. Estimated impacted stock: 500 MT of Paddy." }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "bg-blue-600 text-white px-4 py-2 rounded-lg text-sm font-medium hover:bg-blue-700", children: "Assign Inspection" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "bg-white border border-slate-300 text-slate-700 px-4 py-2 rounded-lg text-sm font-medium hover:bg-slate-50", children: "Mark as False Alarm" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl border border-slate-200 shadow-sm flex-1 flex flex-col", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 border-b border-slate-100 flex justify-between items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-bold text-slate-800", children: "Related Tasks" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "text-blue-600 text-sm font-medium hover:underline", children: "+ New Task" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 space-y-3 flex-1 overflow-y-auto", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(TaskItem, { title: "Conduct manual moisture test", assignee: "R. Kumar (QM)", status: "In Progress" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TaskItem, { title: "Verify aeration fan functionality", assignee: "S. Singh (Tech)", status: "Open" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TaskItem, { title: "Notify Regional Manager", assignee: "System", status: "Resolved" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 border-t border-slate-100 bg-slate-50", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-xs font-bold text-slate-500 uppercase mb-3", children: "Comments" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4 mb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-3", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-8 h-8 rounded-full bg-blue-100 flex items-center justify-center text-blue-700 text-xs font-bold", children: "RK" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white p-3 rounded-lg border border-slate-200 shadow-sm", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-slate-700", children: "I'm on my way to the site. Will update in 30 mins." }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-slate-400 mt-1 pl-1", children: "R. Kumar  10 mins ago" })
                ] })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "text",
                    placeholder: "Write a comment...",
                    className: "w-full pl-4 pr-10 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "absolute right-2 top-1/2 transform -translate-y-1/2 text-blue-600 hover:text-blue-700", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Send, { size: 16 }) })
              ] })
            ] })
          ] })
        ] })
      ] });
    };
    const ImpactAnalytics = () => {
      const preventionData = [
        { district: "Thanjavur", prevented: 450, cost: 85 },
        { district: "Tiruvarur", prevented: 380, cost: 72 },
        { district: "Nagapattinam", prevented: 320, cost: 60 },
        { district: "Trichy", prevented: 280, cost: 52 },
        { district: "Madurai", prevented: 210, cost: 40 }
      ];
      const comparisonData = [
        { month: "Jan", pilot: 1.2, nonPilot: 3.5 },
        { month: "Feb", pilot: 1, nonPilot: 3.8 },
        { month: "Mar", pilot: 0.8, nonPilot: 4.2 },
        { month: "Apr", pilot: 0.9, nonPilot: 4 },
        { month: "May", pilot: 0.7, nonPilot: 4.5 },
        { month: "Jun", pilot: 0.6, nonPilot: 4.3 }
      ];
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col md:flex-row justify-between items-start md:items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-2xl font-bold text-slate-800", children: "Impact Analysis" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-500", children: "Quantifying the efficiency and savings of the RiskGuard system." })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 mt-4 md:mt-0", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "flex items-center space-x-2 bg-white border border-slate-200 px-3 py-2 rounded-lg text-sm font-medium hover:bg-slate-50 text-slate-600", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Printer, { size: 16 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Print" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "flex items-center space-x-2 bg-white border border-slate-200 px-3 py-2 rounded-lg text-sm font-medium hover:bg-slate-50 text-slate-600", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Share2, { size: 16 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Share" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "flex items-center space-x-2 bg-blue-600 text-white px-3 py-2 rounded-lg text-sm font-medium hover:bg-blue-700", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Download, { size: 16 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Export Report" })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-6 rounded-xl border border-slate-200 shadow-sm", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-bold text-slate-800 mb-2", children: "Spoilage Prevented by District" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-slate-500 mb-6", children: "Estimated metric tonnes saved through early intervention alerts." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-80", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: "100%", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ComposedChart, { data: preventionData, layout: "vertical", margin: { top: 0, right: 30, left: 40, bottom: 0 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(CartesianGrid, { stroke: "#f1f5f9", horizontal: false }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(XAxis, { type: "number", axisLine: false, tickLine: false }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(YAxis, { dataKey: "district", type: "category", axisLine: false, tickLine: false, width: 100, tick: { fontSize: 13, fill: "#475569" } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { cursor: { fill: "#f8fafc" }, contentStyle: { borderRadius: "8px", border: "none", boxShadow: "0 4px 6px -1px rgb(0 0 0 / 0.1)" } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Bar, { dataKey: "prevented", name: "Saved (MT)", fill: "#10b981", barSize: 20, radius: [0, 4, 4, 0] })
            ] }) }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-6 rounded-xl border border-slate-200 shadow-sm", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-bold text-slate-800 mb-2", children: "Pilot vs Non-Pilot Performance" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-slate-500 mb-6", children: "Spoilage rate (%) comparison over the last 6 months." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-80", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: "100%", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(LineChart, { data: comparisonData, margin: { top: 10, right: 30, left: 0, bottom: 0 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(CartesianGrid, { strokeDasharray: "3 3", vertical: false, stroke: "#f1f5f9" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(XAxis, { dataKey: "month", axisLine: false, tickLine: false, tick: { fill: "#64748b" }, dy: 10 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(YAxis, { axisLine: false, tickLine: false, tick: { fill: "#64748b" }, unit: "%" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { contentStyle: { borderRadius: "8px", border: "none", boxShadow: "0 4px 6px -1px rgb(0 0 0 / 0.1)" } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Legend, { verticalAlign: "top", height: 36 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { type: "monotone", dataKey: "pilot", name: "Pilot System (RiskGuard)", stroke: "#0ea5e9", strokeWidth: 3, dot: { r: 4 }, activeDot: { r: 6 } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { type: "monotone", dataKey: "nonPilot", name: "Traditional Monitoring", stroke: "#94a3b8", strokeWidth: 3, strokeDasharray: "5 5" })
            ] }) }) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gradient-to-br from-indigo-600 to-indigo-800 rounded-xl p-6 text-white shadow-lg relative overflow-hidden", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-0 right-0 w-32 h-32 bg-white rounded-full mix-blend-overlay opacity-10 -mr-16 -mt-16" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "text-indigo-200 text-sm font-bold uppercase mb-4 flex items-center gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
              " Financial Efficiency"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-baseline gap-2 mb-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-4xl font-bold", children: "12.4 Cr" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium bg-emerald-500/20 px-2 py-0.5 rounded text-emerald-300", children: "+15% YoY" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-indigo-100 text-xs mb-6", children: "Cumulative value preserved through spoilage prevention." }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pt-4 border-t border-indigo-500/30 flex justify-between items-center text-xs", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                "ROI: ",
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-white", children: "8.5x" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Mitigation Cost: 1.45 Cr" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl p-6 border border-slate-200 shadow-sm relative overflow-hidden", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "text-slate-500 text-sm font-bold uppercase mb-4 flex items-center gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
              " Beneficiary Reach"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-baseline gap-2 mb-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-4xl font-bold text-slate-800", children: "85%" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium text-emerald-600", children: "High Coverage" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-500 text-xs mb-4", children: "Percentage of Ration Shops receiving stock on-time." }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between text-xs font-medium text-slate-600", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Families Served" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold", children: "2.4 Crore" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full bg-slate-100 h-1.5 rounded-full overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-blue-500 h-full w-[85%]" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between text-xs font-medium text-slate-600 mt-1", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Card Holders Impacted" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-emerald-600", children: "98.2%" })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl p-6 border border-slate-200 shadow-sm relative overflow-hidden", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "text-slate-500 text-sm font-bold uppercase mb-4 flex items-center gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
              " Operational Velocity"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4 mt-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-2xl font-bold text-slate-800", children: "4.2 Hrs" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-slate-400", children: "Avg. Turnaround Time" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-emerald-600 font-bold mt-1", children: " 12% (Faster)" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-2xl font-bold text-slate-800", children: "99.8%" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-slate-400", children: "Stock Integrity" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-emerald-600 font-bold mt-1", children: " 0.5% (Improved)" })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-4 pt-4 border-t border-slate-100 flex items-center gap-2 text-xs text-slate-500", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(CheckCircle, { size: 14, className: "text-emerald-500" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Zero critical operational halts" })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl border border-slate-200 shadow-sm overflow-hidden", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-6 border-b border-slate-100", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-bold text-slate-800", children: "Infrastructure Gap Analysis" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "w-full text-sm text-left", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { className: "bg-slate-50 text-slate-500", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 font-medium", children: "District" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 font-medium", children: "Risk Score" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 font-medium", children: "Infra Gaps" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 font-medium", children: "Rec. Action" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("tbody", { className: "divide-y divide-slate-100", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-3 font-medium", children: "Dharmapuri" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-3 text-red-600 font-bold", children: "88" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-3", children: "Inadequate Dryer Coverage" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-3 text-blue-600", children: "Procure 12 Mobile Dryers" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-3 font-medium", children: "Villupuram" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-3 text-red-600 font-bold", children: "82" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-3", children: "Roof Leakages (G4/G5)" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-3 text-blue-600", children: "Urgent Civil Repair" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-3 font-medium", children: "Salem" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-3 text-amber-600 font-bold", children: "64" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-3", children: "Low Ventilation" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-3 text-blue-600", children: "Install Exhaust Systems" })
              ] })
            ] })
          ] })
        ] })
      ] });
    };
    const GodownList = () => {
      const { t: t2 } = useLanguage();
      const navigate = useNavigate();
      const [godowns, setGodowns] = reactExports.useState([]);
      reactExports.useEffect(() => {
        const fetchData = () => __async(exports, null, function* () {
          try {
            const response = yield api.get("/godowns");
            if (response.success) {
              setGodowns(response.data);
            }
          } catch (err) {
            console.error(err);
          }
        });
        fetchData();
      }, []);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 border-b bg-slate-50 flex justify-between items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-bold text-slate-700", children: t2("inventory") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-slate-500", children: "Updated: Just now" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "divide-y divide-slate-100 max-h-[500px] overflow-y-auto", children: godowns.map((g) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            onClick: () => navigate(`/godown/${g.id}`),
            className: "p-4 hover:bg-slate-50 cursor-pointer transition-colors flex justify-between items-center",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-bold text-slate-800", children: g.name }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-slate-500 mt-1", children: [
                  "ID: G-00",
                  g.id,
                  "  Last Insp: ",
                  g.lastInspection
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-right", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `text-xs font-bold px-2 py-1 rounded inline-block mb-1 ${g.risk === "High" ? "bg-red-100 text-red-700" : g.risk === "Medium" ? "bg-orange-100 text-orange-700" : "bg-green-100 text-green-700"}`, children: g.risk }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-slate-600 font-medium", children: [
                  g.stock,
                  " MT"
                ] })
              ] })
            ]
          },
          g.id
        )) })
      ] });
    };
    const KPICards = ({ data }) => {
      const { t: t2 } = useLanguage();
      const items = [
        { label: "highRiskGodowns", value: data.highRiskGodowns, color: "text-red-600", bg: "bg-red-50" },
        { label: "stockAtRisk", value: `${data.stockAtRisk} MT`, color: "text-orange-600", bg: "bg-orange-50" },
        { label: "incidentsToday", value: data.incidentsToday, color: "text-blue-600", bg: "bg-blue-50" },
        { label: "slaBreaches", value: data.slaBreaches, color: "text-purple-600", bg: "bg-purple-50" }
      ];
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-2 md:grid-cols-4 gap-4 mb-6", children: items.map((item, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${item.bg} p-4 rounded-xl border border-slate-200 shadow-sm`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-slate-500 font-medium mb-1", children: t2(item.label) || item.label }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `text-2xl font-bold ${item.color}`, children: item.value })
      ] }, index)) });
    };
    const RiskTrendChart = ({ data }) => {
      const { t: t2 } = useLanguage();
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-6 rounded-xl shadow-sm border border-slate-200", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-bold text-slate-700 mb-4", children: t2("riskTrend") || "Risk Incidents Trend" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-64", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: "100%", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(LineChart, { data, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CartesianGrid, { strokeDasharray: "3 3", stroke: "#f1f5f9" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(XAxis, { dataKey: "date", stroke: "#94a3b8", fontSize: 12, tickLine: false }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(YAxis, { stroke: "#94a3b8", fontSize: 12, tickLine: false }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Tooltip,
            {
              contentStyle: { borderRadius: "8px", border: "none", boxShadow: "0 4px 6px -1px rgb(0 0 0 / 0.1)" }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Legend, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { type: "monotone", dataKey: "incidents", name: "Incidents", stroke: "#ef4444", strokeWidth: 3, dot: { r: 4 }, activeDot: { r: 6 } }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { type: "monotone", dataKey: "resolved", name: "Resolved", stroke: "#10b981", strokeWidth: 3, dot: { r: 4 } })
        ] }) }) })
      ] });
    };
    const DistrictRiskChart = ({ data }) => {
      const { t: t2 } = useLanguage();
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-6 rounded-xl shadow-sm border border-slate-200", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-bold text-slate-700 mb-4", children: t2("districtRisk") || "District Risk Profile" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-64", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: "100%", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(BarChart, { data, layout: "vertical", margin: { left: 40 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CartesianGrid, { strokeDasharray: "3 3", stroke: "#f1f5f9", horizontal: true, vertical: false }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(XAxis, { type: "number", hide: true }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(YAxis, { dataKey: "name", type: "category", stroke: "#64748b", fontSize: 12, tickLine: false, width: 80 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { cursor: { fill: "#f8fafc" } }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Bar, { dataKey: "riskScore", name: "Risk Score", radius: [0, 4, 4, 0], barSize: 20, children: data.map((entry, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(Cell, { fill: entry.riskScore > 75 ? "#ef4444" : entry.riskScore > 50 ? "#f97316" : "#3b82f6" }, `cell-${index}`)) })
        ] }) }) })
      ] });
    };
    const AlertsQueue = ({ alerts }) => {
      const { t: t2 } = useLanguage();
      const getStatusColor = (sev) => {
        if (sev === "Critical") return "bg-red-100 text-red-800";
        if (sev === "High") return "bg-orange-100 text-orange-800";
        return "bg-blue-100 text-blue-800";
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden col-span-1 md:col-span-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 border-b border-slate-100 flex justify-between items-center bg-slate-50", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-bold text-slate-700", children: t2("activeAlerts") || "Active Alerts Queue" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-xs font-bold bg-red-500 text-white px-2 py-1 rounded-full", children: [
            alerts.length,
            " New"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "w-full text-sm text-left", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { className: "text-xs text-slate-500 uppercase bg-slate-50 border-b", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: "Time" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: "Location" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: "Issue" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: "Severity" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: "Assignee" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: "Action" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: alerts.map((alert2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: "bg-white border-b hover:bg-slate-50", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 font-mono text-slate-500", children: alert2.time }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 font-bold text-slate-700", children: alert2.location }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4", children: alert2.type }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `px-2 py-1 rounded-full text-xs font-bold ${getStatusColor(alert2.severity)}`, children: alert2.severity }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4", children: alert2.assignee === "Unassigned" ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-slate-400 italic", children: "Unassigned" }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-6 h-6 rounded-full bg-slate-200 flex items-center justify-center text-xs font-bold", children: alert2.assignee.charAt(0) }),
              alert2.assignee
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "text-blue-600 hover:text-blue-800 font-bold text-xs border border-blue-200 px-3 py-1 rounded hover:bg-blue-50 transition-colors", children: "Review" }) })
          ] }, alert2.id)) })
        ] }) })
      ] });
    };
    const AnalyticsDashboard = () => {
      const [stats, setStats] = reactExports.useState(null);
      const [trend, setTrend] = reactExports.useState([]);
      const [districts, setDistricts] = reactExports.useState([]);
      const [alerts, setAlerts] = reactExports.useState([]);
      const [loading, setLoading] = reactExports.useState(true);
      reactExports.useEffect(() => {
        const fetchData = () => __async(exports, null, function* () {
          try {
            const [kpiRes, trendRes, distRes, alertsRes] = yield Promise.all([
              fetch("/api/analytics/kpi"),
              fetch("/api/analytics/risk-trend"),
              fetch("/api/analytics/district-stats"),
              fetch("/api/analytics/alerts")
            ]);
            setStats(yield kpiRes.json());
            setTrend(yield trendRes.json());
            setDistricts(yield distRes.json());
            setAlerts(yield alertsRes.json());
            setLoading(false);
          } catch (err) {
            console.error("Failed to load analytics data", err);
            setLoading(false);
          }
        });
        fetchData();
      }, []);
      if (loading) return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-12 text-center text-slate-500 animate-pulse", children: "Loading Analytics Engine..." });
      if (!stats) return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-12 text-center text-red-500", children: "Failed to load data. API offline?" });
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6 animate-slide-in", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(KPICards, { data: stats }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(RiskTrendChart, { data: trend }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DistrictRiskChart, { data: districts })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlertsQueue, { alerts }) })
      ] });
    };
    const TruckChallanTable = ({ data, type }) => {
      const { t: t2 } = useLanguage();
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "w-full text-sm text-left", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { className: "text-xs text-slate-500 uppercase bg-slate-50 border-b", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: t2("date") || "Date" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: t2("truckNo") || "Truck No" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: t2("commodity") || "Commodity" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: t2("quantity") || "Quantity" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: type === "INWARD" ? t2("source") || "Source" : t2("destination") || "Destination" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: t2("status") || "Status" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: t2("action") || "Action" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: data.map((row) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: "bg-white border-b hover:bg-slate-50", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 font-mono text-slate-500", children: row.date }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 font-bold text-slate-700", children: row.truckNo }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4", children: row.commodity }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 font-bold", children: row.quantity }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4", children: type === "INWARD" ? row.source : row.destination }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `px-2 py-1 rounded-full text-xs font-bold ${row.status === "Completed" || row.status === "Delivered" ? "bg-green-100 text-green-800" : row.status === "In Transit" ? "bg-blue-100 text-blue-800" : "bg-orange-100 text-orange-800"}`, children: row.status }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "text-blue-600 hover:text-blue-800 font-bold text-xs underline", children: t2("viewManifest") || "View Manifest" }) })
        ] }, row.id)) })
      ] }) }) });
    };
    const RailTable = ({ data }) => {
      const { t: t2 } = useLanguage();
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "w-full text-sm text-left", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { className: "text-xs text-slate-500 uppercase bg-slate-50 border-b", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: t2("trainNo") || "Train No" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: t2("wagons") || "Wagons" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: t2("commodity") || "Commodity" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: t2("source") || "Source Depot" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: t2("destination") || "Destination" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: t2("eta") || "ETA" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: t2("status") || "Status" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: data.map((row) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: "bg-white border-b hover:bg-slate-50", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 font-mono font-bold text-slate-700", children: row.trainNo }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4", children: row.wagons }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4", children: row.commodity }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4", children: row.source }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4", children: row.destination }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 font-bold", children: row.eta }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `px-2 py-1 rounded-full text-xs font-bold ${row.status.includes("Verified") ? "bg-blue-100 text-blue-800" : "bg-slate-100 text-slate-600"}`, children: row.status }) })
        ] }, row.id)) })
      ] }) }) });
    };
    const LotDrillDown = ({ godownId, onClose }) => {
      const { t: t2 } = useLanguage();
      const [lots, setLots] = reactExports.useState([]);
      reactExports.useEffect(() => {
        fetch(`/api/stock/lots/${godownId}`).then((res) => res.json()).then((data) => setLots(data));
      }, [godownId]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4 animate-fade-in", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl shadow-2xl w-full max-w-2xl overflow-hidden", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 border-b border-gray-200 flex justify-between items-center bg-slate-50", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-bold text-lg text-slate-800", children: t2("stockLots") || "Stock Lot Details" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-slate-500", children: [
              t2("godown") || "Godown",
              ": ",
              godownId
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: onClose, className: "text-gray-400 hover:text-gray-700", children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { size: 24 }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-0 overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "w-full text-sm text-left", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { className: "bg-slate-100 text-xs uppercase text-slate-500", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-4 py-3", children: "Stack No" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-4 py-3", children: "Commodity" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-4 py-3 text-right", children: "Bags" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-4 py-3 text-right", children: "Weight" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-4 py-3 text-center", children: "Moisture" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-4 py-3 text-center", children: "Age" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { className: "divide-y divide-slate-100", children: lots.map((lot) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: "hover:bg-blue-50/50", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-4 py-3 font-mono font-bold text-slate-700", children: lot.stackNo }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: "px-4 py-3", children: [
              lot.commodity,
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-xs text-gray-400", children: [
                "(",
                lot.grade,
                ")"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-4 py-3 text-right", children: lot.bags }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-4 py-3 text-right font-bold", children: lot.weight }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-4 py-3 text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `px-2 py-0.5 rounded text-xs font-bold ${parseFloat(lot.moisture) > 13 ? "bg-red-100 text-red-700" : "bg-green-100 text-green-700"}`, children: lot.moisture }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-4 py-3 text-center text-slate-500", children: lot.age })
          ] }, lot.id)) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4 bg-slate-50 border-t flex justify-end", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: onClose, className: "px-4 py-2 bg-slate-200 hover:bg-slate-300 text-slate-700 rounded-lg font-bold text-sm", children: t2("close") || "Close" }) })
      ] }) });
    };
    const RouteRiskItem = ({ route, riskLevel, issues, count }) => {
      const getColor = (l2) => {
        if (l2 === "High") return "text-red-600 bg-red-50 border-red-200";
        if (l2 === "Medium") return "text-orange-600 bg-orange-50 border-orange-200";
        return "text-blue-600 bg-blue-50 border-blue-200";
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-4 border-b border-slate-100 last:border-0 hover:bg-slate-50", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-slate-800", children: route }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `text-xs px-2 py-0.5 rounded font-bold border ${getColor(riskLevel)}`, children: [
              riskLevel,
              " Risk"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-slate-500 mt-1", children: issues })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-right", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "font-bold text-slate-900", children: [
            count,
            " Trucks"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-emerald-600 font-bold", children: "Live Tracking" })
        ] })
      ] });
    };
    const MovementDashboard = () => {
      const { t: t2 } = useLanguage();
      const [view, setView] = reactExports.useState("INWARD");
      const [inwardData, setInwardData] = reactExports.useState([]);
      const [outwardData, setOutwardData] = reactExports.useState([]);
      const [railData, setRailData] = reactExports.useState([]);
      const [showDrillDown, setShowDrillDown] = reactExports.useState(false);
      const routeRisks = [
        { route: "Thanjavur - Mannargudi Main Rd", riskLevel: "High", issues: "Severe Potholes  High Theft Zone", count: 12 },
        { route: "Trichy - Madurai NH45", riskLevel: "Medium", issues: "Traffic Congestion  Delay Expected", count: 8 },
        { route: "Nagapattinam Coastal Route", riskLevel: "High", issues: "Flood Warning  Diversion Active", count: 5 }
      ];
      reactExports.useEffect(() => {
        fetch("/api/movement/inward").then((res) => res.json()).then(setInwardData);
        fetch("/api/movement/outward").then((res) => res.json()).then(setOutwardData);
        fetch("/api/movement/rail").then((res) => res.json()).then(setRailData);
      }, []);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6 animate-slide-in", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-1 rounded-lg border border-slate-200 inline-flex shadow-sm", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => setView("INWARD"),
                className: `px-4 py-2 rounded-md text-sm font-bold transition-all ${view === "INWARD" ? "bg-blue-600 text-white shadow-md" : "text-slate-500 hover:bg-slate-50"}`,
                children: t2("inwardMovement") || "Inward (Procurement)"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => setView("OUTWARD"),
                className: `px-4 py-2 rounded-md text-sm font-bold transition-all ${view === "OUTWARD" ? "bg-purple-600 text-white shadow-md" : "text-slate-500 hover:bg-slate-50"}`,
                children: t2("outwardMovement") || "Outward (FPS/Processing)"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => setView("RAIL"),
                className: `px-4 py-2 rounded-md text-sm font-bold transition-all ${view === "RAIL" ? "bg-orange-600 text-white shadow-md" : "text-slate-500 hover:bg-slate-50"}`,
                children: t2("railConsignments") || "Rail Consignments"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "px-4 py-2 bg-red-50 text-red-700 border border-red-200 rounded-lg text-sm font-bold hover:bg-red-100 flex items-center gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
              " Transit Risks (3)"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                onClick: () => setShowDrillDown(true),
                className: "px-4 py-2 bg-emerald-100 text-emerald-700 border border-emerald-200 rounded-lg text-sm font-bold hover:bg-emerald-200 flex items-center gap-2",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
                  " ",
                  t2("inspectStock") || "Inspect Stock Lots"
                ]
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-3 gap-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lg:col-span-2 grid grid-cols-1 md:grid-cols-3 gap-4 h-min", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-4 rounded-xl border border-slate-200 shadow-sm", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-slate-500 uppercase font-bold", children: "Today's Trucks" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-2xl font-bold text-slate-800", children: view === "INWARD" ? inwardData.length : outwardData.length })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-4 rounded-xl border border-slate-200 shadow-sm", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-slate-500 uppercase font-bold", children: "Volume Moved" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-2xl font-bold text-slate-800", children: "450 MT" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-4 rounded-xl border border-slate-200 shadow-sm", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-slate-500 uppercase font-bold", children: "Pending Clearance" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-2xl font-bold text-orange-600", children: "2" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "md:col-span-3", children: view === "RAIL" ? /* @__PURE__ */ jsxRuntimeExports.jsx(RailTable, { data: railData }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
              TruckChallanTable,
              {
                data: view === "INWARD" ? inwardData : outwardData,
                type: view
              }
            ) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl border border-slate-200 shadow-sm overflow-hidden h-fit", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 border-b border-slate-100 bg-slate-50 flex justify-between items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-bold text-slate-800", children: " High Risk Routes" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs font-bold text-red-600 bg-red-100 px-2 py-1 rounded", children: "Live Updates" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "divide-y divide-slate-100", children: routeRisks.map((risk, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(RouteRiskItem, __spreadValues({}, risk), index)) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-3 bg-slate-50 text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "text-xs font-bold text-blue-600 hover:underline", children: "View All Route Alerts" }) })
          ] })
        ] }),
        showDrillDown && /* @__PURE__ */ jsxRuntimeExports.jsx(LotDrillDown, { godownId: "G-THJ-001", onClose: () => setShowDrillDown(false) })
      ] });
    };
    const UserManagement = () => {
      const { t: t2 } = useLanguage();
      const [users, setUsers] = reactExports.useState([]);
      reactExports.useEffect(() => {
        fetch("/api/admin/users").then((res) => res.json()).then(setUsers);
      }, []);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 border-b border-slate-100 bg-slate-50 flex justify-between items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-bold text-slate-700", children: t2("userManagement") || "User Management" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "bg-blue-600 text-white px-3 py-1 rounded-lg text-sm font-bold shadow hover:bg-blue-700", children: [
            "+ ",
            t2("newUser") || "Add User"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "w-full text-sm text-left", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { className: "text-xs text-slate-500 uppercase bg-slate-50 border-b", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: t2("name") || "Name" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: t2("role") || "Role" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: t2("region") || "Region" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: t2("lastActive") || "Last Active" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3", children: t2("action") || "Action" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: users.map((user) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: "bg-white border-b hover:bg-slate-50", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 font-bold text-slate-700", children: user.name }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bg-slate-100 text-slate-700 font-bold px-2 py-1 rounded text-xs", children: user.role }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4", children: user.region }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 text-emerald-600 font-medium", children: user.lastActive }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "text-slate-400 hover:text-red-600 font-bold text-xs uppercase", children: t2("revoke") || "Revoke" }) })
          ] }, user.id)) })
        ] })
      ] });
    };
    const RiskConfig = () => {
      const { t: t2 } = useLanguage();
      const [rules, setRules] = reactExports.useState({ humidityThreshold: 0, moistureThreshold: 0, stockAgeAlert: 0 });
      reactExports.useEffect(() => {
        fetch("/api/admin/rules").then((res) => res.json()).then(setRules);
      }, []);
      const handleChange = (key, value) => {
        setRules((prev) => __spreadProps(__spreadValues({}, prev), { [key]: value }));
      };
      const handleSave = () => {
        fetch("/api/admin/rules", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(rules)
        }).then((res) => res.json()).then((data) => alert(data.message));
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4 border-b border-slate-100 bg-slate-50", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-bold text-slate-700", children: t2("riskConfig") || "Risk Configuration" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6 space-y-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "block text-sm font-bold text-slate-700 mb-2", children: [
              t2("humidityThreshold") || "Max Humidity Allowed",
              " (%)"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "range",
                  min: "50",
                  max: "100",
                  value: rules.humidityThreshold || 0,
                  onChange: (e) => handleChange("humidityThreshold", e.target.value),
                  className: "w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-bold text-lg w-12 text-center text-blue-600", children: [
                rules.humidityThreshold,
                "%"
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "block text-sm font-bold text-slate-700 mb-2", children: [
              t2("moistureThreshold") || "Max Grain Moisture",
              " (%)"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "range",
                  min: "10",
                  max: "25",
                  step: "0.1",
                  value: rules.moistureThreshold || 0,
                  onChange: (e) => handleChange("moistureThreshold", e.target.value),
                  className: "w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-orange-600"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-bold text-lg w-12 text-center text-orange-600", children: [
                rules.moistureThreshold,
                "%"
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "block text-sm font-bold text-slate-700 mb-2", children: [
              t2("stockAge") || "Stock Aging Alert",
              " (Days)"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "number",
                value: rules.stockAgeAlert || 0,
                onChange: (e) => handleChange("stockAgeAlert", e.target.value),
                className: "border border-slate-300 rounded px-3 py-2 w-full font-bold text-slate-700"
              }
            ) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pt-4 border-t", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: handleSave,
              className: "w-full bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 rounded-lg shadow-md transition-colors",
              children: t2("saveConfig") || "Update Configuration"
            }
          ) })
        ] })
      ] });
    };
    const ComplianceWidget = () => {
      const { t: t2 } = useLanguage();
      const resources = [
        { title: "Stock Verification Form (Form A)", type: "PDF", size: "2.4 MB" },
        { title: "Inspection Template (High Risk)", type: "DOCX", size: "1.1 MB" },
        { title: "Standard Operating Procedure (SOP) v4.2", type: "PDF", size: "5.6 MB" },
        { title: "Latest Circulars - Monsoon Prep", type: "PDF", size: "890 KB" }
      ];
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-2 gap-6 p-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl shadow-sm border border-slate-200 p-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "text-lg font-bold text-slate-800 mb-4 flex items-center gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
            " ",
            t2("forms") || "Official Downloads"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3", children: resources.map((res, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-3 bg-slate-50 border border-slate-100 rounded-lg hover:bg-slate-100 cursor-pointer transition-colors group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bg-white px-2 py-1 rounded border border-slate-200 text-xs font-bold text-slate-500", children: res.type }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium text-slate-700 group-hover:text-blue-700", children: res.title })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-slate-400", children: res.size })
          ] }, i)) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "w-full mt-4 py-2 text-sm text-blue-600 font-bold hover:bg-blue-50 rounded-lg border border-transparent hover:border-blue-100 transition-all", children: "View All Repository" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl shadow-sm border border-slate-200 p-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "text-lg font-bold text-slate-800 mb-4 flex items-center gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
            " ",
            t2("escalation") || "Escalation Matrix"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute left-6 top-4 bottom-4 w-0.5 bg-slate-200" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6 relative", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start gap-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-12 h-12 bg-white border-2 border-emerald-500 rounded-full flex items-center justify-center z-10 font-bold text-emerald-700 shadow-sm text-xs", children: "L1" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-bold text-slate-800", children: "Godown In-Charge" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-slate-500", children: "Immediate resolution of moisture/pest alerts." }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs bg-emerald-100 text-emerald-800 px-2 py-0.5 rounded mt-1 inline-block", children: "SLA: 4 Hours" })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start gap-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-12 h-12 bg-white border-2 border-orange-500 rounded-full flex items-center justify-center z-10 font-bold text-orange-700 shadow-sm text-xs", children: "L2" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-slate-500", children: "If stock value at risk > 50L or unresolved L1." }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs bg-orange-100 text-orange-800 px-2 py-0.5 rounded mt-1 inline-block", children: "SLA: 24 Hours" })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start gap-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-12 h-12 bg-white border-2 border-red-500 rounded-full flex items-center justify-center z-10 font-bold text-red-700 shadow-sm text-xs", children: "L3" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-bold text-slate-800", children: "HQ General Manager" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-slate-500", children: "Critical structural failure or mass spoilage risk." }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs bg-red-100 text-red-800 px-2 py-0.5 rounded mt-1 inline-block", children: "SLA: Immediate" })
                ] })
              ] })
            ] })
          ] })
        ] })
      ] });
    };
    const AdminPanel = () => {
      const { t: t2 } = useLanguage();
      const [subTab, setSubTab] = reactExports.useState("USERS");
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6 animate-slide-in", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-1 rounded-lg border border-slate-200 inline-flex shadow-sm mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => setSubTab("USERS"),
              className: `px-4 py-2 rounded-md text-sm font-bold transition-all ${subTab === "USERS" ? "bg-slate-800 text-white shadow-md" : "text-slate-500 hover:bg-slate-50"}`,
              children: t2("users") || "Users & Roles"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => setSubTab("CONFIG"),
              className: `px-4 py-2 rounded-md text-sm font-bold transition-all ${subTab === "CONFIG" ? "bg-slate-800 text-white shadow-md" : "text-slate-500 hover:bg-slate-50"}`,
              children: t2("configuration") || "System Configuration"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => setSubTab("RESOURCES"),
              className: `px-4 py-2 rounded-md text-sm font-bold transition-all ${subTab === "RESOURCES" ? "bg-slate-800 text-white shadow-md" : "text-slate-500 hover:bg-slate-50"}`,
              children: t2("resources") || "Resources & Compliance"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
          subTab === "USERS" && /* @__PURE__ */ jsxRuntimeExports.jsx(UserManagement, {}),
          subTab === "CONFIG" && /* @__PURE__ */ jsxRuntimeExports.jsx(RiskConfig, {}),
          subTab === "RESOURCES" && /* @__PURE__ */ jsxRuntimeExports.jsx(ComplianceWidget, {})
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl shadow-sm border border-slate-200 p-6 opacity-60", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-bold text-slate-700 mb-2", children: t2("auditLog") || "System Audit Log" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-slate-500 border-b pb-2", children: "Admin updated humidity threshold to 82%  2 mins ago" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-slate-500 border-b pb-2", children: "User K. Meera logged in from Thanjavur  2 hours ago" })
          ] })
        ] })
      ] });
    };
    const HQDashboard = () => {
      const { t: t2, language, toggleLanguage } = useLanguage();
      const navigate = useNavigate();
      const [activeTab, setActiveTab] = reactExports.useState("OVERVIEW");
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex h-screen bg-slate-50 font-sans text-slate-900", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("aside", { className: "w-64 bg-slate-900 text-white flex flex-col shadow-xl", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6 border-b border-slate-800 flex items-center gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "https://upload.wikimedia.org/wikipedia/commons/8/83/TamilNadu_Logo.svg", alt: "TN Emblem", className: "w-10 h-10 brightness-200 grayscale opacity-80" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-sm font-extrabold tracking-tight text-white leading-tight", children: t2("tncscFull") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-[10px] text-emerald-500 mt-1 uppercase tracking-wider font-bold", children: "Risk Command Center" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("nav", { className: "flex-1 p-4 space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => setActiveTab("OVERVIEW"),
                className: `w-full text-left px-4 py-3 rounded-lg text-sm font-medium transition-colors ${activeTab === "OVERVIEW" ? "bg-emerald-600 text-white shadow-lg" : "text-slate-400 hover:bg-slate-800 hover:text-white"}`,
                children: t2("dashboard")
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => setActiveTab("INVENTORY"),
                className: `w-full text-left px-4 py-3 rounded-lg text-sm font-medium transition-colors ${activeTab === "INVENTORY" ? "bg-emerald-600 text-white shadow-lg" : "text-slate-400 hover:bg-slate-800 hover:text-white"}`,
                children: t2("inventory")
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => setActiveTab("ANALYTICS"),
                className: `w-full text-left px-4 py-3 rounded-lg text-sm font-medium transition-colors ${activeTab === "ANALYTICS" ? "bg-emerald-600 text-white shadow-lg" : "text-slate-400 hover:bg-slate-800 hover:text-white"}`,
                children: t2("analytics")
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => setActiveTab("MOVEMENT"),
                className: `w-full text-left px-4 py-3 rounded-lg text-sm font-medium transition-colors ${activeTab === "MOVEMENT" ? "bg-emerald-600 text-white shadow-lg" : "text-slate-400 hover:bg-slate-800 hover:text-white"}`,
                children: t2("stockLogistics") || "Stock & Logistics"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => setActiveTab("ADMIN"),
                className: `w-full text-left px-4 py-3 rounded-lg text-sm font-medium transition-colors ${activeTab === "ADMIN" ? "bg-emerald-600 text-white shadow-lg" : "text-slate-400 hover:bg-slate-800 hover:text-white"}`,
                children: t2("adminPanel") || "Administration"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 border-t border-slate-800", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: toggleLanguage,
                className: "w-full mb-3 px-4 py-2 bg-slate-800 rounded-lg text-xs font-bold text-slate-300 hover:text-white border border-slate-700",
                children: language === "en" ? "Switch to Tamil ()" : "Switch to English"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                onClick: () => navigate("/"),
                className: "w-full px-4 py-2 bg-slate-800 hover:bg-red-900/30 text-slate-400 hover:text-red-400 rounded-lg text-xs font-bold transition-colors flex items-center gap-2",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
                  " ",
                  t2("signOut")
                ]
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("main", { className: "flex-1 overflow-hidden flex flex-col", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { className: "bg-white h-16 border-b border-slate-200 flex items-center justify-between px-8 shadow-sm z-10", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "text-lg font-bold text-slate-800", children: [
              activeTab === "OVERVIEW" && t2("riskMap"),
              activeTab === "INVENTORY" && t2("inventory"),
              activeTab === "INVENTORY" && t2("inventory"),
              activeTab === "ANALYTICS" && t2("analytics"),
              activeTab === "MOVEMENT" && (t2("stockLogistics") || "Stock & Logistics"),
              activeTab === "ADMIN" && (t2("adminPanel") || "Administration")
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "w-2 h-2 bg-emerald-500 rounded-full animate-pulse" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs font-bold text-slate-600", children: "System Online" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-8 h-8 rounded-full bg-slate-200 border-2 border-white shadow flex items-center justify-center font-bold text-slate-500 text-xs", children: "HQ" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 overflow-auto p-8 relative", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 opacity-5 pointer-events-none", style: { backgroundImage: "radial-gradient(#cbd5e1 1px, transparent 1px)", backgroundSize: "24px 24px" } }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-7xl mx-auto relative z-0", children: [
              activeTab === "OVERVIEW" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-3 gap-8", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lg:col-span-2 space-y-6", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(RiskMap, {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-4", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-4 rounded-xl border border-slate-200 shadow-sm", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-slate-500 mb-1", children: "Total Stock" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xl font-bold text-slate-800", children: "12,450 MT" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-4 rounded-xl border border-slate-200 shadow-sm", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-slate-500 mb-1", children: "Active Alerts" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xl font-bold text-amber-600", children: "3 High" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-4 rounded-xl border border-slate-200 shadow-sm", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-slate-500 mb-1", children: "Weather" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xl font-bold text-blue-600", children: "Raining" })
                    ] })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(GodownList, {}) })
              ] }),
              activeTab === "INVENTORY" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl shadow border border-slate-200 p-6 min-h-[500px]", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-bold mb-4", children: "Godown Network Inventory" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(GodownList, {})
              ] }),
              activeTab === "ANALYTICS" && /* @__PURE__ */ jsxRuntimeExports.jsx(AnalyticsDashboard, {}),
              activeTab === "MOVEMENT" && /* @__PURE__ */ jsxRuntimeExports.jsx(MovementDashboard, {}),
              activeTab === "ADMIN" && /* @__PURE__ */ jsxRuntimeExports.jsx(AdminPanel, {})
            ] })
          ] })
        ] })
      ] });
    };
    const StockLogistics = () => {
      const vehicleStatusData = [
        { name: "Active (On Route)", value: 145, color: "#10b981" },
        { name: "Loading", value: 42, color: "#3b82f6" },
        { name: "Unloading", value: 38, color: "#f59e0b" },
        { name: "Idle/Maintenance", value: 15, color: "#64748b" }
      ];
      const tatData = [
        { hub: "Thanjavur Central", loading: 45, unloading: 35 },
        { hub: "Mannargudi", loading: 55, unloading: 40 },
        { hub: "Kumbakonam", loading: 30, unloading: 25 },
        { hub: "Pattukkottai", loading: 60, unloading: 45 },
        { hub: "Nagapattinam", loading: 50, unloading: 30 }
      ];
      const transferData = [
        { from: "Thanjavur", to: "Tiruvarur", quantity: "450 MT", status: "In Transit" },
        { from: "Mannargudi", to: "Chennai CPC", quantity: "1200 MT", status: "Scheduled" },
        { from: "Kumbakonam", to: "Trichy", quantity: "320 MT", status: "Delivered" },
        { from: "Thanjavur", to: "Nagapattinam", quantity: "500 MT", status: "In Transit" }
      ];
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6 animate-slide-in", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-2xl font-bold text-slate-800", children: "Stock & Logistics Command" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-4 gap-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white p-6 rounded-xl border border-slate-200 shadow-sm", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-start", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-500 text-xs font-bold uppercase", children: "Total Fleet Active" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-3xl font-bold text-slate-800 mt-2", children: "240" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-3 bg-blue-50 text-blue-600 rounded-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Truck, { size: 24 }) })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white p-6 rounded-xl border border-slate-200 shadow-sm", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-start", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-500 text-xs font-bold uppercase", children: "Avg Turnaround (TAT)" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-3xl font-bold text-slate-800 mt-2", children: "4.2h" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-emerald-600 font-bold mt-1", children: " 12% vs last week" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-3 bg-emerald-50 text-emerald-600 rounded-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Clock, { size: 24 }) })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white p-6 rounded-xl border border-slate-200 shadow-sm", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-start", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-500 text-xs font-bold uppercase", children: "Inter-Godown Transfer" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-3xl font-bold text-slate-800 mt-2", children: "2.4k MT" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-3 bg-purple-50 text-purple-600 rounded-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCw, { size: 24 }) })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white p-6 rounded-xl border border-slate-200 shadow-sm", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-start", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-500 text-xs font-bold uppercase", children: "Fleet Utilization" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-3xl font-bold text-slate-800 mt-2", children: "92%" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-3 bg-amber-50 text-amber-600 rounded-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsx(BarChart3, { size: 24 }) })
          ] }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-2 gap-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-6 rounded-xl border border-slate-200 shadow-sm", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-bold text-slate-800 mb-4", children: "Real-time Vehicle Status" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-64 flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: "100%", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(PieChart, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Pie,
                {
                  data: vehicleStatusData,
                  cx: "50%",
                  cy: "50%",
                  innerRadius: 60,
                  outerRadius: 80,
                  paddingAngle: 5,
                  dataKey: "value",
                  children: vehicleStatusData.map((entry, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(Cell, { fill: entry.color }, `cell-${index}`))
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { contentStyle: { borderRadius: "8px", border: "none" } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("text", { x: "50%", y: "50%", textAnchor: "middle", dominantBaseline: "middle", className: "text-xl font-bold fill-slate-800", children: "240 Total" })
            ] }) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap gap-4 justify-center mt-4", children: vehicleStatusData.map((item, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3 h-3 rounded-full", style: { backgroundColor: item.color } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs font-medium text-slate-600", children: item.name })
            ] }, index)) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-6 rounded-xl border border-slate-200 shadow-sm", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-bold text-slate-800 mb-4", children: "Turnaround Time by Hub (mins)" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-64", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: "100%", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(BarChart, { data: tatData, margin: { top: 20, right: 30, left: 20, bottom: 5 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(CartesianGrid, { strokeDasharray: "3 3", vertical: false }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(XAxis, { dataKey: "hub", axisLine: false, tickLine: false, tick: { fontSize: 10, fill: "#64748b" } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(YAxis, { axisLine: false, tickLine: false, tick: { fontSize: 10, fill: "#64748b" } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { cursor: { fill: "#f8fafc" }, contentStyle: { borderRadius: "8px", border: "none" } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Bar, { dataKey: "loading", name: "Loading Time", fill: "#3b82f6", radius: [4, 4, 0, 0] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Bar, { dataKey: "unloading", name: "Unloading Time", fill: "#10b981", radius: [4, 4, 0, 0] })
            ] }) }) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl border border-slate-200 shadow-sm overflow-hidden", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6 border-b border-slate-100 flex justify-between items-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-bold text-slate-800", children: "Active Inter-Godown Transfers" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "text-blue-600 text-sm font-bold hover:underline", children: "View All Schedules" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "w-full text-sm text-left", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { className: "bg-slate-50 text-slate-500", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 font-medium", children: "Source" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 font-medium", children: "Destination" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 font-medium", children: "Quantity" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 font-medium", children: "Status" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { className: "divide-y divide-slate-100", children: transferData.map((row, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: "hover:bg-slate-50", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 font-medium text-slate-700", children: row.from }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: "px-6 py-4 text-slate-600", children: [
                " ",
                row.to
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 font-bold", children: row.quantity }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `px-2 py-1 rounded text-xs font-bold ${row.status === "In Transit" ? "bg-blue-100 text-blue-700" : row.status === "Delivered" ? "bg-emerald-100 text-emerald-700" : "bg-slate-100 text-slate-700"}`, children: row.status }) })
            ] }, i)) })
          ] })
        ] })
      ] });
    };
    class ErrorBoundary extends React$3.Component {
      constructor(props) {
        super(props);
        this.state = { hasError: false, error: null };
      }
      static getDerivedStateFromError(error) {
        return { hasError: true, error };
      }
      componentDidCatch(error, errorInfo) {
        console.error("Uncaught error:", error, errorInfo);
      }
      render() {
        if (this.state.hasError) {
          return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "min-h-screen flex flex-col items-center justify-center bg-slate-50 text-center p-6", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-8 rounded-xl shadow-lg max-w-md w-full border border-slate-200", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-16 h-16 bg-red-100 rounded-full flex items-center justify-center mx-auto mb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-3xl", children: "" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-xl font-bold text-slate-900 mb-2", children: "Something went wrong" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-500 mb-6", children: "We encountered an unexpected error. The technical team has been notified." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => window.location.reload(),
                className: "w-full bg-slate-900 text-white py-3 rounded-lg font-bold hover:bg-slate-800 transition-colors",
                children: "Refresh Application"
              }
            ),
            false
          ] }) });
        }
        return this.props.children;
      }
    }
    function App() {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(HashRouter, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/", element: /* @__PURE__ */ jsxRuntimeExports.jsx(LandingPage, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/login", element: /* @__PURE__ */ jsxRuntimeExports.jsx(LoginScreen, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/field", element: /* @__PURE__ */ jsxRuntimeExports.jsx(FieldDashboard, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/godown/:id", element: /* @__PURE__ */ jsxRuntimeExports.jsx(GodownDetails, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/hq", element: /* @__PURE__ */ jsxRuntimeExports.jsx(HQDashboard, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "/dashboard", element: /* @__PURE__ */ jsxRuntimeExports.jsx(DashboardLayout, {}), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { index: true, element: /* @__PURE__ */ jsxRuntimeExports.jsx(Navigate, { to: "overview", replace: true }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "overview", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Overview, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "network", element: /* @__PURE__ */ jsxRuntimeExports.jsx(GodownNetwork, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "inventory", element: /* @__PURE__ */ jsxRuntimeExports.jsx(InventoryAging, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "logistics", element: /* @__PURE__ */ jsxRuntimeExports.jsx(StockLogistics, {}) }),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "alerts", element: /* @__PURE__ */ jsxRuntimeExports.jsx(AlertsTasks, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "analytics", element: /* @__PURE__ */ jsxRuntimeExports.jsx(ImpactAnalytics, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "settings", element: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4", children: "Settings Page (Coming Soon)" }) })
        ] })
      ] }) }) }) });
    }
    client.createRoot(document.getElementById("root")).render(
      /* @__PURE__ */ jsxRuntimeExports.jsx(React$3.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
    );
  }
});
export default require_index_001();
